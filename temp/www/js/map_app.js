"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i9 = decorators.length - 1, decorator; i9 >= 0; i9--)
      if (decorator = decorators[i9])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp(target, key, result);
    return result;
  };

  // frontend/node_modules/@protobufjs/aspromise/index.js
  var require_aspromise = __commonJS({
    "frontend/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
      "use strict";
      module2.exports = asPromise;
      function asPromise(fn, ctx) {
        var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
        while (index < arguments.length)
          params[offset++] = arguments[index++];
        return new Promise(function executor(resolve, reject) {
          params[offset] = function callback(err) {
            if (pending) {
              pending = false;
              if (err)
                reject(err);
              else {
                var params2 = new Array(arguments.length - 1), offset2 = 0;
                while (offset2 < params2.length)
                  params2[offset2++] = arguments[offset2];
                resolve.apply(null, params2);
              }
            }
          };
          try {
            fn.apply(ctx || null, params);
          } catch (err) {
            if (pending) {
              pending = false;
              reject(err);
            }
          }
        });
      }
    }
  });

  // frontend/node_modules/@protobufjs/base64/index.js
  var require_base64 = __commonJS({
    "frontend/node_modules/@protobufjs/base64/index.js"(exports2) {
      "use strict";
      var base64 = exports2;
      base64.length = function length(string) {
        var p4 = string.length;
        if (!p4)
          return 0;
        var n7 = 0;
        while (--p4 % 4 > 1 && string.charAt(p4) === "=")
          ++n7;
        return Math.ceil(string.length * 3) / 4 - n7;
      };
      var b64 = new Array(64);
      var s64 = new Array(123);
      for (i9 = 0; i9 < 64; )
        s64[b64[i9] = i9 < 26 ? i9 + 65 : i9 < 52 ? i9 + 71 : i9 < 62 ? i9 - 4 : i9 - 59 | 43] = i9++;
      var i9;
      base64.encode = function encode(buffer, start, end) {
        var parts = null, chunk = [];
        var i10 = 0, j2 = 0, t9;
        while (start < end) {
          var b4 = buffer[start++];
          switch (j2) {
            case 0:
              chunk[i10++] = b64[b4 >> 2];
              t9 = (b4 & 3) << 4;
              j2 = 1;
              break;
            case 1:
              chunk[i10++] = b64[t9 | b4 >> 4];
              t9 = (b4 & 15) << 2;
              j2 = 2;
              break;
            case 2:
              chunk[i10++] = b64[t9 | b4 >> 6];
              chunk[i10++] = b64[b4 & 63];
              j2 = 0;
              break;
          }
          if (i10 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i10 = 0;
          }
        }
        if (j2) {
          chunk[i10++] = b64[t9];
          chunk[i10++] = 61;
          if (j2 === 1)
            chunk[i10++] = 61;
        }
        if (parts) {
          if (i10)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i10)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i10));
      };
      var invalidEncoding = "invalid encoding";
      base64.decode = function decode(string, buffer, offset) {
        var start = offset;
        var j2 = 0, t9;
        for (var i10 = 0; i10 < string.length; ) {
          var c7 = string.charCodeAt(i10++);
          if (c7 === 61 && j2 > 1)
            break;
          if ((c7 = s64[c7]) === void 0)
            throw Error(invalidEncoding);
          switch (j2) {
            case 0:
              t9 = c7;
              j2 = 1;
              break;
            case 1:
              buffer[offset++] = t9 << 2 | (c7 & 48) >> 4;
              t9 = c7;
              j2 = 2;
              break;
            case 2:
              buffer[offset++] = (t9 & 15) << 4 | (c7 & 60) >> 2;
              t9 = c7;
              j2 = 3;
              break;
            case 3:
              buffer[offset++] = (t9 & 3) << 6 | c7;
              j2 = 0;
              break;
          }
        }
        if (j2 === 1)
          throw Error(invalidEncoding);
        return offset - start;
      };
      base64.test = function test(string) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
      };
    }
  });

  // frontend/node_modules/@protobufjs/eventemitter/index.js
  var require_eventemitter = __commonJS({
    "frontend/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
      "use strict";
      module2.exports = EventEmitter;
      function EventEmitter() {
        this._listeners = {};
      }
      EventEmitter.prototype.on = function on(evt, fn, ctx) {
        (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn,
          ctx: ctx || this
        });
        return this;
      };
      EventEmitter.prototype.off = function off(evt, fn) {
        if (evt === void 0)
          this._listeners = {};
        else {
          if (fn === void 0)
            this._listeners[evt] = [];
          else {
            var listeners = this._listeners[evt];
            for (var i9 = 0; i9 < listeners.length; )
              if (listeners[i9].fn === fn)
                listeners.splice(i9, 1);
              else
                ++i9;
          }
        }
        return this;
      };
      EventEmitter.prototype.emit = function emit(evt) {
        var listeners = this._listeners[evt];
        if (listeners) {
          var args = [], i9 = 1;
          for (; i9 < arguments.length; )
            args.push(arguments[i9++]);
          for (i9 = 0; i9 < listeners.length; )
            listeners[i9].fn.apply(listeners[i9++].ctx, args);
        }
        return this;
      };
    }
  });

  // frontend/node_modules/@protobufjs/float/index.js
  var require_float = __commonJS({
    "frontend/node_modules/@protobufjs/float/index.js"(exports2, module2) {
      "use strict";
      module2.exports = factory(factory);
      function factory(exports3) {
        if (typeof Float32Array !== "undefined") (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le2 = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le2 ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le2 ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le2 ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le2 ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
        else (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
        if (typeof Float64Array !== "undefined") (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le2 = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le2 ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le2 ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le2 ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le2 ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
        else (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
        return exports3;
      }
      function writeUintLE(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      function writeUintBE(val, buf, pos) {
        buf[pos] = val >>> 24;
        buf[pos + 1] = val >>> 16 & 255;
        buf[pos + 2] = val >>> 8 & 255;
        buf[pos + 3] = val & 255;
      }
      function readUintLE(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
      }
      function readUintBE(buf, pos) {
        return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
      }
    }
  });

  // frontend/node_modules/@protobufjs/inquire/index.js
  var require_inquire = __commonJS({
    "frontend/node_modules/@protobufjs/inquire/index.js"(exports, module) {
      "use strict";
      module.exports = inquire;
      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName);
          if (mod && (mod.length || Object.keys(mod).length))
            return mod;
        } catch (e9) {
        }
        return null;
      }
    }
  });

  // frontend/node_modules/@protobufjs/utf8/index.js
  var require_utf8 = __commonJS({
    "frontend/node_modules/@protobufjs/utf8/index.js"(exports2) {
      "use strict";
      var utf8 = exports2;
      utf8.length = function utf8_length(string) {
        var len = 0, c7 = 0;
        for (var i9 = 0; i9 < string.length; ++i9) {
          c7 = string.charCodeAt(i9);
          if (c7 < 128)
            len += 1;
          else if (c7 < 2048)
            len += 2;
          else if ((c7 & 64512) === 55296 && (string.charCodeAt(i9 + 1) & 64512) === 56320) {
            ++i9;
            len += 4;
          } else
            len += 3;
        }
        return len;
      };
      utf8.read = function utf8_read(buffer, start, end) {
        var len = end - start;
        if (len < 1)
          return "";
        var parts = null, chunk = [], i9 = 0, t9;
        while (start < end) {
          t9 = buffer[start++];
          if (t9 < 128)
            chunk[i9++] = t9;
          else if (t9 > 191 && t9 < 224)
            chunk[i9++] = (t9 & 31) << 6 | buffer[start++] & 63;
          else if (t9 > 239 && t9 < 365) {
            t9 = ((t9 & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
            chunk[i9++] = 55296 + (t9 >> 10);
            chunk[i9++] = 56320 + (t9 & 1023);
          } else
            chunk[i9++] = (t9 & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
          if (i9 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i9 = 0;
          }
        }
        if (parts) {
          if (i9)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i9)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i9));
      };
      utf8.write = function utf8_write(string, buffer, offset) {
        var start = offset, c1, c22;
        for (var i9 = 0; i9 < string.length; ++i9) {
          c1 = string.charCodeAt(i9);
          if (c1 < 128) {
            buffer[offset++] = c1;
          } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
          } else if ((c1 & 64512) === 55296 && ((c22 = string.charCodeAt(i9 + 1)) & 64512) === 56320) {
            c1 = 65536 + ((c1 & 1023) << 10) + (c22 & 1023);
            ++i9;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          }
        }
        return offset - start;
      };
    }
  });

  // frontend/node_modules/@protobufjs/pool/index.js
  var require_pool = __commonJS({
    "frontend/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
      "use strict";
      module2.exports = pool;
      function pool(alloc, slice2, size) {
        var SIZE = size || 8192;
        var MAX2 = SIZE >>> 1;
        var slab = null;
        var offset = SIZE;
        return function pool_alloc(size2) {
          if (size2 < 1 || size2 > MAX2)
            return alloc(size2);
          if (offset + size2 > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
          }
          var buf = slice2.call(slab, offset, offset += size2);
          if (offset & 7)
            offset = (offset | 7) + 1;
          return buf;
        };
      }
    }
  });

  // frontend/node_modules/protobufjs/src/util/longbits.js
  var require_longbits = __commonJS({
    "frontend/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
      "use strict";
      module2.exports = LongBits;
      var util = require_minimal();
      function LongBits(lo, hi) {
        this.lo = lo >>> 0;
        this.hi = hi >>> 0;
      }
      var zero = LongBits.zero = new LongBits(0, 0);
      zero.toNumber = function() {
        return 0;
      };
      zero.zzEncode = zero.zzDecode = function() {
        return this;
      };
      zero.length = function() {
        return 1;
      };
      var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
      LongBits.fromNumber = function fromNumber2(value) {
        if (value === 0)
          return zero;
        var sign = value < 0;
        if (sign)
          value = -value;
        var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
        if (sign) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
              hi = 0;
          }
        }
        return new LongBits(lo, hi);
      };
      LongBits.from = function from(value) {
        if (typeof value === "number")
          return LongBits.fromNumber(value);
        if (util.isString(value)) {
          if (util.Long)
            value = util.Long.fromString(value);
          else
            return LongBits.fromNumber(parseInt(value, 10));
        }
        return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
      };
      LongBits.prototype.toNumber = function toNumber2(unsigned) {
        if (!unsigned && this.hi >>> 31) {
          var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
          if (!lo)
            hi = hi + 1 >>> 0;
          return -(lo + hi * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
      };
      LongBits.prototype.toLong = function toLong(unsigned) {
        return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
      };
      var charCodeAt = String.prototype.charCodeAt;
      LongBits.fromHash = function fromHash(hash) {
        if (hash === zeroHash)
          return zero;
        return new LongBits(
          (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
          (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
        );
      };
      LongBits.prototype.toHash = function toHash() {
        return String.fromCharCode(
          this.lo & 255,
          this.lo >>> 8 & 255,
          this.lo >>> 16 & 255,
          this.lo >>> 24,
          this.hi & 255,
          this.hi >>> 8 & 255,
          this.hi >>> 16 & 255,
          this.hi >>> 24
        );
      };
      LongBits.prototype.zzEncode = function zzEncode() {
        var mask = this.hi >> 31;
        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
        this.lo = (this.lo << 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.zzDecode = function zzDecode() {
        var mask = -(this.lo & 1);
        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
        this.hi = (this.hi >>> 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.length = function length() {
        var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
        return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
      };
    }
  });

  // frontend/node_modules/protobufjs/src/util/minimal.js
  var require_minimal = __commonJS({
    "frontend/node_modules/protobufjs/src/util/minimal.js"(exports2) {
      "use strict";
      var util = exports2;
      util.asPromise = require_aspromise();
      util.base64 = require_base64();
      util.EventEmitter = require_eventemitter();
      util.float = require_float();
      util.inquire = require_inquire();
      util.utf8 = require_utf8();
      util.pool = require_pool();
      util.LongBits = require_longbits();
      util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
      util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
      util.emptyArray = Object.freeze ? Object.freeze([]) : (
        /* istanbul ignore next */
        []
      );
      util.emptyObject = Object.freeze ? Object.freeze({}) : (
        /* istanbul ignore next */
        {}
      );
      util.isInteger = Number.isInteger || /* istanbul ignore next */
      function isInteger(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
      util.isString = function isString2(value) {
        return typeof value === "string" || value instanceof String;
      };
      util.isObject = function isObject(value) {
        return value && typeof value === "object";
      };
      util.isset = /**
       * Checks if a property on a message is considered to be present.
       * @param {Object} obj Plain object or message instance
       * @param {string} prop Property name
       * @returns {boolean} `true` if considered to be present, otherwise `false`
       */
      util.isSet = function isSet27(obj, prop) {
        var value = obj[prop];
        if (value != null && obj.hasOwnProperty(prop))
          return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
        return false;
      };
      util.Buffer = function() {
        try {
          var Buffer2 = util.inquire("buffer").Buffer;
          return Buffer2.prototype.utf8Write ? Buffer2 : (
            /* istanbul ignore next */
            null
          );
        } catch (e9) {
          return null;
        }
      }();
      util._Buffer_from = null;
      util._Buffer_allocUnsafe = null;
      util.newBuffer = function newBuffer(sizeOrArray) {
        return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
      };
      util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      util.Long = /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long");
      util.key2Re = /^true|false|0|1$/;
      util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
      util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
      util.longToHash = function longToHash(value) {
        return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
      };
      util.longFromHash = function longFromHash(hash, unsigned) {
        var bits = util.LongBits.fromHash(hash);
        if (util.Long)
          return util.Long.fromBits(bits.lo, bits.hi, unsigned);
        return bits.toNumber(Boolean(unsigned));
      };
      function merge2(dst, src, ifNotSet) {
        for (var keys = Object.keys(src), i9 = 0; i9 < keys.length; ++i9)
          if (dst[keys[i9]] === void 0 || !ifNotSet)
            dst[keys[i9]] = src[keys[i9]];
        return dst;
      }
      util.merge = merge2;
      util.lcFirst = function lcFirst(str) {
        return str.charAt(0).toLowerCase() + str.substring(1);
      };
      function newError(name) {
        function CustomError(message, properties) {
          if (!(this instanceof CustomError))
            return new CustomError(message, properties);
          Object.defineProperty(this, "message", { get: function() {
            return message;
          } });
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, CustomError);
          else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });
          if (properties)
            merge2(this, properties);
        }
        CustomError.prototype = Object.create(Error.prototype, {
          constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true
          },
          name: {
            get: function get() {
              return name;
            },
            set: void 0,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true
          },
          toString: {
            value: function value() {
              return this.name + ": " + this.message;
            },
            writable: true,
            enumerable: false,
            configurable: true
          }
        });
        return CustomError;
      }
      util.newError = newError;
      util.ProtocolError = newError("ProtocolError");
      util.oneOfGetter = function getOneOf(fieldNames) {
        var fieldMap = {};
        for (var i9 = 0; i9 < fieldNames.length; ++i9)
          fieldMap[fieldNames[i9]] = 1;
        return function() {
          for (var keys = Object.keys(this), i10 = keys.length - 1; i10 > -1; --i10)
            if (fieldMap[keys[i10]] === 1 && this[keys[i10]] !== void 0 && this[keys[i10]] !== null)
              return keys[i10];
        };
      };
      util.oneOfSetter = function setOneOf(fieldNames) {
        return function(name) {
          for (var i9 = 0; i9 < fieldNames.length; ++i9)
            if (fieldNames[i9] !== name)
              delete this[fieldNames[i9]];
        };
      };
      util.toJSONOptions = {
        longs: String,
        enums: String,
        bytes: String,
        json: true
      };
      util._configure = function() {
        var Buffer2 = util.Buffer;
        if (!Buffer2) {
          util._Buffer_from = util._Buffer_allocUnsafe = null;
          return;
        }
        util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
        function Buffer_from(value, encoding) {
          return new Buffer2(value, encoding);
        };
        util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
          return new Buffer2(size);
        };
      };
    }
  });

  // frontend/node_modules/protobufjs/src/writer.js
  var require_writer = __commonJS({
    "frontend/node_modules/protobufjs/src/writer.js"(exports2, module2) {
      "use strict";
      module2.exports = Writer;
      var util = require_minimal();
      var BufferWriter;
      var LongBits = util.LongBits;
      var base64 = util.base64;
      var utf8 = util.utf8;
      function Op(fn, len, val) {
        this.fn = fn;
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      function noop2() {
      }
      function State(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
      }
      function Writer() {
        this.len = 0;
        this.head = new Op(noop2, 0, 0);
        this.tail = this.head;
        this.states = null;
      }
      var create2 = function create3() {
        return util.Buffer ? function create_buffer_setup() {
          return (Writer.create = function create_buffer() {
            return new BufferWriter();
          })();
        } : function create_array() {
          return new Writer();
        };
      };
      Writer.create = create2();
      Writer.alloc = function alloc(size) {
        return new util.Array(size);
      };
      if (util.Array !== Array)
        Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
      Writer.prototype._push = function push(fn, len, val) {
        this.tail = this.tail.next = new Op(fn, len, val);
        this.len += len;
        return this;
      };
      function writeByte(val, buf, pos) {
        buf[pos] = val & 255;
      }
      function writeVarint32(val, buf, pos) {
        while (val > 127) {
          buf[pos++] = val & 127 | 128;
          val >>>= 7;
        }
        buf[pos] = val;
      }
      function VarintOp(len, val) {
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      VarintOp.prototype = Object.create(Op.prototype);
      VarintOp.prototype.fn = writeVarint32;
      Writer.prototype.uint32 = function write_uint32(value) {
        this.len += (this.tail = this.tail.next = new VarintOp(
          (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
          value
        )).len;
        return this;
      };
      Writer.prototype.int32 = function write_int32(value) {
        return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
      };
      Writer.prototype.sint32 = function write_sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
      };
      function writeVarint64(val, buf, pos) {
        while (val.hi) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
          val.hi >>>= 7;
        }
        while (val.lo > 127) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = val.lo >>> 7;
        }
        buf[pos++] = val.lo;
      }
      Writer.prototype.uint64 = function write_uint64(value) {
        var bits = LongBits.from(value);
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.int64 = Writer.prototype.uint64;
      Writer.prototype.sint64 = function write_sint64(value) {
        var bits = LongBits.from(value).zzEncode();
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.bool = function write_bool(value) {
        return this._push(writeByte, 1, value ? 1 : 0);
      };
      function writeFixed32(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      Writer.prototype.fixed32 = function write_fixed32(value) {
        return this._push(writeFixed32, 4, value >>> 0);
      };
      Writer.prototype.sfixed32 = Writer.prototype.fixed32;
      Writer.prototype.fixed64 = function write_fixed64(value) {
        var bits = LongBits.from(value);
        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
      };
      Writer.prototype.sfixed64 = Writer.prototype.fixed64;
      Writer.prototype.float = function write_float(value) {
        return this._push(util.float.writeFloatLE, 4, value);
      };
      Writer.prototype.double = function write_double(value) {
        return this._push(util.float.writeDoubleLE, 8, value);
      };
      var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytes_for(val, buf, pos) {
        for (var i9 = 0; i9 < val.length; ++i9)
          buf[pos + i9] = val[i9];
      };
      Writer.prototype.bytes = function write_bytes(value) {
        var len = value.length >>> 0;
        if (!len)
          return this._push(writeByte, 1, 0);
        if (util.isString(value)) {
          var buf = Writer.alloc(len = base64.length(value));
          base64.decode(value, buf, 0);
          value = buf;
        }
        return this.uint32(len)._push(writeBytes, len, value);
      };
      Writer.prototype.string = function write_string(value) {
        var len = utf8.length(value);
        return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
      };
      Writer.prototype.fork = function fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
        return this;
      };
      Writer.prototype.reset = function reset() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op(noop2, 0, 0);
          this.len = 0;
        }
        return this;
      };
      Writer.prototype.ldelim = function ldelim() {
        var head = this.head, tail2 = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next;
          this.tail = tail2;
          this.len += len;
        }
        return this;
      };
      Writer.prototype.finish = function finish() {
        var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
        while (head) {
          head.fn(head.val, buf, pos);
          pos += head.len;
          head = head.next;
        }
        return buf;
      };
      Writer._configure = function(BufferWriter_) {
        BufferWriter = BufferWriter_;
        Writer.create = create2();
        BufferWriter._configure();
      };
    }
  });

  // frontend/node_modules/protobufjs/src/writer_buffer.js
  var require_writer_buffer = __commonJS({
    "frontend/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferWriter;
      var Writer = require_writer();
      (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
      var util = require_minimal();
      function BufferWriter() {
        Writer.call(this);
      }
      BufferWriter._configure = function() {
        BufferWriter.alloc = util._Buffer_allocUnsafe;
        BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos);
        } : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy)
            val.copy(buf, pos, 0, val.length);
          else for (var i9 = 0; i9 < val.length; )
            buf[pos++] = val[i9++];
        };
      };
      BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
        if (util.isString(value))
          value = util._Buffer_from(value, "base64");
        var len = value.length >>> 0;
        this.uint32(len);
        if (len)
          this._push(BufferWriter.writeBytesBuffer, len, value);
        return this;
      };
      function writeStringBuffer(val, buf, pos) {
        if (val.length < 40)
          util.utf8.write(val, buf, pos);
        else if (buf.utf8Write)
          buf.utf8Write(val, pos);
        else
          buf.write(val, pos);
      }
      BufferWriter.prototype.string = function write_string_buffer(value) {
        var len = util.Buffer.byteLength(value);
        this.uint32(len);
        if (len)
          this._push(writeStringBuffer, len, value);
        return this;
      };
      BufferWriter._configure();
    }
  });

  // frontend/node_modules/protobufjs/src/reader.js
  var require_reader = __commonJS({
    "frontend/node_modules/protobufjs/src/reader.js"(exports2, module2) {
      "use strict";
      module2.exports = Reader;
      var util = require_minimal();
      var BufferReader;
      var LongBits = util.LongBits;
      var utf8 = util.utf8;
      function indexOutOfRange(reader, writeLength) {
        return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
      }
      function Reader(buffer) {
        this.buf = buffer;
        this.pos = 0;
        this.len = buffer.length;
      }
      var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
          return new Reader(buffer);
        throw Error("illegal buffer");
      } : function create_array2(buffer) {
        if (Array.isArray(buffer))
          return new Reader(buffer);
        throw Error("illegal buffer");
      };
      var create2 = function create3() {
        return util.Buffer ? function create_buffer_setup(buffer) {
          return (Reader.create = function create_buffer(buffer2) {
            return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
          })(buffer);
        } : create_array;
      };
      Reader.create = create2();
      Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
      util.Array.prototype.slice;
      Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
        var value = 4294967295;
        return function read_uint32() {
          value = (this.buf[this.pos] & 127) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
          if (this.buf[this.pos++] < 128) return value;
          if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
          }
          return value;
        };
      }();
      Reader.prototype.int32 = function read_int32() {
        return this.uint32() | 0;
      };
      Reader.prototype.sint32 = function read_sint32() {
        var value = this.uint32();
        return value >>> 1 ^ -(value & 1) | 0;
      };
      function readLongVarint() {
        var bits = new LongBits(0, 0);
        var i9 = 0;
        if (this.len - this.pos > 4) {
          for (; i9 < 4; ++i9) {
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i9 * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
          i9 = 0;
        } else {
          for (; i9 < 3; ++i9) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i9 * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i9 * 7) >>> 0;
          return bits;
        }
        if (this.len - this.pos > 4) {
          for (; i9 < 5; ++i9) {
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i9 * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        } else {
          for (; i9 < 5; ++i9) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i9 * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        }
        throw Error("invalid varint encoding");
      }
      Reader.prototype.bool = function read_bool() {
        return this.uint32() !== 0;
      };
      function readFixed32_end(buf, end) {
        return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
      }
      Reader.prototype.fixed32 = function read_fixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4);
      };
      Reader.prototype.sfixed32 = function read_sfixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4) | 0;
      };
      function readFixed64() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 8);
        return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
      }
      Reader.prototype.float = function read_float() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util.float.readFloatLE(this.buf, this.pos);
        this.pos += 4;
        return value;
      };
      Reader.prototype.double = function read_double() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util.float.readDoubleLE(this.buf, this.pos);
        this.pos += 8;
        return value;
      };
      Reader.prototype.bytes = function read_bytes() {
        var length = this.uint32(), start = this.pos, end = this.pos + length;
        if (end > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
        if (Array.isArray(this.buf))
          return this.buf.slice(start, end);
        if (start === end) {
          var nativeBuffer = util.Buffer;
          return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
        }
        return this._slice.call(this.buf, start, end);
      };
      Reader.prototype.string = function read_string() {
        var bytes = this.bytes();
        return utf8.read(bytes, 0, bytes.length);
      };
      Reader.prototype.skip = function skip(length) {
        if (typeof length === "number") {
          if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
          this.pos += length;
        } else {
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      };
      Reader.prototype.skipType = function(wireType) {
        switch (wireType) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
      };
      Reader._configure = function(BufferReader_) {
        BufferReader = BufferReader_;
        Reader.create = create2();
        BufferReader._configure();
        var fn = util.Long ? "toLong" : (
          /* istanbul ignore next */
          "toNumber"
        );
        util.merge(Reader.prototype, {
          int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
          },
          uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
          },
          sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
          },
          fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
          },
          sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
          }
        });
      };
    }
  });

  // frontend/node_modules/protobufjs/src/reader_buffer.js
  var require_reader_buffer = __commonJS({
    "frontend/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferReader;
      var Reader = require_reader();
      (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
      var util = require_minimal();
      function BufferReader(buffer) {
        Reader.call(this, buffer);
      }
      BufferReader._configure = function() {
        if (util.Buffer)
          BufferReader.prototype._slice = util.Buffer.prototype.slice;
      };
      BufferReader.prototype.string = function read_string_buffer() {
        var len = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
      };
      BufferReader._configure();
    }
  });

  // frontend/node_modules/protobufjs/src/rpc/service.js
  var require_service = __commonJS({
    "frontend/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
      "use strict";
      module2.exports = Service;
      var util = require_minimal();
      (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
      function Service(rpcImpl, requestDelimited, responseDelimited) {
        if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");
        util.EventEmitter.call(this);
        this.rpcImpl = rpcImpl;
        this.requestDelimited = Boolean(requestDelimited);
        this.responseDelimited = Boolean(responseDelimited);
      }
      Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
        if (!request)
          throw TypeError("request must be specified");
        var self2 = this;
        if (!callback)
          return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
        if (!self2.rpcImpl) {
          setTimeout(function() {
            callback(Error("already ended"));
          }, 0);
          return void 0;
        }
        try {
          return self2.rpcImpl(
            method,
            requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {
              if (err) {
                self2.emit("error", err, method);
                return callback(err);
              }
              if (response === null) {
                self2.end(
                  /* endedByRPC */
                  true
                );
                return void 0;
              }
              if (!(response instanceof responseCtor)) {
                try {
                  response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err2) {
                  self2.emit("error", err2, method);
                  return callback(err2);
                }
              }
              self2.emit("data", response, method);
              return callback(null, response);
            }
          );
        } catch (err) {
          self2.emit("error", err, method);
          setTimeout(function() {
            callback(err);
          }, 0);
          return void 0;
        }
      };
      Service.prototype.end = function end(endedByRPC) {
        if (this.rpcImpl) {
          if (!endedByRPC)
            this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
        }
        return this;
      };
    }
  });

  // frontend/node_modules/protobufjs/src/rpc.js
  var require_rpc = __commonJS({
    "frontend/node_modules/protobufjs/src/rpc.js"(exports2) {
      "use strict";
      var rpc = exports2;
      rpc.Service = require_service();
    }
  });

  // frontend/node_modules/protobufjs/src/roots.js
  var require_roots = __commonJS({
    "frontend/node_modules/protobufjs/src/roots.js"(exports2, module2) {
      "use strict";
      module2.exports = {};
    }
  });

  // frontend/node_modules/protobufjs/src/index-minimal.js
  var require_index_minimal = __commonJS({
    "frontend/node_modules/protobufjs/src/index-minimal.js"(exports2) {
      "use strict";
      var protobuf = exports2;
      protobuf.build = "minimal";
      protobuf.Writer = require_writer();
      protobuf.BufferWriter = require_writer_buffer();
      protobuf.Reader = require_reader();
      protobuf.BufferReader = require_reader_buffer();
      protobuf.util = require_minimal();
      protobuf.rpc = require_rpc();
      protobuf.roots = require_roots();
      protobuf.configure = configure2;
      function configure2() {
        protobuf.util._configure();
        protobuf.Writer._configure(protobuf.BufferWriter);
        protobuf.Reader._configure(protobuf.BufferReader);
      }
      configure2();
    }
  });

  // frontend/node_modules/protobufjs/minimal.js
  var require_minimal2 = __commonJS({
    "frontend/node_modules/protobufjs/minimal.js"(exports2, module2) {
      "use strict";
      module2.exports = require_index_minimal();
    }
  });

  // frontend/js/webSocketConnectionManager.js
  var WebSocketConnectionManager = class {
    /**
     * Constructs the WebSocketConnectionManager.
     */
    constructor() {
    }
    /**
     * Starts a Shared Worker for WebSocket communication.
     *
     * @param {string} endpoint The WebSocket endpoint URL.
     * @param {string} channelNameToWS The name of the BroadcastChannel
     * for sending data to the WebSocket.
     * @param {string} channelNameFromWS The name of the BroadcastChannel
     * for receiving data from the WebSocket.
     */
    startWebSocketWorker(endpoint, channelNameToWS, channelNameFromWS) {
      const worker = new SharedWorker(`/js/webSocketManagerWorker.js?endpoint=${endpoint}`, { type: "module" });
      worker.port.postMessage({
        endpoint,
        channelNameToWS,
        channelNameFromWS
      });
      worker.port.onmessage = (event) => {
        const logPrefix = `Worker [${endpoint}]: `;
        if (event.data.type === "error") {
          console.error(`${logPrefix}Error`, event.data.error);
        } else if (event.data.type === "info") {
          console.log(`${logPrefix}Info`, event.data.message);
        }
      };
      worker.port.start();
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/math.js
  var math_exports = {};
  __export(math_exports, {
    ARCSECONDS_TO_RADIANS: () => ARCSECONDS_TO_RADIANS,
    DEG2RAD: () => DEG2RAD,
    DEGREES: () => DEGREES,
    DEGREES_DOUBLE: () => DEGREES_DOUBLE,
    DEGREES_TO_HOURS: () => DEGREES_TO_HOURS,
    EPS1: () => EPS1,
    EPS10: () => EPS10,
    EPS11: () => EPS11,
    EPS12: () => EPS12,
    EPS13: () => EPS13,
    EPS14: () => EPS14,
    EPS15: () => EPS15,
    EPS16: () => EPS16,
    EPS17: () => EPS17,
    EPS18: () => EPS18,
    EPS19: () => EPS19,
    EPS2: () => EPS2,
    EPS20: () => EPS20,
    EPS3: () => EPS3,
    EPS4: () => EPS4,
    EPS5: () => EPS5,
    EPS6: () => EPS6,
    EPS7: () => EPS7,
    EPS8: () => EPS8,
    EPS9: () => EPS9,
    HOURS_TO_DEGREES: () => HOURS_TO_DEGREES,
    HOURS_TO_RADIANS: () => HOURS_TO_RADIANS,
    LOG2: () => LOG2,
    MAX: () => MAX,
    MAX32: () => MAX32,
    MAX_FLOAT: () => MAX_FLOAT,
    MIN: () => MIN,
    PI_TWO: () => PI_TWO,
    RAD2DEG: () => RAD2DEG,
    RADIANS: () => RADIANS,
    RADIANS_HALF: () => RADIANS_HALF,
    RADIANS_TO_HOURS: () => RADIANS_TO_HOURS,
    SQRT_HALF: () => SQRT_HALF,
    TWO_PI: () => TWO_PI,
    W: () => W,
    X: () => X,
    Y: () => Y,
    Z: () => Z,
    bezier1v: () => bezier1v,
    bezier3v: () => bezier3v,
    clamp: () => clamp,
    cube: () => cube,
    degToDec: () => degToDec,
    exp2: () => exp2,
    frac: () => frac,
    getAngleBetweenAzimuths: () => getAngleBetweenAzimuths,
    isPowerOfTwo: () => isPowerOfTwo,
    lerp: () => lerp,
    log: () => log,
    log2: () => log2,
    mod: () => mod2,
    negativePItoPI: () => negativePItoPI,
    nextHighestPowerOfTwo: () => nextHighestPowerOfTwo,
    norm_lon: () => norm_lon,
    pow2i: () => pow2i,
    random: () => random,
    randomi: () => randomi,
    rev: () => rev,
    slice: () => slice,
    solve_iteration: () => solve_iteration,
    solve_iteration_fixed: () => solve_iteration_fixed,
    square: () => square,
    step: () => step,
    zeroTwoPI: () => zeroTwoPI
  });
  var TWO_PI = 2 * Math.PI;
  var PI_TWO = Math.PI / 2;
  var X = 0;
  var Y = 1;
  var Z = 2;
  var W = 3;
  var MAX_FLOAT = Number.MAX_VALUE || 17976931348623157e292;
  var LOG2 = Math.log(2);
  var MAX32 = 2147483647;
  var MAX = 549755748352;
  var MIN = -MAX;
  var RADIANS = Math.PI / 180;
  var DEGREES = 180 / Math.PI;
  var DEGREES_DOUBLE = 2 * DEGREES;
  var RADIANS_HALF = 0.5 * RADIANS;
  var ARCSECONDS_TO_RADIANS = 484813681109536e-20;
  var RADIANS_TO_HOURS = 3.819718634205488;
  var HOURS_TO_RADIANS = 0.26179938779914946;
  var HOURS_TO_DEGREES = 15;
  var DEGREES_TO_HOURS = 1 / 15;
  var SQRT_HALF = Math.sqrt(0.5);
  var EPS1 = 0.1;
  var EPS2 = 0.01;
  var EPS3 = 1e-3;
  var EPS4 = 1e-4;
  var EPS5 = 1e-5;
  var EPS6 = 1e-6;
  var EPS7 = 1e-7;
  var EPS8 = 1e-8;
  var EPS9 = 1e-9;
  var EPS10 = 1e-10;
  var EPS11 = 1e-11;
  var EPS12 = 1e-12;
  var EPS13 = 1e-13;
  var EPS14 = 1e-14;
  var EPS15 = 1e-15;
  var EPS16 = 1e-16;
  var EPS17 = 1e-17;
  var EPS18 = 1e-18;
  var EPS19 = 1e-19;
  var EPS20 = 1e-20;
  function log(n7, base) {
    return Math.log(n7) / Math.log(base);
  }
  function clamp(number, min, max) {
    return Math.max(min, Math.min(number, max));
  }
  function DEG2RAD(degrees) {
    return degrees * RADIANS;
  }
  function RAD2DEG(angle) {
    return angle * DEGREES;
  }
  function isPowerOfTwo(x3) {
    return (x3 & x3 - 1) === 0;
  }
  function nextHighestPowerOfTwo(x3, maxValue = 4096) {
    --x3;
    for (let i9 = 1; i9 < 32; i9 <<= 1) {
      x3 = x3 | x3 >> i9;
    }
    return x3 + 1 > maxValue ? maxValue : x3 + 1;
  }
  function randomi(min = 0, max = 1) {
    return Math.floor(Math.random() * (max - min)) + min;
  }
  function random(min = 0, max = 1) {
    return Math.random() * (max - min) + min;
  }
  function degToDec(d4, m5, s7, p4) {
    if (p4) {
      return d4 + m5 / 60 + s7 / 3600;
    } else {
      return -d4 - m5 / 60 - s7 / 3600;
    }
  }
  function mod2(m5, n7) {
    return (m5 % n7 + n7) % n7;
  }
  function zeroTwoPI(a6) {
    const res = mod2(a6, TWO_PI);
    if (Math.abs(res) < EPS14 && Math.abs(a6) > EPS14) {
      return TWO_PI;
    }
    return res;
  }
  function step(edge, x3) {
    return x3 < edge ? 0 : 1;
  }
  function frac(x3) {
    const mx = Math.abs(x3);
    return mx - Math.floor(mx);
  }
  function log2(x3) {
    return Math.log(x3) / LOG2;
  }
  function exp2(n7) {
    return Math.pow(2, n7);
  }
  function pow2i(n7) {
    return 2 << n7 - 1;
  }
  function slice(t9, h1, h0) {
    return t9 * (h1 - h0);
  }
  function lerp(t9, h1, h0) {
    return h0 + t9 * (h1 - h0);
  }
  function cube(f8) {
    return f8 * f8 * f8;
  }
  function square(f8) {
    return f8 * f8;
  }
  function bezier1v(t9, p0, p1, p22, p32) {
    return cube(1 - t9) * p0 + 3 * square(1 - t9) * t9 * p1 + 3 * (1 - t9) * square(t9) * p22 + cube(t9) * p32;
  }
  function bezier3v(t9, p0, p1, p22, p32) {
    let u4 = 1 - t9;
    let tt = t9 * t9;
    let uu = u4 * u4;
    let uuu = uu * u4;
    let ttt = tt * t9;
    return p0.scaleTo(uuu).addA(p1.scaleTo(3 * uu * t9)).addA(p22.scaleTo(3 * u4 * tt)).addA(p32.scaleTo(ttt));
  }
  function rev(x3) {
    return x3 - Math.floor(x3 / 360) * 360;
  }
  function norm_lon(lon) {
    return lon > 180 ? (lon + 180) % 360 - 180 : lon < -180 ? (lon - 180) % 360 + 180 : lon;
  }
  function negativePItoPI(a6) {
    return zeroTwoPI(a6 + Math.PI) - Math.PI;
  }
  function solve_iteration_fixed(f8, x0, maxIter) {
    let x3 = 0;
    let x22 = x0;
    for (let i9 = 0; i9 < maxIter; i9++) {
      x3 = x22;
      x22 = f8(x3);
    }
    return x22;
  }
  function solve_iteration(f8, x0, err, maxIter = 50) {
    let x3 = 0;
    let x22 = x0;
    for (let i9 = 0; i9 < maxIter; i9++) {
      x3 = x22;
      x22 = f8(x3);
      if (Math.abs(x22 - x3) < err) {
        return x22;
      }
    }
    return x22;
  }
  function getAngleBetweenAzimuths(a6, b4) {
    a6 = zeroTwoPI(a6);
    b4 = zeroTwoPI(b4);
    return ((a6 - b4) % 360 + 360 + 180) % 360 - 180;
  }

  // frontend/node_modules/@openglobus/og/lib/js/LonLat.js
  var HALF_PI = Math.PI * 0.5;
  var INV_PI_BY_180 = 180 / Math.PI;
  var INV_PI_BY_360 = INV_PI_BY_180 * 2;
  var PI_BY_360 = Math.PI / 360;
  var INV_PI_BY_180_HALF_PI = INV_PI_BY_180 * HALF_PI;
  var LonLat = class _LonLat {
    constructor(lon = 0, lat = 0, height = 0) {
      this.lon = 0;
      this.lat = 0;
      this.height = 0;
      this.lon = lon;
      this.lat = lat;
      this.height = height;
    }
    /**
     * Check zero coordinates
     * @returns {boolean} -
     */
    isZero() {
      return this.lon === 0 && this.lat === 0 && this.height === 0;
    }
    /**
     * Creates coordinates array.
     * @static
     * @param{Array.<Array<number>>} arr - Coordinates array data. (exactly 3 entries)
     * @return{Array.<LonLat>} the same coordinates array but each element is LonLat instance.
     */
    static join(arr) {
      let res = [];
      for (let i9 = 0; i9 < arr.length; i9++) {
        let ai = arr[i9];
        res[i9] = new _LonLat(ai[0], ai[1], ai[2]);
      }
      return res;
    }
    /**
     * Creates an object by coordinate array.
     * @static
     * @param {Array.<number>} arr - Coordinates array, where first is longitude, second is latitude and third is a height. (exactly 3 entries)
     * @returns {LonLat} -
     */
    static createFromArray(arr) {
      return new _LonLat(arr[0], arr[1], arr[2]);
    }
    /**
     * Create array from lonLat
     * @param lonLat
     * @returns {number[]}
     */
    static toArray(lonLat) {
      return [lonLat.lon, lonLat.lat, lonLat.height];
    }
    /**
     * Create array from lonLat
     * @returns {number[]}
     */
    toArray() {
      return _LonLat.toArray(this);
    }
    /**
     * Converts degrees to mercator coordinates.
     * @static
     * @param {number} lon - Degrees longitude.
     * @param {number} lat - Degrees latitude.
     * @param {number} [height] - Height.
     * @returns {LonLat} -
     */
    static forwardMercator(lon, lat, height) {
      return new _LonLat(lon * POLE_BY_180, Math.log(Math.tan((90 + lat) * PI_BY_360)) * POLE_BY_PI, height);
    }
    /**
     * Converts degrees to mercator coordinates.
     * @static
     * @param {LonLat} lonLat - Input geodetic degree coordinates
     * @param {LonLat} res - Output mercator coordinates
     * @returns {LonLat} - Output mercator coordinates
     */
    static forwardMercatorRes(lonLat, res) {
      res.lon = lonLat.lon * POLE_BY_180;
      res.lat = Math.log(Math.tan((90 + lonLat.lat) * PI_BY_360)) * POLE_BY_PI, res.height = lonLat.height;
      return res;
    }
    /**
     * Converts mercator to degrees coordinates.
     * @static
     * @param {number} x - Mercator longitude.
     * @param {number} y - Mercator latitude.
     * @param {number} [height] - Height.
     * @returns {LonLat} -
     */
    static inverseMercator(x3, y4, height = 0) {
      return new _LonLat(x3 * INV_POLE_BY_180, INV_PI_BY_360 * Math.atan(Math.exp(y4 * PI_BY_POLE)) - INV_PI_BY_180_HALF_PI, height);
    }
    /**
     * Sets coordinates.
     * @public
     * @param {number} [lon] - Longitude.
     * @param {number} [lat] - Latitude.
     * @param {number} [height] - Height.
     * @returns {LonLat} -
     */
    set(lon = 0, lat = 0, height = 0) {
      this.lon = lon;
      this.lat = lat;
      this.height = height;
      return this;
    }
    /**
     * Copy coordinates.
     * @public
     * @param {LonLat} [lonLat] - Coordinates to copy.
     * @returns {LonLat} -
     */
    copy(lonLat) {
      this.lon = lonLat.lon;
      this.lat = lonLat.lat;
      this.height = lonLat.height;
      return this;
    }
    /**
     * Clone the coordinates.
     * @public
     * @returns {LonLat} -
     */
    clone() {
      return new _LonLat(this.lon, this.lat, this.height);
    }
    /**
     * Converts to mercator coordinates.
     * @public
     * @returns {LonLat} -
     */
    forwardMercator() {
      return _LonLat.forwardMercator(this.lon, this.lat, this.height);
    }
    forwardMercatorEPS01() {
      let lat = this.lat;
      if (lat > 89.9) {
        lat = 89.9;
      } else if (lat < -89.9) {
        lat = -89.9;
      }
      return new _LonLat(this.lon * POLE_BY_180, Math.log(Math.tan((90 + lat) * PI_BY_360)) * POLE_BY_PI);
    }
    /**
     * Converts from mercator coordinates.
     * @public
     * @returns {LonLat} -
     */
    inverseMercator() {
      return _LonLat.inverseMercator(this.lon, this.lat, this.height);
    }
    /**
     * Compares coordinates.
     * @public
     * @param {LonLat} b - Coordinate to compare with.
     * @returns {boolean} -
     */
    equal(b4) {
      if (b4.height) {
        return this.lon === b4.lon && this.lat === b4.lat && this.height === b4.height;
      } else {
        return this.lon === b4.lon && this.lat === b4.lat;
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/mercator.js
  var POLE = 2003750834e-2;
  var POLE2 = POLE * 2;
  var PI_BY_POLE = Math.PI / POLE;
  var POLE_BY_PI = POLE / Math.PI;
  var HALF_PI2 = Math.PI * 0.5;
  var POLE_BY_180 = POLE / 180;
  var INV_POLE_BY_180 = 180 / POLE;
  var PI_BY_3602 = Math.PI / 360;
  var PI_BY_180 = Math.PI / 180;
  var INV_PI_BY_1802 = 180 / Math.PI;
  var POLE_DOUBLE = 2 * POLE;
  var ONE_BY_POLE_DOUBLE = 1 / POLE_DOUBLE;
  function forward(lonLat) {
    return new LonLat(lonLat.lon * POLE / 180, Math.log(Math.tan((90 + lonLat.lat) * PI_BY_3602)) * POLE_BY_PI, lonLat.height);
  }
  function forward_lon(lon) {
    return lon * POLE / 180;
  }
  function forward_lat(lat) {
    return Math.log(Math.tan((90 + lat) * PI_BY_3602)) * POLE_BY_PI;
  }
  function inverse_lat(lat) {
    return INV_PI_BY_1802 * (2 * Math.atan(Math.exp(lat * PI_BY_POLE)) - HALF_PI2);
  }
  function getTileExtent(x3, y4, z3) {
    let size = POLE2 / (1 << z3), sw = new LonLat(-POLE + x3 * size, POLE - y4 * size - size);
    return new Extent(sw, new LonLat(sw.lon + size, sw.lat + size));
  }
  var MAX_LAT = inverse_lat(POLE);
  var MIN_LAT = -MAX_LAT;

  // frontend/node_modules/@openglobus/og/lib/js/Extent.js
  var Extent = class _Extent {
    constructor(sw = new LonLat(), ne = new LonLat()) {
      this.southWest = sw;
      this.northEast = ne;
    }
    /**
     * Creates extent instance from values in array.
     * @static
     * @param {Array.<number>} arr - South west and north-east longitude and latitudes packed in array. (exactly 4 entries)
     * @return {Extent} Extent object.
     */
    static createFromArray(arr) {
      return new _Extent(new LonLat(arr[0], arr[1]), new LonLat(arr[2], arr[3]));
    }
    /**
     * Creates bound extent instance by coordinate array.
     * @static
     * @param {Array.<LonLat>} arr - Coordinate array.
     * @return {Extent} Extent object.
     */
    static createByCoordinates(arr) {
      let lonmin = MAX, lonmax = MIN, latmin = MAX, latmax = MIN;
      for (let i9 = 0; i9 < arr.length; i9++) {
        const vi = arr[i9];
        if (vi.lon < lonmin)
          lonmin = vi.lon;
        if (vi.lon > lonmax)
          lonmax = vi.lon;
        if (vi.lat < latmin)
          latmin = vi.lat;
        if (vi.lat > latmax)
          latmax = vi.lat;
      }
      return new _Extent(new LonLat(lonmin, latmin), new LonLat(lonmax, latmax));
    }
    /**
     * Creates bound extent instance by coordinates array.
     * @static
     * @param {Array.<Array<number>>} arr - Coordinate array. (exactly 2 entries)
     * @return {Extent} Extent object.
     */
    static createByCoordinatesArr(arr) {
      let lonmin = MAX, lonmax = MIN, latmin = MAX, latmax = MIN;
      for (let i9 = 0; i9 < arr.length; i9++) {
        const vi = arr[i9];
        if (vi[0] < lonmin)
          lonmin = vi[0];
        if (vi[0] > lonmax)
          lonmax = vi[0];
        if (vi[1] < latmin)
          latmin = vi[1];
        if (vi[1] > latmax)
          latmax = vi[1];
      }
      return new _Extent(new LonLat(lonmin, latmin), new LonLat(lonmax, latmax));
    }
    /**
     * Creates extent by merсator grid tile coordinates.
     * @static
     * @param {number} x -
     * @param {number} y -
     * @param {number} z -
     * @param {number} width -
     * @param {number} height -
     * @returns {Extent} -
     */
    static fromTile(x3, y4, z3, width = POLE_DOUBLE, height = POLE_DOUBLE) {
      const H2 = 1 << z3;
      const W3 = H2;
      const lnSize = width / W3;
      const ltSize = height / H2;
      const left = -width * 0.5 + x3 * lnSize, top = height * 0.5 - y4 * ltSize, bottom = top - ltSize, right = left + lnSize;
      return new _Extent(new LonLat(left, bottom), new LonLat(right, top));
    }
    /**
     * Sets current bounding extent object by coordinate array.
     * @public
     * @param {Array.<LonLat>} arr - Coordinate array.
     * @return {Extent} Current extent.
     */
    setByCoordinates(arr) {
      let lonmin = MAX, lonmax = MIN, latmin = MAX, latmax = MIN;
      for (let i9 = 0; i9 < arr.length; i9++) {
        const vi = arr[i9];
        if (vi.lon < lonmin)
          lonmin = vi.lon;
        if (vi.lon > lonmax)
          lonmax = vi.lon;
        if (vi.lat < latmin)
          latmin = vi.lat;
        if (vi.lat > latmax)
          latmax = vi.lat;
      }
      this.southWest.lon = lonmin;
      this.southWest.lat = latmin;
      this.northEast.lon = lonmax;
      this.northEast.lat = latmax;
      return this;
    }
    /**
     * Determines if point inside extent.
     * @public
     * @param {LonLat} lonlat - Coordinate point.
     * @return {boolean} Returns true if point inside extent.
     */
    isInside(lonlat) {
      const sw = this.southWest;
      const ne = this.northEast;
      return lonlat.lon >= sw.lon && lonlat.lon <= ne.lon && lonlat.lat >= sw.lat && lonlat.lat <= ne.lat;
    }
    /**
     * Returns true if two extent overlap each other.
     * @public
     * @param {Extent} e - Another extent.
     * @return {boolean} -
     */
    overlaps(e9) {
      const sw = this.southWest;
      const ne = this.northEast;
      return sw.lon <= e9.northEast.lon && ne.lon >= e9.southWest.lon && sw.lat <= e9.northEast.lat && ne.lat >= e9.southWest.lat;
    }
    /**
     * Gets extent width.
     * @public
     * @return {number} Extent width.
     */
    getWidth() {
      return this.northEast.lon - this.southWest.lon;
    }
    /**
     * Gets extent height.
     * @public
     * @return {number} Extent height.
     */
    getHeight() {
      return this.northEast.lat - this.southWest.lat;
    }
    /**
     * Creates clone instance of the current extent.
     * @public
     * @return {Extent} Extent clone.
     */
    clone() {
      return new _Extent(this.southWest.clone(), this.northEast.clone());
    }
    /**
     * Gets the center coordinate of the extent.
     * @public
     * @return {number} Center coordinate.
     */
    getCenter() {
      const sw = this.southWest;
      const ne = this.northEast;
      return new LonLat(sw.lon + (ne.lon - sw.lon) * 0.5, sw.lat + (ne.lat - sw.lat) * 0.5);
    }
    /**
     * @public
     */
    getNorthWest() {
      return new LonLat(this.southWest.lon, this.northEast.lat);
    }
    /**
     * @public
     */
    getNorthEast() {
      return new LonLat(this.northEast.lon, this.northEast.lat);
    }
    /**
     * @public
     */
    getSouthWest() {
      return new LonLat(this.southWest.lon, this.southWest.lat);
    }
    /**
     * @public
     */
    getSouthEast() {
      return new LonLat(this.northEast.lon, this.southWest.lat);
    }
    /**
     * @public
     */
    getNorth() {
      return this.northEast.lat;
    }
    getEast() {
      return this.northEast.lon;
    }
    /**
     * @public
     */
    getWest() {
      return this.southWest.lon;
    }
    /**
     * @public
     */
    getSouth() {
      return this.southWest.lat;
    }
    /**
     * Returns extents are equals.
     * @param {Extent} extent - Extent.
     * @returns {boolean} -
     */
    equals(extent) {
      return this.southWest.lon === extent.southWest.lon && this.southWest.lat === extent.southWest.lat && this.northEast.lon === extent.northEast.lon && this.northEast.lat === extent.northEast.lat;
    }
    /**
     * Converts extent coordinates to mercator projection coordinates.
     * @public
     * @return {Extent} New instance of the current extent.
     */
    forwardMercator() {
      return new _Extent(this.southWest.forwardMercator(), this.northEast.forwardMercator());
    }
    /**
     * Converts extent coordinates from mercator projection to degrees.
     * @public
     * @return {Extent} New instance of the current extent.
     */
    inverseMercator() {
      return new _Extent(this.southWest.inverseMercator(), this.northEast.inverseMercator());
    }
    /**
     * Gets cartesian bounding bounds of the current ellipsoid.
     * @public
     * @param {Ellipsoid} ellipsoid - Ellipsoid.
     * @return {Array.<number>} Cartesian 3d coordinate array. (exactly 6 entries)
     */
    getCartesianBounds(ellipsoid) {
      let xmin = MAX, xmax = MIN, ymin = MAX, ymax = MIN, zmin = MAX, zmax = MIN;
      const v4 = [
        new LonLat(this.southWest.lon, this.southWest.lat),
        new LonLat(this.southWest.lon, this.northEast.lat),
        new LonLat(this.northEast.lon, this.northEast.lat),
        new LonLat(this.northEast.lon, this.southWest.lat)
      ];
      for (let i9 = 0; i9 < v4.length; i9++) {
        const coord = ellipsoid.lonLatToCartesian(v4[i9]);
        const x3 = coord.x;
        const y4 = coord.y;
        const z3 = coord.z;
        if (x3 < xmin)
          xmin = x3;
        if (x3 > xmax)
          xmax = x3;
        if (y4 < ymin)
          ymin = y4;
        if (y4 > ymax)
          ymax = y4;
        if (z3 < zmin)
          zmin = z3;
        if (z3 > zmax)
          zmax = z3;
      }
      return [xmin, ymin, zmin, xmax, ymax, zmax];
    }
    toString() {
      return `[${this.southWest.lon.toFixed(5)}, ${this.southWest.lat.toFixed(5)}, ${this.northEast.lon.toFixed(5)}, ${this.northEast.lat.toFixed(5)}]`;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/math/Mat3.js
  var Mat3 = class _Mat3 {
    constructor() {
      this._m = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
    }
    /**
     * Sets column-major order array matrix.
     * @public
     * @param {Array.<number>} m - Matrix array.
     * @returns {Mat3}
     */
    set(m5) {
      this._m[0] = m5[0];
      this._m[1] = m5[1];
      this._m[2] = m5[2];
      this._m[3] = m5[3];
      this._m[4] = m5[4];
      this._m[5] = m5[5];
      this._m[6] = m5[6];
      this._m[7] = m5[7];
      this._m[8] = m5[8];
      return this;
    }
    /**
     * Duplicates a Mat3 instance.
     * @public
     * @returns {Mat3}
     */
    clone() {
      let res = new _Mat3();
      res.set(this._m);
      return res;
    }
    /**
     * Copy matrix.
     * @public
     * @param {Mat3} a - Matrix to copy.
     * @returns {Mat3}
     */
    copy(a6) {
      return this.set(a6._m);
    }
    /**
     * Creates transposed matrix from the current.
     * @public
     * @returns {Mat3}
     */
    transposeTo() {
      let res = new _Mat3();
      let m5 = this._m;
      res._m[0] = m5[0];
      res._m[1] = m5[3];
      res._m[2] = m5[6];
      res._m[3] = m5[1];
      res._m[4] = m5[4];
      res._m[5] = m5[7];
      res._m[6] = m5[2];
      res._m[7] = m5[5];
      res._m[8] = m5[8];
      return res;
    }
    /**
     * Sets matrix to identity.
     * @public
     * @returns {Mat3}
     */
    setIdentity() {
      this._m[0] = 1;
      this._m[1] = 0;
      this._m[2] = 0;
      this._m[3] = 0;
      this._m[4] = 1;
      this._m[5] = 0;
      this._m[6] = 0;
      this._m[7] = 0;
      this._m[8] = 1;
      return this;
    }
    /**
     * Multiply to 3d vector.
     * @public
     * @params {Vec3} p - 3d vector.
     * @returns {Vec3}
     */
    mulVec(p4) {
      let d4 = p4.x, e9 = p4.y, g4 = p4.z;
      let m5 = this._m;
      return new Vec3(m5[0] * d4 + m5[3] * e9 + m5[6] * g4, m5[1] * d4 + m5[4] * e9 + m5[7] * g4, m5[2] * d4 + m5[5] * e9 + m5[8] * g4);
    }
    /**
     * Converts to 4x4 matrix.
     * @public
     * @returns {Mat4}
     */
    toMatrix4() {
      let res = new Mat4();
      let b4 = res._m;
      let a6 = this._m;
      b4[0] = a6[0];
      b4[1] = a6[1];
      b4[2] = a6[2];
      b4[3] = 0;
      b4[4] = a6[3];
      b4[5] = a6[4];
      b4[6] = a6[5];
      b4[7] = 0;
      b4[8] = a6[6];
      b4[9] = a6[7];
      b4[10] = a6[8];
      b4[11] = 0;
      b4[12] = 0;
      b4[13] = 0;
      b4[14] = 0;
      b4[15] = 1;
      return res;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/math/Vec4.js
  var Vec4 = class _Vec4 {
    constructor(x3 = 0, y4 = 0, z3 = 0, w3 = 0) {
      this.x = x3;
      this.y = y4;
      this.z = z3;
      this.w = w3;
    }
    /**
     * Identity vector [0,0,0,1].
     * @const
     * @type {Vec4}
     */
    static get identity() {
      return new _Vec4(0, 0, 0, 1);
    }
    /**
     * Creates 4d vector from array.
     * @function
     * @param {Array.<number>} arr - Array of four values
     * @returns {Vec4}
     */
    static fromVec(arr) {
      return new _Vec4(arr[0], arr[1], arr[2], arr[3]);
    }
    /**
     * Converts to Vec3, without fourth value.
     * @public
     * @returns {Vec3}
     */
    toVec3() {
      return new Vec3(this.x, this.y, this.z);
    }
    /**
     * Returns clone vector.
     * @public
     * @returns {Vec4}
     */
    clone() {
      return new _Vec4(this.x, this.y, this.z, this.w);
    }
    /**
     * Compares with vector. Returns true if it equals another.
     * @public
     * @param {Vec4} v - Vector to compare.
     * @returns {boolean}
     */
    equal(v4) {
      return this.x === v4.x && this.y === v4.y && this.z === v4.z && this.w === v4.w;
    }
    /**
     * Copy input vector's values.
     * @param {Vec4} v - Vector to copy.
     * @returns {Vec4}
     */
    copy(v4) {
      this.x = v4.x;
      this.y = v4.y;
      this.z = v4.z;
      this.w = v4.w;
      return this;
    }
    /**
     * Converts vector to a number array.
     * @public
     * @returns {Array.<number>} - (exactly 4 entries)
     */
    toArray() {
      return [this.x, this.y, this.z, this.w];
    }
    /**
     * Converts vector to a number array.
     * @public
     * @returns {Array.<number>} - (exactly 4 entries)
     */
    toArray3() {
      return [this.x, this.y, this.z];
    }
    /**
     * Sets vector's values.
     * @public
     * @param {number} x - Value X.
     * @param {number} y - Value Y.
     * @param {number} z - Value Z.
     * @param {number} w - Value W.
     * @returns {Vec4}
     */
    set(x3, y4, z3, w3) {
      this.x = x3;
      this.y = y4;
      this.z = z3;
      this.w = w3;
      return this;
    }
    /**
     * Adds vector to the current.
     * @public
     * @param {Vec4} v - Vector to add.
     * @returns {Vec4}
     */
    addA(v4) {
      this.x += v4.x;
      this.y += v4.y;
      this.z += v4.z;
      this.w += v4.w;
      return this;
    }
    /**
     * Subtract vector from the current.
     * @public
     * @param {Vec4} v - Subtract vector.
     * @returns {Vec4}
     */
    subA(v4) {
      this.x -= v4.x;
      this.y -= v4.y;
      this.z -= v4.z;
      this.w -= v4.w;
      return this;
    }
    /**
     * Scale current vector.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec4}
     */
    scale(scale2) {
      this.x *= scale2;
      this.y *= scale2;
      this.z *= scale2;
      this.w *= scale2;
      return this;
    }
    /**
     * Makes vector affinity. Thereby fourth component becomes to 1.0.
     * @public
     * @returns {Vec4}
     */
    affinity() {
      let iw = 1 / this.w;
      this.x *= iw;
      this.y *= iw;
      this.z *= iw;
      this.w = 1;
      return this;
    }
    /**
     * Scale current vector to another instance.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec3}
     */
    scaleTo(scale2) {
      return new _Vec4(this.x * scale2, this.y * scale2, this.z * scale2, this.w * scale2);
    }
    /**
     * Vector's edge function that returns vector where each component is 0.0 if it's smaller than edge and otherwise 1.0.
     * @public
     * @returns {Vec4}
     */
    getStep(edge) {
      return new _Vec4(this.x < edge ? 0 : 1, this.y < edge ? 0 : 1, this.z < edge ? 0 : 1, this.w < edge ? 0 : 1);
    }
    /**
     * The vector frac function returns the vector of fractional parts of each value, i.e. x minus floor(x).
     * @public
     * @param {Vec4} v - Input vector
     * @returns {Vec4}
     */
    getFrac(v4) {
      return new _Vec4(frac(v4.x), frac(v4.y), frac(v4.z), frac(v4.w));
    }
    /**
     * Gets vectors dot production.
     * @public
     * @param {Vec4} v - Another vector.
     * @returns {number} - Dot product.
     */
    dot(v4) {
      return v4.x * this.x + v4.y * this.y + v4.z * this.z + v4.w * this.w;
    }
    /**
     * Returns true if vector's values are zero.
     * @public
     * @returns {boolean} -
     */
    isZero() {
      return !(this.x || this.y || this.z || this.w);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/math/Mat4.js
  var Mat4 = class _Mat4 {
    constructor() {
      this._m = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
    }
    /**
     * Returns identity matrix instance.
     * @static
     * @returns {Mat4} -
     */
    static identity() {
      let res = new _Mat4();
      res._m[0] = 1;
      res._m[1] = 0;
      res._m[2] = 0;
      res._m[3] = 0;
      res._m[4] = 0;
      res._m[5] = 1;
      res._m[6] = 0;
      res._m[7] = 0;
      res._m[8] = 0;
      res._m[9] = 0;
      res._m[10] = 1;
      res._m[11] = 0;
      res._m[12] = 0;
      res._m[13] = 0;
      res._m[14] = 0;
      res._m[15] = 1;
      return res;
    }
    /**
     * Sets column-major order array matrix.
     * @public
     * @param {Array.<number>} m - Matrix array.
     * @returns {Mat4} -
     */
    set(m5) {
      this._m[0] = m5[0];
      this._m[1] = m5[1];
      this._m[2] = m5[2];
      this._m[3] = m5[3];
      this._m[4] = m5[4];
      this._m[5] = m5[5];
      this._m[6] = m5[6];
      this._m[7] = m5[7];
      this._m[8] = m5[8];
      this._m[9] = m5[9];
      this._m[10] = m5[10];
      this._m[11] = m5[11];
      this._m[12] = m5[12];
      this._m[13] = m5[13];
      this._m[14] = m5[14];
      this._m[15] = m5[15];
      return this;
    }
    /**
     * Duplicates a Matrix3 instance.
     * @public
     * @returns {Mat4} -
     */
    clone() {
      let res = new _Mat4();
      res.set(this._m);
      return res;
    }
    /**
     * Copy matrix.
     * @public
     * @param {Mat4} a - Matrix to copy.
     * @return {Mat4}
     */
    copy(a6) {
      return this.set(a6._m);
    }
    /**
     * Converts to 3x3 matrix.
     * @public
     * @returns {Mat3} -
     */
    toMatrix3() {
      let res = new Mat3();
      let a6 = this._m, b4 = res._m;
      b4[0] = a6[0];
      b4[1] = a6[1];
      b4[2] = a6[2];
      b4[3] = a6[4];
      b4[4] = a6[5];
      b4[5] = a6[6];
      b4[6] = a6[8];
      b4[7] = a6[9];
      b4[8] = a6[10];
      return res;
    }
    /**
     * Multiply to 3d vector.
     * @public
     * @param {Vec3} p - 3d vector.
     * @returns {Vec3} -
     */
    mulVec3(p4) {
      let d4 = p4.x, e9 = p4.y, g4 = p4.z;
      return new Vec3(this._m[0] * d4 + this._m[4] * e9 + this._m[8] * g4 + this._m[12], this._m[1] * d4 + this._m[5] * e9 + this._m[9] * g4 + this._m[13], this._m[2] * d4 + this._m[6] * e9 + this._m[10] * g4 + this._m[14]);
    }
    /**
     * Multiply to 4d vector.
     * @public
     * @param {Vec4} p - 4d vector.
     * @returns {Vec4} -
     */
    mulVec4(p4) {
      let d4 = p4.x, e9 = p4.y, g4 = p4.z, f8 = p4.w;
      return new Vec4(this._m[0] * d4 + this._m[4] * e9 + this._m[8] * g4 + this._m[12] * f8, this._m[1] * d4 + this._m[5] * e9 + this._m[9] * g4 + this._m[13] * f8, this._m[2] * d4 + this._m[6] * e9 + this._m[10] * g4 + this._m[14] * f8, this._m[3] * d4 + this._m[7] * e9 + this._m[11] * g4 + this._m[15] * f8);
    }
    /**
     * Creates an inverse 3x3 matrix of the current.
     * @public
     * @returns {Mat3} -
     */
    toInverseMatrix3() {
      let a6 = this._m;
      let c7 = a6[0], d4 = a6[1], e9 = a6[2], g4 = a6[4], f8 = a6[5], h8 = a6[6], i9 = a6[8], j2 = a6[9], k3 = a6[10], l4 = k3 * f8 - h8 * j2, o7 = -k3 * g4 + h8 * i9, m5 = j2 * g4 - f8 * i9, n7 = c7 * l4 + d4 * o7 + e9 * m5;
      if (!n7) {
        return;
      }
      n7 = 1 / n7;
      let res = new Mat3();
      res._m[0] = l4 * n7;
      res._m[1] = (-k3 * d4 + e9 * j2) * n7;
      res._m[2] = (h8 * d4 - e9 * f8) * n7;
      res._m[3] = o7 * n7;
      res._m[4] = (k3 * c7 - e9 * i9) * n7;
      res._m[5] = (-h8 * c7 + e9 * g4) * n7;
      res._m[6] = m5 * n7;
      res._m[7] = (-j2 * c7 + d4 * i9) * n7;
      res._m[8] = (f8 * c7 - d4 * g4) * n7;
      return res;
    }
    /**
     * Creates an inverse matrix of the current.
     * @public
     * @returns {Mat4} -
     */
    inverseTo(res = new _Mat4()) {
      let c7 = this._m[0], d4 = this._m[1], e9 = this._m[2], g4 = this._m[3], f8 = this._m[4], h8 = this._m[5], i9 = this._m[6], j2 = this._m[7], k3 = this._m[8], l4 = this._m[9], o7 = this._m[10], m5 = this._m[11], n7 = this._m[12], p4 = this._m[13], r8 = this._m[14], s7 = this._m[15], A3 = c7 * h8 - d4 * f8, B3 = c7 * i9 - e9 * f8, t9 = c7 * j2 - g4 * f8, u4 = d4 * i9 - e9 * h8, v4 = d4 * j2 - g4 * h8, w3 = e9 * j2 - g4 * i9, x3 = k3 * p4 - l4 * n7, y4 = k3 * r8 - o7 * n7, z3 = k3 * s7 - m5 * n7, C2 = l4 * r8 - o7 * p4, D2 = l4 * s7 - m5 * p4, E5 = o7 * s7 - m5 * r8, q2 = 1 / (A3 * E5 - B3 * D2 + t9 * C2 + u4 * z3 - v4 * y4 + w3 * x3);
      res._m[0] = (h8 * E5 - i9 * D2 + j2 * C2) * q2;
      res._m[1] = (-d4 * E5 + e9 * D2 - g4 * C2) * q2;
      res._m[2] = (p4 * w3 - r8 * v4 + s7 * u4) * q2;
      res._m[3] = (-l4 * w3 + o7 * v4 - m5 * u4) * q2;
      res._m[4] = (-f8 * E5 + i9 * z3 - j2 * y4) * q2;
      res._m[5] = (c7 * E5 - e9 * z3 + g4 * y4) * q2;
      res._m[6] = (-n7 * w3 + r8 * t9 - s7 * B3) * q2;
      res._m[7] = (k3 * w3 - o7 * t9 + m5 * B3) * q2;
      res._m[8] = (f8 * D2 - h8 * z3 + j2 * x3) * q2;
      res._m[9] = (-c7 * D2 + d4 * z3 - g4 * x3) * q2;
      res._m[10] = (n7 * v4 - p4 * t9 + s7 * A3) * q2;
      res._m[11] = (-k3 * v4 + l4 * t9 - m5 * A3) * q2;
      res._m[12] = (-f8 * C2 + h8 * y4 - i9 * x3) * q2;
      res._m[13] = (c7 * C2 - d4 * y4 + e9 * x3) * q2;
      res._m[14] = (-n7 * u4 + p4 * B3 - r8 * A3) * q2;
      res._m[15] = (k3 * u4 - l4 * B3 + o7 * A3) * q2;
      return res;
    }
    /**
     * Creates a transposed matrix of the current.
     * @public
     * @returns {Mat4} -
     */
    transposeTo() {
      let res = new _Mat4();
      res._m[0] = this._m[0];
      res._m[1] = this._m[4];
      res._m[2] = this._m[8];
      res._m[3] = this._m[12];
      res._m[4] = this._m[1];
      res._m[5] = this._m[5];
      res._m[6] = this._m[9];
      res._m[7] = this._m[13];
      res._m[8] = this._m[2];
      res._m[9] = this._m[6];
      res._m[10] = this._m[10];
      res._m[11] = this._m[14];
      res._m[12] = this._m[3];
      res._m[13] = this._m[7];
      res._m[14] = this._m[11];
      res._m[15] = this._m[15];
      return res;
    }
    /**
     * Sets matrix to identity.
     * @public
     * @returns {Mat4} -
     */
    setIdentity() {
      this._m[0] = 1;
      this._m[1] = 0;
      this._m[2] = 0;
      this._m[3] = 0;
      this._m[4] = 0;
      this._m[5] = 1;
      this._m[6] = 0;
      this._m[7] = 0;
      this._m[8] = 0;
      this._m[9] = 0;
      this._m[10] = 1;
      this._m[11] = 0;
      this._m[12] = 0;
      this._m[13] = 0;
      this._m[14] = 0;
      this._m[15] = 1;
      return this;
    }
    /**
     * Computes the product of two matrices.
     * @public
     * @param {Mat4} mx - Matrix to multiply.
     * @returns {Mat4} -
     */
    mul(mx) {
      let d4 = this._m[0], e9 = this._m[1], g4 = this._m[2], f8 = this._m[3], h8 = this._m[4], i9 = this._m[5], j2 = this._m[6], k3 = this._m[7], l4 = this._m[8], o7 = this._m[9], m5 = this._m[10], n7 = this._m[11], p4 = this._m[12], r8 = this._m[13], s7 = this._m[14], a6 = this._m[15];
      let A3 = mx._m[0], B3 = mx._m[1], t9 = mx._m[2], u4 = mx._m[3], v4 = mx._m[4], w3 = mx._m[5], x3 = mx._m[6], y4 = mx._m[7], z3 = mx._m[8], C2 = mx._m[9], D2 = mx._m[10], E5 = mx._m[11], q2 = mx._m[12], F2 = mx._m[13], G3 = mx._m[14], b4 = mx._m[15];
      let res = new _Mat4();
      res._m[0] = A3 * d4 + B3 * h8 + t9 * l4 + u4 * p4;
      res._m[1] = A3 * e9 + B3 * i9 + t9 * o7 + u4 * r8;
      res._m[2] = A3 * g4 + B3 * j2 + t9 * m5 + u4 * s7;
      res._m[3] = A3 * f8 + B3 * k3 + t9 * n7 + u4 * a6;
      res._m[4] = v4 * d4 + w3 * h8 + x3 * l4 + y4 * p4;
      res._m[5] = v4 * e9 + w3 * i9 + x3 * o7 + y4 * r8;
      res._m[6] = v4 * g4 + w3 * j2 + x3 * m5 + y4 * s7;
      res._m[7] = v4 * f8 + w3 * k3 + x3 * n7 + y4 * a6;
      res._m[8] = z3 * d4 + C2 * h8 + D2 * l4 + E5 * p4;
      res._m[9] = z3 * e9 + C2 * i9 + D2 * o7 + E5 * r8;
      res._m[10] = z3 * g4 + C2 * j2 + D2 * m5 + E5 * s7;
      res._m[11] = z3 * f8 + C2 * k3 + D2 * n7 + E5 * a6;
      res._m[12] = q2 * d4 + F2 * h8 + G3 * l4 + b4 * p4;
      res._m[13] = q2 * e9 + F2 * i9 + G3 * o7 + b4 * r8;
      res._m[14] = q2 * g4 + F2 * j2 + G3 * m5 + b4 * s7;
      res._m[15] = q2 * f8 + F2 * k3 + G3 * n7 + b4 * a6;
      return res;
    }
    /**
     * Add translation vector to the current matrix.
     * @public
     * @param {Vec3} v - Translate vector.
     * @returns {Mat4} -
     */
    translate(v4) {
      let d4 = v4.x, e9 = v4.y, b4 = v4.z;
      let a6 = this._m;
      a6[12] = a6[0] * d4 + a6[4] * e9 + a6[8] * b4 + a6[12];
      a6[13] = a6[1] * d4 + a6[5] * e9 + a6[9] * b4 + a6[13];
      a6[14] = a6[2] * d4 + a6[6] * e9 + a6[10] * b4 + a6[14];
      a6[15] = a6[3] * d4 + a6[7] * e9 + a6[11] * b4 + a6[15];
      return this;
    }
    /**
     * Sets translation matrix to the position.
     * @public
     * @param {Vec3} v - Translate to position.
     * @returns {Mat4} -
     */
    translateToPosition(v4) {
      let a6 = this._m;
      a6[12] = v4.x;
      a6[13] = v4.y;
      a6[14] = v4.z;
      return this;
    }
    /**
     * Rotate current matrix around the aligned axis and angle.
     * @public
     * @param {Vec3} u - Aligned axis.
     * @param {number} angle - Aligned axis angle in radians.
     * @returns {Mat4} -
     */
    rotate(u4, angle) {
      let c7 = Math.cos(angle), s7 = Math.sin(angle);
      let rot = new _Mat4();
      let mx = rot._m;
      mx[0] = c7 + (1 - c7) * u4.x * u4.x;
      mx[1] = (1 - c7) * u4.y * u4.x - s7 * u4.z;
      mx[2] = (1 - c7) * u4.z * u4.x + s7 * u4.y;
      mx[3] = 0;
      mx[4] = (1 - c7) * u4.x * u4.y + s7 * u4.z;
      mx[5] = c7 + (1 - c7) * u4.y * u4.y;
      mx[6] = (1 - c7) * u4.z * u4.y - s7 * u4.x;
      mx[7] = 0;
      mx[8] = (1 - c7) * u4.x * u4.z - s7 * u4.y;
      mx[9] = (1 - c7) * u4.y * u4.z + s7 * u4.x;
      mx[10] = c7 + (1 - c7) * u4.z * u4.z;
      mx[11] = 0;
      mx[12] = 0;
      mx[13] = 0;
      mx[14] = 0;
      mx[15] = 1;
      return this.mul(rot);
    }
    /**
     * Sets current rotation matrix around the aligned axis and angle.
     * @public
     * @param {Vec3} u - Aligned axis.
     * @param {number} angle - Aligned axis angle in radians.
     * @returns {Mat4} -
     */
    setRotation(u4, angle) {
      let c7 = Math.cos(angle), s7 = Math.sin(angle);
      let mx = this._m;
      mx[0] = c7 + (1 - c7) * u4.x * u4.x;
      mx[1] = (1 - c7) * u4.y * u4.x - s7 * u4.z;
      mx[2] = (1 - c7) * u4.z * u4.x + s7 * u4.y;
      mx[3] = 0;
      mx[4] = (1 - c7) * u4.x * u4.y + s7 * u4.z;
      mx[5] = c7 + (1 - c7) * u4.y * u4.y;
      mx[6] = (1 - c7) * u4.z * u4.y - s7 * u4.x;
      mx[7] = 0;
      mx[8] = (1 - c7) * u4.x * u4.z - s7 * u4.y;
      mx[9] = (1 - c7) * u4.y * u4.z + s7 * u4.x;
      mx[10] = c7 + (1 - c7) * u4.z * u4.z;
      mx[11] = 0;
      mx[12] = 0;
      mx[13] = 0;
      mx[14] = 0;
      mx[15] = 1;
      return this;
    }
    /**
     * Gets the rotation matrix from one vector to another.
     * @public
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Mat4} -
     */
    rotateBetweenVectors(a6, b4) {
      let q2 = Quat.getRotationBetweenVectors(a6, b4);
      return q2.getMat4();
    }
    /**
     * Scale current matrix to the vector values.
     * @public
     * @param {Vec3} v - Scale vector.
     * @returns {Mat4} -
     */
    scale(v4) {
      let mx = this._m;
      mx[0] = mx[0] * v4.x;
      mx[1] = mx[1] * v4.x;
      mx[2] = mx[2] * v4.x;
      mx[3] = mx[3] * v4.x;
      mx[4] = mx[4] * v4.y;
      mx[5] = mx[5] * v4.y;
      mx[6] = mx[6] * v4.y;
      mx[7] = mx[7] * v4.y;
      mx[8] = mx[8] * v4.z;
      mx[9] = mx[9] * v4.z;
      mx[10] = mx[10] * v4.z;
      mx[11] = mx[11] * v4.z;
      return this;
    }
    /**
     * Sets perspective projection matrix frustum values.
     * @public
     * @param {number} left -
     * @param {number} right -
     * @param {number} bottom -
     * @param {number} top -
     * @param {number} near -
     * @param {number} far -
     * @returns {Mat4} -
     */
    setPerspective(left, right, bottom, top, near, far) {
      let h8 = right - left, i9 = top - bottom, j2 = near - far, n22 = 2 * near;
      let mm = this._m;
      mm[0] = n22 / h8;
      mm[1] = 0;
      mm[2] = 0;
      mm[3] = 0;
      mm[4] = 0;
      mm[5] = n22 / i9;
      mm[6] = 0;
      mm[7] = 0;
      mm[8] = (right + left) / h8;
      mm[9] = (top + bottom) / i9;
      mm[10] = (far + near) / j2;
      mm[11] = -1;
      mm[12] = 0;
      mm[13] = 0;
      mm[14] = n22 * far / j2;
      mm[15] = 0;
      return this;
    }
    /**
     * Creates current orthographic projection matrix.
     * @public
     * @param {number} left -
     * @param {number} right -
     * @param {number} bottom -
     * @param {number} top -
     * @param {number} near -
     * @param {number} far -
     * @return {Mat4} -
     */
    setOrtho(left, right, bottom, top, near, far) {
      let lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far), m5 = this._m;
      m5[0] = -2 * lr;
      m5[1] = 0;
      m5[2] = 0;
      m5[3] = 0;
      m5[4] = 0;
      m5[5] = -2 * bt;
      m5[6] = 0;
      m5[7] = 0;
      m5[8] = 0;
      m5[9] = 0;
      m5[10] = 2 * nf;
      m5[11] = 0;
      m5[12] = (left + right) * lr;
      m5[13] = (top + bottom) * bt;
      m5[14] = (far + near) * nf;
      m5[15] = 1;
      return this;
    }
    /**
     * Sets current rotation matrix by euler's angles.
     * @public
     * @param {number} ax - Rotation angle in radians around X axis.
     * @param {number} ay - Rotation angle in radians around Y axis.
     * @param {number} az - Rotation angle in radians around Z axis.
     * @returns {Mat4} -
     */
    eulerToMatrix(ax, ay, az) {
      let a6 = Math.cos(ax), b4 = Math.sin(ax), c7 = Math.cos(ay), d4 = Math.sin(ay), e9 = Math.cos(az), f8 = Math.sin(az);
      let ad = a6 * d4, bd = b4 * d4;
      let mat = this._m;
      mat[0] = c7 * e9;
      mat[1] = -c7 * f8;
      mat[2] = -d4;
      mat[4] = -bd * e9 + a6 * f8;
      mat[5] = bd * f8 + a6 * e9;
      mat[6] = -b4 * c7;
      mat[8] = ad * e9 + b4 * f8;
      mat[9] = -ad * f8 + b4 * e9;
      mat[10] = a6 * c7;
      mat[3] = mat[7] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
      mat[15] = 1;
      return this;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/math/Quat.js
  var Quat = class _Quat {
    constructor(x3 = 0, y4 = 0, z3 = 0, w3 = 0) {
      this.x = x3;
      this.y = y4;
      this.z = z3;
      this.w = w3;
    }
    /**
     * Identity Quat.
     * @const
     * @type {Quat}
     */
    static get IDENTITY() {
      return new _Quat(0, 0, 0, 1);
    }
    /**
     * Returns a Quat represents rotation around X axis.
     * @static
     * @param {number} a - The angle in radians to rotate around the axis.
     * @returns {Quat} -
     */
    static xRotation(a6) {
      a6 *= 0.5;
      return new _Quat(Math.sin(a6), 0, 0, Math.cos(a6));
    }
    /**
     * Returns a Quat represents rotation around Y axis.
     * @static
     * @param {number} a - The angle in radians to rotate around the axis.
     * @returns {Quat} -
     */
    static yRotation(a6) {
      a6 *= 0.5;
      return new _Quat(0, Math.sin(a6), 0, Math.cos(a6));
    }
    /**
     * Returns a Quat represents rotation around Z axis.
     * @static
     * @param {number} a - The angle in radians to rotate around the axis.
     * @returns {Quat} -
     */
    static zRotation(a6) {
      a6 *= 0.5;
      return new _Quat(0, 0, Math.sin(a6), Math.cos(a6));
    }
    /**
     * Computes a Quat representing a rotation around an axis.
     * @static
     * @param {Vec3} axis - The axis of rotation.
     * @param {number} [angle=0.0] The angle in radians to rotate around the axis.
     * @returns {Quat} -
     */
    static axisAngleToQuat(axis, angle = 0) {
      let v4 = axis.getNormal();
      let half_angle = angle * 0.5;
      let sin_a = Math.sin(half_angle);
      return new _Quat(v4.x * sin_a, v4.y * sin_a, v4.z * sin_a, Math.cos(half_angle));
    }
    /**
     * Computes a rotation from the given heading and up vector.
     * @static
     * @param {Vec3} forward - Heading target coordinates.
     * @param {Vec3} up - Up vector.
     * @returns {Quat} -
     */
    static getLookRotation(forward2, up) {
      let f8 = forward2.getNormal().negate();
      let s7 = up.cross(f8).normalize();
      let u4 = f8.cross(s7);
      let z3 = 1 + s7.x + u4.y + f8.z;
      if (z3 > 1e-6) {
        let fd2 = 1 / (2 * Math.sqrt(z3));
        return new _Quat((f8.y - u4.z) * fd2, (s7.z - f8.x) * fd2, (u4.x - s7.y) * fd2, 0.25 / fd2);
      }
      if (s7.x > u4.y && s7.x > f8.z) {
        let fd2 = 1 / (2 * Math.sqrt(1 + s7.x - u4.y - f8.z));
        return new _Quat(0.25 / fd2, (u4.x + s7.y) * fd2, (s7.z + f8.x) * fd2, (f8.y - u4.z) * fd2);
      }
      if (u4.y > f8.z) {
        let fd2 = 1 / (2 * Math.sqrt(1 + u4.y - s7.x - f8.z));
        return new _Quat((u4.x + s7.y) * fd2, 0.25 / fd2, (f8.y + u4.z) * fd2, (s7.z - f8.x) * fd2);
      }
      let fd = 1 / (2 * Math.sqrt(1 + f8.z - s7.x - u4.y));
      return new _Quat((s7.z + f8.x) * fd, (f8.y + u4.z) * fd, 0.25 / fd, (u4.x - s7.y) * fd);
    }
    /**
     * Computes a Quat from source point heading to the destination point.
     * @static
     * @param {Vec3} sourcePoint - Source coordinate.
     * @param {Vec3} destPoint - Destination coordinate.
     * @returns {Quat} -
     */
    static getLookAtSourceDest(sourcePoint, destPoint) {
      let forwardVector = destPoint.subA(sourcePoint).normalize();
      let dot = Vec3.FORWARD.dot(forwardVector);
      if (Math.abs(dot - -1) < 1e-6) {
        return _Quat.axisAngleToQuat(Vec3.UP, Math.PI);
      }
      if (Math.abs(dot - 1) < 1e-6) {
        return new _Quat(0, 0, 0, 1);
      }
      let rotAngle = Math.acos(dot);
      let rotAxis = Vec3.FORWARD.cross(forwardVector).normalize();
      return _Quat.axisAngleToQuat(rotAxis, rotAngle);
    }
    /**
     * Compute rotation between two vectors.
     * @static
     * @param {Vec3} u - First vector.
     * @param {Vec3} v - Second vector.
     * @returns {Quat} -
     */
    static getRotationBetweenVectors(u4, v4) {
      let w3 = u4.cross(v4);
      let q2 = new _Quat(w3.x, w3.y, w3.z, 1 + u4.dot(v4));
      return q2.normalize();
    }
    /**
     * Compute rotation between two vectors.
     * @static
     * @param {Vec3} u - First vector.
     * @param {Vec3} v - Second vector.
     * @param {Quat} res
     * @returns {Quat} -
     */
    static getRotationBetweenVectorsRes(u4, v4, res) {
      let w3 = u4.cross(v4);
      res.set(w3.x, w3.y, w3.z, 1 + u4.dot(v4));
      return res.normalize();
    }
    /**
     * Compute rotation between two vectors with around vector up
     * for exactly opposite vectors. If vectors exactly in the same
     * direction as returns identity Quat.
     * @static
     * @param {Vec3} source - First vector.
     * @param {Vec3} dest - Second vector.
     * @param {Vec3} up - Up vector.
     * @returns {Quat} -
     */
    static getRotationBetweenVectorsUp(source, dest, up) {
      let dot = source.dot(dest);
      if (Math.abs(dot + 1) < 1e-6) {
        return _Quat.axisAngleToQuat(up, Math.PI);
      }
      if (Math.abs(dot - 1) < 1e-6) {
        return new _Quat(0, 0, 0, 1);
      }
      let rotAngle = Math.acos(dot);
      let rotAxis = source.cross(dest).normalize();
      return _Quat.axisAngleToQuat(rotAxis, rotAngle);
    }
    /**
     * Returns true if the components are zero.
     * @public
     * @returns {boolean} -
     */
    isZero() {
      return this.x === 0 && this.y === 0 && this.z === 0 && this.w === 0;
    }
    /**
     * Clear Quat. Sets zeroes.
     * @public
     * @returns {Quat} -
     */
    clear() {
      this.x = this.y = this.z = this.w = 0;
      return this;
    }
    /**
     * Sets Quat values.
     * @public
     * @param {Number} [x=0.0] The X component.
     * @param {Number} [y=0.0] The Y component.
     * @param {Number} [z=0.0] The Z component.
     * @param {Number} [w=0.0] The W component.
     * @returns {Quat} -
     */
    set(x3, y4, z3, w3) {
      this.x = x3;
      this.y = y4;
      this.z = z3;
      this.w = w3;
      return this;
    }
    /**
     * Copy Quat values.
     * @public
     * @param {Quat} q - Copy Quat.
     * @returns {Quat} -
     */
    copy(q2) {
      this.x = q2.x;
      this.y = q2.y;
      this.z = q2.z;
      this.w = q2.w;
      return this;
    }
    /**
     * Set current Quat instance to identity Quat.
     * @public
     * @returns {Quat} -
     */
    setIdentity() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
      return this;
    }
    /**
     * Duplicates a Quat instance.
     * @public
     * @returns {Quat} -
     */
    clone() {
      return new _Quat(this.x, this.y, this.z, this.w);
    }
    /**
     * Computes the componentwise sum of two Quats.
     * @public
     * @param {Quat} q - Quat to add.
     * @returns {Quat} -
     */
    add(q2) {
      return new _Quat(this.x + q2.x, this.y + q2.y, this.z + q2.z, this.w + q2.w);
    }
    /**
     * Computes the componentwise difference of two Quats.
     * @public
     * @param {Quat} q - Quat to subtract.
     * @returns {Quat} -
     */
    sub(q2) {
      return new _Quat(this.x - q2.x, this.y - q2.y, this.z - q2.z, this.w - q2.w);
    }
    /**
     * Multiplies the provided Quat componentwise by the provided scalar.
     * @public
     * @param {Number} scale - The scalar to multiply with.
     * @returns {Quat} -
     */
    scaleTo(scale2) {
      return new _Quat(this.x * scale2, this.y * scale2, this.z * scale2, this.w * scale2);
    }
    /**
     * Multiplies the provided Quat componentwise.
     * @public
     * @param {Number} scale - The scalar to multiply with.
     * @returns {Quat} -
     */
    scale(scale2) {
      this.x *= scale2;
      this.y *= scale2;
      this.z *= scale2;
      this.w *= scale2;
      return this;
    }
    /**
     * Converts Quat values to array.
     * @public
     * @returns {Array.<number>} - (exactly 4 entries)
     */
    toVec() {
      return [this.x, this.y, this.z, this.w];
    }
    /**
     * Sets current quaternion by spherical coordinates.
     * @public
     * @param {number} lat - Latitude.
     * @param {number} lon - Longitude.
     * @param {number} angle - Angle in radians.
     * @returns {Quat} -
     */
    setFromSphericalCoords(lat, lon, angle) {
      let sin_a = Math.sin(angle / 2);
      let cos_a = Math.cos(angle / 2);
      let sin_lat = Math.sin(lat);
      let cos_lat = Math.cos(lat);
      let sin_long = Math.sin(lon);
      let cos_long = Math.cos(lon);
      this.x = sin_a * cos_lat * sin_long;
      this.y = sin_a * sin_lat;
      this.z = sin_a * sin_lat * cos_long;
      this.w = cos_a;
      return this;
    }
    /**
     * Sets rotation with the given heading and up vectors.
     * @static
     * @param {Vec3} forward - Heading target coordinates.
     * @param {Vec3} up - Up vector.
     * @returns {Quat} -
     */
    setLookRotation(forward2, up) {
      let f8 = forward2.getNormal().negate();
      let s7 = up.cross(f8).normalize();
      let u4 = f8.cross(s7);
      let z3 = 1 + s7.x + u4.y + f8.z;
      if (z3 > 1e-6) {
        let fd = 1 / (2 * Math.sqrt(z3));
        this.x = (f8.y - u4.z) * fd;
        this.y = (s7.z - f8.x) * fd;
        this.z = (u4.x - s7.y) * fd;
        this.w = 0.25 / fd;
      } else if (s7.x > u4.y && s7.x > f8.z) {
        let fd = 1 / (2 * Math.sqrt(1 + s7.x - u4.y - f8.z));
        this.x = 0.25 / fd;
        this.y = (u4.x + s7.y) * fd;
        this.z = (s7.z + f8.x) * fd;
        this.w = (f8.y - u4.z) * fd;
      } else if (u4.y > f8.z) {
        let fd = 1 / (2 * Math.sqrt(1 + u4.y - s7.x - f8.z));
        this.x = (u4.x + s7.y) * fd;
        this.y = 0.25 / fd;
        this.z = (f8.y + u4.z) * fd;
        this.w = (s7.z - f8.x) * fd;
      } else {
        let fd = 1 / (2 * Math.sqrt(1 + f8.z - s7.x - u4.y));
        this.x = (s7.z + f8.x) * fd;
        this.y = (f8.y + u4.z) * fd;
        this.z = 0.25 / fd;
        this.w = (u4.x - s7.y) * fd;
      }
      return this;
    }
    /**
     * Gets spherical coordinates.
     * @public
     * @returns {Object} Returns object with latitude, longitude and alpha.
     */
    toSphericalCoords() {
      let cos_a = this.w;
      let sin_a = Math.sqrt(1 - cos_a * cos_a);
      if (Math.abs(sin_a) < 5e-4) {
        sin_a = 1;
      }
      let tx = this.x / sin_a;
      let ty = this.y / sin_a;
      let tz = this.z / sin_a;
      let lon, lat = -Math.asin(ty);
      if (tx * tx + tz * tz < 5e-4) {
        lon = 0;
      } else {
        lon = Math.atan2(tx, tz);
      }
      if (lon < 0) {
        lon += 360;
      }
      return {
        lat,
        lon,
        alpha: Math.acos(cos_a)
      };
    }
    /**
     * Sets current Quat representing a rotation around an axis.
     * @public
     * @param {Vec3} axis - The axis of rotation.
     * @param {number} angle The angle in radians to rotate around the axis.
     * @returns {Quat} -
     */
    setFromAxisAngle(axis, angle) {
      let v4 = axis.getNormal();
      let half_angle = angle * 0.5;
      let sin_a = Math.sin(half_angle);
      this.set(v4.x * sin_a, v4.y * sin_a, v4.z * sin_a, Math.cos(half_angle));
      return this;
    }
    /**
     * Returns axis and angle of the current Quat.
     * @public
     * @returns {Object} -
     */
    getAxisAngle() {
      let x3 = this.x, y4 = this.y, z3 = this.z, w3 = this.w;
      let vl = Math.sqrt(x3 * x3 + y4 * y4 + z3 * z3);
      let axis, angle;
      if (vl > 1e-7) {
        let ivl = 1 / vl;
        axis = new Vec3(x3 * ivl, y4 * ivl, z3 * ivl);
        if (w3 < 0) {
          angle = 2 * Math.atan2(-vl, -w3);
        } else {
          angle = 2 * Math.atan2(vl, w3);
        }
      } else {
        axis = new Vec3(0, 0, 0);
        angle = 0;
      }
      return {
        axis,
        angle
      };
    }
    /**
     * Sets current Quat by Euler's angles.
     * @public
     * @param {number} pitch - Pitch angle in degrees.
     * @param {number} yaw - Yaw angle in degrees.
     * @param {number} roll - Roll angle in degrees.
     * @returns {Quat} -
     */
    setFromEulerAngles(pitch, yaw, roll) {
      let ex = pitch * RADIANS_HALF, ey = yaw * RADIANS_HALF, ez = roll * RADIANS_HALF;
      let cr = Math.cos(ex), cp = Math.cos(ey), cy = Math.cos(ez);
      let sr = Math.sin(ex), sp = Math.sin(ey), sy = Math.sin(ez);
      let cpcy = cp * cy, spsy = sp * sy;
      this.w = cr * cpcy + sr * spsy;
      this.x = sr * cpcy - cr * spsy;
      this.y = cr * sp * cy + sr * cp * sy;
      this.z = cr * cp * sy - sr * sp * cy;
      return this.normalize();
    }
    /**
     * Returns Euler's angles of the current Quat.
     * @public
     * @returns {Object} -
     */
    getEulerAngles() {
      let x3 = this.x, y4 = this.y, z3 = this.z, w3 = this.w;
      let sqy = y4 * y4;
      let roll = Math.atan2(2 * (w3 * x3 + y4 * z3), 1 - 2 * (x3 * x3 + sqy));
      let a6 = w3 * y4 - z3 * x3;
      if (a6 < -1) {
        a6 = -1;
      } else if (a6 > 1) {
        a6 = 1;
      }
      let pitch = Math.asin(2 * a6);
      let yaw = Math.atan2(2 * (w3 * z3 + x3 * y4), 1 - 2 * (sqy + z3 * z3));
      return {
        roll,
        pitch,
        yaw
      };
    }
    /**
     * Computes a Quat from the provided 4x4 matrix instance.
     * @public
     * @param {Mat4} mx - The rotation matrix.
     * @returns {Quat} -
     */
    setFromMatrix4(mx) {
      let tr, s7, q2 = [];
      let i9, j2, k3;
      let m5 = mx._m;
      let nxt = [1, 2, 0];
      tr = m5[0] + m5[5] + m5[10];
      if (tr > 0) {
        s7 = Math.sqrt(tr + 1);
        this.w = s7 / 2;
        s7 = 0.5 / s7;
        this.x = (m5[6] - m5[9]) * s7;
        this.y = (m5[8] - m5[2]) * s7;
        this.z = (m5[1] - m5[4]) * s7;
      } else {
        i9 = 0;
        if (m5[5] > m5[0])
          i9 = 1;
        if (m5[10] > m5[i9 * 5])
          i9 = 2;
        j2 = nxt[i9];
        k3 = nxt[j2];
        s7 = Math.sqrt(m5[i9 * 5] - (m5[j2 * 5] + m5[k3 * 5]) + 1);
        q2[i9] = s7 * 0.5;
        if (s7 !== 0)
          s7 = 0.5 / s7;
        q2[3] = (m5[j2 * 4 + k3] - m5[k3 * 4 + j2]) * s7;
        q2[j2] = (m5[i9 * 4 + j2] + m5[j2 * 4 + i9]) * s7;
        q2[k3] = (m5[i9 * 4 + k3] + m5[k3 * 4 + i9]) * s7;
        this.x = q2[0];
        this.y = q2[1];
        this.z = q2[2];
        this.w = q2[3];
      }
      return this;
    }
    /**
     * Converts current Quat to the rotation 4x4 matrix.
     * @public
     * @params {Mat4} [out] - Output matrix
     * @returns {Mat4} -
     */
    getMat4(out = new Mat4()) {
      let xs = this.x + this.x;
      let ys = this.y + this.y;
      let zs = this.z + this.z;
      let wx = this.w * xs;
      let wy = this.w * ys;
      let wz = this.w * zs;
      let xx = this.x * xs;
      let xy = this.x * ys;
      let xz = this.x * zs;
      let yy = this.y * ys;
      let yz = this.y * zs;
      let zz = this.z * zs;
      return out.set([
        1 - (yy + zz),
        xy - wz,
        xz + wy,
        0,
        xy + wz,
        1 - (xx + zz),
        yz - wx,
        0,
        xz - wy,
        yz + wx,
        1 - (xx + yy),
        0,
        0,
        0,
        0,
        1
      ]);
    }
    /**
     * Converts current Quat to the rotation 3x3 matrix.
     * @public
     * @returns {Mat3} -
     * @todo NOT TESTED
     */
    getMat3() {
      let m5 = new Mat3();
      let mx = m5._m;
      let c7 = this.x, d4 = this.y, e9 = this.z, g4 = this.w, f8 = c7 + c7, h8 = d4 + d4, i9 = e9 + e9, j2 = c7 * f8, k3 = c7 * h8;
      c7 = c7 * i9;
      let l4 = d4 * h8;
      d4 = d4 * i9;
      e9 = e9 * i9;
      f8 = g4 * f8;
      h8 = g4 * h8;
      g4 = g4 * i9;
      mx[0] = 1 - (l4 + e9);
      mx[1] = k3 - g4;
      mx[2] = c7 + h8;
      mx[3] = k3 + g4;
      mx[4] = 1 - (j2 + e9);
      mx[5] = d4 - f8;
      mx[6] = c7 - h8;
      mx[7] = d4 + f8;
      mx[8] = 1 - (j2 + l4);
      return m5;
    }
    /**
     * Returns quaternion and vector production.
     * @public
     * @param {Vec3} v - 3d Vector.
     * @returns {Vec3} -
     */
    mulVec3(v4) {
      let d4 = v4.x, e9 = v4.y, g4 = v4.z;
      let b4 = this.x, f8 = this.y, h8 = this.z, a6 = this.w;
      let i9 = a6 * d4 + f8 * g4 - h8 * e9, j2 = a6 * e9 + h8 * d4 - b4 * g4, k3 = a6 * g4 + b4 * e9 - f8 * d4;
      d4 = -b4 * d4 - f8 * e9 - h8 * g4;
      return new Vec3(i9 * a6 + d4 * -b4 + j2 * -h8 - k3 * -f8, j2 * a6 + d4 * -f8 + k3 * -b4 - i9 * -h8, k3 * a6 + d4 * -h8 + i9 * -f8 - j2 * -b4);
    }
    /**
     * Computes the product of two Quats.
     * @public
     * @param {Quat} q - Quat to multiply.
     * @returns {Quat} -
     */
    mul(q2) {
      let d4 = this.x, e9 = this.y, g4 = this.z, a6 = this.w;
      let f8 = q2.x, h8 = q2.y, i9 = q2.z, b4 = q2.w;
      return new _Quat(d4 * b4 + a6 * f8 + e9 * i9 - g4 * h8, e9 * b4 + a6 * h8 + g4 * f8 - d4 * i9, g4 * b4 + a6 * i9 + d4 * h8 - e9 * f8, a6 * b4 - d4 * f8 - e9 * h8 - g4 * i9);
    }
    /**
     * Computes the product of two Quats.
     * @public
     * @param {Quat} q - Quat to multiply.
     * @returns {Quat} -
     */
    mulA(q2) {
      let d4 = this.x, e9 = this.y, g4 = this.z, a6 = this.w;
      let f8 = q2.x, h8 = q2.y, i9 = q2.z, b4 = q2.w;
      this.x = d4 * b4 + a6 * f8 + e9 * i9 - g4 * h8;
      this.y = e9 * b4 + a6 * h8 + g4 * f8 - d4 * i9;
      this.z = g4 * b4 + a6 * i9 + d4 * h8 - e9 * f8;
      this.w = a6 * b4 - d4 * f8 - e9 * h8 - g4 * i9;
      return this;
    }
    /**
     * Gets the conjugate of the Quat.
     * @public
     * @returns {Quat} -
     */
    conjugate() {
      return new _Quat(-this.x, -this.y, -this.z, this.w);
    }
    /**
     * Computes the inverse of the Quat.
     * @public
     * @returns {Quat} -
     */
    inverse() {
      let n7 = 1 / this.magnitude2();
      return new _Quat(-this.x * n7, -this.y * n7, -this.z * n7, this.w * n7);
    }
    /**
     * Computes a magnitude of the Quat.
     * @public
     * @returns {number} -
     */
    magnitude() {
      let b4 = this.x, c7 = this.y, d4 = this.z, a6 = this.w;
      return Math.sqrt(b4 * b4 + c7 * c7 + d4 * d4 + a6 * a6);
    }
    /**
     * Computes a squared magnitude of the Quat.
     * @public
     * @returns {number} -
     */
    magnitude2() {
      let b4 = this.x, c7 = this.y, d4 = this.z, a6 = this.w;
      return b4 * b4 + c7 * c7 + d4 * d4 + a6 * a6;
    }
    /**
     * Computes the dot (scalar) product of two Quats.
     * @public
     * @param {Quat} q - Second quaternion.
     * @returns {number} -
     */
    dot(q2) {
      return this.x * q2.x + this.y * q2.y + this.z * q2.z;
    }
    /**
     * Current Quat normalization.
     * @public
     * @returns {Quat} -
     */
    normalize() {
      let c7 = this.x, d4 = this.y, e9 = this.z, g4 = this.w, f8 = Math.sqrt(c7 * c7 + d4 * d4 + e9 * e9 + g4 * g4);
      if (f8 === 0) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
        return this;
      }
      f8 = 1 / f8;
      this.x = c7 * f8;
      this.y = d4 * f8;
      this.z = e9 * f8;
      this.w = g4 * f8;
      return this;
    }
    /**
     * Compares two Quats.
     * @public
     * @param {Quat} q - Second quaternion.
     * @returns {Boolean} -
     */
    isEqual(q2) {
      let matching = this.dot(q2);
      if (Math.abs(matching - 1) < 1e-3) {
        return true;
      }
      return false;
    }
    /**
     * Performs a spherical linear interpolation between two Quats.
     * @public
     * @param {Quat} b - The end rotation Quat.
     * @param {number} t - interpolation amount between the two Quats.
     * @returns {Quat} -
     */
    slerp(b4, t9) {
      let ax = this.x, ay = this.y, az = this.z, aw = this.w, bx = b4.x, by = b4.y, bz = b4.z, bw = b4.w;
      let omega, cosom, sinom, scale0, scale1;
      cosom = ax * bx + ay * by + az * bz + aw * bw;
      if (cosom < 0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      }
      if (1 - cosom > 1e-6) {
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t9) * omega) / sinom;
        scale1 = Math.sin(t9 * omega) / sinom;
      } else {
        scale0 = 1 - t9;
        scale1 = t9;
      }
      return new _Quat(scale0 * ax + scale1 * bx, scale0 * ay + scale1 * by, scale0 * az + scale1 * bz, scale0 * aw + scale1 * bw);
    }
    /**
     * Returns a roll angle in radians.
     * @public
     * @param {Boolean} [reprojectAxis] -
     * @returns {Number} -
     */
    getRoll(reprojectAxis = false) {
      let x3 = this.x, y4 = this.y, z3 = this.z, w3 = this.w;
      if (reprojectAxis) {
        let fTy = 2 * y4;
        let fTz = 2 * z3;
        let fTwz = fTz * w3;
        let fTxy = fTy * x3;
        let fTyy = fTy * y4;
        let fTzz = fTz * z3;
        return Math.atan2(fTxy + fTwz, 1 - (fTyy + fTzz));
      } else {
        return Math.atan2(2 * (x3 * y4 + w3 * z3), w3 * w3 + x3 * x3 - y4 * y4 - z3 * z3);
      }
    }
    /**
     * Returns a pitch angle in radians.
     * @public
     * @param {Boolean} [reprojectAxis] -
     * @returns {number} -
     */
    getPitch(reprojectAxis = false) {
      let x3 = this.x, y4 = this.y, z3 = this.z, w3 = this.w;
      if (reprojectAxis) {
        let fTx = 2 * x3;
        let fTz = 2 * z3;
        let fTwx = fTx * w3;
        let fTxx = fTx * x3;
        let fTyz = fTz * y4;
        let fTzz = fTz * z3;
        return Math.atan2(fTyz + fTwx, 1 - (fTxx + fTzz));
      } else {
        return Math.atan2(2 * (y4 * z3 + w3 * x3), w3 * w3 - x3 * x3 - y4 * y4 + z3 * z3);
      }
    }
    /**
     * Returns a yaw angle in radians.
     * @public
     * @param {Boolean} [reprojectAxis] -
     * @returns {number} -
     */
    getYaw(reprojectAxis = false) {
      let x3 = this.x, y4 = this.y, z3 = this.z, w3 = this.w;
      if (reprojectAxis) {
        let fTx = 2 * x3;
        let fTy = 2 * y4;
        let fTz = 2 * z3;
        let fTwy = fTy * w3;
        let fTxx = fTx * x3;
        let fTxz = fTz * x3;
        let fTyy = fTy * y4;
        return Math.atan2(fTxz + fTwy, 1 - (fTxx + fTyy));
      } else {
        return Math.asin(-2 * (x3 * z3 - w3 * y4));
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/math/Vec3.js
  var Vec3 = class _Vec3 {
    constructor(x3 = 0, y4 = 0, z3 = 0) {
      this.x = x3;
      this.y = y4;
      this.z = z3;
    }
    /** @const */
    static get UP() {
      return new _Vec3(0, 1, 0);
    }
    /** @const */
    static get DOWN() {
      return new _Vec3(0, -1, 0);
    }
    /** @const */
    static get RIGHT() {
      return new _Vec3(1, 0, 0);
    }
    /** @const */
    static get LEFT() {
      return new _Vec3(-1, 0, 0);
    }
    /** @const */
    static get FORWARD() {
      return new _Vec3(0, 0, -1);
    }
    /** @const */
    static get BACKWARD() {
      return new _Vec3(0, 0, 1);
    }
    /** @const */
    static get ZERO() {
      return new _Vec3();
    }
    /** @const */
    static get UNIT_X() {
      return new _Vec3(1, 0, 0);
    }
    /** @const */
    static get UNIT_Y() {
      return new _Vec3(0, 1, 0);
    }
    /** @const */
    static get UNIT_Z() {
      return new _Vec3(0, 0, 1);
    }
    /** @const */
    static get NORTH() {
      return _Vec3.UNIT_Z;
    }
    /**
     * Separate 63 bit Vec3 to two Vec3 32-bit float values.
     * @function
     * @param {Vec3} v - Double type value.
     * @param {Vec3} high - Out vector high values.
     * @param {Vec3} low - Out vector low values.
     */
    static doubleToTwoFloats(v4, high, low) {
      let x3 = v4.x, y4 = v4.y, z3 = v4.z;
      if (x3 >= 0) {
        let doubleHigh = Math.floor(x3 / 65536) * 65536;
        high.x = Math.fround(doubleHigh);
        low.x = Math.fround(x3 - doubleHigh);
      } else {
        let doubleHigh = Math.floor(-x3 / 65536) * 65536;
        high.x = Math.fround(-doubleHigh);
        low.x = Math.fround(x3 + doubleHigh);
      }
      if (y4 >= 0) {
        let doubleHigh = Math.floor(y4 / 65536) * 65536;
        high.y = Math.fround(doubleHigh);
        low.y = Math.fround(y4 - doubleHigh);
      } else {
        let doubleHigh = Math.floor(-y4 / 65536) * 65536;
        high.y = Math.fround(-doubleHigh);
        low.y = Math.fround(y4 + doubleHigh);
      }
      if (z3 >= 0) {
        let doubleHigh = Math.floor(z3 / 65536) * 65536;
        high.z = Math.fround(doubleHigh);
        low.z = Math.fround(z3 - doubleHigh);
      } else {
        let doubleHigh = Math.floor(-z3 / 65536) * 65536;
        high.z = Math.fround(-doubleHigh);
        low.z = Math.fround(z3 + doubleHigh);
      }
    }
    /**
     * Separate 63 bit Vec3 to two Vec3 32-bit float values.
     * @function
     * @param {Vec3} v - Double type value.
     * @param {Float32Array} high - Out vector high values.
     * @param {Float32Array} low - Out vector low values.
     * @returns {Array.<number>} Encoded array. (exactly 2 entries)
     */
    static doubleToTwoFloat32Array(v4, high, low) {
      let x3 = v4.x, y4 = v4.y, z3 = v4.z;
      if (x3 >= 0) {
        let doubleHigh = Math.floor(x3 / 65536) * 65536;
        high[0] = Math.fround(doubleHigh);
        low[0] = Math.fround(x3 - doubleHigh);
      } else {
        let doubleHigh = Math.floor(-x3 / 65536) * 65536;
        high[0] = Math.fround(-doubleHigh);
        low[0] = Math.fround(x3 + doubleHigh);
      }
      if (y4 >= 0) {
        let doubleHigh = Math.floor(y4 / 65536) * 65536;
        high[1] = Math.fround(doubleHigh);
        low[1] = Math.fround(y4 - doubleHigh);
      } else {
        let doubleHigh = Math.floor(-y4 / 65536) * 65536;
        high[1] = Math.fround(-doubleHigh);
        low[1] = Math.fround(y4 + doubleHigh);
      }
      if (z3 >= 0) {
        let doubleHigh = Math.floor(z3 / 65536) * 65536;
        high[2] = Math.fround(doubleHigh);
        low[2] = Math.fround(z3 - doubleHigh);
      } else {
        let doubleHigh = Math.floor(-z3 / 65536) * 65536;
        high[2] = Math.fround(-doubleHigh);
        low[2] = Math.fround(z3 + doubleHigh);
      }
    }
    /**
     * Creates 3d vector from array.
     * @function
     * @param {NumberArray2 | NumberArray3 | NumberArray4} arr - Input array (exactly 3 entries)
     * @returns {Vec3} -
     */
    static fromVec(arr) {
      return new _Vec3(arr[0], arr[1], arr[2]);
    }
    /**
     * Gets angle between two vectors.
     * @static
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {number} -
     */
    static angle(a6, b4) {
      return Math.acos(a6.dot(b4) / Math.sqrt(a6.length2() * b4.length2()));
    }
    /**
     * Returns two vectors linear interpolation.
     * @static
     * @param {Vec3} v1 - Start vector.
     * @param {Vec3} v2 - End vector.
     * @param {number} l - Interpolate value.
     * @returns {Vec3} -
     */
    static lerp(v1, v22, l4) {
      return new _Vec3(v1.x + (v22.x - v1.x) * l4, v1.y + (v22.y - v1.y) * l4, v1.z + (v22.z - v1.z) * l4);
    }
    /**
     * Returns summary vector.
     * @static
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Vec3} - Summary vector.
     */
    static add(a6, b4) {
      let res = new _Vec3(a6.x, a6.y, a6.z);
      res.addA(b4);
      return res;
    }
    /**
     * Returns two vectors subtraction.
     * @static
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Vec3} - Vectors subtraction.
     */
    static sub(a6, b4) {
      let res = new _Vec3(a6.x, a6.y, a6.z);
      res.subA(b4);
      return res;
    }
    /**
     * Returns scaled vector.
     * @static
     * @param {Vec3} a - Input vector.
     * @param {number} scale - Scale value.
     * @returns {Vec3} -
     */
    static scale(a6, scale2) {
      return a6.scaleTo(scale2);
    }
    /**
     * Returns two vectors production.
     * @static
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Vec3} -
     */
    static mul(a6, b4) {
      let res = new _Vec3(a6.x, a6.y, a6.z);
      res.mulA(b4);
      return res;
    }
    /**
     * Returns true if two vectors are non-collinear.
     * @public
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Vec3} -
     */
    static noncollinear(a6, b4) {
      return Boolean(a6.y * b4.z - a6.z * b4.y || a6.z * b4.x - a6.x * b4.z || a6.x * b4.y - a6.y * b4.z);
    }
    /**
     * Get projection of the vector to plane where n - normal to the plane.
     * @static
     * @param {Vec3} b - Vector to project.
     * @param {Vec3} n - Plane normal.
     * @param {Vec3} [def] - Default value for non existed result.
     * @returns {Vec3} -
     */
    static proj_b_to_plane(b4, n7, def) {
      let res = b4.sub(n7.scaleTo(n7.dot(b4) / n7.dot(n7)));
      if (def && res.isZero()) {
        return new _Vec3(def.x, def.y, def.z);
      }
      return res;
    }
    /**
     * Get projection of the first vector to the second.
     * @static
     * @param {Vec3} b - First vector.
     * @param {Vec3} a - Second vector.
     * @returns {Vec3} -
     */
    static proj_b_to_a(b4, a6) {
      return a6.scaleTo(a6.dot(b4) / a6.dot(a6));
    }
    /**
     * Makes vectors normalized and orthogonal to each other.
     * Normalizes normal. Normalizes tangent and makes sure it is orthogonal to normal (that is, angle between them is 90 degrees).
     * @static
     * @param {Vec3} normal - Normal vector.
     * @param {Vec3} tangent - Tangent vector.
     * @returns {Vec3} -
     */
    static orthoNormalize(normal, tangent) {
      normal = normal.getNormal();
      normal.scale(tangent.dot(normal));
      return tangent.subA(normal).normalize();
    }
    /**
     * Returns vector components division product one to another.
     * @static
     * @param {Vec3} a - First vector.
     * @param {Vec3} b - Second vector.
     * @returns {Vec3} -
     */
    static div(a6, b4) {
      let res = new _Vec3(a6.x, a6.y, a6.z);
      res.divA(b4);
      return res;
    }
    static length2(a6) {
      return a6.length2();
    }
    // static length(a: Vec3): number {
    //     return a.length();
    // }
    static dot(a6, b4) {
      return a6.dot(b4);
    }
    /**
     * Converts to 4d vector, Fourth value is 1.0.
     * @public
     * @returns {Vec4} -
     */
    toVec4() {
      return new Vec4(this.x, this.y, this.z, 1);
    }
    /**
     * Returns clone vector.
     * @public
     * @returns {Vec3} -
     */
    clone() {
      return new _Vec3(this.x, this.y, this.z);
    }
    /**
     * Converts vector to text string.
     * @public
     * @returns {string} -
     */
    toString() {
      return `(${this.x},${this.y},${this.z})`;
    }
    /**
     * Returns true if vector's values are zero.
     * @public
     * @returns {boolean} -
     */
    isZero() {
      return !(this.x || this.y || this.z);
    }
    /**
     * Get projection of the first vector to the second.
     * @static
     * @param {Vec3} a - Project vector.
     * @returns {Vec3} -
     */
    projToVec(a6) {
      return a6.scaleTo(a6.dot(this) / a6.dot(a6));
    }
    /**
     * Compares with vector. Returns true if it equals another.
     * @public
     * @param {Vec3} p - Vector to compare.
     * @returns {boolean} -
     */
    equal(p4) {
      return this.x === p4.x && this.y === p4.y && this.z === p4.z;
    }
    /**
     * Copy input vector's values.
     * @param {Vec3} p - Vector to copy.
     * @returns {Vec3} -
     */
    copy(p4) {
      this.x = p4.x;
      this.y = p4.y;
      this.z = p4.z;
      return this;
    }
    /**
     * Gets vector's length.
     * @public
     * @returns {number} -
     */
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    /**
     * Returns squared vector's length.
     * @public
     * @returns {number} -
     */
    length2() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    /**
     * Converts vector's values to a quaternion object.
     * @public
     * @returns {Quat} -
     */
    getQuat() {
      return new Quat(this.x, this.y, this.z);
    }
    /**
     * Adds vector to the current.
     * @public
     * @param {Vec3} p - Point to add.
     * @returns {Vec3} -
     */
    addA(p4) {
      this.x += p4.x;
      this.y += p4.y;
      this.z += p4.z;
      return this;
    }
    /**
     * Gets two vectors summarization.
     * @public
     * @param {Vec3} p - Vector to add.
     * @returns {Vec3} Returns a sum vector.
     */
    add(p4) {
      return new _Vec3(this.x + p4.x, this.y + p4.y, this.z + p4.z);
    }
    /**
     * Subtract vector from the current.
     * @public
     * @param {Vec3} p - Subtract vector.
     * @returns {Vec3} -
     */
    subA(p4) {
      this.x -= p4.x;
      this.y -= p4.y;
      this.z -= p4.z;
      return this;
    }
    /**
     * Gets vector subtraction.
     * @public
     * @param {Vec3} p - Subtract vector.
     * @return {Vec3} Returns new instance of a subtraction
     */
    sub(p4) {
      return new _Vec3(this.x - p4.x, this.y - p4.y, this.z - p4.z);
    }
    /**
     * Scale current vector.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec3} -
     */
    scale(scale2) {
      this.x *= scale2;
      this.y *= scale2;
      this.z *= scale2;
      return this;
    }
    /**
     * Scale current vector to another instance.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec3} -
     */
    scaleTo(scale2) {
      return new _Vec3(this.x * scale2, this.y * scale2, this.z * scale2);
    }
    /**
     * Multiply current vector object to another and store result in the current instance.
     * @public
     * @param {Vec3} vec - Multiply vector.
     * @returns {Vec3} -
     */
    mulA(vec) {
      this.x *= vec.x;
      this.y *= vec.y;
      this.z *= vec.z;
      return this;
    }
    /**
     * Multiply current vector object to another and returns new vector instance.
     * @public
     * @param {Vec3} vec - Multiply vector.
     * @returns {Vec3} -
     */
    mul(vec) {
      return new _Vec3(this.x * vec.x, this.y * vec.y, this.z * vec.z);
    }
    /**
     * Divide current vector's components to another. Results stores in the current vector object.
     * @public
     * @param {Vec3} vec - Div vector.
     * @returns {Vec3} -
     */
    divA(vec) {
      this.x /= vec.x;
      this.y /= vec.y;
      this.z /= vec.z;
      return this;
    }
    /**
     * Divide current vector's components to another and returns new vector instance.
     * @public
     * @param {Vec3} vec - Div vector.
     * @returns {Vec3} -
     */
    div(vec) {
      return new _Vec3(this.x / vec.x, this.y / vec.y, this.z / vec.z);
    }
    /**
     * Gets vectors dot production.
     * @public
     * @param {Vec3} a - Another vector.
     * @returns {number} -
     */
    dot(a6) {
      return a6.x * this.x + a6.y * this.y + a6.z * this.z;
    }
    /**
     * Gets vectors dot production.
     * @public
     * @param {Array.<number>} arr - Array vector. (exactly 3 entries)
     * @returns {number} -
     */
    dotArr(arr) {
      return arr[0] * this.x + arr[1] * this.y + arr[2] * this.z;
    }
    /**
     * Gets vectors cross production.
     * @public
     * @param {Vec3} point3 - Another vector.
     * @returns {Vec3} -
     */
    cross(point3) {
      return new _Vec3(this.y * point3.z - this.z * point3.y, this.z * point3.x - this.x * point3.z, this.x * point3.y - this.y * point3.x);
    }
    /**
     * Sets vector to zero.
     * @public
     * @returns {Vec3} -
     */
    clear() {
      this.x = this.y = this.z = 0;
      return this;
    }
    /**
     * Returns normalized vector.
     * @public
     * @returns {Vec3} -
     */
    getNormal() {
      let res = new _Vec3();
      res.copy(this);
      let length = 1 / res.length();
      res.x *= length;
      res.y *= length;
      res.z *= length;
      return res;
    }
    /**
     * Returns normalized vector.
     * @deprecated
     * @public
     * @returns {Vec3} -
     */
    normal() {
      let res = new _Vec3();
      res.copy(this);
      let length = 1 / res.length();
      res.x *= length;
      res.y *= length;
      res.z *= length;
      return res;
    }
    /**
     * Returns normalized negate vector.
     * @public
     * @returns {Vec3} -
     */
    normalNegate() {
      let res = new _Vec3();
      res.copy(this);
      let length = -1 / res.length();
      res.x *= length;
      res.y *= length;
      res.z *= length;
      return res;
    }
    /**
     * Returns normalized negate scale vector.
     * @public
     * @returns {Vec3} -
     */
    normalNegateScale(scale2) {
      let res = new _Vec3();
      res.copy(this);
      let length = -scale2 / res.length();
      res.x *= length;
      res.y *= length;
      res.z *= length;
      return res;
    }
    /**
     * Returns normalized scale vector.
     * @public
     * @returns {Vec3} -
     */
    normalScale(scale2) {
      let res = new _Vec3();
      res.copy(this);
      let length = scale2 / res.length();
      res.x *= length;
      res.y *= length;
      res.z *= length;
      return res;
    }
    /**
     * Normalize current vector.
     * @public
     * @returns {Vec3} -
     */
    normalize() {
      let length = 1 / this.length();
      this.x *= length;
      this.y *= length;
      this.z *= length;
      return this;
    }
    /**
     * Converts vector to a number array.
     * @public
     * @returns {Array.<number>} - (exactly 3 entries)
     * @deprecated
     */
    toVec() {
      return [this.x, this.y, this.z];
    }
    /**
     * Converts vector to a number array.
     * @public
     * @returns {Array.<number>} - (exactly 3 entries)
     */
    toArray() {
      return [this.x, this.y, this.z];
    }
    /**
     * Gets distance to point.
     * @public
     * @param {Vec3} p - Distant point.
     * @returns {number} -
     */
    distance(p4) {
      let dx = this.x - p4.x, dy = this.y - p4.y, dz = this.z - p4.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    /**
     * Gets square distance to point.
     * @public
     * @param {Vec3} p - Distant point.
     * @returns {number} -
     */
    distance2(p4) {
      let dx = this.x - p4.x, dy = this.y - p4.y, dz = this.z - p4.z;
      return dx * dx + dy * dy + dz * dz;
    }
    /**
     * Sets vector's values.
     * @public
     * @param {number} x - Value X.
     * @param {number} y - Value Y.
     * @param {number} z - Value Z.
     * @returns {Vec3} -
     */
    set(x3, y4, z3) {
      this.x = x3;
      this.y = y4;
      this.z = z3;
      return this;
    }
    /**
     * Negate current vector.
     * @public
     * @returns {Vec3} -
     */
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    /**
     * Negate current vector to another instance.
     * @public
     * @returns {Vec3} -
     */
    negateTo() {
      return new _Vec3(-this.x, -this.y, -this.z);
    }
    /**
     * Gets projected point coordinates of the current vector on the ray.
     * @public
     * @param {Vec3} pos - Ray position.
     * @param {Vec3} direction - Ray direction.
     * @returns {Vec3} -
     */
    projToRay(pos, direction) {
      let v4 = _Vec3.proj_b_to_a(_Vec3.sub(this, pos), direction);
      v4.addA(pos);
      return v4;
    }
    /**
     * Gets angle between two vectors.
     * @public
     * @param {Vec3} a - Another vector.
     * @returns {number} -
     */
    angle(a6) {
      return _Vec3.angle(this, a6);
    }
    /**
     * Returns two vectors linear interpolation.
     * @public
     * @param {Vec3} v2 - End vector.
     * @param {number} l - Interpolate value.
     * @returns {Vec3} -
     */
    lerp(v22, l4) {
      return new _Vec3(this.x + (v22.x - this.x) * l4, this.y + (v22.y - this.y) * l4, this.z + (v22.z - this.z) * l4);
    }
    /**
     * Returns vector interpolation by v(t) = v1 * t + v2 * (1 - t)
     * @public
     * @param {Vec3} v2 - End vector.
     * @param {number} t - Interpolate value.
     * @returns {Vec3} -
     */
    smerp(v22, t9) {
      let one_d = 1 - t9;
      return new _Vec3(this.x * t9 + v22.x * one_d, this.y * t9 + v22.y * one_d, this.z * t9 + v22.z * one_d);
    }
    static get LERP_DELTA() {
      return 1e-6;
    }
    /**
     * Spherically interpolates between two vectors.
     * Interpolates between current and v2 vector by amount t. The difference between this and linear interpolation (aka, "lerp") is that
     * the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated
     * by the angle and its magnitude is interpolated between the magnitudes of from and to.
     * @public
     * @param {Vec3} v2 -
     * @param {number} t - The parameter t is clamped to the range [0, 1].
     * @returns {Vec3} -
     */
    slerp(v22, t9) {
      let res = new _Vec3();
      if (t9 <= 0) {
        res.copy(this);
        return res;
      } else if (t9 >= 1) {
        res.copy(v22);
        return res;
      }
      let omega, sinom, scale0, scale1;
      let cosom = this.dot(v22);
      if (1 - cosom > _Vec3.LERP_DELTA) {
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t9) * omega) / sinom;
        scale1 = Math.sin(t9 * omega) / sinom;
      } else {
        scale0 = 1 - t9;
        scale1 = t9;
      }
      return _Vec3.add(this.scaleTo(scale0), v22.scale(scale1));
    }
    /**
     * Gets the shortest arc quaternion to rotate this vector to the destination vector.
     * @param {Vec3} dest -
     * @param {Vec3} fallbackAxis -
     * @returns {Quat} -
     * @todo: TEST IT!
     */
    getRotationTo(dest, fallbackAxis) {
      let v0 = this.clone();
      let v1 = dest.clone();
      v0.normalize();
      v1.normalize();
      let d4 = v0.dot(v1);
      if (d4 >= 1) {
        return Quat.IDENTITY.clone();
      }
      if (d4 < 1e-6 - 1) {
        if (!fallbackAxis.equal(_Vec3.ZERO)) {
          return Quat.axisAngleToQuat(fallbackAxis, Math.PI);
        } else {
          let axis = _Vec3.UNIT_X.cross(v0);
          if (axis.isZero()) {
            axis = _Vec3.UNIT_Y.cross(v0);
          }
          axis.normalize();
          return Quat.axisAngleToQuat(axis, Math.PI);
        }
      } else {
        let s7 = Math.sqrt((1 + d4) * 2);
        let invs = 1 / s7;
        let c7 = v0.cross(v1);
        let q2 = new Quat(c7.x * invs, c7.y * invs, c7.z * invs, s7 * 0.5);
        q2.normalize();
        return q2;
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/math/Vec2.js
  var Vec2 = class _Vec2 {
    constructor(x3 = 0, y4 = 0) {
      this.x = x3;
      this.y = y4;
    }
    /** @const */
    static get UP() {
      return new _Vec2(0, 1);
    }
    /** @const */
    static get DOWN() {
      return new _Vec2(0, -1);
    }
    /** @const */
    static get RIGHT() {
      return new _Vec2(1, 0);
    }
    /** @const */
    static get LEFT() {
      return new _Vec2(-1, 0);
    }
    /** @const */
    static get ZERO() {
      return new _Vec2();
    }
    /**
     * Returns summary vector.
     * @static
     * @param {Vec2} a - First vector.
     * @param {Vec2} b - Second vector.
     * @returns {Vec2} - Summary vector.
     */
    static add(a6, b4) {
      const res = new _Vec2(a6.x, a6.y);
      res.addA(b4);
      return res;
    }
    /**
     * Returns two vectors subtraction.
     * @static
     * @param {Vec2} a - First vector.
     * @param {Vec2} b - Second vector.
     * @returns {Vec2} - Vectors subtraction.
     */
    static sub(a6, b4) {
      var res = new _Vec2(a6.x, a6.y);
      res.subA(b4);
      return res;
    }
    /**
     * Returns scaled vector.
     * @static
     * @param {Vec2} a - Input vector.
     * @param {number} scale - Scale value.
     * @returns {Vec2}
     */
    static scale(a6, scale2) {
      let res = new _Vec2(a6.x, a6.y);
      res.scale(scale2);
      return res;
    }
    /**
     * Returns two vectors production.
     * @static
     * @param {Vec2} a - First vector.
     * @param {Vec2} b - Second vector.
     * @returns {Vec2}
     */
    static mul(a6, b4) {
      let res = new _Vec2(a6.x, a6.y);
      res.mulA(b4);
      return res;
    }
    /**
     * Returns vector components division product one to another.
     * @static
     * @param {Vec2} a - First vector.
     * @param {Vec2} b - Second vector.
     * @returns {Vec2}
     */
    static div(a6, b4) {
      let res = new _Vec2(a6.x, a6.y);
      res.divA(b4);
      return res;
    }
    /**
     * Get projection of the first vector to the second.
     * @static
     * @param {Vec2} b - First vector.
     * @param {Vec2} a - Second vector.
     * @returns {Vec2}
     */
    static proj_b_to_a(b4, a6) {
      return a6.scaleTo(a6.dot(b4) / a6.dot(a6));
    }
    /**
     * Gets angle between two vectors.
     * @static
     * @param {Vec2} a - First vector.
     * @param {Vec2} b - Second vector.
     * @returns {number}
     */
    static angle(a6, b4) {
      return Math.acos(a6.dot(b4) / Math.sqrt(a6.length2() * b4.length2()));
    }
    /**
     * Makes vectors normalized and orthogonal to each other.
     * @static
     * @param {Vec2} normal - Normal vector.
     * @param {Vec2} tangent - Tangent vector.
     * @returns {Vec2}
     */
    static orthoNormalize(normal, tangent) {
      normal = normal.normal();
      normal.scale(tangent.dot(normal));
      return tangent.sub(normal).normalize();
    }
    /**
     * Converts to 3d vector, third value is 0.0.
     * @public
     * @returns {Vec3}
     */
    toVector3() {
      return new Vec3(this.x, this.y, 0);
    }
    /**
     * Returns clone vector.
     * @public
     * @returns {Vec2}
     */
    clone() {
      return new _Vec2(this.x, this.y);
    }
    /**
     * Compares with vector. Returns true if it equals another.
     * @public
     * @param {Vec2} p - Vector to compare.
     * @returns {boolean}
     */
    equal(p4) {
      return this.x === p4.x && this.y === p4.y;
    }
    /**
     * Copy input vector's values.
     * @param {Vec2} point2 - Vector to copy.
     * @returns {Vec2}
     */
    copy(point2) {
      this.x = point2.x;
      this.y = point2.y;
      return this;
    }
    /**
     * Gets vector's length.
     * @public
     * @returns {number}
     */
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    /**
     * Returns squared vector's length.
     * @public
     * @returns {number}
     */
    length2() {
      return this.x * this.x + this.y * this.y;
    }
    /**
     * Adds vector to the current.
     * @public
     * @param {Vec2}
     * @returns {Vec2}
     */
    addA(v4) {
      this.x += v4.x;
      this.y += v4.y;
      return this;
    }
    /**
     * Summarize two vectors.
     * @public
     * @param {Vec2}
     * @returns {Vec2}
     */
    add(v4) {
      return new _Vec2(this.x + v4.x, this.y + v4.y);
    }
    /**
     * Subtract vector from the current where results saved on the current instance.
     * @public
     * @param {Vec2} v - Subtract vector.
     * @returns {Vec2}
     */
    subA(v4) {
      this.x -= v4.x;
      this.y -= v4.y;
      return this;
    }
    /**
     * Subtract vector from the current.
     * @public
     * @param {Vec2} v - Subtract vector.
     * @returns {Vec2}
     */
    sub(v4) {
      return new _Vec2(this.x - v4.x, this.y - v4.y);
    }
    /**
     * Scale current vector.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec2}
     */
    scale(scale2) {
      this.x *= scale2;
      this.y *= scale2;
      return this;
    }
    /**
     * Scale current vector to another instance.
     * @public
     * @param {number} scale - Scale value.
     * @returns {Vec2}
     */
    scaleTo(scale2) {
      return new _Vec2(this.x * scale2, this.y * scale2);
    }
    /**
     * Multiply current vector object to another and store result in the current instance.
     * @public
     * @param {Vec2} vec - Multiply vector.
     * @returns {Vec2}
     */
    mulA(vec) {
      this.x *= vec.x;
      this.y *= vec.y;
      return this;
    }
    /**
     * Multiply current vector object to another and returns new vector instance.
     * @public
     * @param {Vec2} vec - Multiply vector.
     * @returns {Vec2}
     */
    mul(vec) {
      return new _Vec2(this.x * vec.x, this.y * vec.y);
    }
    /**
     * Divide current vector's components to another. Results stores in the current vector object.
     * @public
     * @param {Vec2}
     * @returns {Vec2}
     */
    divA(vec) {
      this.x /= vec.x;
      this.y /= vec.y;
      return this;
    }
    /**
     * Gets vectors dot production.
     * @public
     * @param {Vec2} v - Another vector.
     * @returns {number}
     */
    dot(v4) {
      return v4.x * this.x + v4.y * this.y;
    }
    /**
     * Gets vectors dot production.
     * @public
     * @param {Array.<number>} arr - Array vector. (exactly 2 entries)
     * @returns {number}
     */
    dotArr(arr) {
      return arr[0] * this.x + arr[1] * this.y;
    }
    /**
     * Gets vectors cross production.
     * @public
     * @param {Vec2} v - Another vector.
     * @returns {number}
     */
    cross(v4) {
      return this.x * v4.y - this.y * v4.x;
    }
    /**
     * Sets vector to zero.
     * @public
     * @returns {Vec2}
     */
    clear() {
      this.x = this.y = 0;
      return this;
    }
    /**
     * Returns normalized vector.
     * @public
     * @returns {Vec2}
     */
    normal() {
      let res = new _Vec2();
      res.copy(this);
      let length = 1 / res.length();
      res.x *= length;
      res.y *= length;
      return res;
    }
    /**
     * Normalize current vector.
     * @public
     * @returns {Vec2}
     */
    normalize() {
      let length = 1 / this.length();
      this.x *= length;
      this.y *= length;
      return this;
    }
    /**
     * Converts vector to a number array.
     * @public
     * @returns {Array.<number>} - (exactly 2 entries)
     */
    toVec() {
      return [this.x, this.y];
    }
    /**
     * Gets distance to point.
     * @public
     * @param {Vec2} p - Distant point.
     * @returns {number}
     */
    distance(p4) {
      let vec = _Vec2.sub(this, p4);
      return vec.length();
    }
    /**
     * Sets vector's values.
     * @public
     * @param {number} x - Value X.
     * @param {number} y - Value Y.
     * @returns {Vec2}
     */
    set(x3, y4) {
      this.x = x3;
      this.y = y4;
      return this;
    }
    /**
     * Negate current vector.
     * @public
     * @returns {Vec2}
     */
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    /**
     * Negate current vector to another instance.
     * @public
     * @returns {Vec2}
     */
    negateTo() {
      return new _Vec2(-this.x, -this.y);
    }
    /**
     * Gets projected point coordinates of the current vector on the ray.
     * @public
     * @param {Vec2} pos - Ray position.
     * @param {Vec2} direction - Ray direction.
     * @returns {Vec2}
     */
    projToRay(pos, direction) {
      let v4 = _Vec2.proj_b_to_a(_Vec2.sub(this, pos), direction);
      v4.add(pos);
      return v4;
    }
    /**
     * Gets angle between two vectors.
     * @public
     * @param {Vec2} a - Another vector.
     * @returns {number}
     */
    angle(a6) {
      return _Vec2.angle(this, a6);
    }
    /**
     * Returns two vectors linear interpolation.
     * @public
     * @param {Vec2} v2 - End vector.
     * @param {number} l - Interpolate value.
     * @returns {Vec2}
     */
    lerp(v1, v22, l4) {
      let res = this.clone();
      if (l4 <= 0) {
        res.copy(v1);
      } else if (l4 >= 1) {
        res.copy(v22);
      } else {
        res = _Vec2.add(v1, _Vec2.sub(v22, v1).scale(l4));
      }
      return res;
    }
    static get LERP_DELTA() {
      return 1e-6;
    }
    /**
     * Spherically interpolates between two vectors.
     * Interpolates between current and v2 vector by amount t. The difference between this and linear interpolation (aka, "lerp") is that
     * the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated
     * by the angle and its magnitude is interpolated between the magnitudes of from and to.
     * @public
     * @param {Vec2} v2
     * @param {number} t - The parameter t is clamped to the range [0, 1].
     * @returns {Vec2}
     */
    slerp(v22, t9) {
      let res = new _Vec2();
      if (t9 <= 0) {
        res.copy(this);
        return res;
      } else if (t9 >= 1) {
        res.copy(v22);
        return res;
      }
      let omega, sinom, scale0, scale1;
      let cosom = this.dot(v22);
      if (1 - cosom > _Vec2.LERP_DELTA) {
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t9) * omega) / sinom;
        scale1 = Math.sin(t9 * omega) / sinom;
      } else {
        scale0 = 1 - t9;
        scale1 = t9;
      }
      return _Vec2.add(this.scale(scale0), v22.scale(scale1));
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/colorTable.js
  var colorTable = {
    "aliceblue": "#f0f8ff",
    "antiquewhite": "#faebd7",
    "aqua": "#00ffff",
    "aquamarine": "#7fffd4",
    "azure": "#f0ffff",
    "beige": "#f5f5dc",
    "bisque": "#ffe4c4",
    "black": "#000000",
    "blanchedalmond": "#ffebcd",
    "blue": "#0000ff",
    "blueviolet": "#8a2be2",
    "brown": "#a52a2a",
    "burlywood": "#deb887",
    "cadetblue": "#5f9ea0",
    "chartreuse": "#7fff00",
    "chocolate": "#d2691e",
    "coral": "#ff7f50",
    "cornflowerblue": "#6495ed",
    "cornsilk": "#fff8dc",
    "crimson": "#dc143c",
    "cyan": "#00ffff",
    "darkblue": "#00008b",
    "darkcyan": "#008b8b",
    "darkgoldenrod": "#b8860b",
    "darkgray": "#a9a9a9",
    "darkgreen": "#006400",
    "darkkhaki": "#bdb76b",
    "darkmagenta": "#8b008b",
    "darkolivegreen": "#556b2f",
    "darkorange": "#ff8c00",
    "darkorchid": "#9932cc",
    "darkred": "#8b0000",
    "darksalmon": "#e9967a",
    "darkseagreen": "#8fbc8f",
    "darkslateblue": "#483d8b",
    "darkslategray": "#2f4f4f",
    "darkturquoise": "#00ced1",
    "darkviolet": "#9400d3",
    "deeppink": "#ff1493",
    "deepskyblue": "#00bfff",
    "dimgray": "#696969",
    "dodgerblue": "#1e90ff",
    "firebrick": "#b22222",
    "floralwhite": "#fffaf0",
    "forestgreen": "#228b22",
    "fuchsia": "#ff00ff",
    "gainsboro": "#dcdcdc",
    "ghostwhite": "#f8f8ff",
    "gold": "#ffd700",
    "goldenrod": "#daa520",
    "gray": "#808080",
    "green": "#008000",
    "greenyellow": "#adff2f",
    "honeydew": "#f0fff0",
    "hotpink": "#ff69b4",
    "indianred ": "#cd5c5c",
    "indigo": "#4b0082",
    "ivory": "#fffff0",
    "khaki": "#f0e68c",
    "lavender": "#e6e6fa",
    "lavenderblush": "#fff0f5",
    "lawngreen": "#7cfc00",
    "lemonchiffon": "#fffacd",
    "lightblue": "#add8e6",
    "lightcoral": "#f08080",
    "lightcyan": "#e0ffff",
    "lightgoldenrodyellow": "#fafad2",
    "lightgrey": "#d3d3d3",
    "lightgreen": "#90ee90",
    "lightpink": "#ffb6c1",
    "lightsalmon": "#ffa07a",
    "lightseagreen": "#20b2aa",
    "lightskyblue": "#87cefa",
    "lightslategray": "#778899",
    "lightsteelblue": "#b0c4de",
    "lightyellow": "#ffffe0",
    "lime": "#00ff00",
    "limegreen": "#32cd32",
    "linen": "#faf0e6",
    "magenta": "#ff00ff",
    "maroon": "#800000",
    "mediumaquamarine": "#66cdaa",
    "mediumblue": "#0000cd",
    "mediumorchid": "#ba55d3",
    "mediumpurple": "#9370d8",
    "mediumseagreen": "#3cb371",
    "mediumslateblue": "#7b68ee",
    "mediumspringgreen": "#00fa9a",
    "mediumturquoise": "#48d1cc",
    "mediumvioletred": "#c71585",
    "midnightblue": "#191970",
    "mintcream": "#f5fffa",
    "mistyrose": "#ffe4e1",
    "moccasin": "#ffe4b5",
    "navajowhite": "#ffdead",
    "navy": "#000080",
    "oldlace": "#fdf5e6",
    "olive": "#808000",
    "olivedrab": "#6b8e23",
    "orange": "#ffa500",
    "orangered": "#ff4500",
    "orchid": "#da70d6",
    "palegoldenrod": "#eee8aa",
    "palegreen": "#98fb98",
    "paleturquoise": "#afeeee",
    "palevioletred": "#d87093",
    "papayawhip": "#ffefd5",
    "peachpuff": "#ffdab9",
    "peru": "#cd853f",
    "pink": "#ffc0cb",
    "plum": "#dda0dd",
    "powderblue": "#b0e0e6",
    "purple": "#800080",
    "rebeccapurple": "#663399",
    "red": "#ff0000",
    "rosybrown": "#bc8f8f",
    "royalblue": "#4169e1",
    "saddlebrown": "#8b4513",
    "salmon": "#fa8072",
    "sandybrown": "#f4a460",
    "seagreen": "#2e8b57",
    "seashell": "#fff5ee",
    "sienna": "#a0522d",
    "silver": "#c0c0c0",
    "skyblue": "#87ceeb",
    "slateblue": "#6a5acd",
    "slategray": "#708090",
    "snow": "#fffafa",
    "springgreen": "#00ff7f",
    "steelblue": "#4682b4",
    "tan": "#d2b48c",
    "teal": "#008080",
    "thistle": "#d8bfd8",
    "tomato": "#ff6347",
    "turquoise": "#40e0d0",
    "violet": "#ee82ee",
    "wheat": "#f5deb3",
    "white": "#ffffff",
    "whitesmoke": "#f5f5f5",
    "yellow": "#ffff00",
    "yellowgreen": "#9acd32"
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/shared.js
  function getDefault(param, def) {
    return param != void 0 ? param : def;
  }
  function isEmpty(v4) {
    return v4 == null;
  }
  var _stampCounter = 0;
  function stamp(obj) {
    let stamp2 = obj._openglobus_id;
    if (!stamp2) {
      stamp2 = obj._openglobus_id = ++_stampCounter;
    }
    return stamp2;
  }
  function isString(s7) {
    return typeof s7 === "string" || s7 instanceof String;
  }
  function d2h(val) {
    return val.toString(16).padStart(2, "0");
  }
  function rgbToStringHTML(rgb) {
    let r8, g4, b4;
    if (rgb instanceof Array) {
      r8 = d2h(rgb[0]);
      g4 = d2h(rgb[1]);
      b4 = d2h(rgb[2]);
    } else {
      r8 = d2h(rgb.x);
      g4 = d2h(rgb.y);
      b4 = d2h(rgb.z);
    }
    return `#${r8}${g4}${b4}`;
  }
  function htmlColorToRgba(htmlColor, opacity) {
    let hColor = colorTable[htmlColor];
    if (hColor) {
      htmlColor = hColor;
    }
    if (htmlColor[0] === "#") {
      let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      let hex = htmlColor.replace(shorthandRegex, function(m5, r8, g4, b4) {
        return r8 + r8 + g4 + g4 + b4 + b4;
      });
      let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (result) {
        return new Vec4(parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255, isEmpty(opacity) ? 1 : opacity);
      } else {
        return new Vec4();
      }
    } else {
      if (isEmpty(opacity)) {
        opacity = 1;
      }
      let m5 = htmlColor.split(",");
      return new Vec4(parseInt(m5[0].split("(")[1]) / 255, parseInt(m5[1]) / 255, parseInt(m5[2]) / 255, !isEmpty(m5[3]) ? parseFloat(m5[3]) : opacity);
    }
  }
  function htmlColorToFloat32Array(htmlColor, opacity) {
    let c7 = htmlColorToRgba(htmlColor, opacity);
    return new Float32Array([c7.x, c7.y, c7.z, c7.w]);
  }
  function htmlColorToRgb(htmlColor) {
    let hColor = colorTable[htmlColor];
    if (hColor) {
      htmlColor = hColor;
    }
    if (htmlColor[0] === "#") {
      let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      let hex = htmlColor.replace(shorthandRegex, function(m5, r8, g4, b4) {
        return r8 + r8 + g4 + g4 + b4 + b4;
      });
      let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (result) {
        return new Vec3(parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255);
      } else {
        return new Vec3();
      }
    } else {
      let m5 = htmlColor.split(",");
      return new Vec3(parseInt(m5[0].split("(")[1]) / 255, parseInt(m5[1]) / 255, parseInt(m5[2]) / 255);
    }
  }
  function stringTemplate(template, params) {
    return template.replace(/{[^{}]+}/g, function(key) {
      return params[key.replace(/[{}]+/g, "")] || "";
    });
  }
  function parseHTML(htmlStr) {
    let p4 = document.createElement("div");
    p4.innerHTML = htmlStr;
    let domArr = [];
    for (let i9 = 0; i9 < p4.childNodes.length; i9++) {
      domArr.push(p4.childNodes[i9]);
      p4.removeChild(p4.childNodes[i9]);
    }
    return domArr;
  }
  function print2d(id, text, x3, y4) {
    let el = document.getElementById(id);
    if (!el) {
      el = document.createElement("div");
      el.id = id;
      el.classList.add("defaultText");
      document.body.appendChild(el);
    }
    el.innerHTML = text;
    el.style.left = `${x3}px`;
    el.style.top = `${y4}px`;
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  function defaultString(str, def = "") {
    return str ? str.trim() : def;
  }
  function createVector3(v4, def) {
    if (v4) {
      if (isNumber(v4)) {
        return new Vec3(v4, v4, v4);
      } else if (v4 instanceof Vec3) {
        return v4.clone();
      } else if (v4 instanceof Array) {
        return Vec3.fromVec(v4);
      } else if (v4 instanceof Vec2) {
        return new Vec3(v4.x, v4.y, 0);
      }
    } else if (def) {
      return def;
    }
    return new Vec3();
  }
  function createColorRGBA(c7, def) {
    if (c7) {
      if (isString(c7)) {
        return htmlColorToRgba(c7);
      } else if (c7 instanceof Array) {
        return Vec4.fromVec(c7);
      } else if (c7 instanceof Vec4) {
        return c7.clone();
      }
    } else if (def) {
      return def;
    }
    return new Vec4(1, 1, 1, 1);
  }
  function createColorRGB(c7, def) {
    if (c7) {
      if (isString(c7)) {
        return htmlColorToRgb(c7);
      } else if (c7 instanceof Array) {
        return Vec3.fromVec(c7);
      } else if (c7 instanceof Vec3) {
        return c7.clone();
      }
    } else if (def) {
      return def;
    }
    return new Vec3(1, 1, 1);
  }
  function createExtent(e9, def) {
    if (e9) {
      if (e9 instanceof Array) {
        return new Extent(createLonLat(e9[0]), createLonLat(e9[1]));
      } else if (e9 instanceof Extent) {
        return e9.clone();
      }
    } else if (def) {
      return def;
    }
    return new Extent();
  }
  function createLonLat(l4, def) {
    if (l4) {
      if (l4 instanceof Array) {
        return new LonLat(l4[0], l4[1], l4[2]);
      } else if (l4 instanceof LonLat) {
        return l4.clone();
      }
    } else if (def) {
      return def;
    }
    return new LonLat();
  }
  function binarySearchFast(arr, x3) {
    let start = 0, end = arr.length - 1;
    while (start <= end) {
      let k3 = Math.floor((start + end) * 0.5);
      if (Math.abs(arr[k3] - x3) < 1e-3) {
        return k3;
      } else if (arr[k3] < x3) {
        start = k3 + 1;
      } else {
        end = k3 - 1;
      }
    }
    return -1;
  }
  function binarySearch(ar, el, compare_fn) {
    let m5 = 0;
    let n7 = ar.length - 1;
    while (m5 <= n7) {
      let k3 = n7 + m5 >> 1;
      let cmp = compare_fn(el, ar[k3], k3);
      if (cmp > 0) {
        m5 = k3 + 1;
      } else if (cmp < 0) {
        n7 = k3 - 1;
      } else {
        return k3;
      }
    }
    return -m5 - 1;
  }
  function binaryInsert(ar, el, compare_fn) {
    let i9 = binarySearch(ar, el, compare_fn);
    if (i9 < 0) {
      i9 = ~i9;
    }
    ar.splice(i9, 0, el);
    return i9;
  }
  function getLinesIntersectionLonLat(start1, end1, start2, end2, isSegment = false) {
    let dir1 = new LonLat(end1.lon - start1.lon, end1.lat - start1.lat);
    let dir2 = new LonLat(end2.lon - start2.lon, end2.lat - start2.lat);
    let a1 = -dir1.lat;
    let b1 = +dir1.lon;
    let d1 = -(a1 * start1.lon + b1 * start1.lat);
    let a22 = -dir2.lat;
    let b22 = +dir2.lon;
    let d22 = -(a22 * start2.lon + b22 * start2.lat);
    let seg1_line2_start = a22 * start1.lon + b22 * start1.lat + d22;
    let seg1_line2_end = a22 * end1.lon + b22 * end1.lat + d22;
    let seg2_line1_start = a1 * start2.lon + b1 * start2.lat + d1;
    let seg2_line1_end = a1 * end2.lon + b1 * end2.lat + d1;
    if (isSegment && (seg1_line2_start * seg1_line2_end > 0 || seg2_line1_start * seg2_line1_end > 0)) {
      return void 0;
    }
    let u4 = seg1_line2_start / (seg1_line2_start - seg1_line2_end);
    return new LonLat(start1.lon + u4 * dir1.lon, start1.lat + u4 * dir1.lat);
  }
  function throttle(func, limit, skip = false) {
    let lastFunc;
    let lastRan = 0;
    return function() {
      const args = arguments;
      if (!lastRan) {
        func.apply(null, args);
        lastRan = Date.now();
      } else {
        if (skip) {
          clearTimeout(lastFunc);
        }
        lastFunc = setTimeout(() => {
          if (Date.now() - lastRan >= limit) {
            func.apply(null, args);
            lastRan = Date.now();
          }
        }, limit - (Date.now() - lastRan));
      }
    };
  }
  function concatTypedArrays(a6, b4) {
    let c7 = new a6.constructor(a6.length + b4.length);
    c7.set(a6, 0);
    c7.set(b4, a6.length);
    return c7;
  }
  function concatArrays(a6 = [], b4 = []) {
    if (ArrayBuffer.isView(a6)) {
      return concatTypedArrays(a6, b4);
    } else {
      for (let i9 = 0; i9 < b4.length; i9++) {
        a6.push(b4[i9]);
      }
      return a6;
    }
  }
  function makeArrayTyped(arr, ctor = Float32Array) {
    if (!ArrayBuffer.isView(arr)) {
      const typedArr = new ctor(arr.length);
      typedArr.set(arr, 0);
      return typedArr;
    } else {
      return arr;
    }
  }
  function makeArray(arr) {
    if (ArrayBuffer.isView(arr)) {
      return Array.from(arr);
    } else {
      return arr;
    }
  }
  function spliceArray(arr, starting, deleteCount, out) {
    if (ArrayBuffer.isView(arr)) {
      if (starting < 0) {
        deleteCount = Math.abs(starting);
        starting += arr.length;
      }
      return spliceTypedArray(arr, starting, deleteCount, out);
    } else {
      let res;
      if (starting < 0) {
        res = arr.splice(starting);
      } else {
        res = arr.splice(starting, deleteCount);
      }
      if (out) {
        out.result = res;
      }
      return arr;
    }
  }
  function spliceTypedArray(arr, starting, deleteCount, out) {
    if (arr.length === 0) {
      return arr;
    }
    const newSize = arr.length - deleteCount;
    const splicedArray = new arr.constructor(newSize);
    splicedArray.set(arr.subarray(0, starting));
    splicedArray.set(arr.subarray(starting + deleteCount), starting);
    if (out) {
      out.result = arr.subarray(starting, starting + deleteCount);
    }
    return splicedArray;
  }
  function getMatrixSubArray64(sourceArr, gridSize, i0, j0, size) {
    const size_1 = size + 1;
    const i0size = i0 + size_1;
    const j0size = j0 + size_1;
    let res = new Float64Array(size_1 * size_1 * 3);
    let vInd = 0;
    for (let i9 = i0; i9 < i0size; i9++) {
      for (let j2 = j0; j2 < j0size; j2++) {
        let ind = 3 * (i9 * (gridSize + 1) + j2);
        res[vInd++] = sourceArr[ind];
        res[vInd++] = sourceArr[ind + 1];
        res[vInd++] = sourceArr[ind + 2];
      }
    }
    return res;
  }
  function getMatrixSubArray32(sourceArr, gridSize, i0, j0, size) {
    const size_1 = size + 1;
    const i0size = i0 + size_1;
    const j0size = j0 + size_1;
    let res = new Float32Array(size_1 * size_1 * 3);
    let vInd = 0;
    for (let i9 = i0; i9 < i0size; i9++) {
      for (let j2 = j0; j2 < j0size; j2++) {
        let ind = 3 * (i9 * (gridSize + 1) + j2);
        res[vInd++] = sourceArr[ind];
        res[vInd++] = sourceArr[ind + 1];
        res[vInd++] = sourceArr[ind + 2];
      }
    }
    return res;
  }
  function getMatrixSubArrayBoundsExt(sourceArr, sourceArrHigh, sourceArrLow, noDataVertices, gridSize, i0, j0, size, outArr, outArrHigh, outArrLow, outBounds, outNoDataVertices) {
    const i0size = i0 + size + 1;
    const j0size = j0 + size + 1;
    gridSize += 1;
    let vInd = 0, nInd = 0;
    for (let i9 = i0; i9 < i0size; i9++) {
      for (let j2 = j0; j2 < j0size; j2++) {
        let indBy3 = i9 * gridSize + j2, ind = 3 * indBy3;
        let x3 = sourceArr[ind], y4 = sourceArr[ind + 1], z3 = sourceArr[ind + 2];
        if (!noDataVertices || noDataVertices[indBy3] === 0) {
          if (x3 < outBounds.xmin)
            outBounds.xmin = x3;
          if (x3 > outBounds.xmax)
            outBounds.xmax = x3;
          if (y4 < outBounds.ymin)
            outBounds.ymin = y4;
          if (y4 > outBounds.ymax)
            outBounds.ymax = y4;
          if (z3 < outBounds.zmin)
            outBounds.zmin = z3;
          if (z3 > outBounds.zmax)
            outBounds.zmax = z3;
        } else {
          outNoDataVertices[nInd] = 1;
        }
        nInd++;
        outArr[vInd] = x3;
        outArrLow[vInd] = sourceArrLow[ind];
        outArrHigh[vInd++] = sourceArrHigh[ind];
        outArr[vInd] = y4;
        outArrLow[vInd] = sourceArrLow[ind + 1];
        outArrHigh[vInd++] = sourceArrHigh[ind + 1];
        outArr[vInd] = z3;
        outArrLow[vInd] = sourceArrLow[ind + 2];
        outArrHigh[vInd++] = sourceArrHigh[ind + 2];
      }
    }
  }
  function cloneArray(items) {
    return items.map((item) => Array.isArray(item) ? cloneArray(item) : item);
  }
  async function loadImage(url) {
    return new Promise((resolve) => {
      const image = new Image();
      image.addEventListener("load", () => {
        resolve(image);
      });
      image.src = url;
      image.crossOrigin = "";
      return image;
    });
  }
  function distanceFormatExt(v4) {
    if (v4 > 1e3) {
      let d4 = v4 - Math.floor(v4);
      if (d4 !== 0) {
        return [(v4 / 1e3).toFixed(2), "km"];
      }
      return [(v4 / 1e3).toFixed(0), "km"];
    } else if (v4 > 9) {
      return [Math.round(v4).toString(), "m"];
    } else {
      if (v4 <= 0.01) {
        return ["0", "m"];
      }
      return [v4.toFixed(1), "m"];
    }
  }
  function getUrlParam(paramName) {
    let urlParams = new URLSearchParams(location.search);
    let param = urlParams.get(paramName);
    if (param) {
      return Number(param);
    }
  }

  // frontend/node_modules/@openglobus/og/lib/js/astro/jd.js
  var SECONDS_PER_MILLISECOND = 1e-3;
  var MILLISECONDS_PER_SECOND = 1e3;
  var SECONDS_PER_MINUTE = 60;
  var ONE_BY_SECONDS_PER_MINUTE = 1 / SECONDS_PER_MINUTE;
  var HOURS_PER_DAY = 24;
  var ONE_BY_HOURS_PER_DAY = 1 / HOURS_PER_DAY;
  var SECONDS_PER_HOUR = 3600;
  var ONE_BY_SECONDS_PER_HOUR = 1 / SECONDS_PER_HOUR;
  var SECONDS_PER_12_HOURS = 12 * SECONDS_PER_HOUR;
  var MINUTES_PER_DAY = 1440;
  var ONE_BY_MINUTES_PER_DAY = 1 / MINUTES_PER_DAY;
  var SECONDS_PER_DAY = 86400;
  var MILLISECONDS_PER_DAY = 864e5;
  var ONE_BY_MILLISECONDS_PER_DAY = 1 / MILLISECONDS_PER_DAY;
  var ONE_BY_SECONDS_PER_DAY = 1 / SECONDS_PER_DAY;
  var J2000 = 2451545;
  function getDayNumber(year, month, day) {
    let a6 = (month - 14) / 12 | 0;
    let b4 = year + 4800 + a6;
    return (1461 * b4 / 4 | 0) + (367 * (month - 2 - 12 * a6) / 12 | 0) - (3 * ((b4 + 100) / 100 | 0) / 4 | 0) + day - 32075;
  }
  function DateToUTC(date) {
    let dayNumber = getDayNumber(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate());
    let hour = date.getUTCHours() - 12;
    if (hour < 0) {
      hour += 24;
    }
    let secondsOfDay = date.getUTCSeconds() + hour * SECONDS_PER_HOUR + date.getUTCMinutes() * SECONDS_PER_MINUTE + date.getUTCMilliseconds() * SECONDS_PER_MILLISECOND;
    if (secondsOfDay >= SECONDS_PER_12_HOURS) {
      dayNumber--;
    }
    let extraDays = secondsOfDay * ONE_BY_SECONDS_PER_DAY | 0;
    dayNumber += extraDays;
    secondsOfDay -= SECONDS_PER_DAY * extraDays;
    if (secondsOfDay < 0) {
      dayNumber--;
      secondsOfDay += SECONDS_PER_DAY;
    }
    return dayNumber + secondsOfDay * ONE_BY_SECONDS_PER_DAY;
  }
  function UTCtoTAI(jd) {
    let leapSeconds = leapSecondsTable;
    let index = binarySearch(leapSeconds, jd, function(a6, b4) {
      return a6 - b4.jd;
    });
    if (index < 0) {
      index = ~index;
    }
    if (index >= leapSeconds.length) {
      index = leapSeconds.length - 1;
    }
    let offset = leapSeconds[index].leapSeconds;
    if (index !== 0) {
      if ((leapSeconds[index].jd - jd) * SECONDS_PER_DAY > offset) {
        offset = leapSeconds[index - 1].leapSeconds;
      }
    }
    return jd + offset * ONE_BY_SECONDS_PER_DAY;
  }
  function UTCtoDate(utc) {
    let julianDayNumber = utc | 0;
    let secondsOfDay = (utc - julianDayNumber) * SECONDS_PER_DAY;
    if (secondsOfDay >= SECONDS_PER_12_HOURS) {
      julianDayNumber++;
    }
    let L2 = julianDayNumber + 68569 | 0;
    let N4 = 4 * L2 / 146097 | 0;
    L2 = L2 - ((146097 * N4 + 3) / 4 | 0) | 0;
    let I3 = 4e3 * (L2 + 1) / 1461001 | 0;
    L2 = L2 - (1461 * I3 / 4 | 0) + 31 | 0;
    let J = 80 * L2 / 2447 | 0;
    let day = L2 - (2447 * J / 80 | 0) | 0;
    L2 = J / 11 | 0;
    let month = J + 2 - 12 * L2 | 0;
    let year = 100 * (N4 - 49) + I3 + L2 | 0;
    let hour = secondsOfDay * ONE_BY_SECONDS_PER_HOUR | 0;
    let remainingSeconds = secondsOfDay - hour * SECONDS_PER_HOUR;
    let minute = remainingSeconds * ONE_BY_SECONDS_PER_MINUTE | 0;
    remainingSeconds = remainingSeconds - minute * SECONDS_PER_MINUTE;
    let second = remainingSeconds | 0;
    let millisecond = (remainingSeconds - second) * MILLISECONDS_PER_SECOND | 0;
    hour += 12;
    if (hour > 23) {
      hour -= 24;
    }
    return new Date(Date.UTC(year, month - 1, day, hour, minute, second, millisecond));
  }
  function addMilliseconds(jd, milliseconds) {
    return jd + milliseconds * ONE_BY_MILLISECONDS_PER_DAY;
  }
  function __ls(jd, leapSeconds) {
    return {
      jd,
      leapSeconds
    };
  }
  var leapSecondsTable = [
    __ls(24413175e-1, 10),
    // 1972-01-01T00:00:00.000Z
    __ls(24414995e-1, 11),
    // 1972-07-01T00:00:00.000Z
    __ls(24416835e-1, 12),
    // 1973-01-01T00:00:00.000Z
    __ls(24420485e-1, 13),
    // 1974-01-01T00:00:00.000Z
    __ls(24424135e-1, 14),
    // 1975-01-01T00:00:00.000Z
    __ls(24427785e-1, 15),
    // 1976-01-01T00:00:00.000Z
    __ls(24431445e-1, 16),
    // 1977-01-01T00:00:00.000Z
    __ls(24435095e-1, 17),
    // 1978-01-01T00:00:00.000Z
    __ls(24438745e-1, 18),
    // 1979-01-01T00:00:00.000Z
    __ls(24442395e-1, 19),
    // 1980-01-01T00:00:00.000Z
    __ls(24447865e-1, 20),
    // 1981-07-01T00:00:00.000Z
    __ls(24451515e-1, 21),
    // 1982-07-01T00:00:00.000Z
    __ls(24455165e-1, 22),
    // 1983-01-01T00:00:00.000Z
    __ls(24462475e-1, 23),
    // 1985-07-01T00:00:00.000Z
    __ls(24471615e-1, 24),
    // 1988-01-01T00:00:00.000Z
    __ls(24478925e-1, 25),
    // 1990-01-01T00:00:00.000Z
    __ls(24482575e-1, 26),
    // 1991-01-01T00:00:00.000Z
    __ls(24488045e-1, 27),
    // 1992-07-01T00:00:00.000Z
    __ls(24491695e-1, 28),
    // 1993-07-01T00:00:00.000Z
    __ls(24495345e-1, 29),
    // 1994-07-01T00:00:00.000Z
    __ls(24500835e-1, 30),
    // 1996-01-01T00:00:00.000Z
    __ls(24506305e-1, 31),
    // 1997-07-01T00:00:00.000Z
    __ls(24511795e-1, 32),
    // 1999-01-01T00:00:00.000Z
    __ls(24537365e-1, 33),
    // 2006-01-01T00:00:00.000Z
    __ls(24548325e-1, 34),
    // 2009-01-01T00:00:00.000Z
    __ls(24561095e-1, 35),
    // 2012-07-01T00:00:00.000Z
    __ls(24572045e-1, 36)
    // 2015-07-01T00:00:00.000Z
  ];
  var J2000TAI = UTCtoTAI(J2000);

  // frontend/node_modules/@openglobus/og/lib/js/bv/Box.js
  var Box = class {
    constructor(boundsArr) {
      this.vertices = [
        new Vec3(),
        new Vec3(),
        new Vec3(),
        new Vec3(),
        new Vec3(),
        new Vec3(),
        new Vec3(),
        new Vec3()
      ];
      if (boundsArr) {
        this.setFromBoundsArr(boundsArr);
      }
    }
    copy(bbox) {
      for (let i9 = 0, len = this.vertices.length; i9 < len; i9++) {
        this.vertices[i9].copy(bbox.vertices[i9]);
      }
    }
    /**
     * Sets bounding box coordinates by the bounds array.
     * @param {NumberArray6} bounds - Bounds is an array where [minX, minY, minZ, maxX, maxY, maxZ]
     */
    setFromBoundsArr(bounds) {
      let xmin = bounds[0], xmax = bounds[3], ymin = bounds[1], ymax = bounds[4], zmin = bounds[2], zmax = bounds[5];
      let v4 = this.vertices;
      v4[0].set(xmin, ymin, zmin);
      v4[1].set(xmax, ymin, zmin);
      v4[2].set(xmax, ymin, zmax);
      v4[3].set(xmin, ymin, zmax);
      v4[4].set(xmin, ymax, zmin);
      v4[5].set(xmax, ymax, zmin);
      v4[6].set(xmax, ymax, zmax);
      v4[7].set(xmin, ymax, zmax);
    }
    /**
     * Sets bounding box coordinates by ellipsoid geodetic extend.
     * @param {Ellipsoid} ellipsoid - Ellipsoid.
     * @param {Extent} extent - Geodetic extent.
     */
    setFromExtent(ellipsoid, extent) {
      this.setFromBoundsArr(extent.getCartesianBounds(ellipsoid));
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/bv/Sphere.js
  var Sphere = class {
    constructor(radius = 0, center) {
      this.radius = radius;
      this.center = center ? center.clone() : new Vec3();
    }
    /**
     * Sets bounding sphere coordinates by the bounds array.
     * @param {Array.<number>} bounds - Bounds is an array where [minX, minY, minZ, maxX, maxY, maxZ]
     */
    setFromBounds(bounds) {
      let m5 = new Vec3(bounds[0], bounds[1], bounds[2]);
      this.center.set(m5.x + (bounds[3] - m5.x) * 0.5, m5.y + (bounds[3] - m5.y) * 0.5, m5.z + (bounds[5] - m5.z) * 0.5);
      this.radius = this.center.distance(m5);
    }
    /**
     * Sets bounding sphere coordinates by ellipsoid geodetic extend.
     * @param {Ellipsoid} ellipsoid - Ellipsoid.
     * @param {Extent} extent - Geodetic extent.
     */
    setFromExtent(ellipsoid, extent) {
      this.setFromBounds(extent.getCartesianBounds(ellipsoid));
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/index.js
  var control_exports = {};
  __export(control_exports, {
    AtmosphereConfig: () => AtmosphereConfig,
    CompassButton: () => CompassButton,
    Control: () => Control,
    DebugInfo: () => DebugInfo,
    DrawingControl: () => DrawingControl,
    DrawingSwitcher: () => DrawingSwitcher,
    EarthCoordinates: () => EarthCoordinates,
    EarthNavigation: () => EarthNavigation,
    ElevationProfileControl: () => ElevationProfileControl,
    GeoImageDragControl: () => GeoImageDragControl,
    HeightRuler: () => HeightRuler,
    KeyboardNavigation: () => KeyboardNavigation,
    LayerAnimation: () => LayerAnimation,
    LayerSwitcher: () => LayerSwitcher,
    Lighting: () => Lighting,
    MouseNavigation: () => MouseNavigation,
    MouseWheelZoomControl: () => MouseWheelZoomControl,
    Ruler: () => Ruler,
    RulerSwitcher: () => RulerSwitcher,
    ScaleControl: () => ScaleControl,
    Selection: () => Selection,
    ShowFps: () => ShowFps,
    SimpleNavigation: () => SimpleNavigation,
    SimpleSkyBackground: () => SimpleSkyBackground,
    Sun: () => Sun,
    TimelineControl: () => TimelineControl,
    ToggleWireframe: () => ToggleWireframe,
    TouchNavigation: () => TouchNavigation,
    ZoomControl: () => ZoomControl
  });

  // frontend/node_modules/@openglobus/og/lib/js/Events.js
  function createEvents(methodNames, sender) {
    return new Events(methodNames, sender);
  }
  var Events = class _Events {
    constructor(eventNames, sender) {
      this.__id = _Events.__counter__++;
      this._eventNames = [];
      eventNames && this.registerNames(eventNames);
      this._sender = sender || this;
      this._stopPropagation = false;
      this._stampCache = {};
    }
    bindSender(sender) {
      this._sender = sender || this;
    }
    /**
     * Function that creates event object properties that would be dispatched.
     * @public
     * @param {Array.<string>} eventNames - Specified event names list.
     */
    registerNames(eventNames) {
      for (let i9 = 0; i9 < eventNames.length; i9++) {
        this[eventNames[i9]] = {
          active: true,
          handlers: []
        };
        this._eventNames.push(eventNames[i9]);
      }
      return this;
    }
    _getStamp(name, id, ogid) {
      return `${name}_${id}_${ogid}`;
    }
    /**
     * Returns true if event callback has stamped.
     * @protected
     * @param {Object} name - Event identifier.
     * @param {Object} obj - Event callback.
     * @return {boolean} -
     */
    _stamp(name, obj) {
      let ogid = stamp(obj);
      let st2 = this._getStamp(name, this.__id, ogid);
      if (!this._stampCache[st2]) {
        this._stampCache[st2] = ogid;
        return true;
      }
      return false;
    }
    /**
     * Attach listener.
     * @public
     * @param {string} name - Event name to listen.
     * @param {EventCallback} callback - Event callback function.
     * @param {any} [sender] - Event callback function owner.
     * @param {number} [priority] - Priority of event callback.
     */
    on(name, callback, sender, priority = 0) {
      if (this._stamp(name, callback)) {
        if (this[name]) {
          let c7 = callback.bind(sender || this._sender);
          c7._openglobus_id = callback._openglobus_id;
          c7._openglobus_priority = priority;
          binaryInsert(this[name].handlers, c7, (a6, b4) => {
            return (b4._openglobus_priority || 0) - (a6._openglobus_priority || 0);
          });
        }
      }
    }
    /**
     * Stop listening event name with specified callback function.
     * @public
     * @param {string} name - Event name.
     * @param {EventCallback | null} callback - Attached  event callback.
     */
    off(name, callback) {
      if (callback) {
        let st2 = this._getStamp(name, this.__id, callback._openglobus_id);
        if (callback._openglobus_id && this._stampCache[st2]) {
          let h8 = this[name].handlers;
          let i9 = h8.length;
          let indexToRemove = -1;
          while (i9--) {
            let hi = h8[i9];
            if (hi._openglobus_id === callback._openglobus_id) {
              indexToRemove = i9;
              break;
            }
          }
          if (indexToRemove !== -1) {
            h8.splice(indexToRemove, 1);
            this._stampCache[st2] = void 0;
            delete this._stampCache[st2];
          }
        }
      }
    }
    /**
     * Dispatch event.
     * @public
     * @param {EventCallbackHandler} event - Event instance property that created by event name.
     * @param {Object} [args] - Callback parameters.
     */
    dispatch(event, ...args) {
      let result = true;
      if (event && event.active && !this._stopPropagation) {
        let h8 = event.handlers.slice(0), i9 = h8.length;
        while (i9--) {
          if (h8[i9](...args) === false) {
            result = false;
          }
        }
      }
      this._stopPropagation = false;
      return result;
    }
    /**
     * Brakes events propagation.
     * @public
     */
    stopPropagation() {
      this._stopPropagation = true;
    }
    /**
     * Removes all events.
     * @public
     */
    clear() {
      for (let i9 = 0; i9 < this._eventNames.length; i9++) {
        let e9 = this[this._eventNames[i9]];
        e9.handlers.length = 0;
        e9.handlers = [];
      }
      this._eventNames.length = 0;
      this._eventNames = [];
    }
  };
  Events.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/ui/View.js
  var VIEW_EVENTS = ["render"];
  var View = class _View {
    constructor(options2 = {}) {
      this.__id = _View.__counter__++;
      this.events = createEvents(VIEW_EVENTS);
      this.model = options2.model || null;
      this.template = options2.template || "";
      this.parent = options2.parent || null;
      this._classList = options2.classList || [];
      this.el = null;
    }
    static getHTML(template, params) {
      return stringTemplate(template, params);
    }
    static parseHTML(htmlStr) {
      return parseHTML(htmlStr);
    }
    static insertAfter(newNodes, referenceNode) {
      if (!Array.isArray(newNodes)) {
        newNodes = [newNodes];
      }
      for (let i9 = 0; i9 < newNodes.length; i9++) {
        if (referenceNode.parentNode) {
          referenceNode.parentNode.insertBefore(newNodes[i9], referenceNode.nextSibling);
        }
      }
      return newNodes;
    }
    static insertBefore(newNodes, referenceNode) {
      if (!Array.isArray(newNodes)) {
        newNodes = [newNodes];
      }
      for (let i9 = 0; i9 < newNodes.length; i9++) {
        if (referenceNode.parentNode) {
          referenceNode.parentNode.insertBefore(newNodes[i9], referenceNode);
        }
      }
      return newNodes;
    }
    insertBefore(view) {
      if (!this.el) {
        this.render();
      }
      if (this.el) {
        if (view instanceof HTMLElement && view.parentNode) {
          _View.insertBefore(this.el, view);
        }
        if (view instanceof _View && view.el && view.el.parentNode) {
          _View.insertBefore(this.el, view.el);
        }
      }
    }
    insertAfter(view) {
      if (!this.el) {
        this.render();
      }
      if (this.el) {
        if (view instanceof HTMLElement && view.parentNode) {
          _View.insertAfter(this.el, view);
        }
        if (view instanceof _View && view.el && view.el.parentNode) {
          _View.insertAfter(this.el, view.el);
        }
      }
    }
    isEqual(view) {
      return view.__id === this.__id;
    }
    appendTo(node, clean = false, firstPosition = false) {
      if (node) {
        if (!this.el) {
          this.beforeRender(node);
          this.render();
        }
        if (this.el && this.el.parentNode) {
          this.el.parentNode.removeChild(this.el);
        }
        if (clean) {
          node.innerHTML = "";
        }
        if (this.el) {
          if (firstPosition) {
            if (node.childNodes[0]) {
              _View.insertBefore(this.el, node.childNodes[0]);
            } else {
              node.appendChild(this.el);
            }
          } else {
            node.appendChild(this.el);
          }
        }
        this.afterRender(node);
      }
      return this;
    }
    afterRender(parentNode) {
    }
    beforeRender(parentNode) {
    }
    stopPropagation() {
      this.events.stopPropagation();
    }
    renderTemplate(params) {
      return _View.parseHTML(_View.getHTML(this.template, params || {}))[0];
    }
    render(params) {
      this.el = this.renderTemplate(params);
      for (let i9 = 0, len = this._classList.length; i9 < len; i9++) {
        this.el.classList.add(this._classList[i9]);
      }
      this.events.dispatch(this.events.render, this);
      return this;
    }
    select(queryStr) {
      if (this.el) {
        return this.el.querySelector(queryStr);
      }
      return null;
    }
    selectRemove(queryStr) {
      if (this.el) {
        let r8 = this.select(queryStr);
        if (r8 && r8.parentNode) {
          r8.parentNode.removeChild(r8);
          return r8;
        }
      }
    }
    selectAll(queryStr, callback) {
      if (this.el) {
        const res = this.el.querySelectorAll(queryStr);
        if (callback) {
          for (let i9 = 0, len = res.length; i9 < len; i9++) {
            callback(res[i9], i9);
          }
        }
        return res;
      }
    }
    remove() {
      if (this.el && this.el.parentNode) {
        this.el.parentNode.removeChild(this.el);
      }
    }
  };
  View.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/ui/Button.js
  var TEMPLATE = `<div class="og-button" title="{title}">
       <div class="og-button-icon">{icon}</div>
       <div class="og-button-text">{text}</div>
    </div>`;
  var BUTTON_EVENTS = ["click", "mousedown", "mouseup", "touchstart", "touchend", "touchcancel"];
  var Button = class extends View {
    constructor(options2 = {}) {
      super({
        template: stringTemplate(TEMPLATE, {
          icon: options2.icon || "",
          text: options2.text || "",
          title: options2.title || ""
        }),
        ...options2
      });
      this._onMouseDown = (e9) => {
        e9.preventDefault();
        this.events.dispatch(this.events.mousedown, this, e9);
      };
      this._onMouseUp = (e9) => {
        e9.preventDefault();
        this.events.dispatch(this.events.mouseup, this, e9);
      };
      this._onTouchStart = (e9) => {
        e9.preventDefault();
        this.events.dispatch(this.events.touchstart, this, e9);
      };
      this._onTouchEnd = (e9) => {
        e9.preventDefault();
        this.events.dispatch(this.events.touchend, this, e9);
      };
      this._onTouchCancel = (e9) => {
        e9.preventDefault();
        this.events.dispatch(this.events.touchcancel, this, e9);
      };
      this._onMouseClick = (e9) => {
        this._mouseClickHandler(e9);
      };
      this.events = this.events.registerNames(BUTTON_EVENTS);
      this.el = null;
      this.name = options2.name || "";
      this.$icon = null;
      this.$text = null;
    }
    render(params) {
      super.render(params);
      this.$icon = this.select(".og-button-icon");
      this.$text = this.select(".og-button-text");
      this.el.__og_button__ = this;
      this._initEvents();
      return this;
    }
    _initEvents() {
      if (this.el) {
        this.el.addEventListener("click", this._onMouseClick);
        this.el.addEventListener("mousedown", this._onMouseDown);
        this.el.addEventListener("mouseup", this._onMouseUp);
        this.el.addEventListener("touchstart", this._onTouchStart);
        this.el.addEventListener("touchend", this._onTouchEnd);
        this.el.addEventListener("touchcancel", this._onTouchCancel);
      }
    }
    _mouseClickHandler(e9) {
      e9.preventDefault();
      this.events.dispatch(this.events.click, this, e9);
    }
    remove() {
      this._clearEvents();
      super.remove();
    }
    _clearEvents() {
      this.el && this.el.removeEventListener("click", this._onMouseClick);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/Control.js
  var Control = class _Control {
    constructor(options2 = {}) {
      this.__id = _Control.__counter__++;
      this._name = options2.name || `_control_${this.__id.toString()}`;
      this.planet = null;
      this._initialized = false;
      this.renderer = null;
      this.autoActivate = options2.autoActivate || false;
      this._active = false;
      this._deferredActive = true;
    }
    /**
     * Returns control name.
     * @public
     * @return {string} -
     */
    get name() {
      return this._name;
    }
    /**
     * Control initialization function have to be overridden.
     * @public
     */
    oninit() {
    }
    /**
     * Control renderer assigning function have to be overridden.
     * @public
     */
    onadd() {
    }
    /**
     * Control remove function have to be overridden.
     * @public
     */
    onremove() {
    }
    /**
     * Control activation function have to be overridden.
     * @public
     */
    onactivate() {
    }
    /**
     * Control deactivation function have to be overriden.
     * @public
     */
    ondeactivate() {
    }
    /**
     * Assign renderer to the control.
     * @public
     * @type {Renderer}
     */
    addTo(renderer) {
      if (renderer) {
        this.renderer = renderer;
        renderer.controls[this.name] = this;
        this.onadd && this.onadd();
        if (renderer.isInitialized()) {
          this._initialized = true;
          this.oninit && this.oninit();
          if (this.autoActivate) {
            this.activate();
          }
        }
      }
    }
    /**
     * Removes control.
     * @public
     */
    remove() {
      this.deactivate();
      this.onremove && this.onremove();
      let r8 = this.renderer, n7 = this.name;
      if (!r8)
        return;
      let c7 = r8.controls[n7];
      if (c7) {
        if (this.isEqual(c7)) {
          delete r8.controls[n7];
        }
      }
      this.renderer = null;
      this._active = false;
      this._initialized = false;
    }
    /**
     * Activate control.
     * @public
     */
    activate() {
      if (!this._active) {
        if (!this._initialized) {
          this._initialized = true;
          this.oninit && this.oninit();
        }
        if (this._deferredActive) {
          this._active = true;
          this.onactivate && this.onactivate();
        } else {
          this._deferredActive = true;
        }
      }
    }
    /**
     * Deactivate control.
     * @public
     */
    deactivate() {
      if (this._active) {
        this._active = false;
        this.ondeactivate && this.ondeactivate();
      } else if (!this._initialized) {
        this._deferredActive = false;
      }
    }
    /**
     * Is control active.
     * @public
     */
    isActive() {
      return this._active;
    }
    isEqual(control) {
      return control.__id === this.__id;
    }
  };
  Control.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/control/CompassButton.js
  var ICON_BUTTON_SVG = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   viewBox="0 0 110.6 110.3"
   version="1.1"
   id="svg21"
   sodipodi:docname="aaa.svg"
   inkscape:version="0.92.3 (2405546, 2018-03-11)">
  <metadata
     id="metadata11">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs25" />
  <sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="1920"
     inkscape:window-height="1001"
     id="namedview23"
     showgrid="false"
     inkscape:zoom="9.4900968"
     inkscape:cx="28.376998"
     inkscape:cy="60.17054"
     inkscape:window-x="-9"
     inkscape:window-y="-9"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg21" />
  <g
     id="Layer_2"
     data-name="Layer 2"
     transform="matrix(1,0,0,-1,0,110.3)">
    <g
       id="\u0421\u043B\u043E\u0439_1"
       data-name="\u0421\u043B\u043E\u0439 1">
      <g
         id="_Group_"
         data-name="&lt;Group&gt;">
        <g
           id="_Group_7"
           data-name="&lt;Group&gt;">
          <polygon
             id="_Path_7"
             data-name="&lt;Path&gt;"
             points="55.2,97.6 55.3,97.4 55.3,97.6 55.3,97.2 65.3,55.1 55.3,55.1 55.2,55.1 45.3,55.1 55.2,97.2 "
             style="fill:#ff2b45" />
          <polygon
             id="_Path_8"
             data-name="&lt;Path&gt;"
             points="55.3,12.7 55.3,12.9 55.2,12.7 55.2,13.1 45.3,55.1 55.2,55.1 55.3,55.1 65.3,55.1 55.3,13.1 "
             style="fill:#cecece;" />
        </g>
      </g>
    </g>
  </g>
</svg>`;
  var CompassButton = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._heading = 0;
      this._svg = null;
    }
    oninit() {
      let btn = new Button({
        classList: ["og-map-button", "og-compass-button"],
        icon: ICON_BUTTON_SVG
      });
      btn.appendTo(this.renderer.div);
      btn.events.on("click", this._onClick, this);
      this._svg = btn.select("svg");
      this.renderer.events.on("draw", this._draw, this);
    }
    _onClick() {
      const planet = this.planet;
      let c7 = planet.getCartesianFromPixelTerrain(this.renderer.handler.getCenter());
      if (c7) {
        planet.flyCartesian(c7.normal().scaleTo(c7.length() + c7.distance(planet.camera.eye)), null, null, 0, null, null, () => {
          planet.camera.look(c7);
        });
      } else {
        planet.flyCartesian(planet.camera.eye);
      }
    }
    _draw() {
      this.setHeading(this.planet.camera.getHeading());
    }
    setHeading(heading) {
      if (this._heading !== heading) {
        this._heading = heading;
        this._svg.style.transform = `rotateZ(${-heading}deg)`;
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/ui/icons.js
  var CLOSE_ICON = `<svg className="svg-icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor; overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <path d="M777.856 280.192l-33.92-33.952-231.872 231.872-231.84-231.872-33.984 33.888 231.872 231.904-231.84 231.84 33.888 33.984 231.904-231.904 231.84 231.872 33.952-33.888-231.872-231.904z"/>
</svg>`;

  // frontend/node_modules/@openglobus/og/lib/js/ui/Dialog.js
  var DIALOG_EVENTS = ["resize", "focus", "visibility", "dragstart", "dragend"];
  var TEMPLATE2 = `<div class="og-ddialog" 
        style="display:{display}; resize:{resize}; width: {width}px; {height}; top: {top}px; left: {left}px; min-height: {minHeight}; max-height: {maxHeight}; min-width: {minWidth}; max-width: {maxWidth};">
       <div class="og-ddialog-header">
         <div class="og-ddialog-header__title">{title}</div>      
         <div class="og-ddialog-header__buttons"></div>      
        </div>
       <div class="og-ddialog-container"></div>
    </div>>`;
  var Dialog = class _Dialog extends View {
    constructor(options2 = {}) {
      super({
        template: stringTemplate(TEMPLATE2, {
          title: options2.title || "",
          display: getDefault(options2.visible, true) ? "flex" : "none",
          resize: getDefault(options2.resizable, true) ? "both" : "none",
          width: options2.width || 300,
          height: options2.height ? `height: ${options2.height || 200}px` : "",
          left: options2.left || 0,
          top: options2.top || 0,
          minHeight: options2.minHeight ? `${options2.minHeight}px` : "unset",
          maxHeight: options2.maxHeight ? `${options2.maxHeight}px` : "unset",
          minWidth: options2.minWidth ? `${options2.minWidth}px` : "unset",
          maxWidth: options2.maxWidth ? `${options2.maxWidth}px` : "unset"
        }),
        ...options2
      });
      this._onCloseBtnClick = () => {
        this.close();
      };
      this._onMouseDownAll = () => {
        this.bringToFront();
      };
      this._onMouseDown = (e9) => {
        e9.preventDefault();
        this._startDragging();
        this._startPosX = e9.clientX;
        this._startPosY = e9.clientY;
        document.addEventListener("mousemove", this._onMouseMove);
        document.addEventListener("mouseup", this._onMouseUp);
      };
      this._onMouseMove = (e9) => {
        e9.preventDefault();
        let dx = this._startPosX - e9.clientX;
        let dy = this._startPosY - e9.clientY;
        this._startPosX = e9.clientX;
        this._startPosY = e9.clientY;
        this.setPosition(this.el.offsetLeft - dx, this.el.offsetTop - dy);
      };
      this._onMouseUp = () => {
        this._clearDragging();
        document.removeEventListener("mouseup", this._onMouseUp);
        document.removeEventListener("mousemove", this._onMouseMove);
      };
      this.events = this.events.registerNames(DIALOG_EVENTS);
      this._startPosX = 0;
      this._startPosY = 0;
      this.$header = null;
      this.$title = null;
      this.$container = null;
      this.$buttons = null;
      this._closeBtn = new Button({
        icon: CLOSE_ICON,
        classList: ["og-button-size__20"]
      });
      this.useHide = options2.useHide || false;
      this._visibility = getDefault(options2.visible, true);
    }
    setContainer(htmlStr) {
      this.$container.innerHTML = htmlStr;
    }
    get container() {
      return this.$container;
    }
    get width() {
      return this.el ? parseFloat(this.el.style.width) : 0;
    }
    get height() {
      return this.el ? parseFloat(this.el.style.height) : 0;
    }
    bringToFront() {
      this.el.style.zIndex = String(_Dialog.__zIndex__++);
    }
    render(params) {
      super.render(params);
      this.bringToFront();
      this.$header = this.select(".og-ddialog-header");
      this.$title = this.select(".og-ddialog-header__title");
      this.$container = this.select(".og-ddialog-container");
      this.$buttons = this.select(".og-ddialog-header__buttons");
      this._initEvents();
      this._initButtons();
      return this;
    }
    show() {
      if (!this._visibility) {
        this._visibility = true;
        this.el.style.display = "flex";
        this.bringToFront();
        this.events.dispatch(this.events.visibility, true, this);
      }
    }
    hide() {
      if (this._visibility) {
        this._visibility = false;
        this.el.style.display = "none";
        this.events.dispatch(this.events.visibility, false, this);
      }
    }
    close() {
      if (this.useHide) {
        this.hide();
      } else {
        this.remove();
      }
    }
    setVisibility(visibility) {
      if (visibility) {
        this.show();
      } else {
        this.hide();
      }
    }
    _initButtons() {
      this._closeBtn.events.on("click", this._onCloseBtnClick);
      this._closeBtn.appendTo(this.$buttons);
    }
    _initEvents() {
      this.$header.addEventListener("mousedown", this._onMouseDown);
      this.el.addEventListener("mousedown", this._onMouseDownAll);
    }
    setPosition(x3, y4) {
      if (x3 != void 0) {
        this.el.style.left = `${x3}px`;
      }
      if (y4 != void 0) {
        this.el.style.top = `${y4}px`;
      }
    }
    _startDragging() {
      if (!this.el.classList.contains("dragging")) {
        this.el.classList.add("dragging");
        this.events.dispatch(this.events.dragstart, this);
      }
    }
    _clearDragging() {
      if (this.el.classList.contains("dragging")) {
        this.events.dispatch(this.events.dragend, this);
        this.el.classList.remove("dragging");
      }
    }
    remove() {
      this._clearDragging();
      this._clearEvents();
      super.remove();
    }
    _clearEvents() {
      this._closeBtn.events.off("click", this._onCloseBtnClick);
      document.removeEventListener("mouseup", this._onMouseUp);
      document.removeEventListener("mousemove", this._onMouseMove);
      this.$header.removeEventListener("mousedown", this._onMouseDown);
      this.el.removeEventListener("mousedown", this._onMouseDownAll);
    }
  };
  Dialog.__zIndex__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/ui/ToggleButton.js
  var TOGGLEBUTTON_EVENTS = ["change"];
  var ToggleButton = class extends Button {
    constructor(options2) {
      super({
        ...options2
      });
      this._onMouseClick = (e9) => {
        if (!this.preventClick) {
          this._mouseClickHandler(e9);
          this.setActive(!this.isActive);
        }
      };
      this.events = this.events.registerNames(TOGGLEBUTTON_EVENTS);
      this._isActive = options2.isActive || false;
      this.preventClick = options2.preventClick || false;
    }
    setActive(isActive, stopPropagation = false) {
      if (isActive !== this._isActive) {
        this._isActive = isActive;
        this._toggle();
        if (!stopPropagation) {
          this.events.dispatch(this.events.change, isActive, this);
        }
      }
    }
    _toggle() {
      this.el && this.el.classList.toggle("og-button__active");
    }
    get isActive() {
      return this._isActive;
    }
    render(params) {
      super.render(params);
      if (this._isActive) {
        this._toggle();
      }
      return this;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/quadTree/quadTree.js
  var VISIBLE_DISTANCE = 3570;
  var MAX_RENDERED_NODES = 1e3;
  var NW = 0;
  var NE = 1;
  var SW = 2;
  var SE = 3;
  var N = 0;
  var E = 1;
  var S = 2;
  var W2 = 3;
  var NOTRENDERING = 0;
  var RENDERING = 1;
  var WALKTHROUGH = 2;
  var OPSIDE = [S, W2, N, E];
  var NEIGHBOUR = [
    [-1, -1, NW, NE],
    [NE, -1, SE, -1],
    [SW, SE, -1, -1],
    [-1, NW, -1, SW]
  ];
  var OPPART = [
    [SW, SE, NW, NE],
    [NE, NW, SE, SW],
    [SW, SE, NW, NE],
    [NE, NW, SE, SW]
  ];
  var PARTOFFSET = [
    /*     N  E  S  W */
    /*NW*/
    [0, 1, 0, 0],
    /*NE*/
    [1, 0, 0, 0],
    /*SW*/
    [0, 1, 0, 1],
    /*SE*/
    [1, 1, 1, 1]
  ];

  // frontend/node_modules/@openglobus/og/lib/js/layer/Material.js
  var Material = class {
    constructor(segment, layer) {
      this.segment = segment;
      this.layer = layer;
      this.isReady = false;
      this.isLoading = false;
      this.texture = null;
      this.pickingMask = null;
      this.textureExists = false;
      this.appliedNodeId = 0;
      this.appliedNode = null;
      this.texOffset = [0, 0, 1, 1];
      this.loadingAttempts = 0;
      this._updateTexture = null;
      this._updatePickingMask = null;
      this.pickingReady = false;
    }
    abortLoading() {
      this.layer.abortMaterialLoading(this);
    }
    _createTexture(img) {
      return this.layer._planet && this.layer.createTexture(img, this.layer._internalFormat, this.isReady ? this.texture : null);
    }
    applyImage(img) {
      if (this.segment.initialized) {
        this._updateTexture = null;
        this.texture = this._createTexture(img);
        this.isReady = true;
        this.pickingReady = true;
        this.textureExists = true;
        this.isLoading = false;
        this.appliedNodeId = this.segment.node.nodeId;
        this.texOffset = [0, 0, 1, 1];
      }
    }
    applyTexture(texture, pickingMask) {
      if (this.segment.initialized) {
        this.texture = texture;
        this._updateTexture = null;
        this.pickingMask = pickingMask || null;
        this._updatePickingMask = null;
        this.isReady = true;
        this.pickingReady = true;
        this.textureExists = true;
        this.isLoading = false;
        this.appliedNodeId = this.segment.node.nodeId;
        this.texOffset = [0, 0, 1, 1];
      }
    }
    textureNotExists() {
      if (this.segment.initialized) {
        this.pickingReady = true;
        this.isLoading = false;
        this.isReady = true;
        this.textureExists = false;
      }
    }
    clear() {
      this.loadingAttempts = 0;
      this.layer.clearMaterial(this);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/layer/Layer.js
  var FADING_RATIO = 15.8;
  var Layer = class _Layer {
    constructor(name, options2 = {}) {
      this.isVector = false;
      this.__id = _Layer.__counter__++;
      this._iconSrc = options2.iconSrc || null;
      this.events = createEvents(LAYER_EVENTS, this);
      this.name = name || "noname";
      this.properties = options2.properties || {};
      this.hideInLayerSwitcher = options2.hideInLayerSwitcher || false;
      this._hasImageryTiles = true;
      this._opacity = options2.opacity != void 0 ? options2.opacity : 1;
      this.minZoom = options2.minZoom || 0;
      this.maxZoom = options2.maxZoom != void 0 ? options2.maxZoom : 50;
      this._planet = null;
      this.isVector = false;
      this._attribution = options2.attribution || "";
      this._zIndex = options2.zIndex || 0;
      this._isBaseLayer = options2.isBaseLayer || false;
      this._defaultTextures = options2.defaultTextures || [null, null];
      this._visibility = options2.visibility !== void 0 ? options2.visibility : true;
      this._fading = options2.fading || false;
      this._fadingFactor = this._opacity / FADING_RATIO;
      if (this._fading) {
        this._fadingOpacity = this._visibility ? this._opacity : 0;
      } else {
        this._fadingOpacity = this._opacity;
      }
      this._height = options2.height || 0;
      this._extent = new Extent();
      this.createTexture = null;
      this._textureFilter = options2.textureFilter ? options2.textureFilter.trim().toUpperCase() : "MIPMAP";
      this._isSRGB = options2.isSRGB != void 0 ? options2.isSRGB : false;
      this._internalFormat = null;
      this._extentMerc = new Extent();
      this.setExtent(createExtent(options2.extent, new Extent(new LonLat(-180, -90), new LonLat(180, 90))));
      this._pickingColor = new Vec3();
      this._pickingEnabled = options2.pickingEnabled !== void 0 ? options2.pickingEnabled : true;
      this._isPreloadDone = false;
      this._preLoadZoomLevels = options2.preLoadZoomLevels || [0, 1];
      this._ambient = null;
      this._diffuse = null;
      this._specular = null;
      if (options2.ambient) {
        let a6 = createColorRGB(options2.ambient, new Vec3(0.2, 0.2, 0.2));
        this._ambient = new Float32Array([a6.x, a6.y, a6.z]);
      }
      if (options2.diffuse) {
        let d4 = createColorRGB(options2.diffuse, new Vec3(0.8, 0.8, 0.8));
        this._diffuse = new Float32Array([d4.x, d4.y, d4.z]);
      }
      if (options2.specular) {
        let s7 = createColorRGB(options2.specular, new Vec3(3e-4, 3e-4, 3e-4));
        let shininess = options2.shininess || 20;
        this._specular = new Float32Array([s7.x, s7.y, s7.z, shininess]);
      }
      this.nightTextureCoefficient = options2.nightTextureCoefficient || 1;
    }
    get iconSrc() {
      return this._iconSrc;
    }
    set iconSrc(src) {
      this._iconSrc = src;
    }
    set diffuse(rgb) {
      if (rgb) {
        let vec = createColorRGB(rgb);
        this._diffuse = new Float32Array(vec.toArray());
      } else {
        this._diffuse = null;
      }
    }
    set ambient(rgb) {
      if (rgb) {
        let vec = createColorRGB(rgb);
        this._ambient = new Float32Array(vec.toArray());
      } else {
        this._ambient = null;
      }
    }
    set specular(rgb) {
      if (rgb) {
        let vec = createColorRGB(rgb);
        this._specular = new Float32Array([vec.x, vec.y, vec.y, this._specular ? this._specular[3] : 0]);
      } else {
        this._specular = null;
      }
    }
    set shininess(v4) {
      if (this._specular) {
        this._specular[3] = v4;
      }
    }
    // get normalMapCreator() {
    //     return this._normalMapCreator;
    // }
    static getTMS(x3, y4, z3) {
      return {
        x: x3,
        y: (1 << z3) - y4 - 1,
        z: z3
      };
    }
    static getTileIndex(x3, y4, z3, tileGroup) {
      return `${tileGroup}::${x3}_${y4}_${z3}`;
    }
    get instanceName() {
      return "Layer";
    }
    get rendererEvents() {
      return this.events;
    }
    set opacity(opacity) {
      if (opacity !== this._opacity) {
        if (this._fading) {
          if (opacity > this._opacity) {
            this._fadingFactor = (opacity - this._opacity) / FADING_RATIO;
          } else if (opacity < this._opacity) {
            this._fadingFactor = (opacity - this._opacity) / FADING_RATIO;
          }
        } else {
          this._fadingOpacity = opacity;
        }
        this._opacity = opacity;
      }
    }
    set pickingEnabled(picking) {
      this._pickingEnabled = picking;
    }
    get pickingEnabled() {
      return this._pickingEnabled;
    }
    /**
     * Returns true if a layer has imagery tiles.
     * @public
     * @virtual
     * @returns {boolean} - Imagery tiles flag.
     */
    hasImageryTiles() {
      return this._hasImageryTiles;
    }
    /**
     * Gets layer identifier.
     * @public
     * @returns {string} - Layer object id.
     */
    getID() {
      return this.__id;
    }
    get id() {
      return this.__id;
    }
    /**
     * @todo: remove after all
     */
    get _id() {
      return this.__id;
    }
    /**
     * Compares layers instances.
     * @public
     * @param {Layer} layer - Layer instance to compare.
     * @returns {boolean} - Returns true if the layers is the same instance of the input.
     */
    isEqual(layer) {
      return layer.__id === this.__id;
    }
    /**
     * Assign the planet.
     * @protected
     * @virtual
     * @param {Planet} planet - Planet render node.
     */
    _assignPlanet(planet) {
      this._planet = planet;
      planet._layers.push(this);
      if (planet.renderer && planet.renderer.isInitialized()) {
        if (this._isSRGB) {
          this._internalFormat = planet.renderer.handler.gl.SRGB8_ALPHA8;
        } else {
          this._internalFormat = planet.renderer.handler.gl.RGBA8;
        }
        this.createTexture = planet.renderer.handler.createTexture[this._textureFilter];
        this.events.on("visibilitychange", planet._onLayerVisibilityChanged, planet);
        if (this._isBaseLayer && this._visibility) {
          planet.setBaseLayer(this);
        }
        planet.events.dispatch(planet.events.layeradd, this);
        this.events.dispatch(this.events.add, planet);
        planet.updateVisibleLayers();
        this._bindPicking();
        if (this._visibility && this.hasImageryTiles()) {
          this._preLoad();
        }
      }
    }
    get isIdle() {
      return this._planet && this._planet._terrainCompletedActivated || false;
    }
    /**
     * Assign picking color to the layer.
     * @protected
     * @virtual
     */
    _bindPicking() {
      this._planet && this._planet.renderer && this._planet.renderer.assignPickingColor(this);
    }
    /**
     * Adds layer to the planet.
     * @public
     * @param {Planet} planet - Adds layer to the planet.
     */
    addTo(planet) {
      if (!this._planet) {
        this._assignPlanet(planet);
      }
    }
    /**
     * Removes from planet.
     * @public
     * @returns {Layer} -This layer.
     */
    remove() {
      let p4 = this._planet;
      if (p4) {
        for (let i9 = 0; i9 < p4._layers.length; i9++) {
          if (this.isEqual(p4._layers[i9])) {
            p4.renderer && p4.renderer.clearPickingColor(this);
            p4._layers.splice(i9, 1);
            p4.updateVisibleLayers();
            this.clear();
            p4.events.dispatch(p4.events.layerremove, this);
            this.events.dispatch(this.events.remove, p4);
            this._planet = null;
            this._internalFormat = null;
            this.createTexture = null;
            return this;
          }
        }
      }
      return this;
    }
    /**
     * Clears layer material.
     * @virtual
     */
    clear() {
      if (this._planet) {
        this._planet._clearLayerMaterial(this);
      }
    }
    /**
     * Returns planet instance.
     */
    get planet() {
      return this._planet;
    }
    /**
     * Sets layer attribution text.
     * @public
     * @param {string} html - HTML code that represents layer attribution, it could be just a text.
     */
    setAttribution(html) {
      if (this._attribution !== html) {
        this._attribution = html;
        this._planet && this._planet.updateAttributionsList();
      }
    }
    /**
     * Gets layer attribution.
     * @public
     * @returns {string} Layer attribution
     */
    getAttribution() {
      return this._attribution;
    }
    /**
     * Sets height over the ground.
     * @public
     * @param {number} height - Layer height.
     */
    setHeight(height) {
      this._height = height;
      this._planet && this._planet.updateVisibleLayers();
    }
    /**
     * Gets layer height.
     * @public
     * @returns {number} -
     */
    getHeight() {
      return this._height;
    }
    /**
     * Sets z-index.
     * @public
     * @param {number} zIndex - Layer z-index.
     */
    setZIndex(zIndex) {
      this._zIndex = zIndex;
      this._planet && this._planet.updateVisibleLayers();
    }
    /**
     * Gets z-index.
     * @public
     * @returns {number} -
     */
    getZIndex() {
      return this._zIndex;
    }
    /**
     * Set zIndex to the maximal value depend on other layers on the planet.
     * @public
     */
    bringToFront() {
      if (this._planet) {
        let vl = this._planet.visibleTileLayers;
        let l4 = vl[vl.length - 1];
        if (!l4.isEqual(this)) {
          this.setZIndex(l4.getZIndex() + 1);
        }
      }
    }
    /**
     * Returns true if the layer is a base.
     * @public
     * @returns {boolean} - Base layer flag.
     */
    isBaseLayer() {
      return this._isBaseLayer;
    }
    /**
     * Sets base layer type true.
     * @public
     * @param {boolean} isBaseLayer -
     */
    setBaseLayer(isBaseLayer) {
      this._isBaseLayer = isBaseLayer;
      if (this._planet) {
        if (!isBaseLayer && this._planet.baseLayer && this.isEqual(this._planet.baseLayer)) {
          this._planet.baseLayer = null;
        }
        this._planet.updateVisibleLayers();
      }
    }
    /**
     * Sets layer visibility.
     * @public
     * @virtual
     * @param {boolean} visibility - Layer visibility.
     */
    setVisibility(visibility) {
      if (visibility !== this._visibility) {
        this._visibility = visibility;
        if (this._planet) {
          if (this._isBaseLayer && visibility) {
            this._planet.setBaseLayer(this);
          }
          this._planet.updateVisibleLayers();
          if (visibility && !this._isPreloadDone && !this.isVector) {
            this._isPreloadDone = true;
            this._preLoad();
          }
        }
        this.events.dispatch(this.events.visibilitychange, this);
      }
    }
    _forceMaterialApply(segment) {
      let pm = segment.materials, m5 = pm[this.__id];
      if (!m5) {
        m5 = pm[this.__id] = this.createMaterial(segment);
      }
      if (!m5.isReady) {
        this._planet._renderCompleted = false;
      }
      this.applyMaterial(m5, true);
    }
    clearMaterial(material) {
    }
    loadMaterial(material, forceLoading = false) {
    }
    applyMaterial(m5, isForced = false) {
      return [0, 0, 1, 1];
    }
    _preLoadRecursive(node, maxZoom) {
      if (node.segment.tileZoom > maxZoom) {
        return;
      }
      if (this._preLoadZoomLevels.includes(node.segment.tileZoom)) {
        this._forceMaterialApply(node.segment);
      }
      for (let i9 = 0, len = node.nodes.length; i9 < len; i9++) {
        if (node.nodes[i9]) {
          this._preLoadRecursive(node.nodes[i9], maxZoom);
        }
      }
    }
    _preLoad() {
      if (this._planet && this._preLoadZoomLevels.length) {
        let p4 = this._planet, maxZoom = Math.max(...this._preLoadZoomLevels);
        for (let i9 = 0, len = p4.quadTreeStrategy.quadTreeList.length; i9 < len; i9++) {
          this._preLoadRecursive(p4.quadTreeStrategy.quadTreeList[i9], maxZoom);
        }
      }
    }
    /**
     * Gets layer visibility.
     * @public
     * @returns {boolean} - Layer visibility.
     */
    getVisibility() {
      return this._visibility;
    }
    /**
     * Sets visible geographical extent.
     * @public
     * @param {Extent} extent - Layer visible geographical extent.
     */
    setExtent(extent) {
      let sw = extent.southWest.clone(), ne = extent.northEast.clone();
      if (sw.lat < MIN_LAT) {
        sw.lat = MIN_LAT;
      }
      if (ne.lat > MAX_LAT) {
        ne.lat = MAX_LAT;
      }
      this._extent = extent.clone();
      this._extentMerc = new Extent(sw.forwardMercator(), ne.forwardMercator());
      this._correctFullExtent();
    }
    /**
     * Gets layer extent.
     * @public
     * @return {Extent} - Layer geodetic extent.
     */
    getExtent() {
      return this._extent;
    }
    /**
     * Gets layer web-mercator extent.
     * @public
     * @return {Extent} - Layer extent.
     */
    getExtentMerc() {
      return this._extentMerc;
    }
    /**
     * Fly extent.
     * @public
     */
    flyExtent() {
      this._planet?.flyExtent(this.getExtent());
    }
    /**
     * View extent.
     * @public
     */
    viewExtent() {
      this._planet?.viewExtent(this.getExtent());
    }
    /**
     * Special correction of the whole globe extent.
     * @protected
     */
    _correctFullExtent() {
    }
    get opacity() {
      return this._opacity;
    }
    get screenOpacity() {
      return this._fading ? this._fadingOpacity : this._opacity;
    }
    _refreshFadingOpacity() {
      let p4 = this._planet;
      if (this._visibility && p4.getViewExtent().overlaps(this._extent) && p4.maxCurrZoom >= this.minZoom && p4.minCurrZoom <= this.maxZoom) {
        this._fadingOpacity += this._fadingFactor;
        if (this._fadingFactor > 0 && this._fadingOpacity > this._opacity || this._fadingFactor < 0 && this._fadingOpacity < this._opacity) {
          this._fadingOpacity = this._opacity;
        }
        return false;
      } else {
        this._fadingOpacity = 0;
        return !this._visibility;
      }
    }
    createMaterial(segment) {
      return new Material(segment, this);
    }
    redraw() {
      if (this._planet) {
        this._planet.quadTreeStrategy.clearLayerMaterial(this);
      }
    }
    abortMaterialLoading(material) {
    }
    abortLoading() {
    }
  };
  Layer.__counter__ = 0;
  var LAYER_EVENTS = [
    /**
     * Triggered when layer visibility changed.
     * @event og.Layer#visibilitychange
     */
    "visibilitychange",
    /**
     * Triggered when layer has added to the planet.
     * @event og.Layer#add
     */
    "add",
    /**
     * Triggered when layer has removed from the planet.
     * @event og.Layer#remove
     */
    "remove",
    /**
     * Triggered when mouse moves over the layer.
     * @event og.Layer#mousemove
     */
    "mousemove",
    /**
     * Triggered when mouse has entered over the layer.
     * @event og.Layer#mouseenter
     */
    "mouseenter",
    /**
     * Triggered when mouse leaves the layer.
     * @event og.Layer#mouseenter
     */
    "mouseleave",
    /**
     * Mouse left button clicked.
     * @event og.Layer#lclick
     */
    "lclick",
    /**
     * Mouse right button clicked.
     * @event og.Layer#rclick
     */
    "rclick",
    /**
     * Mouse right button clicked.
     * @event og.Layer#mclick
     */
    "mclick",
    /**
     * Mouse left button double click.
     * @event og.Layer#ldblclick
     */
    "ldblclick",
    /**
     * Mouse right button double click.
     * @event og.Layer#rdblclick
     */
    "rdblclick",
    /**
     * Mouse middle button double click.
     * @event og.Layer#mdblclick
     */
    "mdblclick",
    /**
     * Mouse left button up(stop pressing).
     * @event og.Layer#lup
     */
    "lup",
    /**
     * Mouse right button up(stop pressing).
     * @event og.Layer#rup
     */
    "rup",
    /**
     * Mouse middle button up(stop pressing).
     * @event og.Layer#mup
     */
    "mup",
    /**
     * Mouse left button is just pressed down(start pressing).
     * @event og.Layer#ldown
     */
    "ldown",
    /**
     * Mouse right button is just pressed down(start pressing).
     * @event og.Layer#rdown
     */
    "rdown",
    /**
     * Mouse middle button is just pressed down(start pressing).
     * @event og.Layer#mdown
     */
    "mdown",
    /**
     * Mouse left button is pressing.
     * @event og.Layer#lhold
     */
    "lhold",
    /**
     * Mouse right button is pressing.
     * @event og.Layer#rhold
     */
    "rhold",
    /**
     * Mouse middle button is pressing.
     * @event og.Layer#mhold
     */
    "mhold",
    /**
     * Mouse wheel is rotated.
     * @event og.Layer#mousewheel
     */
    "mousewheel",
    /**
     * Triggered when touching moves over the layer.
     * @event og.Layer#touchmove
     */
    "touchmove",
    /**
     * Triggered when layer begins to touch.
     * @event og.Layer#touchstart
     */
    "touchstart",
    /**
     * Triggered when layer has finished touching.
     * @event og.Layer#touchend
     */
    "touchend",
    /**
     * Triggered layer has double touched.
     * @event og.Layer#doubletouch
     */
    "doubletouch",
    /**
     * Triggered when touching leaves layer borders.
     * @event og.Layer#touchleave
     */
    "touchleave",
    /**
     * Triggered when touch enters over the layer.
     * @event og.Layer#touchenter
     */
    "touchenter"
  ];

  // frontend/node_modules/@openglobus/og/lib/js/layer/CanvasTiles.js
  var CANVASTILES_EVENTS = [
    /**
     * Triggered when current tile image has loaded before rendering.
     * @event og.layer.CanvasTiles#load
     */
    "load",
    /**
     * Triggered when all tiles have loaded or loading has stopped.
     * @event og.layer.CanvasTiles#loadend
     */
    "loadend"
  ];
  var CanvasTiles = class _CanvasTiles extends Layer {
    constructor(name, options2) {
      super(name, options2);
      this.events = this.events.registerNames(CANVASTILES_EVENTS);
      this.animated = options2.animated || false;
      this.minNativeZoom = options2.minNativeZoom || 0;
      this.maxNativeZoom = options2.maxNativeZoom || 100;
      this._counter = 0;
      this._pendingsQueue = [];
      this.drawTile = options2.drawTile;
      this._onLoadend_ = null;
    }
    addTo(planet) {
      this._onLoadend_ = this._onLoadend.bind(this);
      this.events.on("loadend", this._onLoadend_, this);
      return super.addTo(planet);
    }
    remove() {
      this.events.off("loadend", this._onLoadend_);
      this._onLoadend_ = null;
      return super.remove();
    }
    _onLoadend() {
      if (this._planet && this._planet._terrainCompletedActivated) {
        this._planet.events.dispatch(this._planet.events.layerloadend, this);
      }
    }
    get instanceName() {
      return "CanvasTiles";
    }
    get isIdle() {
      return super.isIdle && this._counter === 0;
    }
    /**
     * Abort loading tiles.
     * @public
     */
    abortLoading() {
      this._pendingsQueue.forEach((qi) => {
        this.abortMaterialLoading(qi);
      });
      this._pendingsQueue = [];
    }
    /**
     * Sets layer visibility.
     * @public
     * @param {boolean} visibility - Layer visibility.
     */
    setVisibility(visibility) {
      if (visibility !== this._visibility) {
        super.setVisibility(visibility);
        if (!visibility) {
          this.abortLoading();
        }
      }
    }
    /**
     * Start to load tile material.
     * @public
     * @virtual
     * @param {Material} material -
     */
    loadMaterial(material) {
      let seg = material.segment;
      if (this._isBaseLayer) {
        material.texture = seg._isNorth ? seg.planet.solidTextureOne : seg.planet.solidTextureTwo;
      } else {
        material.texture = seg.planet.transparentTexture;
      }
      if (this._planet.layerLock.isFree() || material.segment.tileZoom < 2) {
        material.isReady = false;
        material.isLoading = true;
        if (_CanvasTiles.__requestsCounter >= _CanvasTiles.MAX_REQUESTS && this._counter) {
          this._pendingsQueue.push(material);
        } else {
          this._exec(material);
        }
      }
    }
    /**
     * Loads material image and apply it to the planet segment.
     * @protected
     * @param {Material} material - Loads material image.
     */
    _exec(material) {
      _CanvasTiles.__requestsCounter++;
      this._counter++;
      const e9 = this.events.load;
      if (e9.handlers.length) {
        this.events.dispatch(e9, material);
      }
      requestAnimationFrame(() => {
        this.drawTile(material, (canvas) => {
          this._counter--;
          _CanvasTiles.__requestsCounter--;
          this._correctCounter();
          if (material.isLoading) {
            material.applyImage(canvas);
          }
          this._dequeueRequest();
        });
      });
    }
    _correctCounter() {
      if (this._counter < 0)
        this._counter = 0;
      if (_CanvasTiles.__requestsCounter < 0)
        _CanvasTiles.__requestsCounter = 0;
    }
    /**
     * Abort exact material loading.
     * @public
     * @param {Material} material - Segment material.
     */
    abortMaterialLoading(material) {
      if (material.isLoading) {
        this._counter--;
        _CanvasTiles.__requestsCounter--;
        this._correctCounter();
        this._dequeueRequest();
      }
      material.isLoading = false;
      material.isReady = false;
    }
    _dequeueRequest() {
      if (this._pendingsQueue.length) {
        if (_CanvasTiles.__requestsCounter < _CanvasTiles.MAX_REQUESTS) {
          const pmat = this._whilePendings();
          if (pmat) {
            this._exec(pmat);
          }
        }
      } else if (this._counter === 0 && this._planet && this._planet._terrainCompletedActivated) {
        this.events.dispatch(this.events.loadend);
      }
    }
    _whilePendings() {
      while (this._pendingsQueue.length) {
        const pmat = this._pendingsQueue.pop();
        if (pmat && pmat.segment && pmat.segment.node) {
          if (pmat.segment.initialized && pmat.segment.node.getState() === RENDERING) {
            return pmat;
          }
          pmat.isLoading = false;
        }
      }
      return null;
    }
    applyMaterial(material) {
      if (material.isReady) {
        if (material.layer.animated) {
          requestAnimationFrame(() => {
            this.drawTile(material, function(canvas) {
              material.applyImage(canvas);
            });
          });
        }
        return material.texOffset;
      } else if (material.segment.tileZoom < this.minNativeZoom) {
        material.textureNotExists();
      } else {
        let segment = material.segment;
        let pn = segment.node, parentTextureExists = false;
        let maxNativeZoom = material.layer.maxNativeZoom;
        if (segment.passReady && !material.isLoading && segment.tileZoom <= maxNativeZoom) {
          this.loadMaterial(material);
        }
        let mId = this._id;
        let psegm = material;
        while (pn.parentNode) {
          pn = pn.parentNode;
          psegm = pn.segment.materials[mId];
          if (psegm && psegm.textureExists) {
            parentTextureExists = true;
            break;
          }
        }
        if (segment.passReady) {
          if (pn.segment.tileZoom === maxNativeZoom) {
            if (segment.tileZoom > maxNativeZoom) {
              material.textureNotExists();
            }
          } else if (pn.segment.tileZoom < maxNativeZoom) {
            let pn2 = segment.node;
            while (pn2.segment.tileZoom > maxNativeZoom) {
              pn2 = pn2.parentNode;
            }
            let pnm = pn2.segment.materials[mId];
            if (pnm) {
              !pnm.isLoading && !pnm.isReady && this.loadMaterial(pnm);
            } else {
              pnm = pn2.segment.materials[material.layer._id] = material.layer.createMaterial(pn2.segment);
              this.loadMaterial(pnm);
            }
          }
        }
        if (parentTextureExists) {
          if (material.layer.animated) {
            requestAnimationFrame(() => {
              this.drawTile(material, function(canvas) {
                material.applyImage(canvas);
              });
            });
          }
          material.appliedNodeId = pn.nodeId;
          material.texture = psegm.texture;
          let dZ2 = 1 / (2 << segment.tileZoom - pn.segment.tileZoom - 1);
          material.texOffset[0] = segment.tileX * dZ2 - pn.segment.tileX;
          material.texOffset[1] = segment.tileY * dZ2 - pn.segment.tileY;
          material.texOffset[2] = dZ2;
          material.texOffset[3] = dZ2;
        } else {
          material.texture = segment.planet.transparentTexture;
          material.texOffset[0] = 0;
          material.texOffset[1] = 0;
          material.texOffset[2] = 1;
          material.texOffset[3] = 1;
        }
      }
      return material.texOffset;
    }
    clearMaterial(material) {
      if (material.isReady) {
        material.isReady = false;
        if (material.textureExists && material.texture && !material.texture.default) {
          material.segment.handler.gl.deleteTexture(material.texture);
          material.texture = null;
        }
      }
      this.abortMaterialLoading(material);
      material.isLoading = false;
      material.textureExists = false;
      material.layer = null;
      material.segment = null;
    }
  };
  CanvasTiles.MAX_REQUESTS = 20;
  CanvasTiles.__requestsCounter = 0;

  // frontend/node_modules/@openglobus/og/lib/js/control/DebugInfo.js
  var ICON_LOCK_BUTTON_SVG = `<?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg fill="#000000" width="800px" height="800px" viewBox="-7.5 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg">
<title>lock</title>
<path d="M14.625 15.156h2.094c0.281 0 0.5 0.25 0.5 0.531v11c0 0.281-0.219 0.5-0.5 0.5h-16.219c-0.281 0-0.5-0.219-0.5-0.5v-11c0-0.281 0.219-0.531 0.5-0.531h2.031v-5.125c0-2.875 1.844-5.25 4.688-5.25h2.688c2.875 0 4.719 2.375 4.719 5.25v5.125zM5.188 15.156h6.813v-4.875c0-1.594-1.313-2.938-2.938-2.938h-0.969c-1.594 0-2.906 1.344-2.906 2.938v4.875zM7.156 24h2.906l-0.719-3.156c0.5-0.25 0.844-0.781 0.844-1.375 0-0.906-0.719-1.594-1.594-1.594s-1.563 0.688-1.563 1.594c0 0.594 0.344 1.125 0.844 1.375z"></path>
</svg>`;
  var ICON_BUTTON_SVG2 = `<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg fill="#000000" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 width="800px" height="800px" viewBox="0 0 932.179 932.179"
	 xml:space="preserve">
<g>
	<path d="M61.2,341.538c4.9,16.8,11.7,33,20.3,48.2l-24.5,30.9c-8,10.1-7.1,24.5,1.9,33.6l42.2,42.2c9.1,9.1,23.5,9.899,33.6,1.899
		l30.7-24.3c15.8,9.101,32.6,16.2,50.1,21.2l4.6,39.5c1.5,12.8,12.3,22.4,25.1,22.4h59.7c12.8,0,23.6-9.601,25.1-22.4l4.4-38.1
		c18.8-4.9,36.8-12.2,53.7-21.7l29.7,23.5c10.1,8,24.5,7.1,33.6-1.9l42.2-42.2c9.1-9.1,9.9-23.5,1.9-33.6l-23.1-29.3
		c9.6-16.601,17.1-34.3,22.1-52.8l35.6-4.1c12.801-1.5,22.4-12.3,22.4-25.1v-59.7c0-12.8-9.6-23.6-22.4-25.1l-35.1-4.1
		c-4.801-18.3-12-35.8-21.199-52.2l21.6-27.3c8-10.1,7.1-24.5-1.9-33.6l-42.1-42.1c-9.1-9.1-23.5-9.9-33.6-1.9l-26.5,21
		c-17.2-10.1-35.601-17.8-54.9-23l-4-34.3c-1.5-12.8-12.3-22.4-25.1-22.4h-59.7c-12.8,0-23.6,9.6-25.1,22.4l-4,34.3
		c-19.8,5.3-38.7,13.3-56.3,23.8l-27.5-21.8c-10.1-8-24.5-7.1-33.6,1.9l-42.2,42.2c-9.1,9.1-9.9,23.5-1.9,33.6l23,29.1
		c-9.2,16.6-16.2,34.3-20.8,52.7l-36.8,4.2c-12.8,1.5-22.4,12.3-22.4,25.1v59.7c0,12.8,9.6,23.6,22.4,25.1L61.2,341.538z
		 M277.5,180.038c54.4,0,98.7,44.3,98.7,98.7s-44.3,98.7-98.7,98.7c-54.399,0-98.7-44.3-98.7-98.7S223.1,180.038,277.5,180.038z"/>
	<path d="M867.699,356.238l-31.5-26.6c-9.699-8.2-24-7.8-33.199,0.9l-17.4,16.3c-14.699-7.1-30.299-12.1-46.4-15l-4.898-24
		c-2.5-12.4-14-21-26.602-20l-41.1,3.5c-12.6,1.1-22.5,11.4-22.9,24.1l-0.799,24.4c-15.801,5.7-30.701,13.5-44.301,23.3
		l-20.799-13.8c-10.602-7-24.701-5-32.9,4.7l-26.6,31.7c-8.201,9.7-7.801,24,0.898,33.2l18.201,19.399
		c-6.301,14.2-10.801,29.101-13.4,44.4l-26,5.3c-12.4,2.5-21,14-20,26.601l3.5,41.1c1.1,12.6,11.4,22.5,24.1,22.9l28.1,0.899
		c5.102,13.4,11.801,26.101,19.9,38l-15.699,23.7c-7,10.6-5,24.7,4.699,32.9l31.5,26.6c9.701,8.2,24,7.8,33.201-0.9l20.6-19.3
		c13.5,6.3,27.699,11,42.299,13.8l5.701,28.2c2.5,12.4,14,21,26.6,20l41.1-3.5c12.6-1.1,22.5-11.399,22.9-24.1l0.9-27.601
		c15-5.3,29.199-12.5,42.299-21.399l22.701,15c10.6,7,24.699,5,32.9-4.7l26.6-31.5c8.199-9.7,7.799-24-0.9-33.2l-18.301-19.399
		c6.701-14.2,11.602-29.2,14.4-44.601l25-5.1c12.4-2.5,21-14,20-26.601l-3.5-41.1c-1.1-12.6-11.4-22.5-24.1-22.9l-25.1-0.8
		c-5.201-14.6-12.201-28.399-20.9-41.2l13.699-20.6C879.4,378.638,877.4,364.438,867.699,356.238z M712.801,593.837
		c-44.4,3.801-83.602-29.3-87.301-73.699c-3.801-44.4,29.301-83.601,73.699-87.301c44.4-3.8,83.602,29.301,87.301,73.7
		C790.301,550.938,757.199,590.138,712.801,593.837z"/>
	<path d="M205,704.438c-12.6,1.3-22.3,11.899-22.4,24.6l-0.3,25.3c-0.2,12.7,9.2,23.5,21.8,25.101l18.6,2.399
		c3.1,11.301,7.5,22.101,13.2,32.301l-12,14.8c-8,9.899-7.4,24.1,1.5,33.2l17.7,18.1c8.9,9.1,23.1,10.1,33.2,2.3l14.899-11.5
		c10.5,6.2,21.601,11.101,33.2,14.5l2,19.2c1.3,12.6,11.9,22.3,24.6,22.4l25.301,0.3c12.699,0.2,23.5-9.2,25.1-21.8l2.3-18.2
		c12.601-3.101,24.601-7.8,36-14l14,11.3c9.9,8,24.101,7.4,33.201-1.5l18.1-17.7c9.1-8.899,10.1-23.1,2.301-33.2L496.6,818.438
		c6.6-11,11.701-22.7,15.201-35l16.6-1.7c12.6-1.3,22.299-11.9,22.4-24.6l0.299-25.301c0.201-12.699-9.199-23.5-21.799-25.1
		l-16.201-2.1c-3.1-12.2-7.699-24-13.699-35l10.1-12.4c8-9.9,7.4-24.1-1.5-33.2l-17.699-18.1c-8.9-9.101-23.102-10.101-33.201-2.3
		l-12.101,9.3c-11.399-6.9-23.6-12.2-36.399-15.8l-1.601-15.7c-1.3-12.601-11.899-22.3-24.6-22.4l-25.3-0.3
		c-12.7-0.2-23.5,9.2-25.101,21.8l-2,15.601c-13.199,3.399-25.899,8.6-37.699,15.399l-12.5-10.2c-9.9-8-24.101-7.399-33.201,1.5
		l-18.2,17.801c-9.1,8.899-10.1,23.1-2.3,33.199l10.7,13.801c-6.2,11-11.1,22.699-14.3,35L205,704.438z M368.3,675.837
		c36.3,0.4,65.399,30.301,65,66.601c-0.4,36.3-30.301,65.399-66.601,65c-36.3-0.4-65.399-30.3-65-66.601
		C302.1,704.538,332,675.438,368.3,675.837z"/>
</g>
</svg>`;
  var ICON_CANVASTILES_SVG = `<?xml version="1.0"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M 4 4 L 4 8 L 8 8 L 8 4 L 4 4 z M 10 4 L 10 8 L 14 8 L 14 4 L 10 4 z M 16 4 L 16 8 L 20 8 L 20 4 L 16 4 z M 4 10 L 4 14 L 8 14 L 8 10 L 4 10 z M 10 10 L 10 14 L 14 14 L 14 10 L 10 10 z M 16 10 L 16 14 L 20 14 L 20 10 L 16 10 z M 4 16 L 4 20 L 8 20 L 8 16 L 4 16 z M 10 16 L 10 20 L 14 20 L 14 16 L 10 16 z M 16 16 L 16 20 L 20 20 L 20 16 L 16 16 z"/>
</svg>`;
  var DebugInfo = class extends Control {
    constructor(options2 = {}) {
      if (!options2.name || options2.name === "") {
        options2.name = "DebugInfo";
      }
      super(options2);
      this.el = null;
      this._watch = options2.watch || [];
      this._toggleBtn = new ToggleButton({
        classList: ["og-map-button", "og-debuginfo_button"],
        icon: ICON_BUTTON_SVG2
      });
      this._dialog = new Dialog({
        title: "Debug Info",
        visible: false,
        useHide: true,
        top: 120,
        left: 60,
        width: 480
      });
      this._dialog.events.on("visibility", (v4) => {
        this._toggleBtn.setActive(v4);
      });
      this._canvasTiles = new CanvasTiles("Tile grid", {
        visibility: true,
        isBaseLayer: false,
        hideInLayerSwitcher: true,
        drawTile: function(material, applyCanvas) {
          let cnv = document.createElement("canvas");
          let ctx = cnv.getContext("2d");
          cnv.width = 256;
          cnv.height = 256;
          ctx.clearRect(0, 0, cnv.width, cnv.height);
          ctx.beginPath();
          ctx.rect(0, 0, cnv.width, cnv.height);
          ctx.lineWidth = 2;
          ctx.strokeStyle = "black";
          ctx.stroke();
          let size;
          if (material.segment.tileZoom > 14) {
            size = "26";
          } else {
            size = "32";
          }
          ctx.fillStyle = "black";
          ctx.font = "normal " + size + "px Verdana";
          ctx.textAlign = "center";
          ctx.fillText(material.segment.tileX + "," + material.segment.tileY + "," + material.segment.tileZoom, cnv.width / 2, cnv.height / 2);
          applyCanvas(cnv);
        }
      });
    }
    addWatches(watches) {
      for (let i9 = 0; i9 < watches.length; i9++) {
        this.addWatch(watches[i9]);
      }
    }
    addWatch(watch) {
      this._watch.push(watch);
      let watchEl = document.createElement("div");
      watchEl.classList.add("og-watch-line");
      watchEl.innerHTML = `<div class="og-watch-label">${watch.label}</div><div class="og-watch-value"></div>`;
      watch.valEl = watchEl.querySelector(".og-watch-value");
      this.el.appendChild(watchEl);
    }
    oninit() {
      this._toggleBtn.appendTo(this.renderer.div);
      this._dialog.appendTo(this.renderer.div);
      this._toggleBtn.events.on("change", (isActive) => {
        this._dialog.setVisibility(isActive);
      });
      this.el = document.createElement("div");
      this.el.className = "og-debug-info";
      let $controls = document.createElement("div");
      $controls.classList.add("og-debuginfo_controls");
      this.el.appendChild($controls);
      let temp = this._watch;
      this._watch = [];
      for (let i9 = 0; i9 < temp.length; i9++) {
        this.addWatch(temp[i9]);
      }
      this._dialog.container?.appendChild(this.el);
      this.renderer.events.on("draw", this._frame, this);
      let p4 = this.planet;
      if (p4) {
        this.addWatches([
          {
            label: "Nodes count",
            frame: () => p4._renderedNodes.length
          },
          {
            label: "Planet._fadingNodes",
            frame: () => p4._fadingNodes.size
          },
          {
            label: "createdNodes",
            frame: () => p4._createdNodesCount
          },
          {
            label: "indexesCache",
            frame: () => p4._indexesCacheToRemoveCounter
          },
          {
            label: "distBeforeMemClear",
            frame: () => Math.round(p4._distBeforeMemClear)
          },
          {
            label: "maxZoom/minZoom",
            frame: () => p4.maxCurrZoom + " / " + p4?.minCurrZoom
          },
          {
            label: "viewExtent",
            frame: () => p4.getViewExtent().toString()
          },
          {
            label: "height/alt (km)",
            frame: () => `<div style="width:190px">${(p4.camera._lonLat.height / 1e3).toFixed(2) + " / " + (p4.camera.getAltitude() / 1e3).toFixed(2)}</div>`
          },
          {
            label: "cam.slope",
            frame: () => p4.camera.slope.toFixed(3)
          },
          {
            label: "lodSize",
            frame: () => Math.round(p4.lodSize)
          },
          {
            label: "deltaTime/FPS",
            frame: () => `<div style="width:70px"><div style="width:20px; float: left;">
                        ${Math.round(p4.renderer.handler.deltaTime)}
                        </div> <div style="float: left">
                        ${Math.round(1e3 / p4.renderer.handler.deltaTime)}
                        </div></div>`
          },
          {
            label: "-------------------------"
          },
          {
            label: "_renderCompleted / renderCompletedActivated",
            frame: () => `${p4._renderCompleted} / ${p4._renderCompletedActivated}`
          },
          {
            label: "_terrainCompleted / terrainCompletedActivated",
            frame: () => `${p4._terrainCompleted} / ${p4._terrainCompletedActivated}`
          },
          {
            label: "PlainWorker",
            frame: () => p4._plainSegmentWorker.pendingQueue.length
          },
          {
            label: "TileLoader",
            frame: () => `${p4._tileLoader.loading} ${p4._tileLoader.queue.length}`
          },
          {
            label: "TerrainLoader",
            frame: () => {
              if (p4.terrain && !p4.terrain.isEmpty) {
                return `${p4.terrain.loader.loading}  ${p4.terrain.loader.queue.length}`;
              }
              return "";
            }
          },
          {
            label: "TerrainWorker",
            frame: () => p4._terrainWorker.pendingQueue.length
          },
          {
            label: "NormalMapCreator",
            frame: () => p4._normalMapCreator.queueSize
          },
          {
            label: "VectorTileCreator",
            frame: () => p4._vectorTileCreator.queueSize
          }
        ]);
      }
      let lockTreeBtn = new ToggleButton({
        classList: ["og-debuginfo_controls-button"],
        icon: ICON_LOCK_BUTTON_SVG,
        title: "Lock/Unlock quad tree"
      });
      lockTreeBtn.appendTo($controls);
      lockTreeBtn.events.on("change", (isActive) => {
        if (isActive) {
          p4.lockQuadTree();
        } else {
          p4.unlockQuadTree();
        }
      });
      let canvasTilesBtn = new ToggleButton({
        classList: ["og-debuginfo_controls-button"],
        icon: ICON_CANVASTILES_SVG,
        title: "Show/Hide grid"
      });
      canvasTilesBtn.appendTo($controls);
      canvasTilesBtn.events.on("change", (isActive) => {
        if (isActive) {
          this.planet.addLayer(this._canvasTiles);
        } else {
          this._canvasTiles.remove();
        }
      });
    }
    _frame() {
      this._watch.forEach((w3) => {
        if (w3.valEl) {
          w3.valEl.innerHTML = w3.frame ? String(w3.frame()) : "";
        }
      });
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/ui/ButtonGroup.js
  var BUTTONGROUP_EVENTS = ["change"];
  var ButtonGroup = class {
    constructor(options2 = {}) {
      this._onChange = (isActive, btn) => {
        if (isActive) {
          btn.preventClick = true;
          for (let i9 = 0; i9 < this._buttons.length; i9++) {
            let bi = this._buttons[i9];
            if (!bi.isEqual(btn)) {
              bi.setActive(false);
              bi.preventClick = false;
            }
          }
          this.events.dispatch(this.events.change, btn);
        }
      };
      this.events = createEvents(BUTTONGROUP_EVENTS);
      this._buttons = options2.buttons || [];
      for (let i9 = 0; i9 < this._buttons.length; i9++) {
        this._bindButton(this._buttons[i9]);
      }
    }
    _bindButton(button) {
      button.events.on("change", this._onChange);
    }
    add(button) {
      this._buttons.push(button);
      this._bindButton(button);
    }
    remove(button) {
      for (let i9 = 0; i9 < this._buttons.length; i9++) {
        if (this._buttons[i9].isEqual(button)) {
          this._buttons.splice(i9);
          button.events.off("change", this._onChange);
          return;
        }
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/BaseWorker.js
  var BaseWorker = class {
    constructor(numWorkers = 2, program) {
      this._sourceId = 0;
      this._source = /* @__PURE__ */ new Map();
      this._pendingQueue = [];
      this._numWorkers = numWorkers;
      this._workerQueue = [];
      if (program) {
        this.setProgram(program);
      }
    }
    check() {
      if (this._pendingQueue.length) {
        this.make(this._pendingQueue.pop());
      }
    }
    setProgram(program) {
      let p4 = new Blob([program], { type: "application/javascript" });
      for (let i9 = 0; i9 < this._numWorkers; i9++) {
        let w3 = new Worker(URL.createObjectURL(p4));
        w3.onmessage = (e9) => {
          this._onMessage(e9);
          this._workerQueue && this._workerQueue.unshift(e9.target);
          this.check();
        };
        this._workerQueue.push(w3);
      }
    }
    make(data) {
    }
    _onMessage(e9) {
    }
    destroy() {
      for (let i9 = 0; i9 < this._workerQueue.length; i9++) {
        const w3 = this._workerQueue[i9];
        w3.onmessage = null;
        w3.terminate();
      }
      this._pendingQueue = null;
      this._workerQueue = null;
    }
    get pendingQueue() {
      return this._pendingQueue;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/entity/LabelWorker.js
  var LOCK_UPDATE = -2;
  var LOCK_FREE = -1;
  var LabelWorker = class extends BaseWorker {
    constructor(numWorkers = 4) {
      super(numWorkers, LABEL_PROGRAM);
    }
    _onMessage(e9) {
      let s7 = this._source.get(e9.data.id);
      if (s7.label._lockId === LOCK_UPDATE) {
        requestAnimationFrame(() => {
          this.make({ handler: s7.handler, label: s7.label });
        });
      } else {
        s7.handler.workerCallback(e9.data, s7.label);
      }
      this._source.delete(e9.data.id);
    }
    make(data) {
      let label = data.label, handler = data.handler;
      if (handler._entityCollection) {
        let labelData = label.serializeWorkerData(this._sourceId);
        if (labelData) {
          if (this._workerQueue.length) {
            let w3 = this._workerQueue.pop();
            this._source.set(this._sourceId, data);
            label._lockId = this._sourceId;
            this._sourceId++;
            w3.postMessage({
              labelData
            }, [
              labelData.buffer
            ]);
          } else {
            this._pendingQueue.push(data);
          }
        }
      }
    }
  };
  var LABEL_PROGRAM = `'use strict';

    function concatTypedArrays(dest, index, source) {
        let len = source.length,
            offset = index * len;
        for(let i = 0; i < len; i++) {
            dest[offset + i] = source[i];
        }
    }

    self.onmessage = function (e) {
        var labelData = e.data.labelData,
            id = labelData[0],
            maxLetters = labelData[1],
            isVisible = labelData[2],
            /*3, 4, 5*/_positionHigh_x = labelData[3], _positionHigh_y = labelData[4], _positionHigh_z = labelData[5],
            /*6, 7, 8*/_positionLow_x = labelData[6], _positionLow_y = labelData[7], _positionLow_z = labelData[8],
            /*9*/_size = labelData[9],
            /*10, 11, 12*/_offset_x = labelData[10], _offset_y = labelData[11], _offset_z = labelData[12],
            /*13, 14, 15, 16*/_color_x = labelData[13], _color_y = labelData[14], _color_z = labelData[15], _color_w = labelData[16],
            /*17*/_rotation = labelData[17],
            /*18, 19, 20*/_alignedAxis_x = labelData[18], _alignedAxis_y = labelData[19], _alignedAxis_z = labelData[20],
            /*21*/_fontIndex = labelData[21],
            /*22*/_outline = labelData[22],
            /*23, 24, 25, 26*/_outlineColor_x = labelData[23], _outlineColor_y = labelData[24], _outlineColor_z = labelData[25], _outlineColor_w = labelData[26],
            /*27, 28, 29*/_pickingColor_x = labelData[27], _pickingColor_y = labelData[28], _pickingColor_z = labelData[29]
         

        let _vertexArr = new Float32Array(maxLetters * 12),
            _texCoordArr = new Float32Array(maxLetters * 24),
            _gliphParamArr = new Float32Array(maxLetters * 24),
            _positionHighArr = new Float32Array(maxLetters * 18),
            _positionLowArr = new Float32Array(maxLetters * 18),
            _sizeArr = new Float32Array(maxLetters * 6),
            _offsetArr = new Float32Array(maxLetters * 18),
            _rgbaArr = new Float32Array(maxLetters * 24),
            _rotationArr = new Float32Array(maxLetters * 6),
            _alignedAxisArr = new Float32Array(maxLetters * 18),
            _fontIndexArr = new Float32Array(maxLetters * 6),
            _outlineArr = new Float32Array(maxLetters * 6),
            _outlineColorArr = new Float32Array(maxLetters * 24),
            _pickingColorArr = new Float32Array(maxLetters * 18);
        
        for (let i = 0; i < maxLetters; i++) {
            if (isVisible !== 0) {
                concatTypedArrays(_vertexArr, i, [0, 0, 0, -1, 1, -1, 1, -1, 1, 0, 0, 0]);
            } else {
                concatTypedArrays(_vertexArr, i, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
            }

            concatTypedArrays(_texCoordArr, i, [0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0]);
            concatTypedArrays(_gliphParamArr, i, [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]);

            var x = _positionHigh_x, y = _positionHigh_y, z = _positionHigh_z, w;
            concatTypedArrays(_positionHighArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _positionLow_x; y = _positionLow_y; z = _positionLow_z;
            concatTypedArrays(_positionLowArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _size;
            concatTypedArrays(_sizeArr, i, [x, x, x, x, x, x]);

            x = _offset_x; y = _offset_y; z = _offset_z;
            concatTypedArrays(_offsetArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _color_x; y = _color_y; z = _color_z; w = _color_w;
            concatTypedArrays(_rgbaArr, i, [x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w]);

            x = _rotation;
            concatTypedArrays(_rotationArr, i, [x, x, x, x, x, x]);

            x = _alignedAxis_x; y = _alignedAxis_y; z = _alignedAxis_z;
            concatTypedArrays(_alignedAxisArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = _fontIndex;
            concatTypedArrays(_fontIndexArr, i, [x, x, x, x, x, x]);

            x = _outline;
            concatTypedArrays(_outlineArr, i, [x, x, x, x, x, x]);

            x = _outlineColor_x; y = _outlineColor_y; z = _outlineColor_z; w = _outlineColor_w;
            concatTypedArrays(_outlineColorArr, i, [x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w]);

            x = _pickingColor_x / 255; y = _pickingColor_y / 255; z = _pickingColor_z / 255;
            concatTypedArrays(_pickingColorArr, i, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
        }

        self.postMessage({
                id: id,
                vertexArr: _vertexArr,
                texCoordArr: _texCoordArr,
                gliphParamArr: _gliphParamArr,
                positionHighArr: _positionHighArr,
                positionLowArr: _positionLowArr,
                sizeArr: _sizeArr,
                offsetArr: _offsetArr,
                rgbaArr: _rgbaArr,
                rotationArr: _rotationArr,
                alignedAxisArr: _alignedAxisArr,
                fontIndexArr: _fontIndexArr,
                outlineArr: _outlineArr,
                outlineColorArr: _outlineColorArr,
                pickingColorArr: _pickingColorArr
             }, [
                    _vertexArr.buffer,
                    _texCoordArr.buffer,
                    _gliphParamArr.buffer,
                    _positionHighArr.buffer,
                    _positionLowArr.buffer,
                    _sizeArr.buffer,
                    _offsetArr.buffer,
                    _rgbaArr.buffer,
                    _rotationArr.buffer,
                    _alignedAxisArr.buffer,
                    _fontIndexArr.buffer,
                    _outlineArr.buffer,
                    _outlineColorArr.buffer,
                    _pickingColorArr.buffer
            ]);
    }`;

  // frontend/node_modules/@openglobus/og/lib/js/entity/BaseBillboard.js
  var BaseBillboard = class _BaseBillboard {
    constructor(options2 = {}) {
      this.__id = _BaseBillboard.__counter__++;
      this._position = createVector3(options2.position);
      this._positionHigh = new Vec3();
      this._positionLow = new Vec3();
      Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
      this._rotation = options2.rotation || 0;
      this._color = createColorRGBA(options2.color);
      this._alignedAxis = createVector3(options2.alignedAxis);
      this._offset = createVector3(options2.offset);
      this._visibility = options2.visibility != void 0 ? options2.visibility : true;
      this._entity = null;
      this._handler = null;
      this._handlerIndex = -1;
      this._isReady = false;
      this._lockId = LOCK_FREE;
    }
    /**
     * Sets billboard position.
     * @public
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} z - Z coordinate.
     */
    setPosition(x3, y4, z3) {
      this._position.x = x3;
      this._position.y = y4;
      this._position.z = z3;
      Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
      if (this._isReady && this._handler) {
        this._handler.setPositionArr(this._handlerIndex, this._positionHigh, this._positionLow);
      } else if (this._lockId !== LOCK_FREE) {
        this._lockId = LOCK_UPDATE;
      }
    }
    /**
     * Sets billboard position.
     * @public
     * @param {Vec3} position - Cartesian coordinates.
     */
    setPosition3v(position2) {
      this._position.x = position2.x;
      this._position.y = position2.y;
      this._position.z = position2.z;
      Vec3.doubleToTwoFloats(position2, this._positionHigh, this._positionLow);
      if (this._isReady && this._handler) {
        this._handler.setPositionArr(this._handlerIndex, this._positionHigh, this._positionLow);
      } else if (this._lockId !== LOCK_FREE) {
        this._lockId = LOCK_UPDATE;
      }
    }
    /**
     * Returns billboard position.
     * @public
     * @returns {Vec3}
     */
    getPosition() {
      return this._position;
    }
    /**
     * Sets screen space offset.
     * @public
     * @param {number} x - X offset.
     * @param {number} y - Y offset.
     * @param {number} [z] - Z offset.
     */
    setOffset(x3, y4, z3) {
      this._offset.x = x3;
      this._offset.y = y4;
      z3 != void 0 && (this._offset.z = z3);
      if (this._isReady && this._handler) {
        this._handler.setOffsetArr(this._handlerIndex, this._offset);
      } else if (this._lockId !== LOCK_FREE) {
        this._lockId = LOCK_UPDATE;
      }
    }
    /**
     * Sets screen space offset.
     * @public
     * @param {Vec2} offset - Offset size.
     */
    setOffset3v(offset) {
      this.setOffset(offset.x, offset.y, offset.z);
    }
    /**
     * Returns billboard screen space offset size.
     * @public
     * @returns {Vec3}
     */
    getOffset() {
      return this._offset;
    }
    /**
     * Sets billboard screen space rotation in radians.
     * @public
     * @param {number} rotation - Screen space rotation in radians.
     */
    setRotation(rotation) {
      if (rotation !== this._rotation) {
        this._rotation = rotation;
        if (this._isReady && this._handler) {
          this._handler.setRotationArr(this._handlerIndex, rotation);
        } else if (this._lockId !== LOCK_FREE) {
          this._lockId = LOCK_UPDATE;
        }
      }
    }
    /**
     * Gets screen space rotation.
     * @public
     * @returns {number}
     */
    getRotation() {
      return this._rotation;
    }
    /**
     * Sets billboard opacity.
     * @public
     * @param {number} a - Billboard opacity.
     */
    setOpacity(a6) {
      if (a6 !== this._color.w) {
        a6 != void 0 && (this._color.w = a6);
        if (this._isReady && this._handler) {
          this._handler.setRgbaArr(this._handlerIndex, this._color);
        } else if (this._lockId !== LOCK_FREE) {
          this._lockId = LOCK_UPDATE;
        }
      }
    }
    /**
     * Sets RGBA color. Each channel from 0.0 to 1.0.
     * @public
     * @param {number} r - Red.
     * @param {number} g - Green.
     * @param {number} b - Blue.
     * @param {number} a - Alpha.
     */
    setColor(r8, g4, b4, a6) {
      if (a6 !== this._color.w || r8 !== this._color.x || g4 !== this._color.y || this._color.z !== b4) {
        this._color.x = r8;
        this._color.y = g4;
        this._color.z = b4;
        a6 != void 0 && (this._color.w = a6);
        if (this._isReady && this._handler) {
          this._handler.setRgbaArr(this._handlerIndex, this._color);
        } else if (this._lockId !== LOCK_FREE) {
          this._lockId = LOCK_UPDATE;
        }
      }
    }
    /**
     * Sets RGBA color. Each channel from 0.0 to 1.0.
     * @public
     * @param {Vec4} color - RGBA vector.
     */
    setColor4v(color) {
      this.setColor(color.x, color.y, color.z, color.w);
    }
    /**
     * Sets billboard color.
     * @public
     * @param {string} color - HTML style color.
     */
    setColorHTML(color) {
      this.setColor4v(htmlColorToRgba(color));
    }
    /**
     * Returns RGBA color.
     * @public
     * @returns {Vec4}
     */
    getColor() {
      return this._color;
    }
    /**
     * Sets billboard visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
      if (visibility !== this._visibility) {
        this._visibility = visibility;
        if (this._isReady && this._handler) {
          this._handler.setVisibility(this._handlerIndex, visibility);
        } else if (this._lockId !== LOCK_FREE) {
          this._lockId = LOCK_UPDATE;
        }
      }
    }
    /**
     * Returns billboard visibility.
     * @public
     * @returns {boolean}
     */
    getVisibility() {
      return this._visibility;
    }
    /**
     * Sets billboard cartesian aligned vector.
     * @public
     * @param {number} x - Aligned vector X coordinate.
     * @param {number} y - Aligned vector Y coordinate.
     * @param {number} z - Aligned vector Z coordinate.
     */
    setAlignedAxis(x3, y4, z3) {
      this._alignedAxis.x = x3;
      this._alignedAxis.y = y4;
      this._alignedAxis.z = z3;
      if (this._isReady && this._handler) {
        this._handler.setAlignedAxisArr(this._handlerIndex, this._alignedAxis);
      } else if (this._lockId !== LOCK_FREE) {
        this._lockId = LOCK_UPDATE;
      }
    }
    /**
     * Sets billboard aligned vector.
     * @public
     * @param {Vec3} alignedAxis - Align direction.
     */
    setAlignedAxis3v(alignedAxis) {
      this.setAlignedAxis(alignedAxis.x, alignedAxis.y, alignedAxis.z);
    }
    /**
     * Returns aligned vector.
     * @public
     * @returns {Vec3}
     */
    getAlignedAxis() {
      return this._alignedAxis;
    }
    /**
     * Removes billboard from handler.
     * @public
     */
    remove() {
      this._entity = null;
      this._handler && this._handler.remove(this);
    }
    /**
     * Sets billboard picking color.
     * @public
     * @param {Vec3} color - Picking color.
     */
    setPickingColor3v(color) {
      if (this._isReady && this._handler) {
        this._handler.setPickingColorArr(this._handlerIndex, color);
      } else if (this._lockId !== LOCK_FREE) {
        this._lockId = LOCK_UPDATE;
      }
    }
    serializeWorkerData(workerId) {
      if (this._handler) {
        return new Float32Array([]);
      }
      return null;
    }
  };
  BaseBillboard.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/entity/Billboard.js
  var Billboard = class extends BaseBillboard {
    constructor(options2 = {}) {
      super(options2);
      this._handler = null;
      this._src = options2.src || null;
      this._image = options2.image || null;
      this._scale = 1;
      this._width = options2.width || (options2.size ? options2.size[0] : 30);
      this._height = options2.height || (options2.size ? options2.size[1] : 30);
    }
    /**
     * Sets billboard image url source.
     * @public
     * @param {string} src - Image url.
     */
    setSrc(src) {
      this._src = src;
      let bh = this._handler;
      if (bh && src && src.length) {
        let rn = bh._entityCollection.renderNode;
        if (rn && rn.renderer) {
          let ta = rn.renderer.billboardsTextureAtlas;
          let that = this;
          ta.loadImage(src, function(img) {
            if (img.__nodeIndex != void 0 && ta.get(img.__nodeIndex)) {
              that._image = img;
              bh.setTexCoordArr(that._handlerIndex, ta.get(that._image.__nodeIndex).texCoords);
            } else {
              ta.addImage(img);
              ta.createTexture();
              that._image = img;
              rn.updateBillboardsTexCoords();
            }
          });
        }
      }
    }
    getSrc() {
      return this._src;
    }
    /**
     * Sets image object.
     * @public
     * @param {Object} image - JavaScript image object.
     */
    setImage(image) {
      this.setSrc(image.src);
    }
    getImage() {
      return this._image;
    }
    /**
     * Sets billboard screen size in pixels.
     * @public
     * @param {number} width - Billboard width.
     * @param {number} height - Billboard height.
     */
    setSize(width, height) {
      this._width = width;
      this._height = height;
      this._handler && this._handler.setSizeArr(this._handlerIndex, width * this._scale, height * this._scale);
    }
    /**
     * Returns billboard screen size.
     * @public
     * @returns {Object}
     */
    getSize() {
      return {
        width: this._width,
        height: this._height
      };
    }
    /**
     * Sets billboard screen width.
     * @public
     * @param {number} width - Width.
     */
    setWidth(width) {
      this.setSize(width, this._height);
    }
    /**
     * Gets billboard screen width.
     * @public
     * @returns {number}
     */
    getWidth() {
      return this._width;
    }
    /**
     * Sets billboard screen heigh.
     * @public
     * @param {number} height - Height.
     */
    setHeight(height) {
      this.setSize(this._width, height);
    }
    /**
     * Gets billboard screen height.
     * @public
     * @returns {number}
     */
    getHeight() {
      return this._height;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/entity/Geometry.js
  var GeometryTypeEnum;
  (function(GeometryTypeEnum2) {
    GeometryTypeEnum2[GeometryTypeEnum2["POINT"] = 1] = "POINT";
    GeometryTypeEnum2[GeometryTypeEnum2["LINESTRING"] = 2] = "LINESTRING";
    GeometryTypeEnum2[GeometryTypeEnum2["POLYGON"] = 3] = "POLYGON";
    GeometryTypeEnum2[GeometryTypeEnum2["MULTIPOLYGON"] = 4] = "MULTIPOLYGON";
    GeometryTypeEnum2[GeometryTypeEnum2["MULTILINESTRING"] = 5] = "MULTILINESTRING";
  })(GeometryTypeEnum || (GeometryTypeEnum = {}));
  var GeometryType = {
    POINT: 1,
    LINESTRING: 2,
    POLYGON: 3,
    MULTIPOLYGON: 4,
    MULTILINESTRING: 5
  };
  var Geometry = class _Geometry {
    constructor(options2 = {}) {
      this.__id = _Geometry.__counter__++;
      this._entity = null;
      this._handler = null;
      this._handlerIndex = -1;
      this._polyVerticesHighMerc = [];
      this._polyVerticesLowMerc = [];
      this._polyVerticesLength = -1;
      this._polyIndexesLength = -1;
      this._polyVerticesHandlerIndex = -1;
      this._polyIndexesHandlerIndex = -1;
      this._lineVerticesHighMerc = [];
      this._lineVerticesLowMerc = [];
      this._lineVerticesLength = -1;
      this._lineOrdersLength = -1;
      this._lineIndexesLength = -1;
      this._lineColorsLength = -1;
      this._lineThicknessLength = -1;
      this._lineVerticesHandlerIndex = -1;
      this._lineOrdersHandlerIndex = -1;
      this._lineIndexesHandlerIndex = -1;
      this._lineThicknessHandlerIndex = -1;
      this._lineColorsHandlerIndex = -1;
      this._type = options2.type && _Geometry.getType(options2.type) || GeometryTypeEnum.POINT;
      this._coordinates = options2.coordinates || [];
      this._extent = _Geometry.getExtent({
        type: options2.type || "POINT",
        coordinates: options2.coordinates || []
      }, this._coordinates);
      options2.style = options2.style || {};
      this._style = {
        fillColor: createColorRGBA(options2.style.fillColor, new Vec4(0.19, 0.62, 0.85, 0.4)),
        lineColor: createColorRGBA(options2.style.lineColor, new Vec4(0.19, 0.62, 0.85, 1)),
        strokeColor: createColorRGBA(options2.style.strokeColor, new Vec4(1, 1, 1, 0.95)),
        lineWidth: options2.style.lineWidth || 3,
        strokeWidth: options2.style.strokeWidth || 0
      };
      this._visibility = options2.visibility || true;
      this._pickingReady = false;
    }
    get id() {
      return this.__id;
    }
    get type() {
      return this._type;
    }
    static getType(typeStr2) {
      return GeometryType[typeStr2.toUpperCase()];
    }
    /**
     * Returns geometry extent.
     @static
     @param {IGeometry} geometryObj - GeoJSON style geometry feature.
     @param {IGeometryCoordinates} outCoordinates - Geometry feature coordinates clone.
     @returns {Extent} -
     */
    static getExtent(geometryObj, outCoordinates) {
      let res = new Extent(new LonLat(180, 90), new LonLat(-180, -90));
      let t9 = _Geometry.getType(geometryObj.type);
      if (t9 === GeometryTypeEnum.POINT) {
        let lon = geometryObj.coordinates[0], lat = geometryObj.coordinates[1];
        res.southWest.lon = lon;
        res.southWest.lat = lat;
        res.northEast.lon = lon;
        res.northEast.lat = lat;
        outCoordinates && (outCoordinates[0] = lon) && (outCoordinates[1] = lat);
      } else if (t9 === GeometryTypeEnum.LINESTRING) {
        let c7 = geometryObj.coordinates;
        for (let i9 = 0; i9 < c7.length; i9++) {
          let lon = c7[i9][0], lat = c7[i9][1];
          if (lon < res.southWest.lon)
            res.southWest.lon = lon;
          if (lat < res.southWest.lat)
            res.southWest.lat = lat;
          if (lon > res.northEast.lon)
            res.northEast.lon = lon;
          if (lat > res.northEast.lat)
            res.northEast.lat = lat;
          outCoordinates && (outCoordinates[i9] = [lon, lat]);
        }
      } else if (t9 === GeometryTypeEnum.POLYGON) {
        let c7 = geometryObj.coordinates;
        for (let i9 = 0; i9 < c7.length; i9++) {
          let ci = c7[i9];
          outCoordinates && (outCoordinates[i9] = []);
          for (let j2 = 0; j2 < ci.length; j2++) {
            let cij = ci[j2];
            let lon = cij[0], lat = cij[1];
            if (lon < res.southWest.lon)
              res.southWest.lon = lon;
            if (lat < res.southWest.lat)
              res.southWest.lat = lat;
            if (lon > res.northEast.lon)
              res.northEast.lon = lon;
            if (lat > res.northEast.lat)
              res.northEast.lat = lat;
            outCoordinates && (outCoordinates[i9][j2] = [lon, lat]);
          }
        }
      } else if (t9 === GeometryTypeEnum.MULTIPOLYGON) {
        let p4 = geometryObj.coordinates;
        for (let i9 = 0; i9 < p4.length; i9++) {
          let pi = p4[i9];
          outCoordinates && (outCoordinates[i9] = []);
          for (let j2 = 0; j2 < pi.length; j2++) {
            let pij = pi[j2];
            outCoordinates && (outCoordinates[i9][j2] = []);
            for (let k3 = 0; k3 < pij.length; k3++) {
              let pijk = pij[k3];
              let lon = pijk[0], lat = pijk[1];
              if (lon < res.southWest.lon)
                res.southWest.lon = lon;
              if (lat < res.southWest.lat)
                res.southWest.lat = lat;
              if (lon > res.northEast.lon)
                res.northEast.lon = lon;
              if (lat > res.northEast.lat)
                res.northEast.lat = lat;
              outCoordinates && (outCoordinates[i9][j2][k3] = [lon, lat]);
            }
          }
        }
      } else if (t9 === GeometryTypeEnum.MULTILINESTRING) {
        let c7 = geometryObj.coordinates;
        for (let i9 = 0; i9 < c7.length; i9++) {
          let ci = c7[i9];
          outCoordinates && (outCoordinates[i9] = []);
          for (let j2 = 0; j2 < ci.length; j2++) {
            let cij = ci[j2];
            let lon = cij[0], lat = cij[1];
            if (lon < res.southWest.lon)
              res.southWest.lon = lon;
            if (lat < res.southWest.lat)
              res.southWest.lat = lat;
            if (lon > res.northEast.lon)
              res.northEast.lon = lon;
            if (lat > res.northEast.lat)
              res.northEast.lat = lat;
            outCoordinates && (outCoordinates[i9][j2] = [lon, lat]);
          }
        }
      } else {
        res.southWest.lon = res.southWest.lat = res.northEast.lon = res.northEast.lat = 0;
        outCoordinates && (outCoordinates[0] = 0) && (outCoordinates[1] = 0);
      }
      return res;
    }
    /**
     * @todo ASAP need test for this method
     * @param geoJson
     * @returns {Geometry}
     */
    setGeometry(geoJson) {
      let h8 = this._handler;
      if (h8) {
        this.remove();
        this._type = _Geometry.getType(geoJson.type || "Point");
        this._extent = _Geometry.getExtent(geoJson, this._coordinates);
        h8.add(this);
      }
      return this;
    }
    setFillColor(r8, g4, b4, a6 = 1) {
      let c7 = this._style.fillColor;
      if (c7.w === 0 && a6 !== 0 || c7.w !== 0 && a6 === 0) {
        this._pickingReady = false;
      }
      c7.x = r8;
      c7.y = g4;
      c7.z = b4;
      c7.w = a6;
      this._handler && this._handler.setPolyColorArr(this, c7);
      return this;
    }
    overlaps(extent) {
      return this._extent.overlaps(extent);
    }
    setFillColor4v(rgba) {
      return this.setFillColor(rgba.x, rgba.y, rgba.z, rgba.w);
    }
    setStrokeColor(r8, g4, b4, a6 = 1) {
      let c7 = this._style.strokeColor;
      if (c7.w === 0 && a6 !== 0 || c7.w !== 0 && a6 === 0) {
        this._pickingReady = false;
      }
      c7.x = r8;
      c7.y = g4;
      c7.z = b4;
      c7.w = a6;
      this._handler && this._handler.setLineStrokeColorArr(this, c7);
      return this;
    }
    setLineColor(r8, g4, b4, a6 = 1) {
      let c7 = this._style.lineColor;
      if (c7.w === 0 && a6 !== 0 || c7.w !== 0 && a6 === 0) {
        this._pickingReady = false;
      }
      c7.x = r8;
      c7.y = g4;
      c7.z = b4;
      c7.w = a6;
      this._handler && this._handler.setLineColorArr(this, c7);
      return this;
    }
    setStrokeColor4v(rgba) {
      return this.setStrokeColor(rgba.x, rgba.y, rgba.z, rgba.w);
    }
    setLineColor4v(rgba) {
      return this.setLineColor(rgba.x, rgba.y, rgba.z, rgba.w);
    }
    setStrokeOpacity(opacity) {
      let c7 = this._style.strokeColor;
      c7.w = opacity;
      return this.setStrokeColor(c7.x, c7.y, c7.z, opacity);
    }
    setLineOpacity(opacity) {
      let c7 = this._style.lineColor;
      c7.w = opacity;
      return this.setLineColor(c7.x, c7.y, c7.z, opacity);
    }
    setStrokeWidth(width) {
      this._style.strokeWidth = width;
      this._pickingReady = false;
      this._handler && this._handler.setLineStrokeArr(this, width);
      return this;
    }
    bringToFront() {
      this._handler && this._handler.bringToFront(this);
      return this;
    }
    setLineWidth(width) {
      this._style.lineWidth = width;
      this._pickingReady = false;
      this._handler && this._handler.setLineThicknessArr(this, width);
      return this;
    }
    setFillOpacity(opacity) {
      let c7 = this._style.fillColor;
      if (c7.w === 0 && opacity !== 0 || c7.w !== 0 && opacity === 0) {
        this._pickingReady = false;
      }
      c7.w = opacity;
      this._handler && this._handler.setPolyColorArr(this, c7);
      return this;
    }
    setVisibility(visibility) {
      this._visibility = visibility;
      this._handler && this._handler.setGeometryVisibility(this);
      return this;
    }
    getVisibility() {
      return this._visibility;
    }
    remove() {
      this._handler && this._handler.remove(this);
    }
    getExtent() {
      return this._extent.clone();
    }
    getType() {
      return this._type;
    }
  };
  Geometry.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/math/Line3.js
  var Line3 = class {
    constructor(p0, p1) {
      this.p0 = p0 || new Vec3();
      this.p1 = p1 || new Vec3();
    }
    getMagnitude() {
      return this.p0.distance(this.p1);
    }
    getSphereIntersection(sphere) {
      let p0 = this.p0, p1 = this.p1;
      let cx = sphere.center.x, cy = sphere.center.y, cz = sphere.center.z;
      let px = p0.x, py = p0.y, pz = p0.z;
      let vx = p1.x - px, vy = p1.y - py, vz = p1.z - pz;
      let A3 = vx * vx + vy * vy + vz * vz, B3 = 2 * (px * vx + py * vy + pz * vz - vx * cx - vy * cy - vz * cz), C2 = px * px - 2 * px * cx + cx * cx + py * py - 2 * py * cy + cy * cy + pz * pz - 2 * pz * cz + cz * cz - sphere.radius * sphere.radius;
      let D2 = B3 * B3 - 4 * A3 * C2;
      if (D2 < 0) {
        return [];
      }
      let t1 = (-B3 - Math.sqrt(D2)) / (2 * A3);
      let solution1 = new Vec3(p0.x * (1 - t1) + t1 * p1.x, p0.y * (1 - t1) + t1 * p1.y, p0.z * (1 - t1) + t1 * p1.z);
      if (D2 == 0) {
        return [solution1];
      }
      let t22 = (-B3 + Math.sqrt(D2)) / (2 * A3);
      let solution2 = new Vec3(p0.x * (1 - t22) + t22 * p1.x, p0.y * (1 - t22) + t22 * p1.y, p0.z * (1 - t22) + t22 * p1.z);
      if (Math.abs(t1 - 0.5) < Math.abs(t22 - 0.5)) {
        return [solution1, solution2];
      }
      return [solution2, solution1];
    }
    intersects(line, res, res2) {
      let p13 = this.p0.sub(line.p0), p43 = line.p1.sub(line.p0);
      if (Math.abs(p43.x) < EPS10 && Math.abs(p43.y) < EPS10 && Math.abs(p43.z) < EPS10) {
        return false;
      }
      let p21 = this.p1.sub(this.p0);
      if (Math.abs(p21.x) < EPS10 && Math.abs(p21.y) < EPS10 && Math.abs(p21.z) < EPS10) {
        return false;
      }
      let d1343 = p13.x * p43.x + p13.y * p43.y + p13.z * p43.z, d4321 = p43.x * p21.x + p43.y * p21.y + p43.z * p21.z, d1321 = p13.x * p21.x + p13.y * p21.y + p13.z * p21.z, d4343 = p43.x * p43.x + p43.y * p43.y + p43.z * p43.z, d2121 = p21.x * p21.x + p21.y * p21.y + p21.z * p21.z;
      let denom = d2121 * d4343 - d4321 * d4321;
      if (Math.abs(denom) < EPS10) {
        return false;
      }
      let numer = d1343 * d4321 - d1321 * d4343;
      let mua = numer / denom;
      res.x = this.p0.x + mua * p21.x;
      res.y = this.p0.y + mua * p21.y;
      res.z = this.p0.z + mua * p21.z;
      if (res2) {
        let mub = (d1343 + d4321 * mua) / d4343;
        res2.x = line.p0.x + mub * p43.x;
        res2.y = line.p0.y + mub * p43.y;
        res2.z = line.p0.z + mub * p43.z;
      }
      return true;
    }
    getNearestDistancePoint(point, res) {
      let p0 = this.p0, p1 = this.p1;
      let mag = this.getMagnitude();
      let u4 = ((point.x - p0.x) * (p1.x - p0.x) + (point.y - p0.y) * (p1.y - p0.y) + (point.z - p0.z) * (p1.z - p0.z)) / (mag * mag);
      res.x = p0.x + u4 * (p1.x - p0.x);
      res.y = p0.y + u4 * (p1.y - p0.y);
      res.z = p0.z + u4 * (p1.z - p0.z);
      if (u4 < 0 || u4 > 1) {
        return false;
      }
      return true;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/math/Ray.js
  var Ray = class _Ray {
    constructor(origin = Vec3.ZERO, direction = Vec3.ZERO) {
      this.origin = origin;
      this.direction = direction;
    }
    /** @const */
    static get OUTSIDE() {
      return 0;
    }
    /** @const */
    static get INSIDE() {
      return 1;
    }
    /** @const */
    static get INPLANE() {
      return 2;
    }
    /** @const */
    static get AWAY() {
      return 3;
    }
    /**
     * Sets a ray parameters.
     * @public
     * @param {Vec3} origin - The origin of the ray.
     * @param {Vec3} direction - The direction of the ray.
     * @returns {Ray}
     */
    set(origin, direction) {
      this.origin = origin;
      this.direction = direction;
      return this;
    }
    /**
     * Computes the point along the ray on the distance.
     * @public
     * @param {number} distance - Point distance.
     * @returns {Vec3}
     */
    getPoint(distance) {
      return Vec3.add(this.origin, this.direction.scaleTo(distance));
    }
    /**
     * Returns ray hit a triange result.
     * @public
     * @param {Vec3} v0 - First triangle corner coordinate.
     * @param {Vec3} v1 - Second triangle corner coordinate.
     * @param {Vec3} v2 - Third triangle corner coordinate.
     * @param {Vec3} res - Hit point object pointer that stores hit result.
     * @returns {number} - Hit code, could 0 - og.Ray.OUTSIDE, 1 - og.Ray.INSIDE,
     *      2 - og.Ray.INPLANE and 3 - og.Ray.AWAY(ray goes away from triangle).
     */
    hitTriangle(v0, v1, v22, res) {
      let u4 = v1.sub(v0);
      let v4 = v22.sub(v0);
      let n7 = u4.cross(v4);
      let w0 = this.origin.sub(v0);
      let a6 = -n7.dot(w0);
      let b4 = n7.dot(this.direction);
      if (Math.abs(b4) < EPS10) {
        if (a6 === 0) {
          res.copy(this.origin);
          return _Ray.INPLANE;
        } else {
          return _Ray.OUTSIDE;
        }
      }
      let r8 = a6 / b4;
      res.copy(this.origin.add(this.direction.scaleTo(r8)));
      if (r8 < 0) {
        return _Ray.AWAY;
      }
      let uu = u4.dot(u4);
      let uv = u4.dot(v4);
      let vv = v4.dot(v4);
      let w3 = res.sub(v0);
      let wu = w3.dot(u4);
      let wv = w3.dot(v4);
      let D2 = uv * uv - uu * vv;
      let s7 = (uv * wv - vv * wu) / D2;
      if (s7 < 0 || s7 > 1) {
        return _Ray.OUTSIDE;
      }
      let t9 = (uv * wu - uu * wv) / D2;
      if (t9 < 0 || s7 + t9 > 1) {
        return _Ray.OUTSIDE;
      }
      return _Ray.INSIDE;
    }
    /**
     * Gets a ray hit a plane result. If the ray cross the plane returns 1 - og.Ray.INSIDE otherwise returns 0 - og.Ray.OUTSIDE.
     * @public
     * @param {Vec3} v0 - First plane point.
     * @param {Vec3} v1 - Second plane point.
     * @param {Vec3} v2 - Third plane point.
     * @param {Vec3} res - Hit point object pointer that stores hit result.
     * @returns {number}
     */
    hitPlane(v0, v1, v22, res) {
      let u4 = Vec3.sub(v1, v0);
      let v4 = Vec3.sub(v22, v0);
      let n7 = u4.cross(v4);
      let w0 = Vec3.sub(this.origin, v0);
      let a6 = -n7.dot(w0);
      let b4 = n7.dot(this.direction);
      if (Math.abs(b4) < EPS10) {
        if (a6 === 0) {
          return _Ray.OUTSIDE;
        }
      }
      let r8 = a6 / b4;
      if (r8 < 0) {
        return _Ray.OUTSIDE;
      }
      let d4 = this.direction.scaleTo(r8);
      res.x = this.origin.x + d4.x;
      res.y = this.origin.y + d4.y;
      res.z = this.origin.z + d4.z;
      return _Ray.INSIDE;
    }
    /**
     * Returns a ray hit sphere coordiante. If there isn't hit returns null.
     * @public
     * @param {Sphere} sphere - Sphere object.
     * @returns {Vec3}
     */
    hitSphere(sphere) {
      let r8 = sphere.radius, c7 = sphere.center, o7 = this.origin, d4 = this.direction;
      let vpc = Vec3.sub(c7, o7);
      if (vpc.dot(d4) < 0) {
        var l4 = vpc.length();
        if (l4 > r8) {
          return null;
        } else if (l4 === r8) {
          return o7.clone();
        }
        let pc = c7.projToRay(o7, vpc);
        var lc = Vec3.sub(pc, c7).length();
        let dist = Math.sqrt(r8 * r8 - lc * lc);
        let di1 = dist - Vec3.sub(pc, o7).length();
        let intersection = Vec3.add(o7, d4.scaleTo(di1));
        return intersection;
      } else {
        let pc = c7.projToRay(o7, d4);
        var cpcl = Vec3.sub(c7, pc).length();
        if (cpcl > sphere.radius) {
          return null;
        } else {
          let dist = Math.sqrt(r8 * r8 - cpcl * cpcl);
          let di1;
          pc.subA(o7);
          if (vpc.length() > r8) {
            di1 = pc.length() - dist;
          } else {
            di1 = pc.length() + dist;
          }
          let intersection = Vec3.add(o7, d4.scaleTo(di1));
          return intersection;
        }
      }
    }
    hitBox(box) {
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/objParser.js
  function objParser(text) {
    const objPositions = [[0, 0, 0]];
    const objTexcoords = [[0, 0]];
    const objNormals = [[0, 0, 0]];
    const objVertexData = [
      objPositions,
      objTexcoords,
      objNormals
    ];
    let vertexData = [
      [],
      // positions
      [],
      // texcoords
      []
      // normals
    ];
    const materialLibs = [];
    const geometries = [];
    let geometry;
    let groups = ["default"];
    let material = "default";
    let object = "default";
    function newGeometry() {
      if (geometry && geometry.data.vertices.length) {
        geometry = null;
      }
    }
    function setGeometry() {
      if (!geometry) {
        const vertices = [];
        const textures = [];
        const normals = [];
        vertexData = [
          vertices,
          textures,
          normals
        ];
        geometry = {
          object,
          groups,
          material,
          data: {
            vertices,
            textures,
            normals
          }
        };
        geometries.push(geometry);
      }
    }
    function addVertex(vert) {
      const ptn = vert.split("/");
      ptn.forEach((objIndexStr, i9) => {
        if (!objIndexStr) {
          return;
        }
        const objIndex = parseInt(objIndexStr);
        const index = objIndex + (objIndex >= 0 ? 0 : objVertexData[i9].length);
        vertexData[i9].push(...objVertexData[i9][index]);
      });
    }
    const keywords = {
      v(parts) {
        objPositions.push(parts.map(parseFloat));
      },
      vn(parts) {
        objNormals.push(parts.map(parseFloat));
      },
      vt(parts) {
        objTexcoords.push(parts.map(parseFloat));
      },
      f(parts) {
        setGeometry();
        const numTriangles = parts.length - 2;
        for (let tri = 0; tri < numTriangles; ++tri) {
          addVertex(parts[0]);
          addVertex(parts[tri + 1]);
          addVertex(parts[tri + 2]);
        }
      },
      s: () => {
      },
      // smoothing group
      mtllib(parts, unparsedArgs) {
        materialLibs.push(unparsedArgs);
      },
      usemtl(parts, unparsedArgs) {
        material = unparsedArgs;
        newGeometry();
      },
      g(parts) {
        groups = parts;
        newGeometry();
      },
      o(parts, unparsedArgs) {
        object = unparsedArgs;
        newGeometry();
      }
    };
    const keywordRE = /(\w*)(?: )*(.*)/;
    const lines = text.split("\n");
    for (let lineNo = 0; lineNo < lines.length; ++lineNo) {
      const line = lines[lineNo].trim();
      if (line === "" || line.startsWith("#")) {
        continue;
      }
      const m5 = keywordRE.exec(line);
      if (!m5) {
        continue;
      }
      const [, keyword, unparsedArgs] = m5;
      const parts = line.split(/\s+/).slice(1);
      const handler = keywords[keyword];
      if (!handler) {
        console.warn("unhandled keyword:", keyword);
        continue;
      }
      handler(parts, unparsedArgs);
    }
    for (const geometry2 of geometries) {
      geometry2.data = Object.fromEntries(Object.entries(geometry2.data).filter(([key, array]) => array.length > 0));
    }
    return {
      geometries,
      materialLibs
    };
  }
  function transformLeftToRightCoordinateSystem(objData) {
    const convertedGeometries = objData.geometries.map((geometry) => {
      const vertices = geometry.data.vertices;
      const normals = geometry.data.normals;
      const textures = geometry.data.textures;
      rotateObject(geometry.data, 0);
      let convertedVertices = [];
      let convertedNormals = [];
      let convertedTextures = [];
      for (let i9 = 0; i9 < vertices.length; i9 += 3) {
        const x3 = vertices[i9];
        const y4 = vertices[i9 + 1];
        const z3 = vertices[i9 + 2];
        convertedVertices.push(x3, y4, z3);
      }
      for (let i9 = 0; i9 < normals.length; i9 += 3) {
        const x3 = normals[i9];
        const y4 = normals[i9 + 1];
        const z3 = normals[i9 + 2];
        convertedNormals.push(x3, y4, -z3);
      }
      for (let i9 = 0; i9 < textures.length; i9 += 2) {
        const s7 = textures[i9];
        const t9 = 1 - textures[i9 + 1];
        convertedTextures.push(s7, t9);
      }
      return {
        object: geometry.object,
        groups: geometry.groups,
        material: geometry.material,
        data: {
          vertices: convertedVertices,
          normals: convertedNormals,
          textures: convertedTextures
        }
      };
    });
    return {
      geometries: convertedGeometries,
      materialLibs: objData.materialLibs
    };
  }
  function rotateObject(obj, angle) {
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    const vertices = obj.vertices;
    const normals = obj.normals;
    for (let i9 = 0; i9 < vertices.length; i9 += 3) {
      const x3 = vertices[i9];
      const y4 = vertices[i9 + 1];
      const z3 = vertices[i9 + 2];
      vertices[i9] = x3 * cosA + z3 * sinA;
      vertices[i9 + 1] = y4;
      vertices[i9 + 2] = -x3 * sinA + z3 * cosA;
      const nx = normals[i9];
      const ny = normals[i9 + 1];
      const nz = normals[i9 + 2];
      normals[i9] = nx * cosA + nz * sinA;
      normals[i9 + 1] = ny;
      normals[i9 + 2] = -nx * sinA + nz * cosA;
    }
    return {
      vertices,
      normals
    };
  }

  // frontend/node_modules/@openglobus/og/lib/js/Object3d.js
  function getColor(color) {
    if (color instanceof Array) {
      return new Float32Array(color);
    } else if (typeof color === "string") {
      return htmlColorToFloat32Array(color);
    }
    return new Float32Array([1, 1, 1, 1]);
  }
  var Object3d = class _Object3d {
    constructor(data = {}) {
      this._name = data.name || "noname";
      this._vertices = data.vertices || [];
      this._numVertices = this._vertices.length / 3;
      this._texCoords = data.texCoords || new Array(2 * this._numVertices);
      if (data.center) {
        _Object3d.centering(this._vertices);
      }
      this._src = data.src || null;
      this.color = getColor(data.color);
      if (data.scale) {
        _Object3d.scale(this._vertices, data.scale);
      }
      if (data.indices) {
        this._indices = data.indices;
        this._normals = data.normals || [];
      } else {
        this._normals = _Object3d.getNormals(this._vertices);
        this._indices = new Array(this._vertices.length / 3);
        for (let i9 = 0, len = this._indices.length; i9 < len; i9++) {
          this._indices[i9] = i9;
        }
      }
    }
    static centering(verts) {
      let min_x = MAX, min_y = MAX, min_z = MAX, max_x = MIN, max_y = MIN, max_z = MIN;
      for (let i9 = 0, len = verts.length; i9 < len; i9 += 3) {
        let x3 = verts[i9], y4 = verts[i9 + 1], z3 = verts[i9 + 2];
        if (x3 < min_x)
          min_x = x3;
        if (y4 < min_y)
          min_y = y4;
        if (z3 < min_z)
          min_z = z3;
        if (x3 > max_x)
          max_x = x3;
        if (y4 > max_y)
          max_y = y4;
        if (z3 > max_z)
          max_z = z3;
      }
      let c_x = min_x + (max_x - min_x) * 0.5;
      let c_y = min_y + (max_y - min_y) * 0.5;
      let c_z = min_z + (max_z - min_z) * 0.5;
      for (let i9 = 0, len = verts.length; i9 < len; i9 += 3) {
        verts[i9] -= c_x;
        verts[i9 + 1] -= c_y;
        verts[i9 + 2] -= c_z;
      }
    }
    get src() {
      return this._src;
    }
    set src(src) {
      this._src = src;
    }
    get name() {
      return this._name;
    }
    get vertices() {
      return this._vertices;
    }
    get normals() {
      return this._normals;
    }
    get indices() {
      return this._indices;
    }
    get texCoords() {
      return this._texCoords;
    }
    get numVertices() {
      return this._numVertices;
    }
    static scale(vertices, s7) {
      for (let i9 = 0; i9 < vertices.length; i9++) {
        vertices[i9] *= s7;
      }
    }
    static centroid(vertices) {
      let minX = 1e3, minY = 1e3, minZ = 1e3, maxX = -1e3, maxY = -1e3, maxZ = -1e3;
      for (let i9 = 0; i9 < vertices.length; i9 += 3) {
        let x3 = vertices[i9], y4 = vertices[i9 + 1], z3 = vertices[i9 + 2];
        if (x3 < minX)
          minX = x3;
        if (y4 < minY)
          minY = y4;
        if (z3 < minZ)
          minZ = z3;
        if (x3 > maxX)
          maxX = x3;
        if (y4 > maxY)
          maxY = y4;
        if (z3 > maxZ)
          maxZ = z3;
      }
      return [minX + (maxX - minX) * 0.5, minY + (maxY - minY) * 0.5, minZ + (maxZ - minZ) * 0.5];
    }
    static translate(vertices, v4) {
      for (let i9 = 0; i9 < vertices.length; i9 += 3) {
        vertices[i9] -= v4[0];
        vertices[i9 + 1] -= v4[1];
        vertices[i9 + 2] -= v4[2];
      }
    }
    static getNormals(vertices) {
      let res = new Array(vertices.length);
      for (let i9 = 0; i9 < vertices.length; i9 += 9) {
        let t03 = i9, t13 = i9 + 3, t23 = i9 + 6, v0_x = vertices[t03], v0_y = vertices[t03 + 1], v0_z = vertices[t03 + 2], v1_x = vertices[t13], v1_y = vertices[t13 + 1], v1_z = vertices[t13 + 2], v2_x = vertices[t23], v2_y = vertices[t23 + 1], v2_z = vertices[t23 + 2], vv0_x = v1_x - v0_x, vv0_y = v1_y - v0_y, vv0_z = v1_z - v0_z, vv1_x = v2_x - v0_x, vv1_y = v2_y - v0_y, vv1_z = v2_z - v0_z, n_x = vv0_y * vv1_z - vv0_z * vv1_y, n_y = vv0_z * vv1_x - vv0_x * vv1_z, n_z = vv0_x * vv1_y - vv0_y * vv1_x;
        let l4 = Math.sqrt(n_x * n_x + n_y * n_y + n_z * n_z);
        n_x /= l4;
        n_y /= l4;
        n_z /= l4;
        res[t03] = n_x;
        res[t03 + 1] = n_y;
        res[t03 + 2] = n_z;
        res[t13] = n_x;
        res[t13 + 1] = n_y;
        res[t13 + 2] = n_z;
        res[t23] = n_x;
        res[t23 + 1] = n_y;
        res[t23 + 2] = n_z;
      }
      return res;
    }
    static createSphere(lonBands = 16, latBands = 16, radius = 1, offsetX = 0, offsetY = 0, offsetZ = 0) {
      let vertices = [], indices = [], normals = [];
      for (let latNumber = 0; latNumber <= latBands; latNumber++) {
        let theta = latNumber * Math.PI / latBands;
        let sinTheta = Math.sin(theta);
        let cosTheta = Math.cos(theta);
        for (let longNumber = 0; longNumber <= lonBands; longNumber++) {
          let phi = longNumber * 2 * Math.PI / lonBands;
          let sinPhi = Math.sin(phi);
          let cosPhi = Math.cos(phi);
          let x3 = cosPhi * sinTheta + offsetX;
          let y4 = cosTheta + offsetY;
          let z3 = sinPhi * sinTheta + offsetZ;
          normals.push(x3);
          normals.push(y4);
          normals.push(z3);
          vertices.push(radius * x3);
          vertices.push(radius * y4);
          vertices.push(radius * z3);
        }
      }
      for (let latNumber = 0; latNumber < latBands; latNumber++) {
        for (let longNumber = 0; longNumber < lonBands; longNumber++) {
          let first = latNumber * (lonBands + 1) + longNumber;
          let second = first + lonBands + 1;
          indices.push(first);
          indices.push(first + 1);
          indices.push(second);
          indices.push(second);
          indices.push(first + 1);
          indices.push(second + 1);
        }
      }
      return new _Object3d({
        "vertices": vertices,
        "normals": normals,
        "indices": indices
      });
    }
    static createDisc(radius = 1, height = 0, radialSegments = 8, isTop = true, startIndex = 0, offsetX = 0, offsetY = 0, offsetZ = 0) {
      let vertices = [], indices = [], normals = [];
      let thetaStart = 0, thetaLength = Math.PI * 2;
      let sign = isTop ? 1 : -1;
      let centerIndexStart = startIndex;
      for (let x3 = 1; x3 <= radialSegments; x3++) {
        vertices.push(offsetX, height * sign + offsetY, offsetZ);
        normals.push(0, sign, 0);
        startIndex++;
      }
      let centerIndexEnd = startIndex;
      for (let x3 = 0; x3 <= radialSegments; x3++) {
        let u4 = x3 / radialSegments;
        let theta = u4 * thetaLength + thetaStart;
        let cosTheta = Math.cos(theta);
        let sinTheta = Math.sin(theta);
        vertices.push(radius * sinTheta + offsetX, height * sign + offsetY, radius * cosTheta + offsetZ);
        normals.push(0, sign, 0);
        startIndex++;
      }
      for (let x3 = 0; x3 < radialSegments; x3++) {
        let c7 = centerIndexStart + x3, i9 = centerIndexEnd + x3;
        if (isTop) {
          indices.push(i9, i9 + 1, c7);
        } else {
          indices.push(i9 + 1, i9, c7);
        }
      }
      return new _Object3d({
        "vertices": vertices,
        "normals": normals,
        "indices": indices
      });
    }
    /**
     * Returns scale parameters for a frustum geoObject created with only Object3d.createFrustum();
     * @param length
     * @param horizontalAngle
     * @param verticalAngle
     */
    static getFrustumScaleByCameraAngles(length, horizontalAngle, verticalAngle) {
      return new Vec3(2 * length * Math.tan(RADIANS_HALF * horizontalAngle), 2 * length * Math.tan(RADIANS_HALF * verticalAngle), length);
    }
    /**
     * Returns scale parameters for a frustum geoObject created with only Object3d.createFrustum();
     * @param length
     * @param horizontalAngle
     * @param aspectRatio
     */
    static getFrustumScaleByCameraAspectRatio(length, horizontalAngle, aspectRatio) {
      let vAngle = DEGREES_DOUBLE * Math.atan(Math.tan(RADIANS_HALF * horizontalAngle) / aspectRatio);
      return _Object3d.getFrustumScaleByCameraAngles(length, horizontalAngle, vAngle);
    }
    static createFrustum(length = 1, width = 1, height = 1, xOffset = 0, yOffset = 0, zOffset = 0) {
      width *= 0.5;
      height *= 0.5;
      return new _Object3d({
        vertices: [
          //
          //inside
          //
          //top
          0 + xOffset,
          0 + yOffset,
          0 + zOffset,
          -1 * width + xOffset,
          1 * height + yOffset,
          -1 * length + zOffset,
          1 * width + xOffset,
          1 * height + yOffset,
          -1 * length + zOffset,
          //bottop
          0 + xOffset,
          0 + yOffset,
          0 + zOffset,
          1 * width + xOffset,
          -1 * height + yOffset,
          -1 * length + zOffset,
          -1 * width + xOffset,
          -1 * height + yOffset,
          -1 * length + zOffset,
          //right
          0 + xOffset,
          0 + yOffset,
          0 + zOffset,
          1 * width + xOffset,
          1 * height + yOffset,
          -1 * length + zOffset,
          1 * width + xOffset,
          -1 * height + yOffset,
          -1 * length + zOffset,
          //left
          0 + xOffset,
          0 + yOffset,
          0 + zOffset,
          -1 * width + xOffset,
          -1 * height + yOffset,
          -1 * length + zOffset,
          -1 * width + xOffset,
          1 * height + yOffset,
          -1 * length + zOffset,
          //
          // outside
          //
          //top
          0 + xOffset,
          0 + yOffset,
          0 + zOffset,
          1 * width + xOffset,
          1 * height + yOffset,
          -1 * length + zOffset,
          -1 * width + xOffset,
          1 * height + yOffset,
          -1 * length + zOffset,
          //bottop
          0 + xOffset,
          0 + yOffset,
          0 + zOffset,
          -1 * width + xOffset,
          -1 * height + yOffset,
          -1 * length + zOffset,
          1 * width + xOffset,
          -1 * height + yOffset,
          -1 * length + zOffset,
          //right
          0 + xOffset,
          0 + yOffset,
          0 + zOffset,
          1 * width + xOffset,
          -1 * height + yOffset,
          -1 * length + zOffset,
          1 * width + xOffset,
          1 * height + yOffset,
          -1 * length + zOffset,
          //left
          0 + xOffset,
          0 + yOffset,
          0 + zOffset,
          -1 * width + xOffset,
          1 * height + yOffset,
          -1 * length + zOffset,
          -1 * width + xOffset,
          -1 * height + yOffset,
          -1 * length + zOffset
        ]
      });
    }
    static createCylinder(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, isTop = true, isBottom = true, offsetX = 0, offsetY = 0, offsetZ = 0) {
      let vertices = [], indices = [], normals = [];
      let thetaStart = 0, thetaLength = Math.PI * 2;
      let index = 0;
      let indexArray = [];
      let normal = new Vec3();
      let slope = (radiusBottom - radiusTop) / height;
      for (let y4 = 0; y4 <= heightSegments; y4++) {
        let indexRow = [];
        let v4 = y4 / heightSegments;
        let radius = v4 * (radiusBottom - radiusTop) + radiusTop;
        for (let x3 = 0; x3 <= radialSegments; x3++) {
          let u4 = x3 / radialSegments;
          let theta = u4 * thetaLength + thetaStart;
          let sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
          vertices.push(radius * sinTheta + offsetX, -v4 * height + height + offsetY, radius * cosTheta + offsetZ);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x3 = 0; x3 < radialSegments; x3++) {
        for (let y4 = 0; y4 < heightSegments; y4++) {
          let a6 = indexArray[y4][x3], b4 = indexArray[y4 + 1][x3], c7 = indexArray[y4 + 1][x3 + 1], d4 = indexArray[y4][x3 + 1];
          indices.push(a6, b4, d4);
          indices.push(b4, c7, d4);
        }
      }
      if (radiusTop !== 0 && isTop) {
        let cap = _Object3d.createDisc(radiusTop, height, radialSegments, true, index, offsetX, offsetY, offsetZ);
        vertices.push(...cap.vertices);
        normals.push(...cap.normals);
        indices.push(...cap.indices);
      }
      if (radiusBottom !== 0 && isBottom) {
        let cap = _Object3d.createDisc(radiusBottom, 0, radialSegments, false, index + (isTop ? 1 + 2 * radialSegments : 0), offsetX, offsetY, offsetZ);
        vertices.push(...cap.vertices);
        normals.push(...cap.normals);
        indices.push(...cap.indices);
      }
      return new _Object3d({
        vertices,
        normals,
        indices
      });
    }
    static createCube(length = 1, height = 1, depth2 = 1, xOffset = 0, yOffset = 0, zOffset = 0) {
      let l4 = length * 0.5 + xOffset, h8 = height * 0.5 + yOffset, d4 = depth2 * 0.5 + zOffset;
      return new _Object3d({
        vertices: [
          -l4,
          -h8,
          d4,
          l4,
          -h8,
          -d4,
          l4,
          -h8,
          d4,
          -l4,
          -h8,
          d4,
          -l4,
          -h8,
          -d4,
          l4,
          -h8,
          -d4,
          //top
          -l4,
          h8,
          d4,
          l4,
          h8,
          d4,
          l4,
          h8,
          -d4,
          -l4,
          h8,
          d4,
          l4,
          h8,
          -d4,
          -l4,
          h8,
          -d4,
          //front
          -l4,
          -h8,
          d4,
          l4,
          -h8,
          d4,
          -l4,
          h8,
          d4,
          -l4,
          h8,
          d4,
          l4,
          -h8,
          d4,
          l4,
          h8,
          d4,
          //back
          -l4,
          -h8,
          -d4,
          -l4,
          h8,
          -d4,
          l4,
          -h8,
          -d4,
          -l4,
          h8,
          -d4,
          l4,
          h8,
          -d4,
          l4,
          -h8,
          -d4,
          //left
          l4,
          -h8,
          d4,
          l4,
          -h8,
          -d4,
          l4,
          h8,
          d4,
          l4,
          h8,
          d4,
          l4,
          -h8,
          -d4,
          l4,
          h8,
          -d4,
          //right
          -l4,
          -h8,
          d4,
          -l4,
          h8,
          d4,
          -l4,
          -h8,
          -d4,
          -l4,
          h8,
          d4,
          -l4,
          h8,
          -d4,
          -l4,
          -h8,
          -d4
        ]
      });
    }
    static createArrow(back = 0, height = 2.1, front = -15) {
      return new _Object3d({
        vertices: [
          0,
          height,
          0,
          7,
          0,
          6,
          0,
          0,
          front,
          0,
          0,
          back,
          7,
          0,
          6,
          0,
          height,
          0,
          -7,
          0,
          6,
          0,
          0,
          back,
          0,
          height,
          0,
          -7,
          0,
          6,
          0,
          height,
          0,
          0,
          0,
          front,
          -7,
          0,
          6,
          0,
          0,
          front,
          0,
          0,
          back,
          0,
          0,
          back,
          0,
          0,
          front,
          7,
          0,
          6
        ]
      });
    }
    static async loadObj(src) {
      const obj = await fetch(src, { mode: "cors" }).then((response) => response.text()).then((data) => transformLeftToRightCoordinateSystem(objParser(data))).catch(() => []);
      return obj.geometries.map(({ data: { vertices, normals, textures } }) => new _Object3d({
        vertices,
        normals,
        texCoords: textures
      }));
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/entity/GeoObject.js
  var GeoObject = class {
    constructor(options2) {
      this._handlerIndex = -1;
      this._tag = options2.tag || "none";
      this.instanced = true;
      this._entity = null;
      this._position = createVector3(options2.position);
      this._positionHigh = new Vec3();
      this._positionLow = new Vec3();
      Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
      this._pitch = options2.pitch || 0;
      this._yaw = options2.yaw || 0;
      this._roll = options2.roll || 0;
      this._scale = createVector3(options2.scale, new Vec3(1, 1, 1));
      this._color = createColorRGBA(options2.color);
      this._direction = new Vec3(0, 1, 0);
      this._handler = null;
      this._handlerIndex = -1;
      this._tagData = null;
      this._tagDataIndex = -1;
      let object3d = options2.object3d;
      if (!options2.object3d || options2.object3d?.vertices.length === 0) {
        object3d = new Object3d();
      }
      if (options2.objSrc) {
        this.setObjectSrc(options2.objSrc);
        this._objectSrc = options2.objSrc;
      }
      this._object3d = object3d;
      if (options2.textureSrc) {
        this.setTextureSrc(options2.textureSrc);
      }
      this._visibility = options2.visibility != void 0 ? options2.visibility : true;
      this._qNorthFrame = new Quat();
    }
    get tag() {
      return this._tag;
    }
    getPosition() {
      return this._position;
    }
    getPitch() {
      return this._pitch;
    }
    getYaw() {
      return this._yaw;
    }
    getRoll() {
      return this._roll;
    }
    getDirection() {
      return this._direction;
    }
    get object3d() {
      return this._object3d;
    }
    get vertices() {
      return this._object3d.vertices;
    }
    get normals() {
      return this._object3d.normals;
    }
    get texCoords() {
      return this._object3d.texCoords;
    }
    get indices() {
      return this._object3d.indices;
    }
    /**
     * Sets geo object opacity.
     * @public
     * @param {number} a - Billboard opacity.
     */
    setOpacity(a6) {
      this._color.w = a6;
      this.setColor(this._color.x, this._color.y, this._color.z, a6);
    }
    /**
     * Sets color.
     * @public
     * @param {number} r - Red.
     * @param {number} g - Green.
     * @param {number} b - Blue.
     * @param {number} [a] - Alpha.
     */
    setColor(r8, g4, b4, a6) {
      this._color.x = r8;
      this._color.y = g4;
      this._color.z = b4;
      a6 != void 0 && (this._color.w = a6);
      this._handler && this._handler.setRgbaArr(this._tagData, this._tagDataIndex, this._color);
    }
    /**
     * Sets color.
     * @public
     * @param {Vec3 | Vec4} color - RGBA vector.
     */
    setColor4v(color) {
      this._color.x = color.x;
      this._color.y = color.y;
      this._color.z = color.z;
      color.w != void 0 && (this._color.w = color.w);
      this._handler && this._handler.setRgbaArr(this._tagData, this._tagDataIndex, this._color);
    }
    /**
     * Sets geo object visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
      this._visibility = visibility;
      this._handler && this._handler.setVisibility(this._tagData, this._tagDataIndex, visibility);
    }
    /**
     * Returns geo object visibility.
     * @public
     * @returns {boolean}
     */
    getVisibility() {
      return this._visibility;
    }
    /**
     * Sets geo object position.
     * @public
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} z - Z coordinate.
     */
    setPosition(x3, y4, z3) {
      this._position.x = x3;
      this._position.y = y4;
      this._position.z = z3;
      Vec3.doubleToTwoFloats(this._position, this._positionHigh, this._positionLow);
      this._handler && this._handler.setPositionArr(this._tagData, this._tagDataIndex, this._positionHigh, this._positionLow);
      this.updateDirection();
    }
    /**
     * Sets geo object position.
     * @public
     * @param {Vec3} position - Cartesian coordinates.
     */
    setPosition3v(position2) {
      this._position.x = position2.x;
      this._position.y = position2.y;
      this._position.z = position2.z;
      Vec3.doubleToTwoFloats(position2, this._positionHigh, this._positionLow);
      this._handler && this._handler.setPositionArr(this._tagData, this._tagDataIndex, this._positionHigh, this._positionLow);
      this.updateDirection();
    }
    setYaw(yaw) {
      this._yaw = yaw;
      this.updateDirection();
    }
    setObject(object) {
      this._object3d = object;
    }
    setObjectSrc(src) {
      this._objectSrc = src;
      this._handler && this._handler.setObjectSrc(src, this.tag);
    }
    setTextureSrc(src) {
      this._textureSrc = src;
      this._object3d && (this._object3d.src = src);
      this._handler && this._handler.setTextureTag(src, this.tag);
    }
    setColorHTML(color) {
      this.setColor4v(htmlColorToRgba(color));
    }
    /**
     *
     * @param {number} pitch - Pitch in radians
     */
    setPitch(pitch) {
      this._pitch = pitch;
      this._handler && this._handler.setPitchRollArr(this._tagData, this._tagDataIndex, pitch, this._roll);
    }
    setRoll(roll) {
      this._roll = roll;
      this._handler && this._handler.setPitchRollArr(this._tagData, this._tagDataIndex, this._pitch, roll);
    }
    setPitchYawRoll(pitch, yaw, roll) {
      this.setPitch(pitch);
      this.setYaw(yaw);
      this.setRoll(roll);
    }
    setScale(scale2) {
      this._scale.x = this._scale.y = this._scale.z = scale2;
      this._handler && this._handler.setScaleArr(this._tagData, this._tagDataIndex, this._scale);
    }
    setScale3v(scale2) {
      this._scale.copy(scale2);
      this._handler && this._handler.setScaleArr(this._tagData, this._tagDataIndex, scale2);
    }
    getScale() {
      return this._scale;
    }
    /**
     * Removes geo object from handler.
     * @public
     */
    remove() {
      this._entity = null;
      this._handler && this._handler.remove(this);
    }
    /**
     * Sets billboard picking color.
     * @public
     * @param {Vec3} color - Picking color.
     */
    setPickingColor3v(color) {
      this._handler && this._handler.setPickingColorArr(this._tagData, this._tagDataIndex, color);
    }
    updateDirection() {
      if (this._handler && this._handler._planet) {
        this._qNorthFrame = this._handler._planet.getNorthFrameRotation(this._position);
        let qq = Quat.yRotation(this._yaw).mul(this._qNorthFrame).conjugate();
        this._direction = qq.mulVec3(new Vec3(0, 0, -1)).normalize();
        this._handler.setDirectionArr(this._tagData, this._tagDataIndex, this._direction);
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/entity/Label.js
  var ALIGN = {
    RIGHT: 0,
    LEFT: 1,
    CENTER: 2
  };
  var STR2ALIGN = {
    left: ALIGN.LEFT,
    right: ALIGN.RIGHT,
    center: ALIGN.CENTER
  };
  var Label = class extends BaseBillboard {
    constructor(options2 = {}) {
      super(options2);
      this._handler = null;
      this._text = options2.text || "";
      this._face = defaultString(options2.face, "arial");
      this._size = options2.size || 24;
      this._outline = options2.outline != void 0 ? options2.outline : 0;
      this._outlineColor = createColorRGBA(options2.outlineColor, new Vec4(0, 0, 0, 1));
      this._align = options2.align ? STR2ALIGN[options2.align.trim().toLowerCase()] || ALIGN.RIGHT : ALIGN.RIGHT;
      this._fontIndex = 0;
      this._fontAtlas = null;
      this._isRTL = options2.isRTL || false;
    }
    /**
     * Set label text.
     * @public
     * @param {string} text - Text string.
     * It can't be bigger than maximum labelHandler _maxLetters value.
     */
    setText(text) {
      this._text = text.toString();
      if (this._isReady && this._handler) {
        this._handler.setText(this._handlerIndex, text, this._fontIndex, this._align, this._isRTL);
      }
    }
    /**
     * Change text direction.
     * @public
     * @param {boolean} isRTL - Text string.
     */
    setRtl(isRTL) {
      this._isRTL = isRTL;
      if (this._isReady && this._handler) {
        this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, this._isRTL);
      }
    }
    /**
     * Gets current text string.
     * @public
     * @returns {string}
     */
    getText() {
      return this._text;
    }
    /**
     * Sets label text align. Could be center, left or right. Left is default.
     * @public
     * @param {string} align - Text align.
     */
    setAlign(align) {
      this._align = STR2ALIGN[align.trim().toLowerCase()];
      if (this._isReady && this._handler) {
        this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, this._isRTL);
      } else if (this._lockId !== LOCK_FREE) {
        this._lockId = LOCK_UPDATE;
      }
    }
    /**
     * Gets label text current alignment.
     * @public
     * @returns {string}
     */
    getAlign() {
      return this._align;
    }
    /**
     * Sets font face family.
     * @public
     * @param {string} face - Font face family.
     */
    setFace(face) {
      this._face = face.trim();
      this.update();
    }
    /**
     * Gets current font face.
     * @public
     * @returns {string}
     */
    getFace() {
      return this._face;
    }
    /**
     * Sets label font size in pixels.
     * @public
     * @param {number} size - Label size in pixels.
     */
    setSize(size) {
      if (size !== this._size) {
        this._size = size;
        if (this._isReady && this._handler) {
          this._handler.setSizeArr(this._handlerIndex, size);
        } else if (this._lockId !== LOCK_FREE) {
          this._lockId = LOCK_UPDATE;
        }
      }
    }
    /**
     * Gets label size in pixels.
     * @public
     * @returns {number}
     */
    getSize() {
      return this._size;
    }
    /**
     * Sets text outline border size. Where 0 - is no outline, and 1 - is the maximum outline size.
     * @public
     * @param {number} outline - Text outline size.
     */
    setOutline(outline) {
      this._outline = outline;
      if (this._isReady && this._handler) {
        this._handler.setOutlineArr(this._handlerIndex, outline);
      } else if (this._lockId !== LOCK_FREE) {
        this._lockId = LOCK_UPDATE;
      }
    }
    /**
     * Gets text current outline size.
     * @public
     * @returns {number}
     */
    getOutline() {
      return this._outline;
    }
    /**
     * Sets label opacity.
     * @public
     * @param {number} a - Label opacity.
     */
    setOpacity(a6) {
      super.setOpacity(a6);
      this.setOutlineOpacity(a6);
    }
    /**
     * Sets text outline color.
     * @public
     * @param {number} r - Red.
     * @param {number} g - Green.
     * @param {number} b - Blue.
     * @param {number} a - Alpha.
     */
    setOutlineColor(r8, g4, b4, a6) {
      if (a6 !== this._outlineColor.w || r8 !== this._outlineColor.x || g4 !== this._outlineColor.y || b4 !== this._outlineColor.z) {
        this._outlineColor.x = r8;
        this._outlineColor.y = g4;
        this._outlineColor.z = b4;
        this._outlineColor.w = a6;
        if (this._isReady && this._handler) {
          this._handler.setOutlineColorArr(this._handlerIndex, this._outlineColor);
        } else if (this._lockId !== LOCK_FREE) {
          this._lockId = LOCK_UPDATE;
        }
      }
    }
    /**
     * Sets text outline color.
     * @public
     * @param {Vec4} rgba - Color vector.
     */
    setOutlineColor4v(rgba) {
      this.setOutlineColor(rgba.x, rgba.y, rgba.z, rgba.w);
    }
    /**
     * Sets text outline color HTML string.
     * @public
     * @param {string} color - HTML string color.
     */
    setOutlineColorHTML(color) {
      this.setOutlineColor4v(htmlColorToRgba(color));
    }
    /**
     * Gets outline color vector.
     * @public
     * @returns {Vec4}
     */
    getOutlineColor() {
      return this._outlineColor;
    }
    /**
     * Sets outline opacity. Actually outline color alpha value.
     * @public
     * @param {number} opacity - Outline opacity.
     */
    setOutlineOpacity(opacity) {
      if (opacity !== this._outlineColor.w) {
        this._outlineColor.w = opacity;
        if (this._isReady && this._handler) {
          this._handler.setOutlineColorArr(this._handlerIndex, this._outlineColor);
        } else if (this._lockId !== LOCK_FREE) {
          this._lockId = LOCK_UPDATE;
        }
      }
    }
    /**
     * Gets outline opacity value.
     * @public
     * @returns {number}
     */
    getOutlineOpacity() {
      return this._outlineColor.w;
    }
    /**
     * Updates label parameters.
     * @public
     */
    async update() {
      if (this._fontAtlas) {
        const fontIndex = await this._fontAtlas.getFontIndex(this._face);
        this._applyFontIndex(fontIndex);
      }
    }
    _applyFontIndex(fontIndex) {
      this._fontIndex = fontIndex;
      if (this._isReady && this._handler) {
        this._handler.setFontIndexArr(this._handlerIndex, this._fontIndex);
        this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align, this._isRTL);
      } else if (this._lockId !== LOCK_FREE) {
        this._lockId = LOCK_UPDATE;
      }
    }
    /**
     * Assigns font atlas and update.
     * @public
     * @param {FontAtlas} fontAtlas - Font atlas.
     */
    assignFontAtlas(fontAtlas) {
      if (!this._fontAtlas) {
        this._fontAtlas = fontAtlas;
      }
      this.update();
    }
    serializeWorkerData(workerId) {
      if (this._handler) {
        return new Float32Array([
          /*0*/
          workerId,
          /*1*/
          this._handler._maxLetters,
          /*2*/
          this.getVisibility() ? 1 : 0,
          /*3, 4, 5*/
          this._positionHigh.x,
          this._positionHigh.y,
          this._positionHigh.z,
          /*6, 7, 8*/
          this._positionLow.x,
          this._positionLow.y,
          this._positionLow.z,
          /*9*/
          this._size,
          /*10, 11, 12*/
          this._offset.x,
          this._offset.y,
          this._offset.z,
          /*13, 14, 15, 16*/
          this._color.x,
          this._color.y,
          this._color.z,
          this._color.w,
          /*17*/
          this._rotation,
          /*18, 19, 20*/
          this._alignedAxis.x,
          this._alignedAxis.y,
          this._alignedAxis.z,
          /*21*/
          this._fontIndex,
          /*22*/
          this._outline,
          /*23, 24, 25, 26*/
          this._outlineColor.x,
          this._outlineColor.y,
          this._outlineColor.z,
          this._outlineColor.w,
          /*27, 28, 29*/
          this._entity._pickingColor.x,
          this._entity._pickingColor.y,
          this._entity._pickingColor.z
        ]);
      }
      return null;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/entity/PointCloud.js
  var COORDINATES_BUFFER = 0;
  var COLOR_BUFFER = 1;
  var PICKING_COLOR_BUFFER = 2;
  var PointCloud = class _PointCloud {
    constructor(options2 = {}) {
      this.__id = _PointCloud.__counter__++;
      this.visibility = options2.visibility != void 0 ? options2.visibility : true;
      this.pointSize = options2.pointSize || 3;
      this.pickingScale = options2.pickingScale || 0;
      this._renderNode = null;
      this._entity = null;
      this._points = [];
      this._coordinatesData = [];
      this._colorData = [];
      this._pickingColorData = [];
      this._coordinatesBuffer = null;
      this._colorBuffer = null;
      this._pickingColorBuffer = null;
      this._handler = null;
      this._handlerIndex = -1;
      this._buffersUpdateCallbacks = [];
      this._buffersUpdateCallbacks[COORDINATES_BUFFER] = this._createCoordinatesBuffer;
      this._buffersUpdateCallbacks[COLOR_BUFFER] = this._createColorBuffer;
      this._buffersUpdateCallbacks[PICKING_COLOR_BUFFER] = this._createPickingColorBuffer;
      this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
      if (options2.points) {
        this.setPoints(options2.points);
      }
    }
    /**
     * Clears point cloud data
     * @public
     */
    clear() {
      this._points.length = 0;
      this._points = [];
      this._coordinatesData.length = 0;
      this._coordinatesData = [];
      this._colorData.length = 0;
      this._colorData = [];
      this._pickingColorData.length = 0;
      this._pickingColorData = [];
      this._deleteBuffers();
    }
    /**
     * Sets cloud visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
      this.visibility = visibility;
    }
    /**
     * @return {boolean} Point cloud visibility.
     */
    getVisibility() {
      return this.visibility;
    }
    /**
     * Assign rendering scene node.
     * @public
     * @param {RenderNode}  renderNode - Assigned render node.
     */
    setRenderNode(renderNode) {
      this._renderNode = renderNode;
      this._setPickingColors();
    }
    /**
     * Removes from entity.
     * @public
     */
    remove() {
      this._entity = null;
      this._handler && this._handler.remove(this);
    }
    /**
     * Adds points to render.
     * @public
     * @param { Poi[]} points - Point cloud array.
     * @example
     * var points = [[0, 0, 0, 255, 255, 255, 255, { 'name': 'White point' }], [100, 100, 0, 255, 0, 0, 255, { 'name': 'Red point' }]];
     */
    setPoints(points) {
      this.clear();
      for (let i9 = 0; i9 < points.length; i9++) {
        let pi = points[i9];
        let pos = new Vec3(pi[0], pi[1], pi[2]), col = new Vec4(pi[3], pi[4], pi[5], pi[6] == void 0 ? 255 : pi[6]);
        this._coordinatesData.push(pos.x, pos.y, pos.z);
        this._colorData.push(col.x / 255, col.y / 255, col.z / 255, col.w / 255);
        let p4 = {
          _entity: this._entity,
          _pickingColor: new Vec3(),
          _entityCollection: this._entity ? this._entity._entityCollection : null,
          index: i9,
          position: pos,
          color: col,
          pointCloud: this,
          properties: pi[7] || {}
        };
        this._points.push(p4);
        if (this._renderNode && this._renderNode.renderer) {
          this._renderNode.renderer.assignPickingColor(p4);
          this._pickingColorData.push(p4._pickingColor.x / 255, p4._pickingColor.y / 255, p4._pickingColor.z / 255, 1);
        }
      }
      this._changedBuffers[COORDINATES_BUFFER] = true;
      this._changedBuffers[COLOR_BUFFER] = true;
      this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }
    setPointPosition(index, x3, y4, z3) {
      this._changedBuffers[COORDINATES_BUFFER] = true;
    }
    setPointColor(index, r8, g4, b4, a6) {
      this._changedBuffers[COLOR_BUFFER] = true;
    }
    addPoints(points) {
      this._changedBuffers[COORDINATES_BUFFER] = true;
      this._changedBuffers[COLOR_BUFFER] = true;
      this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }
    addPoint(index, point) {
      this._changedBuffers[COORDINATES_BUFFER] = true;
      this._changedBuffers[COLOR_BUFFER] = true;
      this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }
    /**
     * Returns specific point by index.
     * @public
     * @param {number} index - Point index.
     * @return {Poi} Specific point
     */
    getPoint(index) {
      return this._points[index];
    }
    removePoint(index) {
      this._changedBuffers[COORDINATES_BUFFER] = true;
      this._changedBuffers[COLOR_BUFFER] = true;
      this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }
    insertPoint(index, point) {
      this._changedBuffers[COORDINATES_BUFFER] = true;
      this._changedBuffers[COLOR_BUFFER] = true;
      this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }
    draw() {
      if (this.visibility && this._coordinatesData.length) {
        this._update();
        let rn = this._renderNode;
        let r8 = rn.renderer;
        let sh = r8.handler.programs.pointCloud;
        let p4 = sh._program;
        let gl = r8.handler.gl, sha = p4.attributes, shu = p4.uniforms;
        sh.activate();
        gl.uniformMatrix4fv(shu.projectionViewMatrix, false, r8.activeCamera.getProjectionViewMatrix());
        gl.uniform1f(shu.opacity, this._handler._entityCollection._fadingOpacity);
        gl.uniform1f(shu.pointSize, this.pointSize);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._coordinatesBuffer);
        gl.vertexAttribPointer(sha.coordinates, this._coordinatesBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer);
        gl.vertexAttribPointer(sha.colors, this._colorBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.POINTS, 0, this._coordinatesBuffer.numItems);
      }
    }
    drawPicking() {
      if (this.visibility && this._coordinatesData.length) {
        let rn = this._renderNode;
        let r8 = rn.renderer;
        let sh = r8.handler.programs.pointCloud;
        let p4 = sh._program;
        let gl = r8.handler.gl, sha = p4.attributes, shu = p4.uniforms;
        sh.activate();
        gl.uniformMatrix4fv(shu.projectionViewMatrix, false, r8.activeCamera.getProjectionViewMatrix());
        gl.uniform1f(shu.opacity, this._handler._entityCollection._fadingOpacity);
        gl.uniform1f(shu.pointSize, this.pointSize + this.pickingScale);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._coordinatesBuffer);
        gl.vertexAttribPointer(sha.coordinates, this._coordinatesBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
        gl.vertexAttribPointer(sha.colors, this._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.POINTS, 0, this._coordinatesBuffer.numItems);
      }
    }
    /**
     * Update gl buffers.
     * @protected
     */
    _update() {
      if (this._renderNode) {
        let i9 = this._changedBuffers.length;
        while (i9--) {
          if (this._changedBuffers[i9]) {
            this._buffersUpdateCallbacks[i9].call(this);
            this._changedBuffers[i9] = false;
          }
        }
      }
    }
    /**
     * Delete buffers
     * @public
     */
    _deleteBuffers() {
      if (this._renderNode) {
        let r8 = this._renderNode.renderer, gl = r8.handler.gl;
        gl.deleteBuffer(this._coordinatesBuffer);
        gl.deleteBuffer(this._colorBuffer);
        gl.deleteBuffer(this._pickingColorBuffer);
      }
      this._coordinatesBuffer = null;
      this._colorBuffer = null;
      this._pickingColorBuffer = null;
    }
    _createCoordinatesBuffer() {
      let h8 = this._renderNode.renderer.handler;
      h8.gl.deleteBuffer(this._coordinatesBuffer);
      this._coordinatesBuffer = h8.createArrayBuffer(new Float32Array(this._coordinatesData), 3, this._coordinatesData.length / 3);
    }
    _createColorBuffer() {
      let h8 = this._renderNode.renderer.handler;
      h8.gl.deleteBuffer(this._colorBuffer);
      this._colorBuffer = h8.createArrayBuffer(new Float32Array(this._colorData), 4, this._colorData.length / 4);
    }
    _createPickingColorBuffer() {
      let h8 = this._renderNode.renderer.handler;
      h8.gl.deleteBuffer(this._pickingColorBuffer);
      this._pickingColorBuffer = h8.createArrayBuffer(new Float32Array(this._pickingColorData), 4, this._pickingColorData.length / 4);
    }
    _setPickingColors() {
      if (this._renderNode && this._renderNode.renderer) {
        for (let i9 = 0; i9 < this._points.length; i9++) {
          let p4 = this._points[i9];
          p4._entity = this._entity;
          p4._entityCollection = this._entity._entityCollection;
          this._renderNode.renderer.assignPickingColor(p4);
          this._pickingColorData.push(p4._pickingColor.x / 255, p4._pickingColor.y / 255, p4._pickingColor.z / 255, 1);
        }
        this._changedBuffers[PICKING_COLOR_BUFFER] = true;
      }
    }
  };
  PointCloud.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/entity/Polyline.js
  var VERTICES_BUFFER = 0;
  var INDEX_BUFFER = 1;
  var COLORS_BUFFER = 2;
  var DEFAULT_COLOR = "#0000FF";
  var R = 0;
  var G = 1;
  var B = 2;
  var A = 3;
  var Polyline = class _Polyline {
    constructor(options2 = {}) {
      this.__id = _Polyline.__counter__++;
      this.altitude = options2.altitude || 0;
      this.thickness = options2.thickness || 1.5;
      this._opacity = options2.opacity != void 0 ? options2.opacity : 1;
      this._defaultColor = htmlColorToFloat32Array(options2.color || DEFAULT_COLOR, options2.opacity);
      this.visibility = options2.visibility != void 0 ? options2.visibility : true;
      this._closedLine = options2.isClosed || false;
      this._path3v = [];
      this._pathLengths = [];
      this._pathLonLat = [];
      this._pathLonLatMerc = [];
      this._pathColors = options2.pathColors ? cloneArray(options2.pathColors) : [];
      this._extent = new Extent();
      this._verticesHigh = [];
      this._verticesLow = [];
      this._orders = [];
      this._indexes = [];
      this._colors = [];
      this._verticesHighBuffer = null;
      this._verticesLowBuffer = null;
      this._ordersBuffer = null;
      this._indexesBuffer = null;
      this._colorsBuffer = null;
      this._pickingColor = [0, 0, 0];
      this._renderNode = null;
      this._entity = null;
      this._handler = null;
      this._handlerIndex = -1;
      this._buffersUpdateCallbacks = [];
      this._buffersUpdateCallbacks[VERTICES_BUFFER] = this._createVerticesBuffer;
      this._buffersUpdateCallbacks[INDEX_BUFFER] = this._createIndexBuffer;
      this._buffersUpdateCallbacks[COLORS_BUFFER] = this._createColorsBuffer;
      this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
      if (options2.pathLonLat) {
        this.setPathLonLat(options2.pathLonLat);
      } else if (options2.path3v) {
        this.setPath3v(options2.path3v);
      }
      this._refresh();
    }
    /**
     * Appends to the line array new cartesian coordinates line data.
     * @static
     */
    static appendLineData3v(path3v, pathColors, defaultColor, isClosed, outVerticesHigh, outVerticesLow, outOrders, outIndexes, ellipsoid, outTransformedPathLonLat, outPath3v, outTransformedPathMerc, outExtent, outColors) {
      var index = 0;
      var v_high = new Vec3(), v_low = new Vec3();
      if (outExtent) {
        outExtent.southWest.set(180, 90);
        outExtent.northEast.set(-180, -90);
      }
      if (outIndexes.length > 0) {
        index = outIndexes[outIndexes.length - 5] + 9;
        outIndexes.push(index, index);
      } else {
        outIndexes.push(0, 0);
      }
      for (let j2 = 0, len = path3v.length; j2 < len; j2++) {
        var path = path3v[j2], pathColors_j = pathColors[j2];
        outTransformedPathLonLat[j2] = [];
        outTransformedPathMerc[j2] = [];
        outPath3v[j2] = [];
        if (path.length === 0) {
          continue;
        }
        var startIndex = index;
        var last;
        if (isClosed) {
          last = path[path.length - 1];
          if (last instanceof Array) {
            last = new Vec3(last[0], last[1], last[2]);
          }
        } else {
          var p0 = path[0], p1 = path[1] || p0;
          if (p0 instanceof Array) {
            p0 = new Vec3(p0[0], p0[1], p0[2]);
          }
          if (p1 instanceof Array) {
            p1 = new Vec3(p1[0], p1[1], p1[2]);
          }
          p0 = p0;
          p1 = p1;
          last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
        }
        let color = defaultColor;
        if (pathColors_j && pathColors_j[0]) {
          color = pathColors_j[0];
        }
        Vec3.doubleToTwoFloats(last, v_high, v_low);
        outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
        outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
        let r8 = color[R], g4 = color[G], b4 = color[B], a6 = color[A] != void 0 ? color[A] : 1;
        if (j2 > 0) {
          outColors.push(r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6);
        }
        outOrders.push(1, -1, 2, -2);
        for (let i9 = 0, len2 = path.length; i9 < len2; i9++) {
          var cur = path[i9];
          if (cur instanceof Array) {
            cur = new Vec3(cur[0], cur[1], cur[2]);
          }
          outPath3v[j2].push(cur);
          if (ellipsoid) {
            var lonLat = ellipsoid.cartesianToLonLat(cur);
            outTransformedPathLonLat[j2].push(lonLat);
            outTransformedPathMerc[j2].push(lonLat.forwardMercator());
            if (lonLat.lon < outExtent.southWest.lon) {
              outExtent.southWest.lon = lonLat.lon;
            }
            if (lonLat.lat < outExtent.southWest.lat) {
              outExtent.southWest.lat = lonLat.lat;
            }
            if (lonLat.lon > outExtent.northEast.lon) {
              outExtent.northEast.lon = lonLat.lon;
            }
            if (lonLat.lat > outExtent.northEast.lat) {
              outExtent.northEast.lat = lonLat.lat;
            }
          }
          if (pathColors_j && pathColors_j[i9]) {
            color = pathColors_j[i9];
          }
          r8 = color[R];
          g4 = color[G];
          b4 = color[B];
          a6 = color[A] != void 0 ? color[A] : 1;
          Vec3.doubleToTwoFloats(cur, v_high, v_low);
          outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
          outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
          outColors.push(r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6);
          outOrders.push(1, -1, 2, -2);
          outIndexes.push(index++, index++, index++, index++);
        }
        var first;
        if (isClosed) {
          first = path[0];
          if (first instanceof Array) {
            first = new Vec3(first[0], first[1], first[2]);
          }
          outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
        } else {
          let p02 = path[path.length - 1], p12 = path[path.length - 2] || p02;
          if (p02 instanceof Array) {
            p02 = new Vec3(p02[0], p02[1], p02[2]);
          } else {
            p02 = p02;
          }
          if (p12 instanceof Array) {
            p12 = new Vec3(p12[0], p12[1], p12[2]);
          } else {
            p12 = p12;
          }
          first = new Vec3(p02.x + p02.x - p12.x, p02.y + p02.y - p12.y, p02.z + p02.z - p12.z);
          outIndexes.push(index - 1, index - 1, index - 1, index - 1);
        }
        if (pathColors_j && pathColors_j[path.length - 1]) {
          color = pathColors_j[path.length - 1];
        }
        r8 = color[R];
        g4 = color[G];
        b4 = color[B];
        a6 = color[A] != void 0 ? color[A] : 1;
        Vec3.doubleToTwoFloats(first, v_high, v_low);
        outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
        outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
        outColors.push(r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6);
        outOrders.push(1, -1, 2, -2);
        if (j2 < path3v.length - 1 && path3v[j2 + 1].length !== 0) {
          index += 8;
          outIndexes.push(index, index);
        }
      }
    }
    /**
     * Appends to the line new cartesian coordinates point data.
     * @static
     */
    static appendPoint3v(path3v, point3v, pathColors, color, isClosed, outVerticesHigh, outVerticesLow, outColors, outOrders, outIndexes, ellipsoid, outTransformedPathLonLat, outTransformedPathMerc, outExtent) {
      var v_high = new Vec3(), v_low = new Vec3();
      var ii = outIndexes.length - 4, index = outIndexes[ii - 1] + 1;
      if (path3v.length === 0) {
        path3v.push([]);
        if (!pathColors[0]) {
          pathColors[0] = [];
        }
      } else if (!pathColors[path3v.length - 1]) {
        pathColors[path3v.length - 1] = [];
      }
      var path = path3v[path3v.length - 1], len = path.length;
      path.push(point3v);
      let r8 = color[R], g4 = color[G], b4 = color[B], a6 = color[A] != void 0 ? color[A] : 1, pathColors_last = pathColors[path3v.length - 1];
      if (pathColors_last[len]) {
        pathColors_last[len][R] = r8;
        pathColors_last[len][G] = g4;
        pathColors_last[len][B] = b4;
        pathColors_last[len][A] = a6;
      } else {
        pathColors_last.push(color);
      }
      if (len === 1) {
        var last;
        if (isClosed) {
          last = path[len - 1];
          if (last instanceof Array) {
            last = new Vec3(last[0], last[1], last[2]);
          }
        } else {
          let p0 = path[0], p1 = path[1] || p0;
          if (p0 instanceof Array) {
            p0 = new Vec3(p0[0], p0[1], p0[2]);
          } else {
            p0 = p0;
          }
          if (p1 instanceof Array) {
            p1 = new Vec3(p1[0], p1[1], p1[2]);
          } else {
            p1 = p1;
          }
          last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
        }
        Vec3.doubleToTwoFloats(last, v_high, v_low);
        let vi2 = outVerticesHigh.length - 3 * 12;
        outVerticesHigh[vi2] = v_high.x;
        outVerticesHigh[vi2 + 1] = v_high.y;
        outVerticesHigh[vi2 + 2] = v_high.z;
        outVerticesHigh[vi2 + 3] = v_high.x;
        outVerticesHigh[vi2 + 4] = v_high.y;
        outVerticesHigh[vi2 + 5] = v_high.z;
        outVerticesHigh[vi2 + 6] = v_high.x;
        outVerticesHigh[vi2 + 7] = v_high.y;
        outVerticesHigh[vi2 + 8] = v_high.z;
        outVerticesHigh[vi2 + 9] = v_high.x;
        outVerticesHigh[vi2 + 10] = v_high.y;
        outVerticesHigh[vi2 + 11] = v_high.z;
        outVerticesLow[vi2] = v_low.x;
        outVerticesLow[vi2 + 1] = v_low.y;
        outVerticesLow[vi2 + 2] = v_low.z;
        outVerticesLow[vi2 + 3] = v_low.x;
        outVerticesLow[vi2 + 4] = v_low.y;
        outVerticesLow[vi2 + 5] = v_low.z;
        outVerticesLow[vi2 + 6] = v_low.x;
        outVerticesLow[vi2 + 7] = v_low.y;
        outVerticesLow[vi2 + 8] = v_low.z;
        outVerticesLow[vi2 + 9] = v_low.x;
        outVerticesLow[vi2 + 10] = v_low.y;
        outVerticesLow[vi2 + 11] = v_low.z;
      }
      var startIndex = index;
      if (ellipsoid) {
        if (outTransformedPathLonLat.length === 0) {
          outTransformedPathLonLat.push([]);
        }
        if (outTransformedPathMerc.length === 0) {
          outTransformedPathMerc.push([]);
        }
        var transformedPathLonLat = outTransformedPathLonLat[outTransformedPathLonLat.length - 1], transformedPathMerc = outTransformedPathMerc[outTransformedPathMerc.length - 1];
        let lonLat = ellipsoid.cartesianToLonLat(point3v);
        transformedPathLonLat.push(lonLat);
        transformedPathMerc.push(lonLat.forwardMercator());
        if (lonLat.lon < outExtent.southWest.lon) {
          outExtent.southWest.lon = lonLat.lon;
        }
        if (lonLat.lat < outExtent.southWest.lat) {
          outExtent.southWest.lat = lonLat.lat;
        }
        if (lonLat.lon > outExtent.northEast.lon) {
          outExtent.northEast.lon = lonLat.lon;
        }
        if (lonLat.lat > outExtent.northEast.lat) {
          outExtent.northEast.lat = lonLat.lat;
        }
      }
      Vec3.doubleToTwoFloats(point3v, v_high, v_low);
      let vi = outVerticesHigh.length - 12;
      outVerticesHigh[vi] = v_high.x;
      outVerticesHigh[vi + 1] = v_high.y;
      outVerticesHigh[vi + 2] = v_high.z;
      outVerticesHigh[vi + 3] = v_high.x;
      outVerticesHigh[vi + 4] = v_high.y;
      outVerticesHigh[vi + 5] = v_high.z;
      outVerticesHigh[vi + 6] = v_high.x;
      outVerticesHigh[vi + 7] = v_high.y;
      outVerticesHigh[vi + 8] = v_high.z;
      outVerticesHigh[vi + 9] = v_high.x;
      outVerticesHigh[vi + 10] = v_high.y;
      outVerticesHigh[vi + 11] = v_high.z;
      outVerticesLow[vi] = v_low.x;
      outVerticesLow[vi + 1] = v_low.y;
      outVerticesLow[vi + 2] = v_low.z;
      outVerticesLow[vi + 3] = v_low.x;
      outVerticesLow[vi + 4] = v_low.y;
      outVerticesLow[vi + 5] = v_low.z;
      outVerticesLow[vi + 6] = v_low.x;
      outVerticesLow[vi + 7] = v_low.y;
      outVerticesLow[vi + 8] = v_low.z;
      outVerticesLow[vi + 9] = v_low.x;
      outVerticesLow[vi + 10] = v_low.y;
      outVerticesLow[vi + 11] = v_low.z;
      let ci = outColors.length - 16;
      outColors[ci] = r8;
      outColors[ci + 1] = g4;
      outColors[ci + 2] = b4;
      outColors[ci + 3] = a6;
      outColors[ci + 4] = r8;
      outColors[ci + 5] = g4;
      outColors[ci + 6] = b4;
      outColors[ci + 7] = a6;
      outColors[ci + 8] = r8;
      outColors[ci + 9] = g4;
      outColors[ci + 10] = b4;
      outColors[ci + 11] = a6;
      outColors[ci + 12] = r8;
      outColors[ci + 13] = g4;
      outColors[ci + 14] = b4;
      outColors[ci + 15] = a6;
      outIndexes[ii] = index++;
      outIndexes[ii + 1] = index++;
      outIndexes[ii + 2] = index++;
      outIndexes[ii + 3] = index++;
      var first;
      if (isClosed) {
        first = path[0];
        outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
      } else {
        let p0 = path[path.length - 1], p1 = path[path.length - 2] || p0;
        first = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
        outIndexes.push(index - 1, index - 1, index - 1, index - 1);
      }
      Vec3.doubleToTwoFloats(first, v_high, v_low);
      outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
      outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
      outColors.push(r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6);
      outOrders.push(1, -1, 2, -2);
    }
    static setPathColors(pathLonLat, pathColors, defaultColor, outColors) {
      for (let j2 = 0, len = pathLonLat.length; j2 < len; j2++) {
        var path = pathLonLat[j2], pathColors_j = pathColors[j2];
        if (path.length === 0) {
          continue;
        }
        let color = defaultColor;
        if (pathColors_j && pathColors_j[0]) {
          color = pathColors_j[0];
        }
        let r8 = color[R], g4 = color[G], b4 = color[B], a6 = color[A] != void 0 ? color[A] : 1;
        if (j2 > 0) {
          outColors.push(r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6);
        }
        for (let i9 = 0, len2 = path.length; i9 < len2; i9++) {
          var cur = path[i9];
          if (cur instanceof Array) {
            cur = new LonLat(cur[0], cur[1], cur[2]);
          }
          if (pathColors_j && pathColors_j[i9]) {
            color = pathColors_j[i9];
          }
          r8 = color[R];
          g4 = color[G];
          b4 = color[B];
          a6 = color[A] != void 0 ? color[A] : 1;
          outColors.push(r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6);
        }
        if (pathColors_j && pathColors_j[path.length - 1]) {
          color = pathColors_j[path.length - 1];
        }
        r8 = color[R];
        g4 = color[G];
        b4 = color[B];
        a6 = color[A] != void 0 ? color[A] : 1;
        outColors.push(r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6);
      }
    }
    /**
     * Appends to the line array new geodetic coordinates line data.
     * @static
     */
    static appendLineDataLonLat(pathLonLat, pathColors, defaultColor, isClosed, outVerticesHigh, outVerticesLow, outOrders, outIndexes, ellipsoid, outTransformedPathCartesian, outPathLonLat, outTransformedPathMerc, outExtent, outColors) {
      var index = 0;
      var v_high = new Vec3(), v_low = new Vec3();
      if (outExtent) {
        outExtent.southWest.set(180, 90);
        outExtent.northEast.set(-180, -90);
      }
      if (outIndexes.length > 0) {
        index = outIndexes[outIndexes.length - 5] + 9;
        outIndexes.push(index);
      } else {
        outIndexes.push(0);
      }
      for (let j2 = 0, len = pathLonLat.length; j2 < len; j2++) {
        var path = pathLonLat[j2], pathColors_j = pathColors[j2];
        outTransformedPathCartesian[j2] = [];
        outTransformedPathMerc[j2] = [];
        outPathLonLat[j2] = [];
        if (path.length === 0) {
          continue;
        }
        var startIndex = index;
        var last;
        if (isClosed) {
          let pp = path[path.length - 1];
          if (pp instanceof Array) {
            last = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
          } else {
            last = ellipsoid.lonLatToCartesian(pp);
          }
        } else {
          let p0, p1;
          let pp = path[0];
          if (pp instanceof Array) {
            p0 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
          } else {
            p0 = ellipsoid.lonLatToCartesian(pp);
          }
          pp = path[1];
          if (!pp) {
            pp = path[0];
          }
          if (pp instanceof Array) {
            p1 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
          } else {
            p1 = ellipsoid.lonLatToCartesian(pp);
          }
          last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
        }
        let color = defaultColor;
        if (pathColors_j && pathColors_j[0]) {
          color = pathColors_j[0];
        }
        Vec3.doubleToTwoFloats(last, v_high, v_low);
        outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
        outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
        let r8 = color[R], g4 = color[G], b4 = color[B], a6 = color[A] != void 0 ? color[A] : 1;
        if (j2 > 0) {
          outColors.push(r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6);
        }
        outOrders.push(1, -1, 2, -2);
        for (let i9 = 0, len2 = path.length; i9 < len2; i9++) {
          var cur = path[i9];
          if (cur instanceof Array) {
            cur = new LonLat(cur[0], cur[1], cur[2]);
          }
          if (pathColors_j && pathColors_j[i9]) {
            color = pathColors_j[i9];
          }
          r8 = color[R];
          g4 = color[G];
          b4 = color[B];
          a6 = color[A] != void 0 ? color[A] : 1;
          var cartesian = ellipsoid.lonLatToCartesian(cur);
          outTransformedPathCartesian[j2].push(cartesian);
          outPathLonLat[j2].push(cur);
          outTransformedPathMerc[j2].push(cur.forwardMercator());
          Vec3.doubleToTwoFloats(cartesian, v_high, v_low);
          outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
          outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
          outColors.push(r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6);
          outOrders.push(1, -1, 2, -2);
          outIndexes.push(index++, index++, index++, index++);
          if (cur.lon < outExtent.southWest.lon) {
            outExtent.southWest.lon = cur.lon;
          }
          if (cur.lat < outExtent.southWest.lat) {
            outExtent.southWest.lat = cur.lat;
          }
          if (cur.lon > outExtent.northEast.lon) {
            outExtent.northEast.lon = cur.lon;
          }
          if (cur.lat > outExtent.northEast.lat) {
            outExtent.northEast.lat = cur.lat;
          }
        }
        var first;
        if (isClosed) {
          let pp = path[0];
          if (pp instanceof Array) {
            first = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
          } else {
            first = ellipsoid.lonLatToCartesian(pp);
          }
          outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
        } else {
          let p0, p1;
          let pp = path[path.length - 1];
          if (pp instanceof Array) {
            p0 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
          } else {
            p0 = ellipsoid.lonLatToCartesian(pp);
          }
          pp = path[path.length - 2];
          if (!pp) {
            pp = path[0];
          }
          if (pp instanceof Array) {
            p1 = ellipsoid.lonLatToCartesian(new LonLat(pp[0], pp[1], pp[2]));
          } else {
            p1 = ellipsoid.lonLatToCartesian(pp);
          }
          first = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
          outIndexes.push(index - 1, index - 1, index - 1, index - 1);
        }
        if (pathColors_j && pathColors_j[path.length - 1]) {
          color = pathColors_j[path.length - 1];
        }
        r8 = color[R];
        g4 = color[G];
        b4 = color[B];
        a6 = color[A] != void 0 ? color[A] : 1;
        Vec3.doubleToTwoFloats(first, v_high, v_low);
        outVerticesHigh.push(v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z, v_high.x, v_high.y, v_high.z);
        outVerticesLow.push(v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z, v_low.x, v_low.y, v_low.z);
        outColors.push(r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6, r8, g4, b4, a6);
        outOrders.push(1, -1, 2, -2);
        if (j2 < pathLonLat.length - 1 && pathLonLat[j2 + 1].length !== 0) {
          index += 8;
          outIndexes.push(index, index);
        }
      }
    }
    /**
     * Sets polyline path with cartesian coordinates.
     * @protected
     * @param {SegmentPath3vExt[]} path3v - Cartesian coordinates.
     */
    _setEqualPath3v(path3v) {
      var extent = this._extent;
      extent.southWest.set(180, 90);
      extent.northEast.set(-180, -90);
      var v_high = new Vec3(), v_low = new Vec3();
      var vh = this._verticesHigh, vl = this._verticesLow, l4 = this._pathLonLat, m5 = this._pathLonLatMerc, k3 = 0;
      var ellipsoid = this._renderNode.ellipsoid;
      for (let j2 = 0; j2 < path3v.length; j2++) {
        var path = path3v[j2];
        var last;
        if (this._closedLine) {
          last = path[path.length - 1];
        } else {
          last = new Vec3(path[0].x + path[0].x - path[1].x, path[0].y + path[0].y - path[1].y, path[0].z + path[0].z - path[1].z);
        }
        Vec3.doubleToTwoFloats(last, v_high, v_low);
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        for (let i9 = 0; i9 < path.length; i9++) {
          var cur = path[i9], pji = this._path3v[j2][i9];
          pji.x = cur.x;
          pji.y = cur.y;
          pji.z = cur.z;
          if (ellipsoid) {
            var lonLat = ellipsoid.cartesianToLonLat(cur);
            this._pathLonLat[j2][i9] = lonLat;
            l4[j2][i9] = lonLat;
            m5[j2][i9] = lonLat.forwardMercator();
            if (lonLat.lon < extent.southWest.lon) {
              extent.southWest.lon = lonLat.lon;
            }
            if (lonLat.lat < extent.southWest.lat) {
              extent.southWest.lat = lonLat.lat;
            }
            if (lonLat.lon > extent.northEast.lon) {
              extent.northEast.lon = lonLat.lon;
            }
            if (lonLat.lat > extent.northEast.lat) {
              extent.northEast.lat = lonLat.lat;
            }
          }
          Vec3.doubleToTwoFloats(cur, v_high, v_low);
          vh[k3] = v_high.x;
          vl[k3++] = v_low.x;
          vh[k3] = v_high.y;
          vl[k3++] = v_low.y;
          vh[k3] = v_high.z;
          vl[k3++] = v_low.z;
          vh[k3] = v_high.x;
          vl[k3++] = v_low.x;
          vh[k3] = v_high.y;
          vl[k3++] = v_low.y;
          vh[k3] = v_high.z;
          vl[k3++] = v_low.z;
          vh[k3] = v_high.x;
          vl[k3++] = v_low.x;
          vh[k3] = v_high.y;
          vl[k3++] = v_low.y;
          vh[k3] = v_high.z;
          vl[k3++] = v_low.z;
          vh[k3] = v_high.x;
          vl[k3++] = v_low.x;
          vh[k3] = v_high.y;
          vl[k3++] = v_low.y;
          vh[k3] = v_high.z;
          vl[k3++] = v_low.z;
        }
        var first;
        if (this._closedLine) {
          first = path[0];
        } else {
          var l1 = path.length - 1;
          first = new Vec3(path[l1].x + path[l1].x - path[l1 - 1].x, path[l1].y + path[l1].y - path[l1 - 1].y, path[l1].z + path[l1].z - path[l1 - 1].z);
        }
        Vec3.doubleToTwoFloats(first, v_high, v_low);
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
      }
    }
    /**
     * Sets polyline with geodetic coordinates.
     * @protected
     * @param {SegmentPathLonLat[]} pathLonLat - Geodetic polyline path coordinates.
     */
    _setEqualPathLonLat(pathLonLat) {
      var extent = this._extent;
      extent.southWest.set(180, 90);
      extent.northEast.set(-180, -90);
      var v_high = new Vec3(), v_low = new Vec3();
      var vh = this._verticesHigh, vl = this._verticesLow, l4 = this._pathLonLat, m5 = this._pathLonLatMerc, c7 = this._path3v, k3 = 0;
      var ellipsoid = this._renderNode.ellipsoid;
      for (let j2 = 0; j2 < pathLonLat.length; j2++) {
        var path = pathLonLat[j2];
        var last;
        if (this._closedLine) {
          last = ellipsoid.lonLatToCartesian(path[path.length - 1]);
        } else {
          let p0 = ellipsoid.lonLatToCartesian(path[0]), p1 = ellipsoid.lonLatToCartesian(path[1]);
          last = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
        }
        Vec3.doubleToTwoFloats(last, v_high, v_low);
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        for (let i9 = 0; i9 < path.length; i9++) {
          var cur = path[i9];
          var cartesian = ellipsoid.lonLatToCartesian(cur);
          c7[j2][i9] = cartesian;
          m5[j2][i9] = cur.forwardMercator();
          l4[j2][i9] = cur;
          Vec3.doubleToTwoFloats(cartesian, v_high, v_low);
          vh[k3] = v_high.x;
          vl[k3++] = v_low.x;
          vh[k3] = v_high.y;
          vl[k3++] = v_low.y;
          vh[k3] = v_high.z;
          vl[k3++] = v_low.z;
          vh[k3] = v_high.x;
          vl[k3++] = v_low.x;
          vh[k3] = v_high.y;
          vl[k3++] = v_low.y;
          vh[k3] = v_high.z;
          vl[k3++] = v_low.z;
          vh[k3] = v_high.x;
          vl[k3++] = v_low.x;
          vh[k3] = v_high.y;
          vl[k3++] = v_low.y;
          vh[k3] = v_high.z;
          vl[k3++] = v_low.z;
          vh[k3] = v_high.x;
          vl[k3++] = v_low.x;
          vh[k3] = v_high.y;
          vl[k3++] = v_low.y;
          vh[k3] = v_high.z;
          vl[k3++] = v_low.z;
          if (cur.lon < extent.southWest.lon) {
            extent.southWest.lon = cur.lon;
          }
          if (cur.lat < extent.southWest.lat) {
            extent.southWest.lat = cur.lat;
          }
          if (cur.lon > extent.northEast.lon) {
            extent.northEast.lon = cur.lon;
          }
          if (cur.lat > extent.northEast.lat) {
            extent.northEast.lat = cur.lat;
          }
        }
        var first;
        if (this._closedLine) {
          first = ellipsoid.lonLatToCartesian(path[0]);
        } else {
          let p0 = ellipsoid.lonLatToCartesian(path[path.length - 1]), p1 = ellipsoid.lonLatToCartesian(path[path.length - 2]);
          first = new Vec3(p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
        }
        Vec3.doubleToTwoFloats(first, v_high, v_low);
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
        vh[k3] = v_high.x;
        vl[k3++] = v_low.x;
        vh[k3] = v_high.y;
        vl[k3++] = v_low.y;
        vh[k3] = v_high.z;
        vl[k3++] = v_low.z;
      }
    }
    setPointLonLat(lonlat, index, segmentIndex) {
      if (this._renderNode && this._renderNode.ellipsoid) {
        let l4 = this._pathLonLat, m5 = this._pathLonLatMerc;
        l4[segmentIndex][index] = lonlat;
        m5[segmentIndex][index] = lonlat.forwardMercator();
        var extent = this._extent;
        extent.southWest.set(180, 90);
        extent.northEast.set(-180, -90);
        for (let i9 = 0; i9 < l4.length; i9++) {
          var pi = l4[i9];
          for (let j2 = 0; j2 < pi.length; j2++) {
            var lon = pi[j2].lon, lat = pi[j2].lat;
            if (lon > extent.northEast.lon) {
              extent.northEast.lon = lon;
            }
            if (lat > extent.northEast.lat) {
              extent.northEast.lat = lat;
            }
            if (lon < extent.southWest.lon) {
              extent.southWest.lon = lon;
            }
            if (lat < extent.southWest.lat) {
              extent.southWest.lat = lat;
            }
          }
        }
        this.setPoint3v(this._renderNode.ellipsoid.lonLatToCartesian(lonlat), index, segmentIndex, true);
      } else {
        let path = this._pathLonLat[segmentIndex];
        path[index].lon = lonlat.lon;
        path[index].lat = lonlat.lat;
        path[index].height = lonlat.height;
      }
    }
    /**
     * Changes cartesian point coordinates of the path
     * @param {Vec3} coordinates - New coordinates
     * @param {number} [index=0] - Path segment index
     * @param {number} [segmentIndex=0] - Index of the point in the path segment
     * @param {boolean} [skipLonLat=false] - Do not update geodetic coordinates
     */
    setPoint3v(coordinates, index = 0, segmentIndex = 0, skipLonLat = false) {
      if (this._renderNode) {
        var v_high = new Vec3(), v_low = new Vec3();
        var vh = this._verticesHigh, vl = this._verticesLow, l4 = this._pathLonLat, m5 = this._pathLonLatMerc, k3 = 0, kk = 0;
        kk = this._pathLengths[segmentIndex] * 12 + 24 * segmentIndex;
        let path = this._path3v[segmentIndex];
        path[index].x = coordinates.x;
        path[index].y = coordinates.y;
        path[index].z = coordinates.z;
        let _closedLine = this._closedLine || path.length === 1;
        if (index === 0 || index === 1) {
          var last;
          if (_closedLine) {
            last = path[path.length - 1];
          } else {
            last = new Vec3(path[0].x + path[0].x - path[1].x, path[0].y + path[0].y - path[1].y, path[0].z + path[0].z - path[1].z);
          }
          k3 = kk;
          Vec3.doubleToTwoFloats(last, v_high, v_low);
          vh[k3] = v_high.x;
          vh[k3 + 1] = v_high.y;
          vh[k3 + 2] = v_high.z;
          vh[k3 + 3] = v_high.x;
          vh[k3 + 4] = v_high.y;
          vh[k3 + 5] = v_high.z;
          vh[k3 + 6] = v_high.x;
          vh[k3 + 7] = v_high.y;
          vh[k3 + 8] = v_high.z;
          vh[k3 + 9] = v_high.x;
          vh[k3 + 10] = v_high.y;
          vh[k3 + 11] = v_high.z;
          vl[k3] = v_low.x;
          vl[k3 + 1] = v_low.y;
          vl[k3 + 2] = v_low.z;
          vl[k3 + 3] = v_low.x;
          vl[k3 + 4] = v_low.y;
          vl[k3 + 5] = v_low.z;
          vl[k3 + 6] = v_low.x;
          vl[k3 + 7] = v_low.y;
          vl[k3 + 8] = v_low.z;
          vl[k3 + 9] = v_low.x;
          vl[k3 + 10] = v_low.y;
          vl[k3 + 11] = v_low.z;
        }
        if (!skipLonLat && this._renderNode.ellipsoid) {
          var lonLat = this._renderNode.ellipsoid.cartesianToLonLat(coordinates);
          l4[segmentIndex][index] = lonLat;
          m5[segmentIndex][index] = lonLat.forwardMercator();
          var extent = this._extent;
          extent.southWest.set(180, 90);
          extent.northEast.set(-180, -90);
          for (let i9 = 0; i9 < l4.length; i9++) {
            var pi = l4[i9];
            for (let j2 = 0; j2 < pi.length; j2++) {
              var lon = pi[j2].lon, lat = pi[j2].lat;
              if (lon > extent.northEast.lon) {
                extent.northEast.lon = lon;
              }
              if (lat > extent.northEast.lat) {
                extent.northEast.lat = lat;
              }
              if (lon < extent.southWest.lon) {
                extent.southWest.lon = lon;
              }
              if (lat < extent.southWest.lat) {
                extent.southWest.lat = lat;
              }
            }
          }
        }
        k3 = kk + index * 12 + 12;
        Vec3.doubleToTwoFloats(coordinates, v_high, v_low);
        vh[k3] = v_high.x;
        vh[k3 + 1] = v_high.y;
        vh[k3 + 2] = v_high.z;
        vh[k3 + 3] = v_high.x;
        vh[k3 + 4] = v_high.y;
        vh[k3 + 5] = v_high.z;
        vh[k3 + 6] = v_high.x;
        vh[k3 + 7] = v_high.y;
        vh[k3 + 8] = v_high.z;
        vh[k3 + 9] = v_high.x;
        vh[k3 + 10] = v_high.y;
        vh[k3 + 11] = v_high.z;
        vl[k3] = v_low.x;
        vl[k3 + 1] = v_low.y;
        vl[k3 + 2] = v_low.z;
        vl[k3 + 3] = v_low.x;
        vl[k3 + 4] = v_low.y;
        vl[k3 + 5] = v_low.z;
        vl[k3 + 6] = v_low.x;
        vl[k3 + 7] = v_low.y;
        vl[k3 + 8] = v_low.z;
        vl[k3 + 9] = v_low.x;
        vl[k3 + 10] = v_low.y;
        vl[k3 + 11] = v_low.z;
        if (index === path.length - 1 || index === path.length - 2) {
          var first;
          if (_closedLine) {
            first = path[0];
          } else {
            var l1 = path.length - 1;
            first = new Vec3(path[l1].x + path[l1].x - path[l1 - 1].x, path[l1].y + path[l1].y - path[l1 - 1].y, path[l1].z + path[l1].z - path[l1 - 1].z);
          }
          k3 = kk + path.length * 12 + 12;
          Vec3.doubleToTwoFloats(first, v_high, v_low);
          vh[k3] = v_high.x;
          vh[k3 + 1] = v_high.y;
          vh[k3 + 2] = v_high.z;
          vh[k3 + 3] = v_high.x;
          vh[k3 + 4] = v_high.y;
          vh[k3 + 5] = v_high.z;
          vh[k3 + 6] = v_high.x;
          vh[k3 + 7] = v_high.y;
          vh[k3 + 8] = v_high.z;
          vh[k3 + 9] = v_high.x;
          vh[k3 + 10] = v_high.y;
          vh[k3 + 11] = v_high.z;
          vl[k3] = v_low.x;
          vl[k3 + 1] = v_low.y;
          vl[k3 + 2] = v_low.z;
          vl[k3 + 3] = v_low.x;
          vl[k3 + 4] = v_low.y;
          vl[k3 + 5] = v_low.z;
          vl[k3 + 6] = v_low.x;
          vl[k3 + 7] = v_low.y;
          vl[k3 + 8] = v_low.z;
          vl[k3 + 9] = v_low.x;
          vl[k3 + 10] = v_low.y;
          vl[k3 + 11] = v_low.z;
        }
        this._changedBuffers[VERTICES_BUFFER] = true;
      } else {
        let path = this._path3v[segmentIndex];
        path[index].x = coordinates.x;
        path[index].y = coordinates.y;
        path[index].z = coordinates.z;
      }
    }
    _resizePathLengths(index = 0) {
      this._pathLengths[0] = 0;
      for (let i9 = index + 1, len = this._path3v.length; i9 <= len; i9++) {
        this._pathLengths[i9] = this._pathLengths[i9 - 1] + this._path3v[i9 - 1].length;
      }
    }
    /**
     * Remove path segment
     * @param {number} index - Path segment index
     */
    removeSegment(index) {
      this._path3v.splice(index, 1);
      this.setPath3v([].concat(this._path3v));
    }
    /**
     * Remove point from the path
     * @param {number} index - Point index in a path segment
     * @param {number} [multiLineIndex=0] - Segment path index
     */
    removePoint(index, multiLineIndex = 0) {
      this._path3v[multiLineIndex].splice(index, 1);
      if (this._path3v[multiLineIndex].length === 0) {
        this._path3v.splice(multiLineIndex, 1);
      }
      this.setPath3v([].concat(this._path3v));
    }
    /**
     * Insert point coordinates in a path segment
     * @param {Vec3} point3v - Point coordinates
     * @param {number} [index=0] - Index in the path
     * @param {NumberArray4} [color] - Point color
     * @param {number} [multilineIndex=0] - Path segment index
     */
    insertPoint3v(point3v, index = 0, color, multilineIndex = 0) {
      let p4 = [].concat(this._path3v), pp = p4[multilineIndex];
      if (pp) {
        let c7 = [].concat(this._pathColors);
        pp.splice(index, 0, point3v);
        if (color) {
          let cc = c7[multilineIndex];
          if (!cc) {
            cc = new Array(pp.length);
          }
          cc.splice(index, 0, color);
        }
        this.setPath3v(p4, c7);
      } else {
        this.addPoint3v(point3v, multilineIndex);
      }
    }
    /**
     * Adds a new cartesian point in the end of the path in a last line segment.
     * @public
     * @param {Vec3} point3v - New coordinates.
     * @param {NumberArray4} [color] -
     * @param {boolean} [skipEllipsoid] -
     */
    appendPoint3v(point3v, color, skipEllipsoid) {
      if (this._path3v.length === 0 || !this._renderNode) {
        this._pathColors.push([color || this._defaultColor]);
        this.addPoint3v(point3v);
      } else {
        this._verticesHigh = makeArray(this._verticesHigh);
        this._verticesLow = makeArray(this._verticesLow);
        this._colors = makeArray(this._colors);
        this._orders = makeArray(this._orders);
        this._indexes = makeArray(this._indexes);
        _Polyline.appendPoint3v(this._path3v, point3v, this._pathColors, color || this._defaultColor, this._closedLine, this._verticesHigh, this._verticesLow, this._colors, this._orders, this._indexes, !skipEllipsoid ? this._renderNode.ellipsoid : null, this._pathLonLat, this._pathLonLatMerc, this._extent);
        this._pathLengths[this._path3v.length] += 1;
        this._changedBuffers[VERTICES_BUFFER] = true;
        this._changedBuffers[COLORS_BUFFER] = true;
        this._changedBuffers[INDEX_BUFFER] = true;
      }
    }
    /**
     * Append new point in the end of the path.
     * @public
     * @param {Vec3} point3v - New point coordinates.
     * @param {number} [multiLineIndex=0] - Path segment index, first by default.
     */
    addPoint3v(point3v, multiLineIndex = 0) {
      if (multiLineIndex >= this._path3v.length) {
        this._path3v.push([]);
      }
      this._path3v[multiLineIndex].push(point3v);
      this.setPath3v([].concat(this._path3v));
    }
    /**
     * Append new geodetic point in the end of the path.
     * @public
     * @param {LonLat} lonLat - New coordinate.
     * @param {number} [multiLineIndex=0] - Path segment index, first by default.
     */
    addPointLonLat(lonLat, multiLineIndex = 0) {
      if (multiLineIndex >= this._pathLonLat.length) {
        this._pathLonLat.push([]);
      }
      this._pathLonLat[multiLineIndex].push(lonLat);
      this.setPathLonLat([].concat(this._pathLonLat));
    }
    /**
     * Clear polyline data.
     * @public
     */
    clear() {
      this._clearData();
    }
    /**
     * Change path point color
     * @param {NumberArray4} color - New color
     * @param {number} [index=0] - Point index
     * @param {number} [segmentIndex=0] - Path segment index
     */
    setPointColor(color, index = 0, segmentIndex = 0) {
      if (this._renderNode && index < this._path3v[segmentIndex].length) {
        let colors = this._pathColors[segmentIndex];
        if (!colors) {
          if (this._path3v[segmentIndex] && index < this._path3v[segmentIndex].length) {
            this._pathColors[segmentIndex] = new Array(this._path3v[segmentIndex].length);
          } else {
            return;
          }
        }
        if (!colors[index]) {
          colors[index] = [color[R], color[G], color[B], color[A] || 1];
        } else {
          colors[index][R] = color[R];
          colors[index][G] = color[G];
          colors[index][B] = color[B];
          colors[index][A] = color[A] || 1;
        }
        let c7 = this._colors;
        let k3 = index * 16 + this._pathLengths[segmentIndex] * 16 + 32 * segmentIndex;
        c7[k3] = c7[k3 + 4] = c7[k3 + 8] = c7[k3 + 12] = color[R];
        c7[k3 + 1] = c7[k3 + 5] = c7[k3 + 9] = c7[k3 + 13] = color[G];
        c7[k3 + 2] = c7[k3 + 6] = c7[k3 + 10] = c7[k3 + 14] = color[B];
        c7[k3 + 3] = c7[k3 + 7] = c7[k3 + 11] = c7[k3 + 15] = color[A] || 1;
        this._changedBuffers[COLORS_BUFFER] = true;
      } else {
        let pathColors = this._pathColors[segmentIndex];
        pathColors[index] = color;
      }
    }
    /**
     * Sets polyline opacity.
     * @public
     * @param {number} opacity - Opacity.
     */
    setOpacity(opacity) {
      this._opacity = opacity;
    }
    /**
     * Sets Polyline thickness in screen pixels.
     * @public
     * @param {number} thickness - Thickness.
     */
    setAltitude(altitude) {
      this.altitude = altitude;
    }
    /**
     * Sets Polyline thickness in screen pixels.
     * @public
     * @param {number} thickness - Thickness.
     */
    setThickness(thickness) {
      this.thickness = thickness;
    }
    /**
     * Returns thickness.
     * @public
     * @return {number} Thickness in screen pixels.
     */
    getThickness() {
      return this.thickness;
    }
    /**
     * Sets visibility.
     * @public
     * @param {boolean} visibility - Polyline visibility.
     */
    setVisibility(visibility) {
      this.visibility = visibility;
    }
    /**
     * Gets Polyline visibility.
     * @public
     * @return {boolean} Polyline visibility.
     */
    getVisibility() {
      return this.visibility;
    }
    /**
     * Assign with render node.
     * @public
     * @param {RenderNode} renderNode -
     */
    setRenderNode(renderNode) {
      if (renderNode) {
        this._renderNode = renderNode;
        if (this._pathLonLat.length) {
          this._createDataLonLat([].concat(this._pathLonLat));
        } else {
          this._createData3v([].concat(this._path3v));
        }
        this._refresh();
        if (renderNode.renderer && renderNode.renderer.isInitialized()) {
          this._update();
        }
      }
    }
    _clearData() {
      this._verticesHigh = null;
      this._verticesLow = null;
      this._orders = null;
      this._indexes = null;
      this._colors = null;
      this._verticesHigh = [];
      this._verticesLow = [];
      this._orders = [];
      this._indexes = [];
      this._colors = [];
      this._path3v.length = 0;
      this._pathLonLat.length = 0;
      this._pathLonLatMerc.length = 0;
      this._path3v = [];
      this._pathLonLat = [];
      this._pathLonLatMerc = [];
    }
    _createData3v(path3v) {
      this._clearData();
      _Polyline.appendLineData3v(path3v, this._pathColors, this._defaultColor, this._closedLine, this._verticesHigh, this._verticesLow, this._orders, this._indexes, this._renderNode.ellipsoid, this._pathLonLat, this._path3v, this._pathLonLatMerc, this._extent, this._colors);
      this._resizePathLengths(0);
    }
    _createDataLonLat(pathLonlat) {
      this._clearData();
      _Polyline.appendLineDataLonLat(pathLonlat, this._pathColors, this._defaultColor, this._closedLine, this._verticesHigh, this._verticesLow, this._orders, this._indexes, this._renderNode.ellipsoid, this._path3v, this._pathLonLat, this._pathLonLatMerc, this._extent, this._colors);
      this._resizePathLengths(0);
    }
    /**
     * Removes from an entity.
     * @public
     */
    remove() {
      this._entity = null;
      this._pathColors.length = 0;
      this._pathColors = [];
      this._verticesHigh = null;
      this._verticesLow = null;
      this._orders = null;
      this._indexes = null;
      this._colors = null;
      this._verticesHigh = [];
      this._verticesLow = [];
      this._orders = [];
      this._indexes = [];
      this._colors = [];
      this._deleteBuffers();
      this._handler && this._handler.remove(this);
    }
    setPickingColor3v(color) {
      this._pickingColor[0] = color.x / 255;
      this._pickingColor[1] = color.y / 255;
      this._pickingColor[2] = color.z / 255;
    }
    /**
     * Returns polyline geodetic extent.
     * @public
     * @returns {Extent} - Geodetic extent
     */
    getExtent() {
      return this._extent.clone();
    }
    /**
     * Returns path cartesian coordinates.
     * @return {SegmentPath3vExt[]} Polyline path.
     */
    getPath3v() {
      return this._path3v;
    }
    /**
     * Returns geodetic path coordinates.
     * @return {SegmentPathLonLatExt[]} Polyline path.
     */
    getPathLonLat() {
      return this._pathLonLat;
    }
    getPathColors() {
      return this._pathColors;
    }
    /**
     * @todo
     * @param {NumberArray4[][]} pathColors
     */
    setPathColors(pathColors) {
      if (pathColors) {
        this._colors = [];
        this._pathColors = [].concat(pathColors);
        _Polyline.setPathColors(this._pathLonLat, pathColors, this._defaultColor, this._colors);
        this._changedBuffers[COLORS_BUFFER] = true;
      }
    }
    /**
     * Sets polyline color
     * @param {string} htmlColor- HTML color
     */
    setColorHTML(htmlColor) {
      this._defaultColor = htmlColorToFloat32Array(htmlColor);
      let color = htmlColorToRgba(htmlColor), p4 = this._pathColors;
      for (let i9 = 0, len = p4.length; i9 < len; i9++) {
        let s7 = p4[i9];
        for (let j2 = 0, slen = s7.length; j2 < slen; j2++) {
          s7[j2][0] = color.x;
          s7[j2][1] = color.y;
          s7[j2][2] = color.z;
          s7[j2][3] = color.w;
        }
      }
      let c7 = this._colors;
      for (let i9 = 0, len = c7.length; i9 < len; i9 += 4) {
        c7[i9] = color.x;
        c7[i9 + 1] = color.y;
        c7[i9 + 2] = color.z;
        c7[i9 + 3] = color.w;
      }
      this._changedBuffers[COLORS_BUFFER] = true;
    }
    /**
     * Sets polyline geodetic coordinates.
     * @public
     * @param {SegmentPathLonLat[]} pathLonLat - Polyline path cartesian coordinates.
     * @param {Boolean} [forceEqual=false] - OPTIMIZATION FLAG: Makes assigning faster for size equal coordinates array.
     */
    setPathLonLat(pathLonLat, forceEqual = false) {
      if (this._renderNode && this._renderNode.ellipsoid) {
        if (forceEqual) {
          this._setEqualPathLonLat(pathLonLat);
          this._changedBuffers[VERTICES_BUFFER] = true;
          this._changedBuffers[COLORS_BUFFER] = true;
        } else {
          this._createDataLonLat(pathLonLat);
          this._changedBuffers[VERTICES_BUFFER] = true;
          this._changedBuffers[INDEX_BUFFER] = true;
          this._changedBuffers[COLORS_BUFFER] = true;
        }
      } else {
        this._pathLonLat = [].concat(pathLonLat);
      }
    }
    /**
     * Sets Polyline cartesian coordinates.
     * @public
     * @param {SegmentPath3vExt[]} path3v - Polyline path cartesian coordinates. (exactly 3 entries)
     * @param {SegmentPathColor[]} [pathColors] - Polyline path cartesian coordinates. (exactly 3 entries)
     * @param {Boolean} [forceEqual=false] - Makes assigning faster for size equal coordinates array.
     */
    setPath3v(path3v, pathColors, forceEqual = false) {
      if (pathColors) {
        this._pathColors = [].concat(pathColors);
      }
      if (this._renderNode) {
        if (forceEqual) {
          this._setEqualPath3v(path3v);
          this._changedBuffers[VERTICES_BUFFER] = true;
          this._changedBuffers[COLORS_BUFFER] = true;
        } else {
          this._createData3v(path3v);
          this._changedBuffers[VERTICES_BUFFER] = true;
          this._changedBuffers[INDEX_BUFFER] = true;
          this._changedBuffers[COLORS_BUFFER] = true;
        }
      } else {
        this._path3v = [].concat(path3v);
      }
    }
    draw() {
      if (this.visibility && this._path3v.length) {
        this._update();
        let rn = this._renderNode;
        let r8 = rn.renderer;
        let sh = r8.handler.programs.polyline_screen;
        let p4 = sh._program;
        let gl = r8.handler.gl, sha = p4.attributes, shu = p4.uniforms;
        let ec = this._handler._entityCollection;
        sh.activate();
        gl.disable(gl.CULL_FACE);
        gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
        gl.uniformMatrix4fv(shu.proj, false, r8.activeCamera.getProjectionMatrix());
        gl.uniformMatrix4fv(shu.view, false, r8.activeCamera.getViewMatrix());
        gl.uniform3fv(shu.eyePositionHigh, r8.activeCamera.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, r8.activeCamera.eyeLow);
        gl.uniform2fv(shu.uFloatParams, [rn._planetRadius2 || 0, r8.activeCamera._tanViewAngle_hradOneByHeight]);
        gl.uniform2fv(shu.viewport, [r8.handler.canvas.width, r8.handler.canvas.height]);
        gl.uniform1f(shu.thickness, this.thickness * 0.5);
        gl.uniform1f(shu.opacity, this._opacity * ec._fadingOpacity);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._colorsBuffer);
        gl.vertexAttribPointer(sha.color, this._colorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
        let v4 = this._verticesHighBuffer;
        gl.bindBuffer(gl.ARRAY_BUFFER, v4);
        gl.vertexAttribPointer(sha.prevHigh, v4.itemSize, gl.FLOAT, false, 12, 0);
        gl.vertexAttribPointer(sha.currentHigh, v4.itemSize, gl.FLOAT, false, 12, 48);
        gl.vertexAttribPointer(sha.nextHigh, v4.itemSize, gl.FLOAT, false, 12, 96);
        v4 = this._verticesLowBuffer;
        gl.bindBuffer(gl.ARRAY_BUFFER, v4);
        gl.vertexAttribPointer(sha.prevLow, v4.itemSize, gl.FLOAT, false, 12, 0);
        gl.vertexAttribPointer(sha.currentLow, v4.itemSize, gl.FLOAT, false, 12, 48);
        gl.vertexAttribPointer(sha.nextLow, v4.itemSize, gl.FLOAT, false, 12, 96);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._ordersBuffer);
        gl.vertexAttribPointer(sha.order, this._ordersBuffer.itemSize, gl.FLOAT, false, 4, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexesBuffer);
        gl.drawElements(gl.TRIANGLE_STRIP, this._indexesBuffer.numItems, gl.UNSIGNED_INT, 0);
        gl.enable(gl.CULL_FACE);
      }
    }
    drawPicking() {
      if (this.visibility && this._path3v.length) {
        let rn = this._renderNode;
        let r8 = rn.renderer;
        let sh = r8.handler.programs.polyline_picking;
        let p4 = sh._program;
        let gl = r8.handler.gl, sha = p4.attributes, shu = p4.uniforms;
        sh.activate();
        gl.disable(gl.CULL_FACE);
        gl.uniform1f(shu.depthOffset, this._handler._entityCollection.polygonOffsetUnits);
        gl.uniformMatrix4fv(shu.proj, false, r8.activeCamera.getProjectionMatrix());
        gl.uniformMatrix4fv(shu.view, false, r8.activeCamera.getViewMatrix());
        gl.uniform4fv(shu.color, [
          this._pickingColor[0],
          this._pickingColor[1],
          this._pickingColor[2],
          1
        ]);
        gl.uniform3fv(shu.eyePositionHigh, r8.activeCamera.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, r8.activeCamera.eyeLow);
        gl.uniform2fv(shu.uFloatParams, [rn._planetRadius2 || 0, r8.activeCamera._tanViewAngle_hradOneByHeight]);
        gl.uniform2fv(shu.viewport, [r8.handler.canvas.width, r8.handler.canvas.height]);
        gl.uniform1f(shu.thickness, this.thickness * 0.5);
        let v4 = this._verticesHighBuffer;
        gl.bindBuffer(gl.ARRAY_BUFFER, v4);
        gl.vertexAttribPointer(sha.prevHigh, v4.itemSize, gl.FLOAT, false, 12, 0);
        gl.vertexAttribPointer(sha.currentHigh, v4.itemSize, gl.FLOAT, false, 12, 48);
        gl.vertexAttribPointer(sha.nextHigh, v4.itemSize, gl.FLOAT, false, 12, 96);
        v4 = this._verticesLowBuffer;
        gl.bindBuffer(gl.ARRAY_BUFFER, v4);
        gl.vertexAttribPointer(sha.prevLow, v4.itemSize, gl.FLOAT, false, 12, 0);
        gl.vertexAttribPointer(sha.currentLow, v4.itemSize, gl.FLOAT, false, 12, 48);
        gl.vertexAttribPointer(sha.nextLow, v4.itemSize, gl.FLOAT, false, 12, 96);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._ordersBuffer);
        gl.vertexAttribPointer(sha.order, this._ordersBuffer.itemSize, gl.FLOAT, false, 4, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexesBuffer);
        gl.drawElements(gl.TRIANGLE_STRIP, this._indexesBuffer.numItems, gl.UNSIGNED_INT, 0);
        gl.enable(gl.CULL_FACE);
      }
    }
    /**
     * Refresh buffers.
     * @protected
     */
    _refresh() {
      let i9 = this._changedBuffers.length;
      while (i9--) {
        this._changedBuffers[i9] = true;
      }
    }
    /**
     * Updates render buffers.
     * @protected
     */
    _update() {
      if (this._renderNode) {
        let i9 = this._changedBuffers.length;
        while (i9--) {
          if (this._changedBuffers[i9]) {
            this._buffersUpdateCallbacks[i9].call(this);
            this._changedBuffers[i9] = false;
          }
        }
      }
    }
    /**
     * Clear GL buffers.
     * @public
     */
    _deleteBuffers() {
      if (this._renderNode) {
        let r8 = this._renderNode.renderer, gl = r8.handler.gl;
        gl.deleteBuffer(this._verticesHighBuffer);
        gl.deleteBuffer(this._verticesLowBuffer);
        gl.deleteBuffer(this._ordersBuffer);
        gl.deleteBuffer(this._indexesBuffer);
        gl.deleteBuffer(this._colorsBuffer);
        this._verticesHighBuffer = null;
        this._verticesLowBuffer = null;
        this._ordersBuffer = null;
        this._indexesBuffer = null;
        this._colorsBuffer = null;
      }
    }
    /**
     * Creates vertices buffers.
     * @protected
     */
    _createVerticesBuffer() {
      let h8 = this._renderNode.renderer.handler;
      let numItems = this._verticesHigh.length / 3;
      if (!this._verticesHighBuffer || this._verticesHighBuffer.numItems !== numItems) {
        h8.gl.deleteBuffer(this._verticesHighBuffer);
        h8.gl.deleteBuffer(this._verticesLowBuffer);
        this._verticesHighBuffer = h8.createStreamArrayBuffer(3, numItems);
        this._verticesLowBuffer = h8.createStreamArrayBuffer(3, numItems);
      }
      this._verticesHigh = makeArrayTyped(this._verticesHigh);
      this._verticesLow = makeArrayTyped(this._verticesLow);
      h8.setStreamArrayBuffer(this._verticesHighBuffer, this._verticesHigh);
      h8.setStreamArrayBuffer(this._verticesLowBuffer, this._verticesLow);
    }
    /**
     * Creates gl index and order buffer.
     * @protected
     */
    _createIndexBuffer() {
      let h8 = this._renderNode.renderer.handler;
      h8.gl.deleteBuffer(this._ordersBuffer);
      h8.gl.deleteBuffer(this._indexesBuffer);
      this._orders = makeArrayTyped(this._orders);
      this._ordersBuffer = h8.createArrayBuffer(this._orders, 1, this._orders.length / 2);
      this._indexes = makeArrayTyped(this._indexes, Uint32Array);
      this._indexesBuffer = h8.createElementArrayBuffer(this._indexes, 1, this._indexes.length);
    }
    _createColorsBuffer() {
      let h8 = this._renderNode.renderer.handler;
      h8.gl.deleteBuffer(this._colorsBuffer);
      this._colors = makeArrayTyped(this._colors);
      this._colorsBuffer = h8.createArrayBuffer(new Float32Array(this._colors), 4, this._colors.length / 4);
    }
  };
  Polyline.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/entity/Ray.js
  var Ray2 = class _Ray {
    constructor(options2 = {}) {
      this.__id = _Ray.__counter__++;
      this._thickness = options2.thickness || 2;
      this._startPosition = createVector3(options2.startPosition);
      this._startPositionHigh = new Vec3();
      this._startPositionLow = new Vec3();
      Vec3.doubleToTwoFloats(this._startPosition, this._startPositionHigh, this._startPositionLow);
      this._endPosition = createVector3(options2.endPosition);
      this._endPositionHigh = new Vec3();
      this._endPositionLow = new Vec3();
      Vec3.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);
      this._startColor = createColorRGBA(options2.startColor);
      this._endColor = createColorRGBA(options2.endColor);
      this._visibility = options2.visibility != void 0 ? options2.visibility : true;
      this._entity = null;
      this._handler = null;
      this._handlerIndex = -1;
    }
    /**
     * Sets ray start position.
     * @public
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} z - Z coordinate.
     */
    setStartPosition(x3, y4, z3) {
      this._startPosition.x = x3;
      this._startPosition.y = y4;
      this._startPosition.z = z3;
      Vec3.doubleToTwoFloats(this._startPosition, this._startPositionHigh, this._startPositionLow);
      this._handler && this._handler.setStartPositionArr(this._handlerIndex, this._startPositionHigh, this._startPositionLow);
    }
    getLength() {
      return this._startPosition.distance(this._endPosition);
    }
    /**
     * Sets ray start position.
     * @public
     * @param {Vec3} position - Cartesian coordinates.
     */
    setStartPosition3v(position2) {
      this._startPosition.x = position2.x;
      this._startPosition.y = position2.y;
      this._startPosition.z = position2.z;
      Vec3.doubleToTwoFloats(this._startPosition, this._startPositionHigh, this._startPositionLow);
      this._handler && this._handler.setStartPositionArr(this._handlerIndex, this._startPositionHigh, this._startPositionLow);
    }
    /**
     * Sets ray end position.
     * @public
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} z - Z coordinate.
     */
    setEndPosition(x3, y4, z3) {
      this._endPosition.x = x3;
      this._endPosition.y = y4;
      this._endPosition.z = z3;
      Vec3.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);
      this._handler && this._handler.setEndPositionArr(this._handlerIndex, this._endPositionHigh, this._endPositionLow);
    }
    /**
     * Sets ray end position.
     * @public
     * @param {Vec3} position - Cartesian coordinates.
     */
    setEndPosition3v(position2) {
      this._endPosition.x = position2.x;
      this._endPosition.y = position2.y;
      this._endPosition.z = position2.z;
      Vec3.doubleToTwoFloats(this._endPosition, this._endPositionHigh, this._endPositionLow);
      this._handler && this._handler.setEndPositionArr(this._handlerIndex, this._endPositionHigh, this._endPositionLow);
    }
    setThickness(thickness) {
      this._thickness = thickness;
      this._handler && this._handler.setThicknessArr(this._handlerIndex, thickness);
    }
    setColors4v(startColor, endColor) {
      if (startColor) {
        this._startColor.x = startColor.x;
        this._startColor.y = startColor.y;
        this._startColor.z = startColor.z;
        this._startColor.w = startColor.w;
      }
      if (endColor) {
        this._endColor.x = endColor.x;
        this._endColor.y = endColor.y;
        this._endColor.z = endColor.z;
        this._endColor.w = endColor.w;
      }
      this._handler && this._handler.setRgbaArr(this._handlerIndex, this._startColor, this._endColor);
    }
    setColorsHTML(startColor, endColor) {
      if (startColor) {
        this._startColor = htmlColorToRgba(startColor);
      }
      if (endColor) {
        this._endColor = htmlColorToRgba(endColor);
      }
      this._handler && this._handler.setRgbaArr(this._handlerIndex, this._startColor, this._endColor);
    }
    /**
     * Returns ray start position.
     * @public
     * @returns {Vec3}
     */
    getStartPosition() {
      return this._startPosition;
    }
    /**
     * Returns ray end position.
     * @public
     * @returns {Vec3}
     */
    getEndPosition() {
      return this._endPosition;
    }
    /**
     * Sets visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
      this._visibility = visibility;
      this._handler && this._handler.setVisibility(this._handlerIndex, visibility);
    }
    /**
     * Returns visibility.
     * @public
     * @returns {boolean}
     */
    getVisibility() {
      return this._visibility;
    }
    /**
     * Remove from handler.
     * @public
     */
    remove() {
      this._entity = null;
      this._handler && this._handler.remove(this);
    }
    /**
     * Set picking color.
     * @public
     * @param {Vec3} color - Picking color.
     */
    setPickingColor3v(color) {
      this._handler && this._handler.setPickingColorArr(this._handlerIndex, color);
    }
  };
  Ray2.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/entity/Strip.js
  var _tempHigh = new Vec3();
  var _tempLow = new Vec3();
  var Strip = class _Strip {
    constructor(options2 = {}) {
      this.__id = _Strip.__counter__++;
      this.visibility = options2.visibility != void 0 ? options2.visibility : true;
      this.color = new Float32Array([1, 1, 1, 0.5]);
      if (options2.color) {
        let color = createColorRGBA(options2.color);
        this.setColor(color.x, color.y, color.z, color.w);
      }
      if (options2.opacity) {
        this.setOpacity(options2.opacity);
      }
      this._renderNode = null;
      this._entity = null;
      this._verticesHighBuffer = null;
      this._verticesLowBuffer = null;
      this._indexBuffer = null;
      this._verticesHigh = [];
      this._verticesLow = [];
      this._indexes = [];
      this._path = [];
      this._pickingColor = new Float32Array(4);
      this._gridSize = 1;
      this._handler = null;
      this._handlerIndex = -1;
      if (options2.path) {
        this.setPath(options2.path);
      }
    }
    /**
     * Assign picking color.
     * @public
     * @param {Vec3} color - Picking RGB color.
     */
    setPickingColor3v(color) {
      this._pickingColor[0] = color.x / 255;
      this._pickingColor[1] = color.y / 255;
      this._pickingColor[2] = color.z / 255;
      this._pickingColor[3] = 1;
    }
    /**
     * Clears object
     * @public
     */
    clear() {
      this._path.length = 0;
      this._path = [];
      this._verticesHigh.length = 0;
      this._verticesHigh = [];
      this._verticesLow.length = 0;
      this._verticesLow = [];
      this._indexes.length = 0;
      this._indexes = [];
      this._deleteBuffers();
    }
    /**
     * Sets RGBA color. Each channel from 0.0 to 1.0.
     * @public
     * @param {Vec4} color - RGBA vector.
     */
    setColor4v(color) {
      this.setColor(color.x, color.y, color.z, color.w);
    }
    /**
     * Sets strip color.
     * @public
     * @param {string} color - HTML style color.
     */
    setColorHTML(color) {
      this.setColor4v(htmlColorToRgba(color));
    }
    setColor(r8, g4, b4, a6) {
      a6 = a6 || this.color[3];
      this.color[0] = r8;
      this.color[1] = g4;
      this.color[2] = b4;
      this.color[3] = a6;
    }
    /**
     * Set strip opacity.
     * @public
     * @param {number} opacity - opacity.
     */
    setOpacity(opacity) {
      this.color[3] = opacity || 0;
    }
    /**
     * Sets cloud visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
      this.visibility = visibility;
    }
    /**
     * @return {boolean} Strip visibility.
     */
    getVisibility() {
      return this.visibility;
    }
    /**
     * Assign rendering scene node.
     * @public
     * @param {RenderNode}  renderNode - Assigned render node.
     */
    setRenderNode(renderNode) {
      this._renderNode = renderNode;
      this._createBuffers();
    }
    /**
     * Removes from entity.
     * @public
     */
    remove() {
      this._entity = null;
      this._handler && this._handler.remove(this);
    }
    draw() {
      if (this.visibility && this._verticesHigh.length) {
        let r8 = this._renderNode.renderer;
        let gl = r8.handler.gl;
        let sh = r8.handler.programs.strip, p4 = sh._program, sha = p4.attributes, shu = p4.uniforms;
        sh.activate();
        gl.disable(gl.CULL_FACE);
        gl.uniformMatrix4fv(shu.viewMatrix, false, r8.activeCamera.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, r8.activeCamera.getProjectionMatrix());
        gl.uniform3fv(shu.eyePositionHigh, r8.activeCamera.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, r8.activeCamera.eyeLow);
        gl.uniform4fv(shu.uColor, this.color);
        gl.uniform1f(shu.uOpacity, this._entity._entityCollection._fadingOpacity);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesHighBuffer);
        gl.vertexAttribPointer(sha.aVertexPositionHigh, this._verticesHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesLowBuffer);
        gl.vertexAttribPointer(sha.aVertexPositionLow, this._verticesLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.drawElements(r8.handler.gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
        gl.enable(gl.CULL_FACE);
      }
    }
    drawPicking() {
      if (this.visibility && this._verticesHigh.length) {
        let r8 = this._renderNode.renderer;
        let gl = r8.handler.gl;
        let sh = r8.handler.programs.strip, p4 = sh._program, sha = p4.attributes, shu = p4.uniforms;
        sh.activate();
        gl.disable(gl.CULL_FACE);
        gl.uniformMatrix4fv(shu.viewMatrix, false, r8.activeCamera.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, r8.activeCamera.getProjectionMatrix());
        gl.uniform3fv(shu.eyePositionHigh, r8.activeCamera.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, r8.activeCamera.eyeLow);
        gl.uniform1f(shu.uOpacity, this._entity._entityCollection._fadingOpacity != 0 ? 1 : 0);
        gl.uniform4fv(shu.uColor, this._pickingColor);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesHighBuffer);
        gl.vertexAttribPointer(sha.aVertexPositionHigh, this._verticesHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesLowBuffer);
        gl.vertexAttribPointer(sha.aVertexPositionLow, this._verticesLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.drawElements(r8.handler.gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
        gl.enable(gl.CULL_FACE);
      }
    }
    /**
     * Delete buffers
     * @public
     */
    _deleteBuffers() {
      if (this._renderNode && this._renderNode.renderer) {
        let r8 = this._renderNode.renderer, gl = r8.handler.gl;
        gl.deleteBuffer(this._indexBuffer);
        gl.deleteBuffer(this._verticesHighBuffer);
        gl.deleteBuffer(this._verticesLowBuffer);
      }
      this._verticesHighBuffer = null;
      this._verticesLowBuffer = null;
      this._indexBuffer = null;
    }
    _createBuffers() {
      if (this._renderNode && this._renderNode.renderer && this._renderNode.renderer.isInitialized()) {
        let gl = this._renderNode.renderer.handler.gl;
        gl.deleteBuffer(this._indexBuffer);
        gl.deleteBuffer(this._verticesHighBuffer);
        gl.deleteBuffer(this._verticesLowBuffer);
        this._verticesHighBuffer = this._renderNode.renderer.handler.createArrayBuffer(new Float32Array(this._verticesHigh), 3, this._verticesHigh.length / 3);
        this._verticesLowBuffer = this._renderNode.renderer.handler.createArrayBuffer(new Float32Array(this._verticesLow), 3, this._verticesLow.length / 3);
        this._indexBuffer = this._renderNode.renderer.handler.createElementArrayBuffer(new Uint32Array(this._indexes), 1, this._indexes.length);
      }
    }
    addEdge3v(p22, p32) {
      let length = this._path.length;
      if (length === 0) {
        this._path.push([p22.clone(), p32.clone()]);
      } else {
        let p0 = this._path[length - 1][0], p1 = this._path[length - 1][1];
        this._path.push([p22.clone(), p32.clone()]);
        let vHigh = this._verticesHigh, vLow = this._verticesLow;
        let gs = this._gridSize, gs1 = gs + 1;
        let p4 = new Vec3();
        let last = this._verticesHigh.length / 3, ind = last;
        let d4 = Math.abs(p0.sub(p1).normal().dot(p22.sub(p0).normal()));
        for (let i9 = 0; i9 < gs1; i9++) {
          let di = i9 / gs;
          let p02 = p0.lerp(p22, di), p13 = p1.lerp(p32, di);
          for (let j2 = 0; j2 < gs1; j2++) {
            let dj = j2 / gs;
            let p01 = p0.lerp(p1, dj), p23 = p22.lerp(p32, dj);
            if (d4 !== 1) {
              new Line3(p02, p13).intersects(new Line3(p01, p23), p4);
            } else {
              p4 = p23;
            }
            ind = last + i9 * gs1 + j2;
            Vec3.doubleToTwoFloats(p4, _tempHigh, _tempLow);
            let ind3 = ind * 3;
            vHigh[ind3] = _tempHigh.x;
            vHigh[ind3 + 1] = _tempHigh.y;
            vHigh[ind3 + 2] = _tempHigh.z;
            vLow[ind3] = _tempLow.x;
            vLow[ind3 + 1] = _tempLow.y;
            vLow[ind3 + 2] = _tempLow.z;
            if (i9 < gs) {
              this._indexes.push(ind, ind + gs1);
            }
          }
          if (i9 < gs) {
            this._indexes.push(ind + gs1, ind + 1);
          }
        }
        this._createBuffers();
      }
    }
    setEdge3v(p22, p32, index) {
      if (index === this._path.length) {
        this.addEdge3v(p22, p32);
        return;
      }
      if (this._path[index]) {
        this._path[index][0] = p22;
        this._path[index][1] = p32;
        if (this._path.length > 1) {
          let gs = this._gridSize, gs1 = gs + 1;
          let vSize = gs1 * gs1;
          let p4 = new Vec3();
          let vHigh = this._verticesHigh, vLow = this._verticesLow;
          if (index === this._path.length - 1) {
            let p0 = this._path[index - 1][0], p1 = this._path[index - 1][1];
            let prev = this._verticesHigh.length / 3 - vSize, ind = prev;
            let d4 = Math.abs(p0.sub(p1).normal().dot(p22.sub(p0).normal()));
            for (let i9 = 0; i9 < gs1; i9++) {
              let di = i9 / gs;
              let p02 = p0.lerp(p22, di), p13 = p1.lerp(p32, di);
              for (let j2 = 0; j2 < gs1; j2++) {
                let dj = j2 / gs;
                let p01 = p0.lerp(p1, dj), p23 = p22.lerp(p32, dj);
                if (d4 !== 1) {
                  new Line3(p02, p13).intersects(new Line3(p01, p23), p4);
                } else {
                  p4 = p23;
                }
                ind = prev + i9 * gs1 + j2;
                Vec3.doubleToTwoFloats(p4, _tempHigh, _tempLow);
                let ind3 = ind * 3;
                vHigh[ind3] = _tempHigh.x;
                vHigh[ind3 + 1] = _tempHigh.y;
                vHigh[ind3 + 2] = _tempHigh.z;
                vLow[ind3] = _tempLow.x;
                vLow[ind3 + 1] = _tempLow.y;
                vLow[ind3 + 2] = _tempLow.z;
              }
            }
          } else if (index === 0) {
            let ind = 0;
            let p0 = p22, p1 = p32;
            p22 = this._path[1][0];
            p32 = this._path[1][1];
            for (let i9 = 0; i9 < gs1; i9++) {
              let di = i9 / gs;
              let p02 = p0.lerp(p22, di), p13 = p1.lerp(p32, di);
              for (let j2 = 0; j2 < gs1; j2++) {
                let dj = j2 / gs;
                let p01 = p0.lerp(p1, dj), p23 = p22.lerp(p32, dj);
                new Line3(p02, p13).intersects(new Line3(p01, p23), p4);
                ind = i9 * gs1 + j2;
                Vec3.doubleToTwoFloats(p4, _tempHigh, _tempLow);
                let ind3 = ind * 3;
                vHigh[ind3] = _tempHigh.x;
                vHigh[ind3 + 1] = _tempHigh.y;
                vHigh[ind3 + 2] = _tempHigh.z;
                vLow[ind3] = _tempLow.x;
                vLow[ind3 + 1] = _tempLow.y;
                vLow[ind3 + 2] = _tempLow.z;
              }
            }
          } else if (index > 0 && index < this._path.length) {
            let p0 = this._path[index - 1][0], p1 = this._path[index - 1][1];
            let p42 = this._path[index + 1][0], p5 = this._path[index + 1][1];
            let next = index * vSize, prev = (index - 1) * vSize, ind = prev;
            for (let i9 = 0; i9 < gs1; i9++) {
              let di = i9 / gs;
              let p02 = p0.lerp(p22, di), p35 = p32.lerp(p5, di), p24 = p22.lerp(p42, di), p13 = p1.lerp(p32, di);
              for (let j2 = 0; j2 < gs1; j2++) {
                let dj = j2 / gs;
                let p01 = p0.lerp(p1, dj), p23 = p22.lerp(p32, dj);
                new Line3(p02, p13).intersects(new Line3(p01, p23), p4);
                let ij = i9 * gs1 + j2;
                ind = prev + ij;
                Vec3.doubleToTwoFloats(p4, _tempHigh, _tempLow);
                let ind3 = ind * 3;
                vHigh[ind3] = _tempHigh.x;
                vHigh[ind3 + 1] = _tempHigh.y;
                vHigh[ind3 + 2] = _tempHigh.z;
                vLow[ind3] = _tempLow.x;
                vLow[ind3 + 1] = _tempLow.y;
                vLow[ind3 + 2] = _tempLow.z;
                let p45 = p42.lerp(p5, dj);
                p23 = p22.lerp(p32, dj);
                new Line3(p24, p35).intersects(new Line3(p23, p45), p4);
                ind = next + ij;
                Vec3.doubleToTwoFloats(p4, _tempHigh, _tempLow);
                ind3 = ind * 3;
                vHigh[ind3] = _tempHigh.x;
                vHigh[ind3 + 1] = _tempHigh.y;
                vHigh[ind3 + 2] = _tempHigh.z;
                vLow[ind3] = _tempLow.x;
                vLow[ind3 + 1] = _tempLow.y;
                vLow[ind3 + 2] = _tempLow.z;
              }
            }
          }
          this._createBuffers();
        }
      } else {
        console.warn(`strip index ${index} is out of range`);
      }
    }
    removeEdge(index) {
      this._path.splice(index, 1);
      this.setPath([].concat(this._path));
    }
    setGridSize(gridSize) {
      this._gridSize = gridSize;
      this.setPath([].concat(this._path));
    }
    getPath() {
      return this._path;
    }
    setPath(path) {
      this._verticesHigh = [];
      this._verticesLow = [];
      this._indexes = [];
      this._path = [];
      for (let i9 = 0; i9 < path.length; i9++) {
        let p0 = path[i9][0], p1 = path[i9][1];
        if (p0 instanceof Array) {
          p0 = new Vec3(p0[0], p0[1], p0[2]);
        }
        if (p1 instanceof Array) {
          p1 = new Vec3(p1[0], p1[1], p1[2]);
        }
        this.addEdge3v(p0, p1);
      }
    }
    insertEdge3v(p0, p1, index) {
      if (index < this._path.length) {
        let p4 = [].concat(this._path);
        p4.splice(index, 0, [p0, p1]);
        this.setPath(p4);
      } else if (index === this._path.length) {
        this.addEdge3v(p0, p1);
      }
    }
  };
  Strip.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/entity/Entity.js
  var Entity = class _Entity {
    constructor(options2 = {}) {
      options2.properties = options2.properties || {};
      this.__id = _Entity.__counter__++;
      this.properties = options2.properties || {};
      this.properties.name = this.properties.name != void 0 ? this.properties.name : "";
      this.childrenNodes = [];
      this.parent = null;
      this._cartesian = createVector3(options2.cartesian);
      this._lonLat = createLonLat(options2.lonlat);
      this._lonLatMerc = new LonLat();
      this._altitude = options2.altitude || 0;
      this._visibility = options2.visibility != void 0 ? options2.visibility : true;
      this._entityCollection = null;
      this._entityCollectionIndex = -1;
      this._layer = null;
      this._layerIndex = -1;
      this._pickingColor = new Vec3(0, 0, 0);
      this._featureConstructorArray = {
        billboard: [Billboard, this.setBillboard],
        label: [Label, this.setLabel],
        polyline: [Polyline, this.setPolyline],
        pointCloud: [PointCloud, this.setPointCloud],
        geometry: [Geometry, this.setGeometry],
        geoObject: [GeoObject, this.setGeoObject],
        strip: [Strip, this.setStrip],
        ray: [Ray2, this.setRay]
      };
      this.billboard = this._createOptionFeature("billboard", options2.billboard);
      this.label = this._createOptionFeature("label", options2.label);
      this.polyline = this._createOptionFeature("polyline", options2.polyline);
      this.ray = this._createOptionFeature("ray", options2.ray);
      this.pointCloud = this._createOptionFeature("pointCloud", options2.pointCloud);
      this.geometry = this._createOptionFeature("geometry", options2.geometry);
      this.geoObject = this._createOptionFeature("geoObject", options2.geoObject);
      this.strip = this._createOptionFeature("strip", options2.strip);
    }
    get id() {
      return this.__id;
    }
    isEqual(entity) {
      return this.__id === entity.__id;
    }
    get layerIndex() {
      return this._layerIndex;
    }
    get instanceName() {
      return "Entity";
    }
    _createOptionFeature(featureName, options2) {
      if (options2) {
        let c7 = this._featureConstructorArray[featureName];
        return c7[1].call(this, new c7[0](options2));
      }
      return null;
    }
    getCollectionIndex() {
      return this._entityCollectionIndex;
    }
    /**
     * Adds current entity into the specified entity collection.
     * @public
     * @param {EntityCollection | Vector} collection - Specified entity collection or vector layer.
     * @param {Boolean} [rightNow=false] - Entity insertion option for vector layer.
     * @returns {Entity} - This object.
     */
    addTo(collection, rightNow = false) {
      collection.add(this, rightNow);
      return this;
    }
    /**
     * Removes current entity from collection and layer.
     * @public
     */
    remove() {
      this._layer && this._layer.removeEntity(this);
      this._entityCollection && this._entityCollection.removeEntity(this);
    }
    /**
     * Sets the entity visibility.
     * @public
     * @param {boolean} visibility - Entity visibility.
     */
    setVisibility(visibility) {
      this._visibility = visibility;
      this.billboard && this.billboard.setVisibility(visibility);
      this.geoObject && this.geoObject.setVisibility(visibility);
      this.label && this.label.setVisibility(visibility);
      this.polyline && this.polyline.setVisibility(visibility);
      this.ray && this.ray.setVisibility(visibility);
      this.geometry && this.geometry.setVisibility(visibility);
      for (let i9 = 0; i9 < this.childrenNodes.length; i9++) {
        this.childrenNodes[i9].setVisibility(visibility);
      }
    }
    /**
     * Returns entity visibility.
     * @public
     * @returns {boolean} -
     */
    getVisibility() {
      return this._visibility;
    }
    /**
     * Sets entity cartesian position.
     * @public
     * @param {Vec3} cartesian - Cartesian position in 3d space.
     */
    setCartesian3v(cartesian) {
      this.setCartesian(cartesian.x, cartesian.y, cartesian.z);
    }
    /**
     * Sets entity cartesian position.
     * @public
     * @param {number} x - 3d space X - position.
     * @param {number} y - 3d space Y - position.
     * @param {number} z - 3d space Z - position.
     */
    setCartesian(x3, y4, z3) {
      let p4 = this._cartesian;
      p4.x = x3 || 0;
      p4.y = y4 || 0;
      p4.z = z3 || 0;
      this.billboard && this.billboard.setPosition3v(p4);
      this.geoObject && this.geoObject.setPosition3v(p4);
      this.label && this.label.setPosition3v(p4);
      for (let i9 = 0; i9 < this.childrenNodes.length; i9++) {
        this.childrenNodes[i9].setCartesian(x3, y4, z3);
      }
      let ec = this._entityCollection;
      if (ec && ec.renderNode && ec.renderNode.ellipsoid) {
        this._lonLat = ec.renderNode.ellipsoid.cartesianToLonLat(p4);
        if (Math.abs(this._lonLat.lat) < MAX_LAT) {
          this._lonLatMerc = this._lonLat.forwardMercator();
        } else {
          this._lonLatMerc.lon = this._lonLatMerc.lat = this._lonLatMerc.height = 0;
        }
      }
    }
    /**
     * Sets entity cartesian position without event dispatching.
     * @public
     * @param {Vec3} cartesian - Cartesian position in 3d space.
     * @param {boolean} skipLonLat - skip geodetic calculation.
     */
    _setCartesian3vSilent(cartesian, skipLonLat = false) {
      let p4 = this._cartesian;
      p4.x = cartesian.x || 0;
      p4.y = cartesian.y || 0;
      p4.z = cartesian.z || 0;
      this.billboard && this.billboard.setPosition3v(p4);
      this.geoObject && this.geoObject.setPosition3v(p4);
      this.label && this.label.setPosition3v(p4);
      for (let i9 = 0; i9 < this.childrenNodes.length; i9++) {
        this.childrenNodes[i9].setCartesian(p4.x, p4.y, p4.z);
      }
      let ec = this._entityCollection;
      if (!skipLonLat && ec && ec.renderNode && ec.renderNode.ellipsoid) {
        this._lonLat = ec.renderNode.ellipsoid.cartesianToLonLat(p4);
        if (Math.abs(this._lonLat.lat) < MAX_LAT) {
          this._lonLatMerc = this._lonLat.forwardMercator();
        } else {
        }
      }
    }
    /**
     * Gets entity geodetic coordinates.
     * @public
     * @returns {LonLat} -
     */
    getLonLat() {
      return this._lonLat.clone();
    }
    /**
     * Sets geodetic coordinates of the entity point object.
     * @public
     * @param {LonLat} lonlat - WGS84 coordinates.
     */
    setLonLat(lonlat) {
      let l4 = this._lonLat;
      l4.lon = lonlat.lon;
      l4.lat = lonlat.lat;
      l4.height = lonlat.height;
      let ec = this._entityCollection;
      if (ec && ec.renderNode && ec.renderNode.ellipsoid) {
        if (Math.abs(l4.lat) < MAX_LAT) {
          this._lonLatMerc = l4.forwardMercator();
        } else {
        }
        ec.renderNode.ellipsoid.lonLatToCartesianRes(l4, this._cartesian);
        this.setCartesian3v(this._cartesian);
      }
    }
    /**
     * Sets geodetic coordinates of the entity point object.
     * @public
     * @param {number} lon - Longitude.
     * @param {number} lat - Latitude
     * @param {number} [height] - Height
     */
    setLonLat2(lon, lat, height) {
      let l4 = this._lonLat;
      l4.lon = lon;
      l4.lat = lat;
      l4.height = height != void 0 ? height : l4.height;
      let ec = this._entityCollection;
      if (ec && ec.renderNode && ec.renderNode.ellipsoid) {
        if (Math.abs(l4.lat) < MAX_LAT) {
          this._lonLatMerc = l4.forwardMercator();
        } else {
          this._lonLatMerc.lon = this._lonLatMerc.lat = this._lonLatMerc.height = 0;
        }
        ec.renderNode.ellipsoid.lonLatToCartesianRes(l4, this._cartesian);
        this.setCartesian3v(this._cartesian);
      }
    }
    /**
     * Sets entity altitude over the planet.
     * @public
     * @param {number} altitude - Altitude.
     */
    setAltitude(altitude) {
      this._altitude = altitude;
    }
    /**
     * Sets entity altitude over the planet.
     * @public
     * @return {number} Altitude.
     */
    getAltitude() {
      return this._altitude;
    }
    /**
     * Returns cartesian position.
     * @public
     * @returns {Vec3} -
     */
    getCartesian() {
      return this._cartesian.clone();
    }
    /**
     * Sets entity billboard.
     * @public
     * @param {Billboard} billboard - Billboard object.
     * @returns {Billboard} -
     */
    setBillboard(billboard) {
      if (this.billboard) {
        this.billboard.remove();
      }
      this.billboard = billboard;
      this.billboard._entity = this;
      this.billboard.setPosition3v(this._cartesian);
      this.billboard.setVisibility(this._visibility);
      this._entityCollection && this._entityCollection.billboardHandler.add(billboard);
      return billboard;
    }
    /**
     * Sets entity label.
     * @public
     * @param {Label} label - Text label.
     * @returns {Label} -
     */
    setLabel(label) {
      if (this.label) {
        this.label.remove();
      }
      this.label = label;
      this.label._entity = this;
      this.label.setPosition3v(this._cartesian);
      this.label.setVisibility(this._visibility);
      this._entityCollection && this._entityCollection.labelHandler.add(label);
      return label;
    }
    /**
     * Sets entity ray.
     * @public
     * @param {Ray} ray - Ray object.
     * @returns {Ray} -
     */
    setRay(ray) {
      if (this.ray) {
        this.ray.remove();
      }
      this.ray = ray;
      this.ray._entity = this;
      this.ray.setVisibility(this._visibility);
      this._entityCollection && this._entityCollection.rayHandler.add(ray);
      return ray;
    }
    /**
     * Sets entity polyline.
     * @public
     * @param {Polyline} polyline - Polyline object.
     * @returns {Polyline} -
     */
    setPolyline(polyline) {
      if (this.polyline) {
        this.polyline.remove();
      }
      this.polyline = polyline;
      this.polyline._entity = this;
      this.polyline.setVisibility(this._visibility);
      this._entityCollection && this._entityCollection.polylineHandler.add(polyline);
      return polyline;
    }
    /**
     * Sets entity pointCloud.
     * @public
     * @param {PointCloud} pointCloud - PointCloud object.
     * @returns {PointCloud} -
     */
    setPointCloud(pointCloud2) {
      if (this.pointCloud) {
        this.pointCloud.remove();
      }
      this.pointCloud = pointCloud2;
      this.pointCloud._entity = this;
      this.pointCloud.setVisibility(this._visibility);
      this._entityCollection && this._entityCollection.pointCloudHandler.add(pointCloud2);
      return pointCloud2;
    }
    /**
     * Sets entity geometry.
     * @public
     * @param {Geometry} geometry - Geometry object.
     * @returns {Geometry} -
     */
    setGeometry(geometry) {
      if (this.geometry) {
        this.geometry.remove();
      }
      this.geometry = geometry;
      this.geometry._entity = this;
      this.geometry.setVisibility(this._visibility);
      let layer = this._layer;
      if (this._layer) {
        this._layer.removeEntity(this);
      }
      layer && layer.add(this);
      return geometry;
    }
    /**
     * Sets entity geoObject.
     * @public
     * @param {GeoObject} geoObject - GeoObject.
     * @returns {GeoObject} -
     */
    setGeoObject(geoObject) {
      if (this.geoObject) {
        this.geoObject.remove();
      }
      this.geoObject = geoObject;
      this.geoObject._entity = this;
      this.geoObject.setPosition3v(this._cartesian);
      this.geoObject.setVisibility(this._visibility);
      this._entityCollection && this._entityCollection.geoObjectHandler.add(geoObject);
      return geoObject;
    }
    /**
     * Sets entity strip.
     * @public
     * @param {Strip} strip - Strip object.
     * @returns {Strip} -
     */
    setStrip(strip) {
      if (this.strip) {
        this.strip.remove();
      }
      this.strip = strip;
      this.strip._entity = this;
      this.strip.setVisibility(this._visibility);
      this._entityCollection && this._entityCollection.stripHandler.add(strip);
      return strip;
    }
    get layer() {
      return this._layer;
    }
    get rendererEvents() {
      if (this._layer) {
        return this._layer.events;
      } else if (this._entityCollection) {
        return this._entityCollection.events;
      }
      return null;
    }
    /**
     * Append child entity.
     * @public
     * @param {Entity} entity - Child entity.
     */
    appendChild(entity) {
      entity._entityCollection = this._entityCollection;
      entity._pickingColor = this._pickingColor;
      entity.parent = this;
      this.childrenNodes.push(entity);
      this._entityCollection && this._entityCollection.appendChildEntity(entity);
    }
    /**
     * Appends entity items(billboard, label etc.) picking color.
     * @public
     */
    setPickingColor() {
      let c7 = this._pickingColor;
      this.billboard && this.billboard.setPickingColor3v(c7);
      this.label && this.label.setPickingColor3v(c7);
      this.polyline && this.polyline.setPickingColor3v(c7);
      this.ray && this.ray.setPickingColor3v(c7);
      this.strip && this.strip.setPickingColor3v(c7);
      this.geoObject && this.geoObject.setPickingColor3v(c7);
      for (let i9 = 0; i9 < this.childrenNodes.length; i9++) {
        this.childrenNodes[i9].setPickingColor();
      }
    }
    /**
     * Return geodetic extent.
     * @public
     * @returns {Extent} -
     */
    getExtent() {
      let res;
      let c7 = this._lonLat;
      if (this.billboard || this.label) {
        res = new Extent(new LonLat(c7.lon, c7.lat), new LonLat(c7.lon, c7.lat));
      } else {
        res = new Extent(new LonLat(180, 90), new LonLat(-180, -90));
      }
      let sw = res.southWest, ne = res.northEast;
      if (this.polyline) {
        let e9 = this.polyline.getExtent();
        if (e9.southWest.lon < sw.lon)
          sw.lon = e9.southWest.lon;
        if (e9.southWest.lat < sw.lat)
          sw.lat = e9.southWest.lat;
        if (e9.northEast.lon > ne.lon)
          ne.lon = e9.northEast.lon;
        if (e9.northEast.lat > ne.lat)
          ne.lat = e9.northEast.lat;
      }
      if (this.geometry) {
        let e9 = this.geometry.getExtent();
        if (e9.southWest.lon < sw.lon)
          sw.lon = e9.southWest.lon;
        if (e9.southWest.lat < sw.lat)
          sw.lat = e9.southWest.lat;
        if (e9.northEast.lon > ne.lon)
          ne.lon = e9.northEast.lon;
        if (e9.northEast.lat > ne.lat)
          ne.lat = e9.northEast.lat;
      }
      for (let i9 = 0; i9 < this.childrenNodes.length; i9++) {
        let e9 = this.childrenNodes[i9].getExtent();
        if (e9.southWest.lon < sw.lon)
          sw.lon = e9.southWest.lon;
        if (e9.southWest.lat < sw.lat)
          sw.lat = e9.southWest.lat;
        if (e9.northEast.lon > ne.lon)
          ne.lon = e9.northEast.lon;
        if (e9.northEast.lat > ne.lat)
          ne.lat = e9.northEast.lat;
      }
      return res;
    }
  };
  Entity.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/scene/BaseNode.js
  var BaseNode = class _BaseNode {
    constructor(name) {
      this.__id = _BaseNode.__counter__++;
      this._name = name || `nonameNode:${this.__id}`;
      this.topNode = this;
      this._dictionary = {};
      this._dictionary[this._name] = this;
      this.childNodes = [];
      this.parentNode = null;
    }
    get name() {
      return this._name;
    }
    /**
     * Adds node to the current hierarchy.
     * @public
     * @type {BaseNode}
     */
    addNode(node) {
      if (this.parentNode == null) {
        node.topNode = this;
      } else {
        node.topNode = this.topNode;
      }
      node.parentNode = this;
      node._dictionary = this.topNode._dictionary;
      this.childNodes.push(node);
      this.topNode._dictionary[node.name] = node;
    }
    /**
     * Destroy node.
     * @public
     */
    destroy() {
      for (let i9 = 0; i9 < this.childNodes.length; i9++) {
        this.childNodes[i9].destroy();
      }
      this._clear();
    }
    /**
     * Gets node by name in the current.
     * @public
     * @param {string} name - Node name.
     * @return {RenderNode} Node object in the current node.
     */
    getNodeByName(name) {
      return this._dictionary[name];
    }
    /**
     * Clear current node.
     * @protected
     */
    _clear() {
      this.parentNode = null;
      this.topNode = this;
      this.childNodes.length = 0;
    }
    isEqual(node) {
      return node.__id === this.__id;
    }
  };
  BaseNode.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/scene/RenderNode.js
  var RenderNode = class extends BaseNode {
    constructor(name) {
      super(name);
      this.childNodes = [];
      this.renderer = null;
      this.drawMode = 0;
      this.show = true;
      this._isActive = true;
      this.lightEnabled = false;
      this._lights = [];
      this._lightsNames = [];
      this._lightsPositions = [];
      this._lightsParamsv = [];
      this._lightsParamsf = [];
      this.entityCollections = [];
      this._pickingId = -1;
    }
    /**
     * Adds node to the current hierarchy.
     * @public
     * @type {RenderNode}
     */
    addNode(node) {
      super.addNode(node);
      this.renderer && node.assign(this.renderer);
    }
    /**
     * Assign render node with renderer.
     * @public
     * @param {Renderer} renderer - Render node's renderer.
     */
    assign(renderer) {
      this.renderer = renderer;
      this._pickingId = renderer.addPickingCallback(this, this._entityCollectionPickingCallback);
      this.initialize();
    }
    initialize() {
      if (this.renderer && this.renderer.isInitialized()) {
        for (let i9 = 0; i9 < this.entityCollections.length; i9++) {
          this.entityCollections[i9].bindRenderNode(this);
        }
        this.init();
      }
    }
    init() {
    }
    onremove() {
    }
    remove() {
      let r8 = this.renderer, n7 = this.name;
      if (r8) {
        if (r8.renderNodes[n7] && r8.renderNodes[n7].isEqual(this)) {
          r8.renderNodes[n7] = null;
          delete r8.renderNodes[n7];
        }
        for (let i9 = 0; i9 < r8._renderNodesArr.length; i9++) {
          if (r8._renderNodesArr[i9].isEqual(this)) {
            r8._renderNodesArr.splice(i9, 1);
            break;
          }
        }
        r8.removePickingCallback(this._pickingId);
        this._pickingId = -1;
        this.onremove && this.onremove();
      }
    }
    /**
     * Adds entity collection.
     * @public
     * @param {EntityCollection} entityCollection - Entity collection.
     * @param {boolean} [isHidden] - If it's true that this collection has specific rendering.
     * @returns {RenderNode} -
     */
    addEntityCollection(entityCollection, isHidden) {
      entityCollection.addTo(this, isHidden);
      return this;
    }
    /**
     * Removes entity collection.
     * @public
     * @param {EntityCollection} entityCollection - Entity collection for remove.
     */
    removeEntityCollection(entityCollection) {
      entityCollection.remove();
    }
    /**
     * Adds point light source.
     * @public
     * @param {LightSource} light - Light source.
     * @returns {RenderNode}
     */
    addLight(light) {
      light.addTo(this);
      return this;
    }
    /**
     * Gets light object by its name.
     * @public
     * @param {string} name - Point light name.
     * @returns {LightSource}
     */
    getLightByName(name) {
      let li = this._lightsNames.indexOf(name);
      return this._lights[li];
    }
    /**
     * Removes light source.
     * @public
     * @param {LightSource} light - Light source object.
     */
    removeLight(light) {
      light.remove();
    }
    /**
     * Calls render frame node's callback. Used in renderer.
     * @public
     */
    preDrawNode() {
      this._isActive && this._preDrawNodes();
    }
    /**
     * Calls render frame node's callback. Used in renderer.
     * @public
     */
    drawNode() {
      this._isActive && this._drawNodes();
    }
    /**
     * Gets render node activity.
     * @public
     * @returns {Boolean} -
     */
    isActive() {
      return this._isActive;
    }
    /**
     * Rendering activation.
     * @public
     * @param {boolean} isActive - Activation flag.
     */
    setActive(isActive) {
      this._isActive = isActive;
      if (this.renderer) {
        if (this._isActive && this._pickingId === -1) {
          this._pickingId = this.renderer.addPickingCallback(this, this._entityCollectionPickingCallback);
        } else if (!this._isActive && this._pickingId !== -1) {
          this.renderer.removePickingCallback(this._pickingId);
          this._pickingId = -1;
        }
      }
      for (let i9 = 0; i9 < this.childNodes.length; i9++) {
        this.childNodes[i9].setActive(isActive);
      }
    }
    /**
     * Sets draw mode
     * @public
     * @param {Number} mode - Draw mode, such as gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.LINES etc.
     */
    setDrawMode(mode2) {
      this.drawMode = mode2;
      for (let i9 = 0; i9 < this.childNodes.length; i9++) {
        this.childNodes[i9].setDrawMode(mode2);
      }
    }
    /**
     * IMPORTANT: This function have to be called manually in each render node frame callback, before drawing scene geometry.
     * @public
     */
    transformLights() {
      for (let i9 = 0; i9 < this._lights.length; i9++) {
        let ii = i9 * 3;
        let tp;
        tp = this._lights[i9]._position;
        this._lightsPositions[ii] = tp.x;
        this._lightsPositions[ii + 1] = tp.y;
        this._lightsPositions[ii + 2] = tp.z;
      }
    }
    updateBillboardsTexCoords() {
      for (let i9 = 0; i9 < this.entityCollections.length; i9++) {
        this.entityCollections[i9].billboardHandler.refreshTexCoordsArr();
      }
    }
    // public updateGeoObjectsTexCoords() {
    //     for (let i = 0; i < this.entityCollections.length; i++) {
    //         this.entityCollections[i].geoObjectHandler.refreshTexCoordsArr();
    //     }
    // }
    frame() {
    }
    preFrame() {
    }
    _preDrawNodes() {
      for (let i9 = 0; i9 < this.childNodes.length; i9++) {
        if (this.childNodes[i9]._isActive) {
          this.childNodes[i9]._preDrawNodes();
        }
      }
      if (this.show) {
        this.preFrame();
        this.drawEntityCollections(this.entityCollections);
      }
    }
    _drawNodes() {
      for (let i9 = 0; i9 < this.childNodes.length; i9++) {
        if (this.childNodes[i9]._isActive) {
          this.childNodes[i9]._drawNodes();
        }
      }
      if (this.show) {
        this.frame();
      }
    }
    drawEntityCollections(ec) {
      this.renderer.enqueueEntityCollectionsToDraw(ec);
    }
    /**
     * Draw entity collections picking frame.
     * @public
     * @param {Array<EntityCollection>} ec - Entity collection array.
     */
    drawPickingEntityCollections(ec) {
      if (ec.length) {
        let i9 = ec.length;
        while (i9--) {
          ec[i9]._fadingOpacity && ec[i9].billboardHandler.drawPicking();
        }
        i9 = ec.length;
        while (i9--) {
          ec[i9]._fadingOpacity && ec[i9].geoObjectHandler.drawPicking();
        }
        i9 = ec.length;
        while (i9--) {
          ec[i9]._fadingOpacity && ec[i9].labelHandler.drawPicking();
        }
        i9 = ec.length;
        while (i9--) {
          ec[i9]._fadingOpacity && ec[i9].rayHandler.drawPicking();
        }
        i9 = ec.length;
        while (i9--) {
          ec[i9]._visibility && ec[i9].polylineHandler.drawPicking();
        }
        i9 = ec.length;
        while (i9--) {
          ec[i9]._visibility && ec[i9].stripHandler.drawPicking();
        }
      }
    }
    _entityCollectionPickingCallback() {
      this.drawPickingEntityCollections(this.entityCollections);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/cons.js
  var Cons = class {
    constructor() {
      this._container = document.createElement("div");
      this._container.classList.add("ogConsole");
      this._container.style.display = "none";
      if (document.body) {
        document.body.appendChild(this._container);
      }
      this._visibility = false;
    }
    getVisibility() {
      return this._visibility;
    }
    setVisibility(visibility) {
      if (this._visibility != visibility) {
        this._visibility = visibility;
        if (this._visibility) {
          this.show();
        } else {
          this.hide();
        }
      }
    }
    /**
     * Show console panel.
     * @public
     */
    show() {
      if (!this._container.parentNode) {
        if (document.body) {
          document.body.appendChild(this._container);
        }
      }
      this._container.style.display = "block";
      this._visibility = true;
    }
    /**
     * Hide console panel.
     * @public
     */
    hide() {
      this._container.style.display = "none";
      this._visibility = false;
    }
    /**
     * Adds error text in the console.
     * @public
     * @param {string} str - Error text.
     */
    logErr(str) {
      let d4 = document.createElement("div");
      d4.classList.add("ogConsole-text");
      d4.classList.add("ogConsole-error");
      d4.innerHTML = "error: " + str;
      console.trace(d4.innerHTML);
      this._container.appendChild(d4);
      this.show();
    }
    /**
     * Adds warning text in the console.
     * @public
     * @param {string} str - Warning text.
     */
    logWrn(str) {
      let d4 = document.createElement("div");
      d4.classList.add("ogConsole-text");
      d4.classList.add("ogConsole-warning");
      d4.innerHTML = "warning: " + str;
      console.trace(d4.innerHTML);
      this._container.appendChild(d4);
      this.show();
    }
    /**
     * Adds log text in the console.
     * @public
     * @param {string} str - Log text.
     */
    log(str) {
      let d4 = document.createElement("div");
      d4.classList.add("ogConsole-text");
      d4.innerHTML = str;
      console.trace(str);
      this._container.appendChild(d4);
      this.show();
    }
  };
  var cons = new Cons();

  // frontend/node_modules/@openglobus/og/lib/js/webgl/types.js
  var _declarations = [
    "FLOAT",
    "DOUBLE",
    "BOOL",
    "INT",
    "UINT",
    "VEC2",
    "VEC3",
    "VEC4",
    "DVEC2",
    "DVEC3",
    "DVEC4",
    "BVEC2",
    "BVEC3",
    "BVEC4",
    "IVEC2",
    "IVEC3",
    "IVEC4",
    "UVEC2",
    "UVEC3",
    "UVEC4",
    "MAT2",
    "DMAT2",
    "MAT3",
    "DMAT3",
    "MAT4",
    "DMAT4",
    "MAT2X3",
    "MAT2X4",
    "MAT3X2",
    "MAT3X4",
    "MAT4X2",
    "MAT4X3",
    "DMAT2X3",
    "DMAT2X4",
    "DMAT3X2",
    "DMAT3X4",
    "DMAT4X2",
    "DMAT4X3",
    "SAMPLER1D",
    "SAMPLER2D",
    "SAMPLER3D",
    "SAMPLERCUBE",
    "SAMPLER2DSHADOW",
    "SAMPLER2DARRAY",
    "INTXX",
    "FLOATXX"
  ];
  var types = {};
  for (let i9 = 0; i9 < _declarations.length; i9++) {
    types[_declarations[i9]] = i9;
  }
  var typeStr = {};
  for (let i9 = 0; i9 < _declarations.length; i9++) {
    typeStr[_declarations[i9].toLowerCase()] = types[_declarations[i9]];
  }

  // frontend/node_modules/@openglobus/og/lib/js/webgl/variableHandlers.js
  var variableHandlers = {
    u: [],
    a: []
  };
  variableHandlers.u[types.MAT4] = function(program, variable) {
    program.gl.uniformMatrix4fv(variable._pName, false, variable.value);
  };
  variableHandlers.u[types.MAT3] = function(program, variable) {
    program.gl.uniformMatrix3fv(variable._pName, false, variable.value);
  };
  variableHandlers.u[types.FLOAT] = function(program, variable) {
    program.gl.uniform1f(variable._pName, variable.value);
  };
  variableHandlers.u[types.INT] = function(program, variable) {
    program.gl.uniform1i(variable._pName, variable.value);
  };
  variableHandlers.u[types.VEC2] = function(program, variable) {
    program.gl.uniform2fv(variable._pName, variable.value);
  };
  variableHandlers.u[types.VEC3] = function(program, variable) {
    program.gl.uniform3fv(variable._pName, variable.value);
  };
  variableHandlers.u[types.VEC4] = function(program, variable) {
    program.gl.uniform4fv(variable._pName, variable.value);
  };
  variableHandlers.u[types.SAMPLER2D] = function(program, variable) {
    let pgl = program.gl;
    pgl.activeTexture(pgl.TEXTURE0 + program._textureID);
    pgl.bindTexture(pgl.TEXTURE_2D, variable.value);
    pgl.uniform1i(variable._pName, program._textureID);
    program._textureID++;
  };
  variableHandlers.u[types.SAMPLERCUBE] = function(program, variable) {
    let pgl = program.gl;
    pgl.activeTexture(pgl.TEXTURE0 + program._textureID);
    pgl.bindTexture(pgl.TEXTURE_CUBE_MAP, variable.value);
    pgl.uniform1i(variable._pName, program._textureID);
    program._textureID++;
  };
  variableHandlers.u[types.SAMPLER2DARRAY] = function(program, variable) {
    let value = variable.value;
    let pgl = program.gl, size = value.length;
    let samplerArr = new Int32Array(size);
    for (let i9 = 0; i9 < size; i9++) {
      pgl.activeTexture(pgl.TEXTURE0 + program._textureID + i9);
      pgl.bindTexture(pgl.TEXTURE_2D, value[i9]);
      samplerArr[i9] = i9;
    }
    pgl.uniform1iv(variable._pName, samplerArr);
  };
  variableHandlers.u[types.INTXX] = function(program, variable) {
    program.gl.uniform1iv(variable._pName, variable.value);
  };
  variableHandlers.u[types.FLOATXX] = function(program, variable) {
    program.gl.uniform1fv(variable._pName, variable.value);
  };
  variableHandlers.a[types.FLOAT] = function(program, variable) {
    program.gl.vertexAttrib1f(variable._pName, variable.value);
  };
  variableHandlers.a[types.VEC2] = function(program, variable) {
    program.gl.vertexAttrib2fv(variable._pName, variable.value);
  };
  variableHandlers.a[types.VEC3] = function(program, variable) {
    program.gl.vertexAttrib3fv(variable._pName, variable.value);
  };

  // frontend/node_modules/@openglobus/og/lib/js/webgl/Program.js
  var itemTypes = ["BYTE", "SHORT", "UNSIGNED_BYTE", "UNSIGNED_SHORT", "FLOAT", "HALF_FLOAT"];
  var Program = class _Program {
    constructor(name, material) {
      this.name = name;
      this._attributes = {};
      for (let t9 in material.attributes) {
        if (typeof material.attributes[t9] === "string" || typeof material.attributes[t9] === "number") {
          this._attributes[t9] = { type: material.attributes[t9] };
        } else {
          this._attributes[t9] = material.attributes[t9];
        }
      }
      this._uniforms = {};
      for (let t9 in material.uniforms) {
        if (typeof material.uniforms[t9] === "string" || typeof material.uniforms[t9] === "number") {
          this._uniforms[t9] = { type: material.uniforms[t9] };
        } else {
          this._uniforms[t9] = material.uniforms[t9];
        }
      }
      this.vertexShader = material.vertexShader;
      this.fragmentShader = material.fragmentShader;
      this.gl = null;
      this._variables = {};
      this._p = null;
      this._textureID = 0;
      this._attribArrays = [];
      this._attribDivisor = [];
      this.attributes = {};
      this.uniforms = {};
      this.vertexAttribDivisor = null;
      this.drawElementsInstanced = null;
    }
    /**
     * Bind program buffer.
     * @function
     * @param {Program} program - Used program.
     * @param {Object} variable - Variable represents buffer data.
     */
    static bindBuffer(program, variable) {
      let gl = program.gl;
      if (gl) {
        gl.bindBuffer(gl.ARRAY_BUFFER, variable.value);
        gl.vertexAttribPointer(variable._pName, variable.value.itemSize, variable.itemType, variable.normalized, 0, 0);
      }
    }
    /**
     * Sets the current program frame.
     * @public
     */
    use() {
      this.gl && this.gl.useProgram(this._p);
    }
    /**
     * Sets program variables.
     * @public
     * @param {Object} material - Variables and values object.
     */
    set(material) {
      this._textureID = 0;
      for (let i9 in material) {
        this._variables[i9].value = material[i9];
        this._variables[i9].func(this, this._variables[i9]);
      }
    }
    /**
     * Apply current variables.
     * @public
     */
    apply() {
      this._textureID = 0;
      let v4 = this._variables;
      for (let i9 in v4) {
        v4[i9].func(this, v4[i9]);
      }
    }
    /**
     * Calls drawElements index buffer function.
     * @public
     * @param {number} mode - Draw mode(GL_TRIANGLES, GL_LINESTRING etc.).
     * @param {Object} buffer - Index buffer.
     */
    drawIndexBuffer(mode2, buffer) {
      let gl = this.gl;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
      gl.drawElements(mode2, buffer.numItems, gl.UNSIGNED_SHORT, 0);
    }
    /**
     * Calls drawArrays function.
     * @public
     * @param {number} mode - Draw mode GL_TRIANGLES, GL_LINESTRING, etc.
     * @param {number} numItems - Items to draw
     */
    drawArrays(mode2, numItems) {
      this.gl.drawArrays(mode2, 0, numItems);
    }
    /**
     * Check and log for a shader compile errors and warnings. Returns True - if no errors otherwise returns False.
     * @private
     * @param {WebGLShader} shader - WebGl shader program.
     * @param {string} src - Shader program source.
     * @returns {boolean} -
     */
    _getShaderCompileStatus(shader, src) {
      if (!this.gl)
        return false;
      this.gl.shaderSource(shader, src);
      this.gl.compileShader(shader);
      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        cons.logErr(`Shader program "${this.name}":${this.gl.getShaderInfoLog(shader)}.`);
        return false;
      }
      return true;
    }
    /**
     * Returns compiled vertex shader program pointer.
     * @private
     * @param {string} src - Vertex shader source code.
     * @returns {Object} -
     */
    _createVertexShader(src) {
      if (!this.gl)
        return;
      let shader = this.gl.createShader(this.gl.VERTEX_SHADER);
      if (shader && this._getShaderCompileStatus(shader, src)) {
        return shader;
      }
    }
    /**
     * Returns compiled fragment shader program pointer.
     * @private
     * @param {string} src - Vertex shader source code.
     * @returns {Object} -
     */
    _createFragmentShader(src) {
      if (!this.gl)
        return;
      let shader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
      if (shader && this._getShaderCompileStatus(shader, src)) {
        return shader;
      }
    }
    /**
     * Disable current program vertexAttribArrays.
     * @public
     */
    disableAttribArrays() {
      let gl = this.gl;
      let a6 = this._attribArrays;
      for (let i9 = 0, len = a6.length; i9 < len; i9++) {
        gl.disableVertexAttribArray(a6[i9]);
        this.vertexAttribDivisor(a6[i9], 0);
      }
    }
    /**
     * Enable current program vertexAttribArrays.
     * @public
     */
    enableAttribArrays() {
      let gl = this.gl;
      let a6 = this._attribArrays;
      let d4 = this._attribDivisor;
      for (let i9 = 0, len = a6.length; i9 < len; i9++) {
        gl.enableVertexAttribArray(a6[i9]);
        this.vertexAttribDivisor(a6[i9], d4[i9]);
      }
    }
    // public vertexAttribDivisor(index: number, divisor: number) {
    //     const gl = this.gl!;
    //     gl.vertexAttribDivisor ?
    //         gl.vertexAttribDivisor(index, divisor) :
    //         gl.getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(index, divisor);
    // }
    /**
     * Delete program.
     * @public
     */
    delete() {
      this.gl && this.gl.deleteProgram(this._p);
    }
    /**
     * Creates program.
     * @public
     * @param {Object} gl - WebGl context.
     */
    createProgram(gl) {
      this.gl = gl;
      this._p = this.gl.createProgram();
      if (!this._p)
        return;
      let fs = this._createFragmentShader(this.fragmentShader);
      let vs = this._createVertexShader(this.vertexShader);
      if (!fs || !vs)
        return;
      gl.attachShader(this._p, fs);
      gl.attachShader(this._p, vs);
      gl.linkProgram(this._p);
      if (!this.drawElementsInstanced) {
        if (gl.drawElementsInstanced) {
          this.drawElementsInstanced = gl.drawElementsInstanced.bind(gl);
        } else {
          let ext = gl.getExtension("ANGLE_instanced_arrays");
          if (ext) {
            this.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);
          }
        }
      }
      if (!this.vertexAttribDivisor) {
        if (gl.vertexAttribDivisor) {
          this.vertexAttribDivisor = gl.vertexAttribDivisor.bind(gl);
        } else {
          let ext = gl.getExtension("ANGLE_instanced_arrays");
          if (ext) {
            this.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);
          }
        }
      }
      if (!gl.getProgramParameter(this._p, gl.LINK_STATUS)) {
        cons.logErr(`Shader program "${this.name}": initialization failed. ${gl.getProgramInfoLog(this._p)}.`);
        gl.deleteProgram(this._p);
        return;
      }
      this.use();
      for (let a6 in this._attributes) {
        this._variables[a6] = this._attributes[a6];
        this._attributes[a6].func = _Program.bindBuffer;
        let t9 = this._attributes[a6].itemType;
        let itemTypeStr = t9 ? t9.trim().toUpperCase() : "FLOAT";
        if (itemTypes.indexOf(itemTypeStr) == -1) {
          cons.logErr(`Shader program "${this.name}": attribute '${a6}', item type '${this._attributes[a6].itemType}' not exists.`);
          this._attributes[a6].itemType = gl.FLOAT;
        } else {
          this._attributes[a6].itemType = gl[itemTypeStr];
        }
        this._attributes[a6].normalized = this._attributes[a6].normalized || false;
        this._attributes[a6].divisor = this._attributes[a6].divisor || 0;
        this._p[a6] = gl.getAttribLocation(this._p, a6);
        if (this._p[a6] == void 0) {
          cons.logErr(`Shader program "${this.name}":  attribute '${a6}' not exists.`);
          gl.deleteProgram(this._p);
          return;
        }
        let type = this._attributes[a6].type;
        if (typeof type === "string") {
          type = typeStr[type.trim().toLowerCase()];
        }
        let d4 = this._attributes[a6].divisor;
        if (type === types.MAT4) {
          let loc = this._p[a6];
          this._attribArrays.push(loc, loc + 1, loc + 2, loc + 3);
          this._attribDivisor.push(d4, d4, d4, d4);
        } else {
          this._attribArrays.push(this._p[a6]);
          this._attribDivisor.push(d4);
        }
        gl.enableVertexAttribArray(this._p[a6]);
        this._attributes[a6]._pName = this._p[a6];
        this.attributes[a6] = this._p[a6];
      }
      for (let u4 in this._uniforms) {
        if (typeof this._uniforms[u4].type === "string") {
          let t9 = this._uniforms[u4].type;
          this._uniforms[u4].func = variableHandlers.u[typeStr[t9.trim().toLowerCase()]];
        } else {
          this._uniforms[u4].func = variableHandlers.u[this._uniforms[u4].type];
        }
        this._variables[u4] = this._uniforms[u4];
        this._p[u4] = gl.getUniformLocation(this._p, u4);
        if (this._p[u4] == void 0) {
          cons.logErr(`Shader program "${this.name}": uniform '${u4}' not exists.`);
          gl.deleteProgram(this._p);
          return;
        }
        this._uniforms[u4]._pName = this._p[u4];
        this.uniforms[u4] = this._p[u4];
      }
      gl.detachShader(this._p, fs);
      gl.detachShader(this._p, vs);
      gl.deleteShader(fs);
      gl.deleteShader(vs);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/shaders/billboard.js
  var PROJECT = `vec2 project(vec4 p) {
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }`;
  var ROTATE2D = `mat2 rotate2d(float angle) {
        return mat2(cos(angle), -sin(angle),
           sin(angle), cos(angle));
     }`;
  function billboardPicking() {
    return new Program("billboardPicking", {
      uniforms: {
        viewport: "vec2",
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        planetRadius: "float",
        uScaleByDistance: "vec3",
        opacity: "float",
        depthOffset: "float"
      },
      attributes: {
        a_vertices: "vec2",
        a_positionsHigh: "vec3",
        a_positionsLow: "vec3",
        a_offset: "vec3",
        a_size: "vec2",
        a_rotation: "float",
        a_rgba: "vec4"
      },
      vertexShader: `precision highp float;
            attribute vec2 a_vertices;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute vec2 a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;

            varying vec3 v_rgb;

            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform vec3 uScaleByDistance;
            uniform float opacity;
            uniform float planetRadius;
            uniform vec2 viewport;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT}

            ${ROTATE2D}

            void main() {

                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                v_rgb = a_rgba.rgb;

                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                //vec3 up = vec3( viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1] );
                //vec3 right = vec3( viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0] );

                float scd = (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookDist)) * (1.0 - step(uScaleByDistance[2], lookDist));

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                
                projPos.z += depthOffset + a_offset.z;
                                
                vec2 screenPos = project(projPos);

                vec2 v =  screenPos + rotate2d(a_rotation) * (a_vertices * a_size * scd + a_offset.xy);

                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
      fragmentShader: `precision highp float;
            varying vec3 v_rgb;
            void main () {
                gl_FragColor = vec4(v_rgb, 1.0);
            }`
    });
  }
  function billboard_screen() {
    return new Program("billboard", {
      uniforms: {
        viewport: "vec2",
        u_texture: "sampler2d",
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        planetRadius: "float",
        uScaleByDistance: "vec3",
        opacity: "float",
        depthOffset: "float"
      },
      attributes: {
        a_vertices: "vec2",
        a_texCoord: "vec2",
        a_positionsHigh: "vec3",
        a_positionsLow: "vec3",
        a_offset: "vec3",
        a_size: "vec2",
        a_rotation: "float",
        a_rgba: "vec4"
      },
      vertexShader: `precision highp float;
            attribute vec2 a_vertices;
            attribute vec2 a_texCoord;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute vec2 a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;

            varying vec2 v_texCoords;
            varying vec4 v_rgba;

            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform vec3 uScaleByDistance;
            uniform float opacity;
            uniform float planetRadius;
            uniform vec2 viewport;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT}

            ${ROTATE2D}

            void main() {
                
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                v_texCoords = a_texCoord;
                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                v_rgba = a_rgba;

                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                //vec3 up = vec3( viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1] );
                //vec3 right = vec3( viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0] );

                float scd = (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookDist)) * (1.0 - step(uScaleByDistance[2], lookDist));

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                
                projPos.z += depthOffset + a_offset.z;
                
                vec2 screenPos = project(projPos);

                vec2 v = screenPos + rotate2d(a_rotation) * (a_vertices * a_size * scd + a_offset.xy);

                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
      fragmentShader: `precision highp float;
            uniform sampler2D u_texture;
            varying vec2 v_texCoords;
            varying vec4 v_rgba;
            void main () {
                vec4 color = texture2D(u_texture, v_texCoords);
                if(color.a < 0.1)
                    discard;
                gl_FragColor = color * v_rgba;
            }`
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/entity/BaseBillboardHandler.js
  var PICKINGCOLOR_BUFFER = 0;
  var POSITION_BUFFER = 1;
  var SIZE_BUFFER = 2;
  var OFFSET_BUFFER = 3;
  var RGBA_BUFFER = 4;
  var ROTATION_BUFFER = 5;
  var TEXCOORD_BUFFER = 6;
  var VERTEX_BUFFER = 7;
  var BaseBillboardHandler = class _BaseBillboardHandler {
    constructor(entityCollection) {
      this.__id = _BaseBillboardHandler.__counter__++;
      this.pickingEnabled = true;
      this._entityCollection = entityCollection;
      this._renderer = null;
      this._billboards = [];
      this._positionHighBuffer = null;
      this._positionLowBuffer = null;
      this._sizeBuffer = null;
      this._offsetBuffer = null;
      this._rgbaBuffer = null;
      this._rotationBuffer = null;
      this._texCoordBuffer = null;
      this._vertexBuffer = null;
      this._pickingColorBuffer = null;
      this._texCoordArr = new Float32Array([]);
      this._vertexArr = new Float32Array([]);
      this._positionHighArr = new Float32Array([]);
      this._positionLowArr = new Float32Array([]);
      this._sizeArr = new Float32Array([]);
      this._offsetArr = new Float32Array([]);
      this._rgbaArr = new Float32Array([]);
      this._rotationArr = new Float32Array([]);
      this._pickingColorArr = new Float32Array([]);
      this._buffersUpdateCallbacks = [];
      this._buffersUpdateCallbacks[PICKINGCOLOR_BUFFER] = this.createPickingColorBuffer;
      this._buffersUpdateCallbacks[POSITION_BUFFER] = this.createPositionBuffer;
      this._buffersUpdateCallbacks[SIZE_BUFFER] = this.createSizeBuffer;
      this._buffersUpdateCallbacks[OFFSET_BUFFER] = this.createOffsetBuffer;
      this._buffersUpdateCallbacks[RGBA_BUFFER] = this.createRgbaBuffer;
      this._buffersUpdateCallbacks[ROTATION_BUFFER] = this.createRotationBuffer;
      this._buffersUpdateCallbacks[TEXCOORD_BUFFER] = this.createTexCoordBuffer;
      this._buffersUpdateCallbacks[VERTEX_BUFFER] = this.createVertexBuffer;
      this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    }
    isEqual(handler) {
      return handler && handler.__id === this.__id;
    }
    static concArr(dest, curr) {
      for (let i9 = 0; i9 < curr.length; i9++) {
        dest.push(curr[i9]);
      }
    }
    initProgram() {
      if (this._renderer && this._renderer.handler) {
        if (!this._renderer.handler.programs.billboard) {
          this._renderer.handler.addProgram(billboard_screen());
        }
        if (!this._renderer.handler.programs.billboardPicking) {
          this._renderer.handler.addProgram(billboardPicking());
        }
      }
    }
    setRenderer(renderer) {
      this._renderer = renderer;
      this.initProgram();
    }
    refresh() {
      let i9 = this._changedBuffers.length;
      while (i9--) {
        this._changedBuffers[i9] = true;
      }
    }
    _removeBillboards() {
      let i9 = this._billboards.length;
      while (i9--) {
        let bi = this._billboards[i9];
        bi._handlerIndex = -1;
        bi._handler = null;
        bi._isReady = false;
        bi._lockId = LOCK_FREE;
      }
      this._billboards.length = 0;
      this._billboards = [];
    }
    clear() {
      this._texCoordArr = null;
      this._vertexArr = null;
      this._positionHighArr = null;
      this._positionLowArr = null;
      this._sizeArr = null;
      this._offsetArr = null;
      this._rgbaArr = null;
      this._rotationArr = null;
      this._pickingColorArr = null;
      this._texCoordArr = new Float32Array([]);
      this._vertexArr = new Float32Array([]);
      this._positionHighArr = new Float32Array([]);
      this._positionLowArr = new Float32Array([]);
      this._sizeArr = new Float32Array([]);
      this._offsetArr = new Float32Array([]);
      this._rgbaArr = new Float32Array([]);
      this._rotationArr = new Float32Array([]);
      this._pickingColorArr = new Float32Array([]);
      this._removeBillboards();
      this._deleteBuffers();
      this.refresh();
    }
    _deleteBuffers() {
      if (this._renderer) {
        let gl = this._renderer.handler.gl;
        gl.deleteBuffer(this._positionHighBuffer);
        gl.deleteBuffer(this._positionLowBuffer);
        gl.deleteBuffer(this._sizeBuffer);
        gl.deleteBuffer(this._offsetBuffer);
        gl.deleteBuffer(this._rgbaBuffer);
        gl.deleteBuffer(this._rotationBuffer);
        gl.deleteBuffer(this._vertexBuffer);
        gl.deleteBuffer(this._texCoordBuffer);
        gl.deleteBuffer(this._pickingColorBuffer);
      }
      this._positionHighBuffer = null;
      this._positionLowBuffer = null;
      this._sizeBuffer = null;
      this._offsetBuffer = null;
      this._rgbaBuffer = null;
      this._rotationBuffer = null;
      this._vertexBuffer = null;
      this._texCoordBuffer = null;
      this._pickingColorBuffer = null;
    }
    update() {
      if (this._renderer) {
        let i9 = this._changedBuffers.length;
        while (i9--) {
          if (this._changedBuffers[i9]) {
            this._buffersUpdateCallbacks[i9].call(this);
            this._changedBuffers[i9] = false;
          }
        }
      }
    }
    add(billboard) {
      if (billboard._handlerIndex == -1) {
        billboard._isReady = true;
        billboard._handler = this;
        billboard._handlerIndex = this._billboards.length;
        this._billboards.push(billboard);
      }
    }
    _displayPASS() {
      let r8 = this._renderer;
      let h8 = r8.handler;
      h8.programs.billboard.activate();
      let sh = h8.programs.billboard._program;
      let sha = sh.attributes, shu = sh.uniforms;
      let gl = h8.gl, ec = this._entityCollection;
      gl.disable(gl.CULL_FACE);
      gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
      gl.uniform1i(shu.u_texture, 0);
      gl.uniformMatrix4fv(shu.viewMatrix, false, r8.activeCamera.getViewMatrix());
      gl.uniformMatrix4fv(shu.projectionMatrix, false, r8.activeCamera.getProjectionMatrix());
      gl.uniform3fv(shu.eyePositionHigh, r8.activeCamera.eyeHigh);
      gl.uniform3fv(shu.eyePositionLow, r8.activeCamera.eyeLow);
      gl.uniform3fv(shu.uScaleByDistance, ec.scaleByDistance);
      gl.uniform1f(shu.opacity, ec._fadingOpacity);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
      gl.vertexAttribPointer(sha.a_texCoord, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
      gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
      gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer);
      gl.vertexAttribPointer(sha.a_rgba, this._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
      gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
      gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.uniform1f(shu.planetRadius, ec.renderNode._planetRadius2 || 0);
      gl.uniform2fv(shu.viewport, [h8.canvas.clientWidth, h8.canvas.clientHeight]);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
      gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
      gl.enable(gl.CULL_FACE);
    }
    _pickingPASS() {
      let r8 = this._renderer;
      let h8 = r8.handler;
      h8.programs.billboardPicking.activate();
      let sh = h8.programs.billboardPicking._program;
      let sha = sh.attributes, shu = sh.uniforms;
      let gl = h8.gl, ec = this._entityCollection;
      gl.disable(gl.CULL_FACE);
      gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
      gl.uniformMatrix4fv(shu.viewMatrix, false, r8.activeCamera.getViewMatrix());
      gl.uniformMatrix4fv(shu.projectionMatrix, false, r8.activeCamera.getProjectionMatrix());
      gl.uniform3fv(shu.eyePositionHigh, r8.activeCamera.eyeHigh);
      gl.uniform3fv(shu.eyePositionLow, r8.activeCamera.eyeLow);
      gl.uniform3fv(shu.uScaleByDistance, ec.scaleByDistance);
      gl.uniform1f(shu.opacity, ec._fadingOpacity);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
      gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
      gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
      gl.vertexAttribPointer(sha.a_rgba, this._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
      gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
      gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.uniform1f(shu.planetRadius, ec.renderNode._planetRadius2 || 0);
      gl.uniform2fv(shu.viewport, [h8.canvas.clientWidth, h8.canvas.clientHeight]);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
      gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
      gl.enable(gl.CULL_FACE);
    }
    draw() {
      if (this._billboards.length) {
        this.update();
        this._displayPASS();
      }
    }
    drawPicking() {
      if (this._billboards.length && this.pickingEnabled) {
        this._pickingPASS();
      }
    }
    reindexBillboardsArray(startIndex) {
      let b4 = this._billboards;
      for (let i9 = startIndex; i9 < b4.length; i9++) {
        b4[i9]._handlerIndex = i9;
      }
    }
    _removeBillboard(billboard) {
      let bi = billboard._handlerIndex;
      this._billboards.splice(bi, 1);
      let i9 = bi * 24;
      this._rgbaArr = spliceTypedArray(this._rgbaArr, i9, 24);
      i9 = bi * 18;
      this._positionHighArr = spliceTypedArray(this._positionHighArr, i9, 18);
      this._positionLowArr = spliceTypedArray(this._positionLowArr, i9, 18);
      this._offsetArr = spliceTypedArray(this._offsetArr, i9, 18);
      this._pickingColorArr = spliceTypedArray(this._pickingColorArr, i9, 18);
      i9 = bi * 12;
      this._vertexArr = spliceTypedArray(this._vertexArr, i9, 12);
      this._sizeArr = spliceTypedArray(this._sizeArr, i9, 12);
      this._texCoordArr = spliceTypedArray(this._texCoordArr, i9, 12);
      i9 = bi * 6;
      this._rotationArr = spliceTypedArray(this._rotationArr, i9, 6);
      this.reindexBillboardsArray(bi);
      this.refresh();
      billboard._handlerIndex = -1;
      billboard._handler = null;
      billboard._isReady = false;
      billboard._lockId = LOCK_FREE;
    }
    setAlignedAxisArr(index, alignedAxis) {
    }
    remove(billboard) {
      if (billboard._handler) {
        if (billboard._isReady && this.__id === billboard._handler.__id) {
          this._removeBillboard(billboard);
        } else {
          billboard._handler = null;
        }
      }
    }
    setPositionArr(index, positionHigh, positionLow) {
      let i9 = index * 18;
      let a6 = this._positionHighArr, x3 = positionHigh.x, y4 = positionHigh.y, z3 = positionHigh.z;
      a6[i9] = x3;
      a6[i9 + 1] = y4;
      a6[i9 + 2] = z3;
      a6[i9 + 3] = x3;
      a6[i9 + 4] = y4;
      a6[i9 + 5] = z3;
      a6[i9 + 6] = x3;
      a6[i9 + 7] = y4;
      a6[i9 + 8] = z3;
      a6[i9 + 9] = x3;
      a6[i9 + 10] = y4;
      a6[i9 + 11] = z3;
      a6[i9 + 12] = x3;
      a6[i9 + 13] = y4;
      a6[i9 + 14] = z3;
      a6[i9 + 15] = x3;
      a6[i9 + 16] = y4;
      a6[i9 + 17] = z3;
      a6 = this._positionLowArr;
      x3 = positionLow.x;
      y4 = positionLow.y;
      z3 = positionLow.z;
      a6[i9] = x3;
      a6[i9 + 1] = y4;
      a6[i9 + 2] = z3;
      a6[i9 + 3] = x3;
      a6[i9 + 4] = y4;
      a6[i9 + 5] = z3;
      a6[i9 + 6] = x3;
      a6[i9 + 7] = y4;
      a6[i9 + 8] = z3;
      a6[i9 + 9] = x3;
      a6[i9 + 10] = y4;
      a6[i9 + 11] = z3;
      a6[i9 + 12] = x3;
      a6[i9 + 13] = y4;
      a6[i9 + 14] = z3;
      a6[i9 + 15] = x3;
      a6[i9 + 16] = y4;
      a6[i9 + 17] = z3;
      this._changedBuffers[POSITION_BUFFER] = true;
    }
    setPickingColorArr(index, color) {
      let i9 = index * 18;
      let a6 = this._pickingColorArr, x3 = color.x / 255, y4 = color.y / 255, z3 = color.z / 255;
      a6[i9] = x3;
      a6[i9 + 1] = y4;
      a6[i9 + 2] = z3;
      a6[i9 + 3] = x3;
      a6[i9 + 4] = y4;
      a6[i9 + 5] = z3;
      a6[i9 + 6] = x3;
      a6[i9 + 7] = y4;
      a6[i9 + 8] = z3;
      a6[i9 + 9] = x3;
      a6[i9 + 10] = y4;
      a6[i9 + 11] = z3;
      a6[i9 + 12] = x3;
      a6[i9 + 13] = y4;
      a6[i9 + 14] = z3;
      a6[i9 + 15] = x3;
      a6[i9 + 16] = y4;
      a6[i9 + 17] = z3;
      this._changedBuffers[PICKINGCOLOR_BUFFER] = true;
    }
    setSizeArr(index, width, height) {
      let i9 = index * 12;
      let a6 = this._sizeArr, x3 = width, y4 = height;
      a6[i9] = x3;
      a6[i9 + 1] = y4;
      a6[i9 + 2] = x3;
      a6[i9 + 3] = y4;
      a6[i9 + 4] = x3;
      a6[i9 + 5] = y4;
      a6[i9 + 6] = x3;
      a6[i9 + 7] = y4;
      a6[i9 + 8] = x3;
      a6[i9 + 9] = y4;
      a6[i9 + 10] = x3;
      a6[i9 + 11] = y4;
      this._changedBuffers[SIZE_BUFFER] = true;
    }
    setOffsetArr(index, offset) {
      let i9 = index * 18;
      let a6 = this._offsetArr, x3 = offset.x, y4 = offset.y, z3 = offset.z;
      a6[i9] = x3;
      a6[i9 + 1] = y4;
      a6[i9 + 2] = z3;
      a6[i9 + 3] = x3;
      a6[i9 + 4] = y4;
      a6[i9 + 5] = z3;
      a6[i9 + 6] = x3;
      a6[i9 + 7] = y4;
      a6[i9 + 8] = z3;
      a6[i9 + 9] = x3;
      a6[i9 + 10] = y4;
      a6[i9 + 11] = z3;
      a6[i9 + 12] = x3;
      a6[i9 + 13] = y4;
      a6[i9 + 14] = z3;
      a6[i9 + 15] = x3;
      a6[i9 + 16] = y4;
      a6[i9 + 17] = z3;
      this._changedBuffers[OFFSET_BUFFER] = true;
    }
    setRgbaArr(index, rgba) {
      let i9 = index * 24;
      let a6 = this._rgbaArr, x3 = rgba.x, y4 = rgba.y, z3 = rgba.z, w3 = rgba.w;
      a6[i9] = x3;
      a6[i9 + 1] = y4;
      a6[i9 + 2] = z3;
      a6[i9 + 3] = w3;
      a6[i9 + 4] = x3;
      a6[i9 + 5] = y4;
      a6[i9 + 6] = z3;
      a6[i9 + 7] = w3;
      a6[i9 + 8] = x3;
      a6[i9 + 9] = y4;
      a6[i9 + 10] = z3;
      a6[i9 + 11] = w3;
      a6[i9 + 12] = x3;
      a6[i9 + 13] = y4;
      a6[i9 + 14] = z3;
      a6[i9 + 15] = w3;
      a6[i9 + 16] = x3;
      a6[i9 + 17] = y4;
      a6[i9 + 18] = z3;
      a6[i9 + 19] = w3;
      a6[i9 + 20] = x3;
      a6[i9 + 21] = y4;
      a6[i9 + 22] = z3;
      a6[i9 + 23] = w3;
      this._changedBuffers[RGBA_BUFFER] = true;
    }
    setRotationArr(index, rotation) {
      let i9 = index * 6;
      let a6 = this._rotationArr;
      a6[i9] = rotation;
      a6[i9 + 1] = rotation;
      a6[i9 + 2] = rotation;
      a6[i9 + 3] = rotation;
      a6[i9 + 4] = rotation;
      a6[i9 + 5] = rotation;
      this._changedBuffers[ROTATION_BUFFER] = true;
    }
    setTexCoordArr(index, tcoordArr) {
      let i9 = index * 12;
      let a6 = this._texCoordArr;
      a6[i9] = tcoordArr[0];
      a6[i9 + 1] = tcoordArr[1];
      a6[i9 + 2] = tcoordArr[2];
      a6[i9 + 3] = tcoordArr[3];
      a6[i9 + 4] = tcoordArr[4];
      a6[i9 + 5] = tcoordArr[5];
      a6[i9 + 6] = tcoordArr[6];
      a6[i9 + 7] = tcoordArr[7];
      a6[i9 + 8] = tcoordArr[8];
      a6[i9 + 9] = tcoordArr[9];
      a6[i9 + 10] = tcoordArr[10];
      a6[i9 + 11] = tcoordArr[11];
      this._changedBuffers[TEXCOORD_BUFFER] = true;
    }
    setVisibility(index, visibility) {
      let vArr;
      if (visibility) {
        vArr = [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5];
      } else {
        vArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      this.setVertexArr(index, vArr);
    }
    setVertexArr(index, vertexArr) {
      let i9 = index * 12;
      let a6 = this._vertexArr;
      a6[i9] = vertexArr[0];
      a6[i9 + 1] = vertexArr[1];
      a6[i9 + 2] = vertexArr[2];
      a6[i9 + 3] = vertexArr[3];
      a6[i9 + 4] = vertexArr[4];
      a6[i9 + 5] = vertexArr[5];
      a6[i9 + 6] = vertexArr[6];
      a6[i9 + 7] = vertexArr[7];
      a6[i9 + 8] = vertexArr[8];
      a6[i9 + 9] = vertexArr[9];
      a6[i9 + 10] = vertexArr[10];
      a6[i9 + 11] = vertexArr[11];
      this._changedBuffers[VERTEX_BUFFER] = true;
    }
    createPositionBuffer() {
      let h8 = this._renderer.handler, numItems = this._positionHighArr.length / 3;
      if (!this._positionHighBuffer || this._positionHighBuffer.numItems !== numItems) {
        h8.gl.deleteBuffer(this._positionHighBuffer);
        h8.gl.deleteBuffer(this._positionLowBuffer);
        this._positionHighBuffer = h8.createStreamArrayBuffer(3, numItems);
        this._positionLowBuffer = h8.createStreamArrayBuffer(3, numItems);
      }
      h8.setStreamArrayBuffer(this._positionHighBuffer, this._positionHighArr);
      h8.setStreamArrayBuffer(this._positionLowBuffer, this._positionLowArr);
    }
    createSizeBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._sizeBuffer);
      this._sizeBuffer = h8.createArrayBuffer(this._sizeArr, 2, this._sizeArr.length / 2);
    }
    createOffsetBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._offsetBuffer);
      this._offsetBuffer = h8.createArrayBuffer(this._offsetArr, 3, this._offsetArr.length / 3);
    }
    createRgbaBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._rgbaBuffer);
      this._rgbaBuffer = h8.createArrayBuffer(this._rgbaArr, 4, this._rgbaArr.length / 4);
    }
    createRotationBuffer() {
      let h8 = this._renderer.handler;
      if (!this._rotationBuffer || this._rotationBuffer.numItems !== this._rotationArr.length) {
        h8.gl.deleteBuffer(this._rotationBuffer);
        this._rotationBuffer = h8.createStreamArrayBuffer(1, this._rotationArr.length);
      }
      h8.setStreamArrayBuffer(this._rotationBuffer, this._rotationArr);
    }
    createVertexBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._vertexBuffer);
      this._vertexBuffer = h8.createArrayBuffer(this._vertexArr, 2, this._vertexArr.length / 2);
    }
    createTexCoordBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._texCoordBuffer);
      this._texCoordBuffer = h8.createArrayBuffer(this._texCoordArr, 2, this._texCoordArr.length / 2);
    }
    //createAlignedAxisBuffer() {
    //    var h = this._renderer.handler;
    //    h.gl.deleteBuffer(this._alignedAxisBuffer);
    //    this._alignedAxisBuffer = h.createArrayBuffer(
    //        this._alignedAxisArr,
    //        3,
    //        this._alignedAxisArr.length / 3
    //    );
    //}
    createPickingColorBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._pickingColorBuffer);
      this._pickingColorBuffer = h8.createArrayBuffer(this._pickingColorArr, 3, this._pickingColorArr.length / 3);
    }
    refreshTexCoordsArr() {
    }
  };
  BaseBillboardHandler.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/entity/BillboardHandler.js
  var BillboardHandler = class extends BaseBillboardHandler {
    constructor(props) {
      super(props);
      this._billboards = [];
    }
    add(billboard) {
      if (billboard._handlerIndex == -1) {
        super.add(billboard);
        this._addBillboardToArrays(billboard);
        this.refresh();
        let src = billboard.getSrc() || billboard.getImage() && billboard.getImage().src;
        if (src) {
          billboard.setSrc(src);
        }
      }
    }
    _addBillboardToArrays(billboard) {
      if (billboard.getVisibility()) {
        this._vertexArr = concatTypedArrays(this._vertexArr, [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5]);
      } else {
        this._vertexArr = concatTypedArrays(this._vertexArr, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      }
      this._texCoordArr = concatTypedArrays(this._texCoordArr, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      let x3 = billboard._positionHigh.x, y4 = billboard._positionHigh.y, z3 = billboard._positionHigh.z, w3;
      this._positionHighArr = concatTypedArrays(this._positionHighArr, [
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3
      ]);
      x3 = billboard._positionLow.x;
      y4 = billboard._positionLow.y;
      z3 = billboard._positionLow.z;
      this._positionLowArr = concatTypedArrays(this._positionLowArr, [
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3
      ]);
      x3 = billboard._width;
      y4 = billboard._height;
      this._sizeArr = concatTypedArrays(this._sizeArr, [x3, y4, x3, y4, x3, y4, x3, y4, x3, y4, x3, y4]);
      x3 = billboard._offset.x;
      y4 = billboard._offset.y;
      z3 = billboard._offset.z;
      this._offsetArr = concatTypedArrays(this._offsetArr, [
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3,
        x3,
        y4,
        z3
      ]);
      x3 = billboard._color.x;
      y4 = billboard._color.y;
      z3 = billboard._color.z;
      w3 = billboard._color.w;
      this._rgbaArr = concatTypedArrays(this._rgbaArr, [
        x3,
        y4,
        z3,
        w3,
        x3,
        y4,
        z3,
        w3,
        x3,
        y4,
        z3,
        w3,
        x3,
        y4,
        z3,
        w3,
        x3,
        y4,
        z3,
        w3,
        x3,
        y4,
        z3,
        w3
      ]);
      x3 = billboard._rotation;
      this._rotationArr = concatTypedArrays(this._rotationArr, [x3, x3, x3, x3, x3, x3]);
      x3 = billboard._entity._pickingColor.x / 255;
      y4 = billboard._entity._pickingColor.y / 255;
      z3 = billboard._entity._pickingColor.z / 255;
      this._pickingColorArr = concatTypedArrays(this._pickingColorArr, [x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3]);
    }
    get billboards() {
      return this._billboards;
    }
    refreshTexCoordsArr() {
      let bc = this._entityCollection;
      if (bc && this._renderer) {
        let ta = this._renderer.billboardsTextureAtlas;
        for (let i9 = 0; i9 < this._billboards.length; i9++) {
          let bi = this._billboards[i9];
          let img = bi.getImage();
          if (img) {
            let imageNode = ta.get(img.__nodeIndex);
            if (imageNode) {
              this.setTexCoordArr(bi._handlerIndex, imageNode.texCoords);
            }
          }
        }
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/shaders/geoObject.js
  var geo_object = () => new Program("geo_object", {
    uniforms: {
      viewMatrix: "mat4",
      projectionMatrix: "mat4",
      uScaleByDistance: "vec3",
      eyePositionHigh: "vec3",
      eyePositionLow: "vec3",
      lightsPositions: "vec3",
      lightsParamsv: "vec3",
      lightsParamsf: "float",
      uTexture: "sampler2d",
      uUseTexture: "float"
    },
    attributes: {
      aVertexPosition: "vec3",
      aVertexNormal: "vec3",
      aTexCoord: "vec2",
      aPositionHigh: { type: "vec3", divisor: 1 },
      aPositionLow: { type: "vec3", divisor: 1 },
      aDirection: { type: "vec3", divisor: 1 },
      aPitchRoll: { type: "vec2", divisor: 1 },
      aColor: { type: "vec4", divisor: 1 },
      aScale: { type: "vec3", divisor: 1 },
      aDispose: { type: "float", divisor: 1 }
    },
    vertexShader: `precision highp float;
            
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal; 
            attribute vec3 aPositionHigh;
            attribute vec3 aPositionLow;    
            attribute vec3 aDirection;
            attribute vec2 aPitchRoll;
            attribute vec4 aColor;
            attribute vec3 aScale;
            attribute float aDispose;
            attribute float aUseTexture;
            attribute vec2 aTexCoord;
            
            uniform vec3 uScaleByDistance;
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;

            varying vec3 cameraPosition;
            varying vec3 vNormal;
            varying vec3 v_vertex;           
            varying vec4 vColor;
            varying float vDispose;
            varying vec2 vTexCoords;
            //varying float useLighting;
            
            const float PI = 3.141592653589793;
            
            const float RADIANS = PI / 180.0;
           
            void main(void) {
                        
                if (aDispose == 0.0) {
                   return;
                }
                
                vec3 position = aPositionHigh + aPositionLow;
                cameraPosition = eyePositionHigh + eyePositionLow;
                
                vec3 look = cameraPosition - position;
                float lookLength = length(look);

                // useLighting = 1.0;                
                // if(lookLength > 2000000.0){
                //      useLighting = 0.0;
                // }

            
                vColor = aColor;
                vTexCoords = aTexCoord;
              
                float cos_roll = cos(aPitchRoll.y);
                float sin_roll = sin(aPitchRoll.y);
                
                mat3 rotZ = mat3(
                     vec3(cos_roll, sin_roll, 0.0),
                     vec3(-sin_roll, cos_roll, 0.0), 
                     vec3(0.0, 0.0, 1.0) 
                );

                float cos_pitch = cos(aPitchRoll.x);
                float sin_pitch = sin(aPitchRoll.x);

                mat3 rotX = mat3(
                    vec3(1.0, 0.0, 0.0),
                    vec3(0.0, cos_pitch, sin_pitch), 
                    vec3(0.0, -sin_pitch, cos_pitch) 
               );

                vec3 r = cross(normalize(-position), aDirection);
                mat3 modelMatrix = mat3(r, normalize(position), -aDirection) * rotX * rotZ;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = aPositionHigh - eyePositionHigh;
                vec3 lowDiff = aPositionLow - eyePositionLow;
             
                vNormal = modelMatrix * aVertexNormal;
                               
                // if(lookLength > uScaleByDistance[1])
                // {
                //     scd = uScaleByDistance[1] / uScaleByDistance[0];
                // }
                // else if(lookLength > uScaleByDistance[0])
                // {
                //     scd = lookLength / uScaleByDistance[0];
                // }
                // ... is the same math
                float scd = uScaleByDistance[2] * clamp(lookLength, uScaleByDistance[0], uScaleByDistance[1]) / uScaleByDistance[0];
                
                vec3 vert = modelMatrix * (aVertexPosition * aScale) * scd;
                
                vert += lowDiff;
                               
                gl_Position = projectionMatrix * viewMatrixRTE  * vec4(highDiff * step(1.0, length(highDiff)) + vert, 1.0);
                
                v_vertex = position + vert;
            }`,
    fragmentShader: `precision highp float;

                #define MAX_POINT_LIGHTS 1
                
                uniform vec3 lightsPositions[MAX_POINT_LIGHTS];
                uniform vec3 lightsParamsv[MAX_POINT_LIGHTS * 3];
                uniform float lightsParamsf[MAX_POINT_LIGHTS];
                uniform sampler2D uTexture;
                uniform float uUseTexture;
                            
                varying vec3 cameraPosition;
                varying vec3 v_vertex;                
                varying vec4 vColor;
                varying vec3 vNormal;
                varying vec2 vTexCoords;
                //varying float useLighting;
                
                void main(void) {        
                                        
                    vec3 lightWeighting = vec3(1.0);
                
                    //if(useLighting != 0.0){
                        vec3 normal = normalize(vNormal);
                        vec3 lightDir = normalize(lightsPositions[0]);
                        vec3 viewDir = normalize(cameraPosition - v_vertex);                
                        vec3 reflectionDirection = reflect(-lightDir, normal);
                        float reflection = max( dot(reflectionDirection, viewDir), 0.0);
                        float specularLightWeighting = pow( reflection, lightsParamsf[0]);                                        
                        float diffuseLightWeighting = max(dot(normal, lightDir), 0.0);
                        lightWeighting = lightsParamsv[0] + lightsParamsv[1] * diffuseLightWeighting + lightsParamsv[2] * specularLightWeighting;
                    //}
                                       
                    if(uUseTexture > 0.0) {
                        vec4 tColor = texture2D(uTexture, vTexCoords);
                        gl_FragColor = vec4(tColor.rgb * lightWeighting, tColor.a);
                    } else {
                        gl_FragColor = vec4(vColor.rgb * lightWeighting, vColor.a);
                    }
                }`
  });
  var geo_object_picking = () => new Program("geo_object_picking", {
    uniforms: {
      viewMatrix: "mat4",
      projectionMatrix: "mat4",
      uScaleByDistance: "vec3",
      eyePositionHigh: "vec3",
      eyePositionLow: "vec3",
      pickingScale: "float"
    },
    attributes: {
      aVertexPosition: "vec3",
      aPositionHigh: { type: "vec3", divisor: 1 },
      aPositionLow: { type: "vec3", divisor: 1 },
      aDirection: { type: "vec3", divisor: 1 },
      aPitchRoll: { type: "vec2", divisor: 1 },
      aPickingColor: { type: "vec3", divisor: 1 },
      aScale: { type: "vec3", divisor: 1 },
      aDispose: { type: "float", divisor: 1 }
    },
    vertexShader: `precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aPositionHigh;
            attribute vec3 aPositionLow;    
            attribute vec3 aDirection;
            attribute vec3 aPickingColor;
            attribute vec2 aPitchRoll;
            attribute vec3 aScale;
            attribute float aDispose;
            
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform vec3 uScaleByDistance;
            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform float pickingScale;

            varying vec3 vColor;
            
            const float RADIANS = 3.141592653589793 / 180.0;

            void main(void) {

                if (aDispose == 0.0) {
                    return;
                 }
            
                 vColor = aPickingColor;
               
                float cos_roll = cos(aPitchRoll.y);
                float sin_roll = sin(aPitchRoll.y);
                
                mat3 rotZ = mat3(
                     vec3(cos_roll, sin_roll, 0.0),
                     vec3(-sin_roll, cos_roll, 0.0), 
                     vec3(0.0, 0.0, 1.0) 
                );

                float cos_pitch = cos(aPitchRoll.x);
                float sin_pitch = sin(aPitchRoll.x);

                mat3 rotX = mat3(
                    vec3(1.0, 0.0, 0.0),
                    vec3(0.0, cos_pitch, sin_pitch), 
                    vec3(0.0, -sin_pitch, cos_pitch) 
               );
 
                 vec3 position = aPositionHigh + aPositionLow;
                 vec3 cameraPosition = eyePositionHigh + eyePositionLow;
                 vec3 r = cross(normalize(-position), aDirection);
                 mat3 modelMatrix = mat3(r, normalize(position), -aDirection) * rotX * rotZ;
 
                 mat4 viewMatrixRTE = viewMatrix;
                 viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);
 
                 vec3 highDiff = aPositionHigh - eyePositionHigh;
                 vec3 lowDiff = aPositionLow - eyePositionLow;
              
                 vec3 look = cameraPosition - position;
                 float lookLength = length(look);
                                
                 // if(lookLength > uScaleByDistance[1])
                 // {
                 //     scd = uScaleByDistance[1] / uScaleByDistance[0];
                 // }
                 // else if(lookLength > uScaleByDistance[0])
                 // {
                 //     scd = lookLength / uScaleByDistance[0];
                 // }
                 // ... is the same math above
                 // @hack
                 // pickingScale replace to this line, because when it s
                 // tays in the vert above it affects on Mac Safari jitter
                 float scd = pickingScale * uScaleByDistance[2] * clamp(lookLength, uScaleByDistance[0], uScaleByDistance[1]) / uScaleByDistance[0];

                 vec3 vert = modelMatrix * (aVertexPosition * aScale) * scd;
                 
                 vert += lowDiff;
                                
                 gl_Position = projectionMatrix * viewMatrixRTE  * vec4(highDiff * step(1.0, length(highDiff)) + vert, 1.0);
            }`,
    fragmentShader: `precision highp float;
            varying vec3 vColor;
            void main () {
                gl_FragColor = vec4(vColor, 1.0);
            }`
  });

  // frontend/node_modules/@openglobus/og/lib/js/entity/GeoObjectHandler.js
  var VERTEX_BUFFER2 = 0;
  var POSITION_BUFFER2 = 1;
  var RGBA_BUFFER2 = 2;
  var NORMALS_BUFFER = 3;
  var INDEX_BUFFER2 = 4;
  var DIRECTION_BUFFER = 5;
  var PITCH_ROLL_BUFFER = 6;
  var SIZE_BUFFER2 = 7;
  var PICKINGCOLOR_BUFFER2 = 8;
  var VISIBLE_BUFFER = 9;
  var TEXCOORD_BUFFER2 = 10;
  function setParametersToArray(arr, index = 0, length = 0, itemSize = 1, ...params) {
    const currIndex = index * length;
    for (let i9 = currIndex, len = currIndex + length; i9 < len; i9++) {
      arr[i9] = params[i9 % itemSize];
    }
    return arr;
  }
  var InstanceData = class {
    constructor(geoObjectHandler) {
      this.isFree = true;
      this._geoObjectHandler = geoObjectHandler;
      this.geoObjects = [];
      this.numInstances = 0;
      this._texture = null;
      this._textureSrc = null;
      this._pitchRollArr = [];
      this._sizeArr = [];
      this._vertexArr = [];
      this._positionHighArr = [];
      this._positionLowArr = [];
      this._directionArr = [];
      this._rgbaArr = [];
      this._normalsArr = [];
      this._indicesArr = [];
      this._pickingColorArr = [];
      this._visibleArr = [];
      this._texCoordArr = [];
      this._pitchRollBuffer = null;
      this._sizeBuffer = null;
      this._vertexBuffer = null;
      this._positionHighBuffer = null;
      this._positionLowBuffer = null;
      this._directionBuffer = null;
      this._rgbaBuffer = null;
      this._normalsBuffer = null;
      this._indicesBuffer = null;
      this._pickingColorBuffer = null;
      this._visibleBuffer = null;
      this._texCoordBuffer = null;
      this._buffersUpdateCallbacks = [];
      this._buffersUpdateCallbacks[PICKINGCOLOR_BUFFER2] = this.createPickingColorBuffer;
      this._buffersUpdateCallbacks[POSITION_BUFFER2] = this.createPositionBuffer;
      this._buffersUpdateCallbacks[DIRECTION_BUFFER] = this.createDirectionBuffer;
      this._buffersUpdateCallbacks[NORMALS_BUFFER] = this.createNormalsBuffer;
      this._buffersUpdateCallbacks[RGBA_BUFFER2] = this.createRgbaBuffer;
      this._buffersUpdateCallbacks[INDEX_BUFFER2] = this.createIndicesBuffer;
      this._buffersUpdateCallbacks[VERTEX_BUFFER2] = this.createVertexBuffer;
      this._buffersUpdateCallbacks[SIZE_BUFFER2] = this.createSizeBuffer;
      this._buffersUpdateCallbacks[PITCH_ROLL_BUFFER] = this.createPitchRollBuffer;
      this._buffersUpdateCallbacks[VISIBLE_BUFFER] = this.createVisibleBuffer;
      this._buffersUpdateCallbacks[TEXCOORD_BUFFER2] = this.createTexCoordBuffer;
      this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    }
    createTexture(image) {
      if (this._geoObjectHandler && this._geoObjectHandler._planet) {
        this._texture = this._geoObjectHandler._planet.renderer.handler.createTextureDefault(image);
      }
    }
    clear() {
      this.numInstances = 0;
      this.geoObjects = [];
      this._pitchRollArr = [];
      this._sizeArr = [];
      this._vertexArr = [];
      this._positionHighArr = [];
      this._positionLowArr = [];
      this._directionArr = [];
      this._rgbaArr = [];
      this._normalsArr = [];
      this._indicesArr = [];
      this._pickingColorArr = [];
      this._visibleArr = [];
      this._texCoordArr = [];
      this._deleteBuffers();
      this.isFree = false;
    }
    _deleteBuffers() {
      if (this._geoObjectHandler && this._geoObjectHandler._planet && this._geoObjectHandler._planet.renderer) {
        let h8 = this._geoObjectHandler._planet.renderer.handler, gl = h8.gl;
        h8.deleteTexture(this._texture);
        this._texture = null;
        gl.deleteBuffer(this._pitchRollBuffer);
        gl.deleteBuffer(this._sizeBuffer);
        gl.deleteBuffer(this._vertexBuffer);
        gl.deleteBuffer(this._positionHighBuffer);
        gl.deleteBuffer(this._positionLowBuffer);
        gl.deleteBuffer(this._directionBuffer);
        gl.deleteBuffer(this._rgbaBuffer);
        gl.deleteBuffer(this._normalsBuffer);
        gl.deleteBuffer(this._indicesBuffer);
        gl.deleteBuffer(this._pickingColorBuffer);
        gl.deleteBuffer(this._visibleBuffer);
        gl.deleteBuffer(this._texCoordBuffer);
      }
      this._pitchRollBuffer = null;
      this._sizeBuffer = null;
      this._vertexBuffer = null;
      this._positionHighBuffer = null;
      this._positionLowBuffer = null;
      this._directionBuffer = null;
      this._rgbaBuffer = null;
      this._normalsBuffer = null;
      this._indicesBuffer = null;
      this._pickingColorBuffer = null;
      this._visibleBuffer = null;
      this._texCoordBuffer = null;
    }
    createVertexBuffer() {
      const h8 = this._geoObjectHandler._planet.renderer.handler;
      h8.gl.deleteBuffer(this._vertexBuffer);
      this._vertexArr = makeArrayTyped(this._vertexArr);
      this._vertexBuffer = h8.createArrayBuffer(this._vertexArr, 3, this._vertexArr.length / 3);
    }
    createPitchRollBuffer() {
      let h8 = this._geoObjectHandler._planet.renderer.handler, numItems = this._pitchRollArr.length / 2;
      if (!this._pitchRollBuffer || this._pitchRollBuffer.numItems !== numItems) {
        h8.gl.deleteBuffer(this._pitchRollBuffer);
        this._pitchRollBuffer = h8.createStreamArrayBuffer(2, numItems);
      }
      this._pitchRollArr = makeArrayTyped(this._pitchRollArr);
      h8.setStreamArrayBuffer(this._pitchRollBuffer, this._pitchRollArr);
    }
    createVisibleBuffer() {
      const h8 = this._geoObjectHandler._planet.renderer.handler, numItems = this._visibleArr.length;
      if (!this._visibleBuffer || this._visibleBuffer.numItems !== numItems) {
        h8.gl.deleteBuffer(this._visibleBuffer);
        this._visibleBuffer = h8.createStreamArrayBuffer(1, numItems);
      }
      this._visibleArr = makeArrayTyped(this._visibleArr);
      h8.setStreamArrayBuffer(this._visibleBuffer, this._visibleArr);
    }
    createSizeBuffer() {
      let h8 = this._geoObjectHandler._planet.renderer.handler, numItems = this._sizeArr.length / 3;
      if (!this._sizeBuffer || this._sizeBuffer.numItems !== numItems) {
        h8.gl.deleteBuffer(this._sizeBuffer);
        this._sizeBuffer = h8.createStreamArrayBuffer(3, numItems);
      }
      this._sizeArr = makeArrayTyped(this._sizeArr);
      h8.setStreamArrayBuffer(this._sizeBuffer, this._sizeArr);
    }
    createTexCoordBuffer() {
      const h8 = this._geoObjectHandler._planet.renderer.handler;
      h8.gl.deleteBuffer(this._texCoordBuffer);
      this._texCoordArr = makeArrayTyped(this._texCoordArr);
      this._texCoordBuffer = h8.createArrayBuffer(this._texCoordArr, 2, this._texCoordArr.length / 2);
    }
    createPositionBuffer() {
      let h8 = this._geoObjectHandler._planet.renderer.handler, numItems = this._positionHighArr.length / 3;
      if (!this._positionHighBuffer || this._positionHighBuffer.numItems !== numItems) {
        h8.gl.deleteBuffer(this._positionHighBuffer);
        h8.gl.deleteBuffer(this._positionLowBuffer);
        this._positionHighBuffer = h8.createStreamArrayBuffer(3, numItems);
        this._positionLowBuffer = h8.createStreamArrayBuffer(3, numItems);
      }
      this._positionHighArr = makeArrayTyped(this._positionHighArr);
      this._positionLowArr = makeArrayTyped(this._positionLowArr);
      h8.setStreamArrayBuffer(this._positionHighBuffer, this._positionHighArr);
      h8.setStreamArrayBuffer(this._positionLowBuffer, this._positionLowArr);
    }
    createRgbaBuffer() {
      let h8 = this._geoObjectHandler._planet.renderer.handler, numItems = this._rgbaArr.length / 4;
      if (!this._rgbaBuffer || this._rgbaBuffer.numItems !== numItems) {
        h8.gl.deleteBuffer(this._rgbaBuffer);
        this._rgbaBuffer = h8.createStreamArrayBuffer(4, numItems);
      }
      this._rgbaArr = makeArrayTyped(this._rgbaArr);
      h8.setStreamArrayBuffer(this._rgbaBuffer, this._rgbaArr);
    }
    createDirectionBuffer() {
      let h8 = this._geoObjectHandler._planet.renderer.handler, numItems = this._directionArr.length / 3;
      if (!this._directionBuffer || this._directionBuffer.numItems !== numItems) {
        h8.gl.deleteBuffer(this._directionBuffer);
        this._directionBuffer = h8.createStreamArrayBuffer(3, numItems);
      }
      this._directionArr = makeArrayTyped(this._directionArr);
      h8.setStreamArrayBuffer(this._directionBuffer, this._directionArr);
    }
    createNormalsBuffer() {
      const h8 = this._geoObjectHandler._planet.renderer.handler;
      h8.gl.deleteBuffer(this._normalsBuffer);
      this._normalsArr = makeArrayTyped(this._normalsArr);
      this._normalsBuffer = h8.createArrayBuffer(this._normalsArr, 3, this._normalsArr.length / 3);
    }
    createIndicesBuffer() {
      const h8 = this._geoObjectHandler._planet.renderer.handler;
      h8.gl.deleteBuffer(this._indicesBuffer);
      this._indicesArr = makeArrayTyped(this._indicesArr, Uint32Array);
      this._indicesBuffer = h8.createElementArrayBuffer(this._indicesArr, 1, this._indicesArr.length);
    }
    createPickingColorBuffer() {
      const h8 = this._geoObjectHandler._planet.renderer.handler;
      h8.gl.deleteBuffer(this._pickingColorBuffer);
      this._pickingColorArr = makeArrayTyped(this._pickingColorArr);
      this._pickingColorBuffer = h8.createArrayBuffer(this._pickingColorArr, 3, this._pickingColorArr.length / 3);
    }
    refresh() {
      let i9 = this._changedBuffers.length;
      while (i9--) {
        this._changedBuffers[i9] = true;
      }
    }
    update() {
      if (this._geoObjectHandler._planet) {
        let i9 = this._changedBuffers.length;
        while (i9--) {
          if (this._changedBuffers[i9]) {
            this._buffersUpdateCallbacks[i9].call(this);
            this._changedBuffers[i9] = false;
          }
        }
        this.isFree = true;
      }
    }
  };
  var GeoObjectHandler = class _GeoObjectHandler {
    constructor(entityCollection) {
      this.__id = _GeoObjectHandler.__counter__++;
      this.pickingEnabled = true;
      this._entityCollection = entityCollection;
      this._planet = null;
      this._geoObjects = [];
      this._instanceDataMap = /* @__PURE__ */ new Map();
      this._instanceDataMapValues = [];
      this._dataTagUpdateQueue = [];
    }
    initProgram() {
      if (this._planet && this._planet.renderer) {
        if (!this._planet.renderer.handler.programs.geo_object) {
          this._planet.renderer.handler.addProgram(geo_object());
        }
        if (!this._planet.renderer.handler.programs.geo_object_picking) {
          this._planet.renderer.handler.addProgram(geo_object_picking());
        }
      }
    }
    setRenderNode(renderNode) {
      this._planet = renderNode;
      this.initProgram();
      for (let i9 = 0; i9 < this._instanceDataMapValues.length; i9++) {
        this._loadDataTagTexture(this._instanceDataMapValues[i9]);
      }
      for (let i9 = 0; i9 < this._geoObjects.length; i9++) {
        this._geoObjects[i9].updateDirection();
      }
      this.update();
    }
    setTextureTag(src, tag) {
      const tagData = this._instanceDataMap.get(tag);
      if (tagData) {
        tagData._textureSrc = src;
        this._instanceDataMap.set(tag, tagData);
        this._loadDataTagTexture(tagData);
      }
    }
    setObjectSrc(src, tag) {
      const tagData = this._instanceDataMap.get(tag);
      if (src) {
        if (tagData && tagData._objectSrc !== src) {
          tagData._objectSrc = src;
          Object3d.loadObj(src).then((object3d) => {
            this._updateInstanceData(object3d[0], tag);
          });
        }
      }
    }
    _updateInstanceData(object, tag) {
      const tagData = this._instanceDataMap.get(tag);
      if (tagData) {
        if (object.vertices.length !== tagData._vertexArr.length) {
          tagData._vertexArr = object.vertices;
          tagData._changedBuffers[VERTEX_BUFFER2] = true;
          tagData._changedBuffers[DIRECTION_BUFFER] = true;
        }
        if (object.normals.length !== tagData._normalsArr.length) {
          tagData._normalsArr = object.normals;
          tagData._changedBuffers[NORMALS_BUFFER] = true;
        }
        if (object.indices.length !== tagData._indicesArr.length) {
          tagData._indicesArr = object.indices;
          tagData._changedBuffers[INDEX_BUFFER2] = true;
        }
        if (object.texCoords.length !== tagData._texCoordArr.length) {
          tagData._texCoordArr = object.texCoords;
          tagData._changedBuffers[TEXCOORD_BUFFER2] = true;
        }
        tagData._textureSrc = object.src;
        this._loadDataTagTexture(tagData);
        this._updateTag(tagData);
        this._instanceDataMapValues = Array.from(this._instanceDataMap.values());
      }
    }
    _addGeoObjectToArray(geoObject) {
      const tag = geoObject.tag;
      let tagData = this._instanceDataMap.get(tag);
      if (!tagData) {
        tagData = new InstanceData(this);
        this._instanceDataMap.set(tag, tagData);
        this._instanceDataMapValues = Array.from(this._instanceDataMap.values());
        tagData._vertexArr = geoObject.vertices;
        tagData._normalsArr = geoObject.normals;
        tagData._indicesArr = geoObject.indices;
        tagData._texCoordArr = geoObject.texCoords;
        tagData._textureSrc = geoObject.object3d.src;
        this._loadDataTagTexture(tagData);
      }
      geoObject._tagDataIndex = tagData.numInstances++;
      geoObject._tagData = tagData;
      tagData.geoObjects.push(geoObject);
      let itemSize = 3;
      tagData._visibleArr = concatArrays(tagData._visibleArr, setParametersToArray([], 0, 1, 1, geoObject.getVisibility() ? 1 : 0));
      let x3 = geoObject._positionHigh.x, y4 = geoObject._positionHigh.y, z3 = geoObject._positionHigh.z, w3;
      tagData._positionHighArr = concatArrays(tagData._positionHighArr, setParametersToArray([], 0, itemSize, itemSize, x3, y4, z3));
      x3 = geoObject._positionLow.x;
      y4 = geoObject._positionLow.y;
      z3 = geoObject._positionLow.z;
      tagData._positionLowArr = concatArrays(tagData._positionLowArr, setParametersToArray([], 0, itemSize, itemSize, x3, y4, z3));
      x3 = geoObject._entity._pickingColor.x / 255;
      y4 = geoObject._entity._pickingColor.y / 255;
      z3 = geoObject._entity._pickingColor.z / 255;
      tagData._pickingColorArr = concatArrays(tagData._pickingColorArr, setParametersToArray([], 0, itemSize, itemSize, x3, y4, z3));
      x3 = geoObject._direction.x;
      y4 = geoObject._direction.y;
      z3 = geoObject._direction.z;
      tagData._directionArr = concatArrays(tagData._directionArr, setParametersToArray([], 0, itemSize, itemSize, x3, y4, z3));
      itemSize = 4;
      x3 = geoObject._color.x;
      y4 = geoObject._color.y;
      z3 = geoObject._color.z;
      w3 = geoObject._color.w;
      tagData._rgbaArr = concatArrays(tagData._rgbaArr, setParametersToArray([], 0, itemSize, itemSize, x3, y4, z3, w3));
      itemSize = 2;
      x3 = geoObject.getPitch();
      y4 = geoObject.getRoll();
      tagData._pitchRollArr = concatArrays(tagData._pitchRollArr, setParametersToArray([], 0, itemSize, itemSize, x3, y4));
      itemSize = 3;
      let scale2 = geoObject.getScale();
      x3 = scale2.x;
      y4 = scale2.y;
      z3 = scale2.z;
      tagData._sizeArr = concatArrays(tagData._sizeArr, setParametersToArray([], 0, itemSize, itemSize, x3, y4, z3));
    }
    _displayPASS() {
      let r8 = this._planet.renderer, sh = r8.handler.programs.geo_object, p4 = sh._program, u4 = p4.uniforms, a6 = p4.attributes, gl = r8.handler.gl, ec = this._entityCollection;
      sh.activate();
      gl.uniform3fv(u4.uScaleByDistance, ec.scaleByDistance);
      gl.uniform3fv(u4.eyePositionHigh, r8.activeCamera.eyeHigh);
      gl.uniform3fv(u4.eyePositionLow, r8.activeCamera.eyeLow);
      gl.uniformMatrix4fv(u4.projectionMatrix, false, r8.activeCamera.getProjectionMatrix());
      gl.uniformMatrix4fv(u4.viewMatrix, false, r8.activeCamera.getViewMatrix());
      gl.uniform3fv(u4.lightsPositions, this._planet._lightsPositions);
      gl.uniform3fv(u4.lightsParamsv, this._planet._lightsParamsv);
      gl.uniform1fv(u4.lightsParamsf, this._planet._lightsParamsf);
      for (let i9 = 0; i9 < this._instanceDataMapValues.length; i9++) {
        let tagData = this._instanceDataMapValues[i9];
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._directionBuffer);
        gl.vertexAttribPointer(a6.aDirection, tagData._directionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._sizeBuffer);
        gl.vertexAttribPointer(a6.aScale, tagData._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._pitchRollBuffer);
        gl.vertexAttribPointer(a6.aPitchRoll, tagData._pitchRollBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._rgbaBuffer);
        gl.vertexAttribPointer(a6.aColor, tagData._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._visibleBuffer);
        gl.vertexAttribPointer(a6.aDispose, tagData._visibleBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.uniform1f(u4.uUseTexture, tagData._texture ? 1 : 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._positionHighBuffer);
        gl.vertexAttribPointer(a6.aPositionHigh, tagData._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._positionLowBuffer);
        gl.vertexAttribPointer(a6.aPositionLow, tagData._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._normalsBuffer);
        gl.vertexAttribPointer(a6.aVertexNormal, tagData._normalsBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._vertexBuffer);
        gl.vertexAttribPointer(a6.aVertexPosition, tagData._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tagData._texture || r8.handler.defaultTexture);
        gl.uniform1i(u4.uTexture, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._texCoordBuffer);
        gl.vertexAttribPointer(a6.aTexCoord, tagData._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tagData._indicesBuffer);
        p4.drawElementsInstanced(gl.TRIANGLES, tagData._indicesBuffer.numItems, gl.UNSIGNED_INT, 0, tagData.numInstances);
      }
    }
    drawPicking() {
      if (this._geoObjects.length && this.pickingEnabled) {
        this.update();
        this._pickingPASS();
      }
    }
    _pickingPASS() {
      let r8 = this._planet.renderer, sh = r8.handler.programs.geo_object_picking, p4 = sh._program, u4 = p4.uniforms, a6 = p4.attributes, gl = r8.handler.gl, ec = this._entityCollection;
      sh.activate();
      gl.uniform3fv(u4.uScaleByDistance, ec.scaleByDistance);
      gl.uniform1f(u4.pickingScale, ec.pickingScale);
      gl.uniform3fv(u4.eyePositionHigh, r8.activeCamera.eyeHigh);
      gl.uniform3fv(u4.eyePositionLow, r8.activeCamera.eyeLow);
      gl.uniformMatrix4fv(u4.projectionMatrix, false, r8.activeCamera.getProjectionMatrix());
      gl.uniformMatrix4fv(u4.viewMatrix, false, r8.activeCamera.getViewMatrix());
      for (let i9 = 0; i9 < this._instanceDataMapValues.length; i9++) {
        let tagData = this._instanceDataMapValues[i9];
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._directionBuffer);
        gl.vertexAttribPointer(a6.aDirection, tagData._directionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._sizeBuffer);
        gl.vertexAttribPointer(a6.aScale, tagData._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._pitchRollBuffer);
        gl.vertexAttribPointer(a6.aPitchRoll, tagData._pitchRollBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._pickingColorBuffer);
        gl.vertexAttribPointer(a6.aPickingColor, tagData._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._positionHighBuffer);
        gl.vertexAttribPointer(a6.aPositionHigh, tagData._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._positionLowBuffer);
        gl.vertexAttribPointer(a6.aPositionLow, tagData._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._visibleBuffer);
        gl.vertexAttribPointer(a6.aDispose, tagData._visibleBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tagData._vertexBuffer);
        gl.vertexAttribPointer(a6.aVertexPosition, tagData._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tagData._indicesBuffer);
        p4.drawElementsInstanced(gl.TRIANGLES, tagData._indicesBuffer.numItems, gl.UNSIGNED_INT, 0, tagData.numInstances);
      }
    }
    async _loadDataTagTexture(tagData) {
      if (this._planet && tagData._textureSrc) {
        const image = await loadImage(tagData._textureSrc);
        tagData.createTexture(image);
      }
    }
    setDirectionArr(tagData, tagDataIndex, direction) {
      setParametersToArray(tagData._directionArr, tagDataIndex, 3, 3, direction.x, direction.y, direction.z);
      tagData._changedBuffers[DIRECTION_BUFFER] = true;
      this._updateTag(tagData);
    }
    setVisibility(tagData, tagDataIndex, visibility) {
      setParametersToArray(tagData._visibleArr, tagDataIndex, 1, 1, visibility ? 1 : 0);
      tagData._changedBuffers[VISIBLE_BUFFER] = true;
      this._updateTag(tagData);
    }
    setPositionArr(tagData, tagDataIndex, positionHigh, positionLow) {
      setParametersToArray(tagData._positionHighArr, tagDataIndex, 3, 3, positionHigh.x, positionHigh.y, positionHigh.z);
      setParametersToArray(tagData._positionLowArr, tagDataIndex, 3, 3, positionLow.x, positionLow.y, positionLow.z);
      tagData._changedBuffers[POSITION_BUFFER2] = true;
      this._updateTag(tagData);
    }
    setRgbaArr(tagData, tagDataIndex, rgba) {
      setParametersToArray(tagData._rgbaArr, tagDataIndex, 4, 4, rgba.x, rgba.y, rgba.z, rgba.w);
      tagData._changedBuffers[RGBA_BUFFER2] = true;
      this._updateTag(tagData);
    }
    setPickingColorArr(tagData, tagDataIndex, color) {
      setParametersToArray(tagData._pickingColorArr, tagDataIndex, 3, 3, color.x / 255, color.y / 255, color.z / 255);
      tagData._changedBuffers[PICKINGCOLOR_BUFFER2] = true;
      this._updateTag(tagData);
    }
    // setTexCoordArr(tagData, tagDataIndex, tcoordArr) {
    //     setParametersToArray(tagData._texCoordArr, tagDataIndex, 2, 2, ...tcoordArr);
    //     tagData._changedBuffers[TEXCOORD_BUFFER] = true;
    //     this._updateTag(tagData);
    // }
    setPitchRollArr(tagData, tagDataIndex, pitch, roll) {
      setParametersToArray(tagData._pitchRollArr, tagDataIndex, 2, 2, pitch, roll);
      tagData._changedBuffers[PITCH_ROLL_BUFFER] = true;
      this._updateTag(tagData);
    }
    setScaleArr(tagData, tagDataIndex, scale2) {
      setParametersToArray(tagData._sizeArr, tagDataIndex, 3, 3, scale2.x, scale2.y, scale2.z);
      tagData._changedBuffers[SIZE_BUFFER2] = true;
      this._updateTag(tagData);
    }
    _updateTag(dataTag) {
      if (dataTag.isFree) {
        dataTag.isFree = false;
        this._dataTagUpdateQueue.push(dataTag);
      }
    }
    update() {
      for (let i9 = 0, len = this._dataTagUpdateQueue.length; i9 < len; i9++) {
        this._dataTagUpdateQueue[i9].update();
      }
      this._dataTagUpdateQueue = [];
    }
    _removeAll() {
      let i9 = this._geoObjects.length;
      while (i9--) {
        const gi = this._geoObjects[i9];
        gi._tagDataIndex = -1;
        gi._tagData = null;
        gi._handlerIndex = -1;
        gi._handler = null;
      }
      this._geoObjects.length = 0;
      this._geoObjects = [];
      for (let i10 = 0; i10 < this._instanceDataMapValues.length; i10++) {
        this._instanceDataMapValues[i10].clear();
      }
      this._instanceDataMap.clear();
      this._instanceDataMapValues = [];
    }
    clear() {
      this._removeAll();
    }
    draw() {
      if (this._geoObjects.length) {
        this.update();
        this._displayPASS();
      }
    }
    add(geoObject) {
      if (geoObject._handlerIndex === -1) {
        geoObject._handler = this;
        geoObject._handlerIndex = this._geoObjects.length;
        this._geoObjects.push(geoObject);
        this._addGeoObjectToArray(geoObject);
        geoObject.updateDirection();
        geoObject._tagData.refresh();
        this._updateTag(geoObject._tagData);
        geoObject.setObjectSrc(geoObject._objectSrc);
      }
    }
    remove(geoObject) {
      if (geoObject._handler && this.__id == geoObject._handler.__id) {
        this._removeGeoObject(geoObject);
      }
    }
    _clearDataTagQueue() {
      this._dataTagUpdateQueue = [];
    }
    _removeGeoObject(geoObject) {
      let tagData = geoObject._tagData;
      let tag = geoObject.tag;
      tagData.numInstances--;
      let isEmpty2 = false;
      if (tagData.numInstances === 0) {
        tagData.clear();
        this._instanceDataMap.delete(tag);
        this._instanceDataMapValues = [];
        this._clearDataTagQueue();
        isEmpty2 = true;
      }
      this._geoObjects.splice(geoObject._handlerIndex, 1);
      for (let i9 = geoObject._handlerIndex, len = this._geoObjects.length; i9 < len; i9++) {
        let gi = this._geoObjects[i9];
        gi._handlerIndex = gi._handlerIndex - 1;
      }
      let tdi = geoObject._tagDataIndex;
      tagData.geoObjects.splice(tdi, 1);
      for (let i9 = geoObject._tagDataIndex, len = tagData.geoObjects.length; i9 < len; i9++) {
        let gi = tagData.geoObjects[i9];
        gi._tagDataIndex = gi._tagDataIndex - 1;
      }
      tagData._rgbaArr = spliceArray(tagData._rgbaArr, tdi * 4, 4);
      tagData._positionHighArr = spliceArray(tagData._positionHighArr, tdi * 3, 3);
      tagData._positionLowArr = spliceArray(tagData._positionLowArr, tdi * 3, 3);
      tagData._directionArr = spliceArray(tagData._directionArr, tdi * 3, 3);
      tagData._pickingColorArr = spliceArray(tagData._pickingColorArr, tdi * 3, 3);
      tagData._sizeArr = spliceArray(tagData._sizeArr, tdi * 3, 3);
      tagData._pitchRollArr = spliceArray(tagData._pitchRollArr, tdi * 2, 2);
      tagData._visibleArr = spliceArray(tagData._visibleArr, tdi, 1);
      geoObject._handlerIndex = -1;
      geoObject._handler = null;
      geoObject._tagDataIndex = -1;
      geoObject._tagData = null;
      if (!isEmpty2) {
        tagData.refresh();
        this._updateTag(tagData);
      }
    }
  };
  GeoObjectHandler.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/shaders/label.js
  var DEFINE = `
#define EMPTY -1.0
#define RTL 1.0`;
  var PROJECT2 = `vec2 project(vec4 p) {
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }`;
  var ROTATE2D2 = `mat2 rotate2d(float angle) {
        return mat2(cos(angle), -sin(angle),
           sin(angle), cos(angle));
     }`;
  function label_webgl2() {
    return new Program("label", {
      uniforms: {
        viewport: "vec2",
        fontTextureArr: "sampler2darray",
        sdfParamsArr: "vec4",
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        planetRadius: "float",
        scaleByDistance: "vec3",
        opacity: "float",
        isOutlinePass: "int",
        depthOffset: "float"
      },
      attributes: {
        a_outline: "float",
        a_gliphParam: "vec4",
        a_vertices: "vec2",
        a_texCoord: "vec4",
        a_positionsHigh: "vec3",
        a_positionsLow: "vec3",
        a_size: "float",
        a_rotation: "float",
        a_rgba: "vec4",
        a_offset: "vec3",
        a_fontIndex: "float"
      },
      vertexShader: `#version 300 es
            
            ${DEFINE}
            
            in float a_outline;
            in vec4 a_gliphParam;
            in vec2 a_vertices;
            in vec4 a_texCoord;
            in vec3 a_positionsHigh;
            in vec3 a_positionsLow;
            in vec3 a_offset;
            in float a_size;
            in float a_rotation;
            in vec4 a_rgba;
            in float a_fontIndex;

            out vec2 v_uv;
            out vec4 v_rgba;
            flat out int v_fontIndex;            
            out vec4 v_outlineColor;
            flat out float v_outline;

            uniform vec2 viewport;
            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float planetRadius;
            uniform vec3 scaleByDistance;
            uniform float opacity;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);
           
            ${PROJECT2}

            ${ROTATE2D2}

            void main() {

                if(a_texCoord.w == EMPTY) {
                    gl_Position = vec4(0.0);
                    v_fontIndex = -1;
                    return;
                }
               
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                v_outline = a_outline;

                v_fontIndex = int(a_fontIndex);
                v_uv = a_texCoord.xy;
                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                v_rgba = a_rgba;
                
                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));

                v_rgba.a *= opacity;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;                  
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                        
                projPos.z += depthOffset + a_offset.z;
                               
                vec2 screenPos = project(projPos);
                
                vec2 vert = a_vertices;                
                vec4 gp = a_gliphParam;                                
                if(a_texCoord.w == RTL){
                    vert.x = step(vert.x * 0.5 + 1.0, 1.0);
                    gp.x = -a_gliphParam.x;
                    gp.z = -(a_gliphParam.z + a_texCoord.z);
                }else{
                    gp.z = a_gliphParam.z + a_texCoord.z;
                }
                                
                vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);

                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
      fragmentShader: `#version 300 es

            uniform int isOutlinePass;
            
            precision highp float;

            const int MAX_SIZE = 11;

            // x - ATLAS_WIDTH = 512.0;
            // y - ATLAS_HEIGHT = 512.0;
            // z - ATLAS_GLYPH_SIZE = 32.0;
            // w - ATLAS_FIELD_RANGE = 8.0;

            uniform sampler2D fontTextureArr[MAX_SIZE];
            uniform vec4 sdfParamsArr[MAX_SIZE];

            flat in int v_fontIndex;
            in vec2 v_uv;
            in vec4 v_rgba;           

            flat in float v_outline;

            in vec3 v_pickingColor;

            layout(location = 0) out vec4 outScreen;

            float median(float r, float g, float b) {
                return max(min(r, g), min(max(r, g), b));
            }

            float getDistance() {
                vec3 msdf;
                if(v_fontIndex == 0) {
                    msdf = texture(fontTextureArr[0], v_uv).rgb;
                } else if(v_fontIndex == 1){
                    msdf = texture(fontTextureArr[1], v_uv).rgb;
                } else if(v_fontIndex == 2){
                    msdf = texture(fontTextureArr[2], v_uv).rgb;
                } else if(v_fontIndex == 3){
                    msdf = texture(fontTextureArr[3], v_uv).rgb;
                } else if(v_fontIndex == 4){
                    msdf = texture(fontTextureArr[4], v_uv).rgb;
                } else if(v_fontIndex == 5){
                    msdf = texture(fontTextureArr[5], v_uv).rgb;
                } else if(v_fontIndex == 6){
                    msdf = texture(fontTextureArr[6], v_uv).rgb;
                } else if(v_fontIndex == 7){
                    msdf = texture(fontTextureArr[7], v_uv).rgb;
                } else if(v_fontIndex == 8){
                    msdf = texture(fontTextureArr[8], v_uv).rgb;
                } else if(v_fontIndex == 9){
                    msdf = texture(fontTextureArr[9], v_uv).rgb;
                } else if(v_fontIndex == 10){
                    msdf = texture(fontTextureArr[10], v_uv).rgb;
                }
                return median(msdf.r, msdf.g, msdf.b);
            }
                        
            void main () {
            
                if(v_fontIndex == -1) {
                    return;
                }
                
                vec4 sdfParams = sdfParamsArr[v_fontIndex];
                float sd = getDistance();             
                vec2 dxdy = fwidth(v_uv) * sdfParams.xy;

                if(isOutlinePass == 0){                             
                    float dist = sd + min(0.001, 0.5 - 1.0 / sdfParams.w) - 0.5;
                    float opacity = clamp(dist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);
                    if(opacity <= 0.1){
                        discard;
                    }
                    outScreen = vec4(v_rgba.rgb, opacity * v_rgba.a);
                } else {             
                    float dist = sd + min(v_outline, 0.5 - 1.0 / sdfParams.w) - 0.5;
                    float opacity = clamp(dist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);                       
                    if(opacity <= 0.1){
                        discard;
                    }
                    outScreen = vec4(v_rgba.rgb, opacity * v_rgba.a);
                    //outScreen = v_rgba * strokeAlpha * (0.5 - opacity) * 2.0;
                }         
            }`
    });
  }
  function label_screen() {
    return new Program("label", {
      uniforms: {
        viewport: "vec2",
        fontTextureArr: "sampler2darray",
        sdfParamsArr: "vec4",
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        planetRadius: "float",
        scaleByDistance: "vec3",
        opacity: "float",
        isOutlinePass: "int",
        depthOffset: "float"
      },
      attributes: {
        a_outline: "float",
        a_gliphParam: "vec4",
        a_vertices: "vec2",
        a_texCoord: "vec4",
        a_positionsHigh: "vec3",
        a_positionsLow: "vec3",
        a_size: "float",
        a_rotation: "float",
        a_rgba: "vec4",
        a_offset: "vec3",
        a_fontIndex: "float"
      },
      vertexShader: `            
            ${DEFINE}
                        
            attribute float a_outline;
            attribute vec4 a_gliphParam;
            attribute vec2 a_vertices;
            attribute vec4 a_texCoord;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute float a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;
            attribute float a_fontIndex;

            varying float v_outline;
            varying vec2 v_uv;
            varying vec4 v_rgba;
            varying float v_fontIndex;            

            uniform vec2 viewport;
            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float planetRadius;
            uniform vec3 scaleByDistance;
            uniform float opacity;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT2}

            ${ROTATE2D2}

            void main() {

                if(a_texCoord.w == EMPTY) {
                    gl_Position = vec4(0.0);
                    v_fontIndex = -1.0;
                    return;
                }
               
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;

                v_outline = a_outline;
                v_uv = vec2(a_texCoord.xy);
                v_rgba = a_rgba;
                v_fontIndex = a_fontIndex;
                
                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                
                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));

                v_rgba.a *= opacity;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;                  
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                        
                projPos.z += depthOffset + a_offset.z;
                               
                vec2 screenPos = project(projPos);
                
                vec2 vert = a_vertices;                
                vec4 gp = a_gliphParam;                                
                if(a_texCoord.w == RTL){
                    vert.x = step(vert.x * 0.5 + 1.0, 1.0);
                    gp.x = -a_gliphParam.x;
                    gp.z = -(a_gliphParam.z + a_texCoord.z);
                }else{
                    gp.z = a_gliphParam.z + a_texCoord.z;
                }
                                
                vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);
                
                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
      fragmentShader: `#extension GL_OES_standard_derivatives : enable

            precision highp float;
            precision highp int;

            const int MAX_SIZE = 11;

            // x - ATLAS_WIDTH = 512.0;
            // y - ATLAS_HEIGHT = 512.0;
            // z - ATLAS_GLYPH_SIZE = 32.0;
            // w - ATLAS_FIELD_RANGE = 8.0;

            uniform sampler2D fontTextureArr[MAX_SIZE];
            uniform vec4 sdfParamsArr[MAX_SIZE];
            uniform int isOutlinePass;
            
            varying float v_outline;
            varying vec2 v_uv;
            varying vec4 v_rgba;           
            varying float v_fontIndex;
            
            float fontIndex;

            float median(float r, float g, float b) {
                return max(min(r, g), min(max(r, g), b));
            }

            float getDistance() {
                vec3 msdf;
                if(fontIndex >= 0.0 && fontIndex < 1.0) {
                    msdf = texture2D(fontTextureArr[0], v_uv).rgb;
                } else if(fontIndex >= 1.0 && fontIndex < 2.0){
                    msdf = texture2D(fontTextureArr[1], v_uv).rgb;
                } else if(fontIndex >= 2.0 && fontIndex < 3.0){
                    msdf = texture2D(fontTextureArr[2], v_uv).rgb;
                } else if(fontIndex >= 3.0 && fontIndex < 4.0){
                    msdf = texture2D(fontTextureArr[3], v_uv).rgb;
                } else if(fontIndex >= 4.0 && fontIndex < 5.0){
                    msdf = texture2D(fontTextureArr[4], v_uv).rgb;
                } else if(fontIndex >= 5.0 && fontIndex < 6.0){
                    msdf = texture2D(fontTextureArr[5], v_uv).rgb;
                } else if(fontIndex >= 6.0 && fontIndex < 7.0){
                    msdf = texture2D(fontTextureArr[6], v_uv).rgb;
                } else if(fontIndex >= 7.0 && fontIndex < 8.0){
                    msdf = texture2D(fontTextureArr[7], v_uv).rgb;
                } else if(fontIndex >= 8.0 && fontIndex < 9.0){
                    msdf = texture2D(fontTextureArr[8], v_uv).rgb;
                } else if(fontIndex >= 9.0 && fontIndex < 10.0){
                    msdf = texture2D(fontTextureArr[9], v_uv).rgb;
                } else if(fontIndex >= 10.0 && fontIndex < 11.0){
                    msdf = texture2D(fontTextureArr[10], v_uv).rgb;
                }
                return median(msdf.r, msdf.g, msdf.b);
            }


            vec4 getSDFParams() {
                if(fontIndex >= 0.0 && fontIndex < 1.0) {
                    return sdfParamsArr[0];
                } else if(fontIndex >= 1.0 && fontIndex < 2.0){
                    return sdfParamsArr[1];
                } else if(fontIndex >= 2.0 && fontIndex < 3.0){
                    return sdfParamsArr[2];
                } else if(fontIndex >= 3.0 && fontIndex < 4.0){
                    return sdfParamsArr[3];
                } else if(fontIndex >= 4.0 && fontIndex < 5.0){
                    return sdfParamsArr[4];
                } else if(fontIndex >= 5.0 && fontIndex < 6.0){
                    return sdfParamsArr[5];
                } else if(fontIndex >= 6.0 && fontIndex < 7.0){
                    return sdfParamsArr[6];
                } else if(fontIndex >= 7.0 && fontIndex < 8.0){
                    return sdfParamsArr[7];
                } else if(fontIndex >= 8.0 && fontIndex < 9.0){
                    return sdfParamsArr[8];
                } else if(fontIndex >= 9.0 && fontIndex < 10.0){
                    return sdfParamsArr[9];
                } else if(fontIndex >= 10.0 && fontIndex < 11.0){
                    return sdfParamsArr[10];
                }
            }
                    
            void main () {

                fontIndex = v_fontIndex + 0.1;
                
                if(v_fontIndex < 0.0){
                    return;
                }
                
                vec4 sdfParams = getSDFParams();
                float sd = getDistance();             
                vec2 dxdy = fwidth(v_uv) * sdfParams.xy;
                float dist = sd + min(0.001, 0.5 - 1.0 / sdfParams.w) - 0.5;
                float opacity = clamp(dist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);

                if(isOutlinePass == 0){                             
                    //gl_FragColor = vec4(v_rgba.rgb, opacity * v_rgba.a);
                } else {                
                    float strokeDist = sd + min(v_outline, 0.5 - 1.0 / sdfParams.w) - 0.5;
                    float strokeAlpha = v_rgba.a * clamp(strokeDist * sdfParams.w / length(dxdy) + 0.5, 0.0, 1.0);                    
                    if(strokeAlpha < 0.1){
                        discard;
                    }
                    //gl_FragColor = v_rgba * strokeAlpha * (0.5 - opacity) * 2.0;
                }
            }`
    });
  }
  function labelPicking() {
    return new Program("labelPicking", {
      uniforms: {
        viewport: "vec2",
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        planetRadius: "float",
        scaleByDistance: "vec3",
        opacity: "float",
        depthOffset: "float"
      },
      attributes: {
        a_gliphParam: "vec4",
        a_vertices: "vec2",
        a_texCoord: "vec4",
        a_positionsHigh: "vec3",
        a_positionsLow: "vec3",
        a_offset: "vec3",
        a_size: "float",
        a_rotation: "float",
        a_rgba: "vec4"
      },
      vertexShader: `
            
            ${DEFINE}
            
            attribute vec4 a_gliphParam;
            attribute vec2 a_vertices;
            attribute vec4 a_texCoord;
            attribute vec3 a_positionsHigh;
            attribute vec3 a_positionsLow;
            attribute vec3 a_offset;
            attribute float a_size;
            attribute float a_rotation;
            attribute vec4 a_rgba;

            varying vec4 v_rgba;

            uniform vec2 viewport;
            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float planetRadius;
            uniform vec3 scaleByDistance;
            uniform float opacity;
            uniform float depthOffset;

            const vec3 ZERO3 = vec3(0.0);

            ${PROJECT2}

            ${ROTATE2D2}

            void main() {
                vec3 a_positions = a_positionsHigh + a_positionsLow;
                vec3 cameraPos = eyePositionHigh + eyePositionLow;
                v_rgba = a_rgba;
                
                if(a_texCoord.w == EMPTY) {
                    v_rgba.a = 0.0;
                    gl_Position = vec4(0.0);
                    return;
                }

                vec3 look = a_positions - cameraPos;
                float lookDist = length(look);
                if(opacity * step(lookDist, sqrt(dot(cameraPos,cameraPos) - planetRadius) + sqrt(dot(a_positions,a_positions) - planetRadius)) == 0.0){
                    return;
                }

                float scd = (1.0 - smoothstep(scaleByDistance[0], scaleByDistance[1], lookDist)) * (1.0 - step(scaleByDistance[2], lookDist));

                v_rgba.a *= opacity;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                vec3 highDiff = a_positionsHigh - eyePositionHigh;
                vec3 lowDiff = a_positionsLow - eyePositionLow;
                vec4 posRTE = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);
                vec4 projPos = projectionMatrix * posRTE;
                
                float camSlope = dot(vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]), normalize(cameraPos));                
                if(camSlope > 0.5) {
                    float dist = dot(look, normalize(cameraPos));
                    projPos.z += dist * 0.02;                  
                }else{
                    projPos.z += -(abs(projPos.z)) * 0.002;                 
                }
                        
                projPos.z += depthOffset + a_offset.z;
                
                vec2 screenPos = project(projPos);
                
                vec2 vert = a_vertices;                
                vec4 gp = a_gliphParam;                                
                if(a_texCoord.w == RTL){
                    vert.x = step(vert.x * 0.5 + 1.0, 1.0);
                    gp.x = -a_gliphParam.x;
                    gp.z = -(a_gliphParam.z + a_texCoord.z);
                }else{
                    gp.z = a_gliphParam.z + a_texCoord.z;
                }
                                
                vec2 v = screenPos + rotate2d(a_rotation) * ((vert * gp.xy + gp.zw) * a_size * scd + a_offset.xy);
                                
                gl_Position = vec4((2.0 * v / viewport - 1.0) * projPos.w, projPos.z, projPos.w);
            }`,
      fragmentShader: `precision highp float;

            varying vec4 v_rgba;

            varying vec3 v_pickingColor;

            void main () {

                vec4 color = v_rgba;
                if (color.a < 0.05) {
                    return;
                }

                gl_FragColor = vec4(v_rgba.rgb, v_rgba.a);
            }`
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/entity/LabelHandler.js
  var PICKINGCOLOR_BUFFER3 = 0;
  var POSITION_BUFFER3 = 1;
  var SIZE_BUFFER3 = 2;
  var OFFSET_BUFFER2 = 3;
  var RGBA_BUFFER3 = 4;
  var ROTATION_BUFFER2 = 5;
  var TEXCOORD_BUFFER3 = 6;
  var VERTEX_BUFFER3 = 7;
  var FONTINDEX_BUFFER = 8;
  var OUTLINE_BUFFER = 9;
  var OUTLINECOLOR_BUFFER = 10;
  var EMPTY = -1;
  var RTL = 1;
  var LabelHandler = class extends BaseBillboardHandler {
    constructor(entityCollection, maxLetters = 21) {
      super(entityCollection);
      this._billboards = [];
      this._gliphParamBuffer = null;
      this._fontIndexBuffer = null;
      this._outlineBuffer = null;
      this._outlineColorBuffer = null;
      this._gliphParamArr = new Float32Array([]);
      this._fontIndexArr = new Float32Array([]);
      this._outlineArr = new Float32Array([]);
      this._outlineColorArr = new Float32Array([]);
      this._buffersUpdateCallbacks[FONTINDEX_BUFFER] = this.createFontIndexBuffer;
      this._buffersUpdateCallbacks[OUTLINE_BUFFER] = this.createOutlineBuffer;
      this._buffersUpdateCallbacks[OUTLINECOLOR_BUFFER] = this.createOutlineColorBuffer;
      this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
      this._maxLetters = maxLetters;
    }
    initProgram() {
      if (this._renderer && this._renderer.handler && this._renderer.handler.gl) {
        if (!this._renderer.handler.programs.label) {
          if (this._renderer.handler.gl.type === "webgl2") {
            this._renderer.handler.addProgram(label_webgl2());
          } else {
            this._renderer.handler.addProgram(label_screen());
          }
        }
        if (!this._renderer.handler.programs.labelPicking) {
          this._renderer.handler.addProgram(labelPicking());
        }
      }
    }
    get labels() {
      return this._billboards;
    }
    add(label) {
      if (!label._handler) {
        label._handler = this;
        this.assignFontAtlas(label);
        this.refresh();
      }
    }
    updateFonts() {
      let l4 = [...this._billboards];
      this._billboards = [];
      for (let i9 = 0; i9 < l4.length; i9++) {
        this.assignFontAtlas(l4[i9]);
      }
    }
    _addLabelToArrays(label) {
      this._renderer && this._renderer.labelWorker.make({ handler: this, label });
    }
    assignFontAtlas(label) {
      if (this._entityCollection && this._renderer) {
        label.assignFontAtlas(this._renderer.fontAtlas);
        this._addLabelToArrays(label);
      } else {
        this._billboards.push(label);
      }
    }
    workerCallback(data, label) {
      if (label._lockId !== LOCK_FREE && label._handler && this.isEqual(label._handler)) {
        label._isReady = true;
        label._lockId = LOCK_FREE;
        label._handlerIndex = this._billboards.length;
        this._billboards.push(label);
        this._vertexArr = concatTypedArrays(this._vertexArr, data.vertexArr);
        this._texCoordArr = concatTypedArrays(this._texCoordArr, data.texCoordArr);
        this._gliphParamArr = concatTypedArrays(this._gliphParamArr, data.gliphParamArr);
        this._positionHighArr = concatTypedArrays(this._positionHighArr, data.positionHighArr);
        this._positionLowArr = concatTypedArrays(this._positionLowArr, data.positionLowArr);
        this._sizeArr = concatTypedArrays(this._sizeArr, data.sizeArr);
        this._offsetArr = concatTypedArrays(this._offsetArr, data.offsetArr);
        this._rgbaArr = concatTypedArrays(this._rgbaArr, data.rgbaArr);
        this._rotationArr = concatTypedArrays(this._rotationArr, data.rotationArr);
        this._fontIndexArr = concatTypedArrays(this._fontIndexArr, data.fontIndexArr);
        this._outlineArr = concatTypedArrays(this._outlineArr, data.outlineArr);
        this._outlineColorArr = concatTypedArrays(this._outlineColorArr, data.outlineColorArr);
        this._pickingColorArr = concatTypedArrays(this._pickingColorArr, data.pickingColorArr);
        label.update();
        this.refresh();
      }
    }
    clear() {
      this._texCoordArr = null;
      this._gliphParamArr = null;
      this._vertexArr = null;
      this._positionHighArr = null;
      this._positionLowArr = null;
      this._sizeArr = null;
      this._offsetArr = null;
      this._rgbaArr = null;
      this._rotationArr = null;
      this._fontIndexArr = null;
      this._outlineArr = null;
      this._outlineColorArr = null;
      this._texCoordArr = new Float32Array([]);
      this._gliphParamArr = new Float32Array([]);
      this._vertexArr = new Float32Array([]);
      this._positionHighArr = new Float32Array([]);
      this._positionLowArr = new Float32Array([]);
      this._sizeArr = new Float32Array([]);
      this._offsetArr = new Float32Array([]);
      this._rgbaArr = new Float32Array([]);
      this._rotationArr = new Float32Array([]);
      this._fontIndexArr = new Float32Array([]);
      this._outlineArr = new Float32Array([]);
      this._outlineColorArr = new Float32Array([]);
      this._removeBillboards();
      this._deleteBuffers();
      this.refresh();
    }
    _deleteBuffers() {
      if (this._renderer) {
        let gl = this._renderer.handler.gl;
        gl.deleteBuffer(this._gliphParamBuffer);
        gl.deleteBuffer(this._sizeBuffer);
        gl.deleteBuffer(this._fontIndexBuffer);
        gl.deleteBuffer(this._texCoordBuffer);
        gl.deleteBuffer(this._outlineBuffer);
        gl.deleteBuffer(this._outlineColorBuffer);
        gl.deleteBuffer(this._positionHighBuffer);
        gl.deleteBuffer(this._positionLowBuffer);
        gl.deleteBuffer(this._sizeBuffer);
        gl.deleteBuffer(this._offsetBuffer);
        gl.deleteBuffer(this._rgbaBuffer);
        gl.deleteBuffer(this._rotationBuffer);
        gl.deleteBuffer(this._vertexBuffer);
        gl.deleteBuffer(this._texCoordBuffer);
        gl.deleteBuffer(this._pickingColorBuffer);
        this._gliphParamBuffer = null;
        this._sizeBuffer = null;
        this._fontIndexBuffer = null;
        this._texCoordBuffer = null;
        this._outlineBuffer = null;
        this._outlineColorBuffer = null;
        this._positionHighBuffer = null;
        this._positionLowBuffer = null;
        this._sizeBuffer = null;
        this._offsetBuffer = null;
        this._rgbaBuffer = null;
        this._rotationBuffer = null;
        this._vertexBuffer = null;
        this._texCoordBuffer = null;
        this._pickingColorBuffer = null;
      }
    }
    _displayPASS() {
      let r8 = this._renderer;
      let h8 = r8.handler;
      h8.programs.label.activate();
      let sh = h8.programs.label._program;
      let sha = sh.attributes, shu = sh.uniforms;
      let gl = h8.gl, ec = this._entityCollection;
      gl.disable(gl.CULL_FACE);
      gl.uniform1iv(shu.fontTextureArr, r8.fontAtlas.samplerArr);
      gl.uniform4fv(shu.sdfParamsArr, r8.fontAtlas.sdfParamsArr);
      gl.uniformMatrix4fv(shu.viewMatrix, false, r8.activeCamera.getViewMatrix());
      gl.uniformMatrix4fv(shu.projectionMatrix, false, r8.activeCamera.getProjectionMatrix());
      gl.uniform3fv(shu.eyePositionHigh, r8.activeCamera.eyeHigh);
      gl.uniform3fv(shu.eyePositionLow, r8.activeCamera.eyeLow);
      gl.uniform3fv(shu.scaleByDistance, ec.scaleByDistance);
      gl.uniform1f(shu.opacity, ec._fadingOpacity);
      gl.uniform1f(shu.planetRadius, ec.renderNode._planetRadius2 || 0);
      gl.uniform2fv(shu.viewport, [h8.canvas.clientWidth, h8.canvas.clientHeight]);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
      gl.vertexAttribPointer(sha.a_texCoord, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._gliphParamBuffer);
      gl.vertexAttribPointer(sha.a_gliphParam, this._gliphParamBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
      gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
      gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
      gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
      gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
      gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._fontIndexBuffer);
      gl.vertexAttribPointer(sha.a_fontIndex, this._fontIndexBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.uniform1i(shu.isOutlinePass, 1);
      gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._outlineColorBuffer);
      gl.vertexAttribPointer(sha.a_rgba, this._outlineColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._outlineBuffer);
      gl.vertexAttribPointer(sha.a_outline, this._outlineBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
      gl.depthFunc(gl.EQUAL);
      gl.uniform1i(shu.isOutlinePass, 0);
      gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer);
      gl.vertexAttribPointer(sha.a_rgba, this._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
      gl.depthFunc(gl.LESS);
      gl.enable(gl.CULL_FACE);
    }
    _pickingPASS() {
      let r8 = this._renderer;
      let h8 = r8.handler;
      h8.programs.labelPicking.activate();
      let sh = h8.programs.labelPicking._program;
      let sha = sh.attributes, shu = sh.uniforms;
      let gl = h8.gl, ec = this._entityCollection;
      let rn = ec.renderNode;
      gl.disable(gl.CULL_FACE);
      gl.uniformMatrix4fv(shu.viewMatrix, false, r8.activeCamera.getViewMatrix());
      gl.uniformMatrix4fv(shu.projectionMatrix, false, r8.activeCamera.getProjectionMatrix());
      gl.uniform3fv(shu.eyePositionHigh, r8.activeCamera.eyeHigh);
      gl.uniform3fv(shu.eyePositionLow, r8.activeCamera.eyeLow);
      gl.uniform3fv(shu.scaleByDistance, ec.scaleByDistance);
      gl.uniform1f(shu.opacity, ec._fadingOpacity);
      gl.uniform1f(shu.planetRadius, rn._planetRadius2 || 0);
      gl.uniform2fv(shu.viewport, [h8.canvas.clientWidth, h8.canvas.clientHeight]);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
      gl.vertexAttribPointer(sha.a_texCoord, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._gliphParamBuffer);
      gl.vertexAttribPointer(sha.a_gliphParam, this._gliphParamBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._positionHighBuffer);
      gl.vertexAttribPointer(sha.a_positionsHigh, this._positionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._positionLowBuffer);
      gl.vertexAttribPointer(sha.a_positionsLow, this._positionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
      gl.vertexAttribPointer(sha.a_size, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
      gl.vertexAttribPointer(sha.a_rotation, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
      gl.vertexAttribPointer(sha.a_offset, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
      gl.vertexAttribPointer(sha.a_rgba, this._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.uniform1f(shu.depthOffset, ec.polygonOffsetUnits);
      gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
      gl.enable(gl.CULL_FACE);
    }
    _removeBillboard(label) {
      let li = label._handlerIndex;
      this._billboards.splice(li, 1);
      let ml = 24 * this._maxLetters;
      let i9 = li * ml;
      this._rgbaArr = spliceTypedArray(this._rgbaArr, i9, ml);
      this._outlineColorArr = spliceTypedArray(this._outlineColorArr, i9, ml);
      this._texCoordArr = spliceTypedArray(this._texCoordArr, i9, ml);
      this._gliphParamArr = spliceTypedArray(this._gliphParamArr, i9, ml);
      ml = 18 * this._maxLetters;
      i9 = li * ml;
      this._positionHighArr = spliceTypedArray(this._positionHighArr, i9, ml);
      this._positionLowArr = spliceTypedArray(this._positionLowArr, i9, ml);
      this._offsetArr = spliceTypedArray(this._offsetArr, i9, ml);
      this._pickingColorArr = spliceTypedArray(this._pickingColorArr, i9, ml);
      ml = 12 * this._maxLetters;
      i9 = li * ml;
      this._vertexArr = spliceTypedArray(this._vertexArr, i9, ml);
      ml = 6 * this._maxLetters;
      i9 = li * ml;
      this._sizeArr = spliceTypedArray(this._sizeArr, i9, ml);
      this._rotationArr = spliceTypedArray(this._rotationArr, i9, ml);
      this._fontIndexArr = spliceTypedArray(this._fontIndexArr, i9, ml);
      this._outlineArr = spliceTypedArray(this._outlineArr, i9, ml);
      this.reindexBillboardsArray(li);
      this.refresh();
      label._handlerIndex = -1;
      label._handler = null;
      label._isReady = false;
    }
    setText(index, text, fontIndex, align, isRTL = false) {
      text = text.normalize("NFKC");
      let fa = this._renderer.fontAtlas.atlasesArr[fontIndex];
      if (!fa)
        return;
      let i9 = index * 24 * this._maxLetters;
      let a6 = this._texCoordArr, g4 = this._gliphParamArr;
      let c7 = 0;
      let len = Math.min(this._maxLetters, text.length);
      let _rtl_ = 0;
      if (isRTL) {
        _rtl_ = RTL;
      }
      let offset = 0;
      let kern = fa.kernings;
      for (c7 = 0; c7 < len; c7++) {
        let j2 = i9 + c7 * 24;
        let char = text[c7];
        let n7 = fa.get(char.charCodeAt(0)) || fa.get(" ".charCodeAt(0));
        if (!n7)
          continue;
        let tc = n7.texCoords;
        let m5 = n7.metrics;
        a6[j2] = tc[0];
        a6[j2 + 1] = tc[1];
        a6[j2 + 2] = offset;
        a6[j2 + 3] = _rtl_;
        a6[j2 + 4] = tc[2];
        a6[j2 + 5] = tc[3];
        a6[j2 + 6] = offset;
        a6[j2 + 7] = _rtl_;
        a6[j2 + 8] = tc[4];
        a6[j2 + 9] = tc[5];
        a6[j2 + 10] = offset;
        a6[j2 + 11] = _rtl_;
        a6[j2 + 12] = tc[6];
        a6[j2 + 13] = tc[7];
        a6[j2 + 14] = offset;
        a6[j2 + 15] = _rtl_;
        a6[j2 + 16] = tc[8];
        a6[j2 + 17] = tc[9];
        a6[j2 + 18] = offset;
        a6[j2 + 19] = _rtl_;
        a6[j2 + 20] = tc[10];
        a6[j2 + 21] = tc[11];
        a6[j2 + 22] = offset;
        a6[j2 + 23] = _rtl_;
        g4[j2] = m5.nWidth;
        g4[j2 + 1] = m5.nHeight;
        g4[j2 + 2] = m5.nXOffset;
        g4[j2 + 3] = m5.nYOffset;
        g4[j2 + 4] = m5.nWidth;
        g4[j2 + 5] = m5.nHeight;
        g4[j2 + 6] = m5.nXOffset;
        g4[j2 + 7] = m5.nYOffset;
        g4[j2 + 8] = m5.nWidth;
        g4[j2 + 9] = m5.nHeight;
        g4[j2 + 10] = m5.nXOffset;
        g4[j2 + 11] = m5.nYOffset;
        g4[j2 + 12] = m5.nWidth;
        g4[j2 + 13] = m5.nHeight;
        g4[j2 + 14] = m5.nXOffset;
        g4[j2 + 15] = m5.nYOffset;
        g4[j2 + 16] = m5.nWidth;
        g4[j2 + 17] = m5.nHeight;
        g4[j2 + 18] = m5.nXOffset;
        g4[j2 + 19] = m5.nYOffset;
        g4[j2 + 20] = m5.nWidth;
        g4[j2 + 21] = m5.nHeight;
        g4[j2 + 22] = m5.nXOffset;
        g4[j2 + 23] = m5.nYOffset;
        let k3 = kern[char.charCodeAt(0)];
        if (k3 && text[c7 + 1]) {
          let kk = k3[text[c7 + 1].charCodeAt(0)];
          if (kk) {
            offset += m5.nAdvance + kk;
          } else {
            offset += m5.nAdvance;
          }
        } else {
          offset += m5.nAdvance;
        }
      }
      if (align === ALIGN.CENTER) {
        offset *= -0.5;
        for (c7 = 0; c7 < len; c7++) {
          let j2 = i9 + c7 * 24;
          a6[j2 + 2] += offset;
          a6[j2 + 6] += offset;
          a6[j2 + 10] += offset;
          a6[j2 + 14] += offset;
          a6[j2 + 18] += offset;
          a6[j2 + 22] += offset;
        }
      }
      for (; c7 < this._maxLetters; c7++) {
        let j2 = i9 + c7 * 24;
        a6[j2 + 3] = EMPTY;
        a6[j2 + 7] = EMPTY;
        a6[j2 + 11] = EMPTY;
        a6[j2 + 15] = EMPTY;
        a6[j2 + 19] = EMPTY;
        a6[j2 + 23] = EMPTY;
      }
      this._changedBuffers[TEXCOORD_BUFFER3] = true;
    }
    setPositionArr(index, positionHigh, positionLow) {
      let i9 = index * 18 * this._maxLetters;
      let a6 = this._positionHighArr, x3 = positionHigh.x, y4 = positionHigh.y, z3 = positionHigh.z, b4 = this._positionLowArr, xl = positionLow.x, yl = positionLow.y, zl = positionLow.z;
      for (let q2 = 0; q2 < this._maxLetters; q2++) {
        let j2 = i9 + q2 * 18;
        a6[j2] = x3;
        a6[j2 + 1] = y4;
        a6[j2 + 2] = z3;
        a6[j2 + 3] = x3;
        a6[j2 + 4] = y4;
        a6[j2 + 5] = z3;
        a6[j2 + 6] = x3;
        a6[j2 + 7] = y4;
        a6[j2 + 8] = z3;
        a6[j2 + 9] = x3;
        a6[j2 + 10] = y4;
        a6[j2 + 11] = z3;
        a6[j2 + 12] = x3;
        a6[j2 + 13] = y4;
        a6[j2 + 14] = z3;
        a6[j2 + 15] = x3;
        a6[j2 + 16] = y4;
        a6[j2 + 17] = z3;
        b4[j2] = xl;
        b4[j2 + 1] = yl;
        b4[j2 + 2] = zl;
        b4[j2 + 3] = xl;
        b4[j2 + 4] = yl;
        b4[j2 + 5] = zl;
        b4[j2 + 6] = xl;
        b4[j2 + 7] = yl;
        b4[j2 + 8] = zl;
        b4[j2 + 9] = xl;
        b4[j2 + 10] = yl;
        b4[j2 + 11] = zl;
        b4[j2 + 12] = xl;
        b4[j2 + 13] = yl;
        b4[j2 + 14] = zl;
        b4[j2 + 15] = xl;
        b4[j2 + 16] = yl;
        b4[j2 + 17] = zl;
      }
      this._changedBuffers[POSITION_BUFFER3] = true;
    }
    setPickingColorArr(index, color) {
      let i9 = index * 18 * this._maxLetters;
      let a6 = this._pickingColorArr, x3 = color.x / 255, y4 = color.y / 255, z3 = color.z / 255;
      for (let q2 = 0; q2 < this._maxLetters; q2++) {
        let j2 = i9 + q2 * 18;
        a6[j2] = x3;
        a6[j2 + 1] = y4;
        a6[j2 + 2] = z3;
        a6[j2 + 3] = x3;
        a6[j2 + 4] = y4;
        a6[j2 + 5] = z3;
        a6[j2 + 6] = x3;
        a6[j2 + 7] = y4;
        a6[j2 + 8] = z3;
        a6[j2 + 9] = x3;
        a6[j2 + 10] = y4;
        a6[j2 + 11] = z3;
        a6[j2 + 12] = x3;
        a6[j2 + 13] = y4;
        a6[j2 + 14] = z3;
        a6[j2 + 15] = x3;
        a6[j2 + 16] = y4;
        a6[j2 + 17] = z3;
      }
      this._changedBuffers[PICKINGCOLOR_BUFFER3] = true;
    }
    setSizeArr(index, size) {
      let i9 = index * 6 * this._maxLetters;
      let a6 = this._sizeArr;
      for (let q2 = 0; q2 < this._maxLetters; q2++) {
        let j2 = i9 + q2 * 6;
        a6[j2] = size;
        a6[j2 + 1] = size;
        a6[j2 + 2] = size;
        a6[j2 + 3] = size;
        a6[j2 + 4] = size;
        a6[j2 + 5] = size;
      }
      this._changedBuffers[SIZE_BUFFER3] = true;
    }
    setOffsetArr(index, offset) {
      let i9 = index * 18 * this._maxLetters;
      let a6 = this._offsetArr, x3 = offset.x, y4 = offset.y, z3 = offset.z;
      for (let q2 = 0; q2 < this._maxLetters; q2++) {
        let j2 = i9 + q2 * 18;
        a6[j2] = x3;
        a6[j2 + 1] = y4;
        a6[j2 + 2] = z3;
        a6[j2 + 3] = x3;
        a6[j2 + 4] = y4;
        a6[j2 + 5] = z3;
        a6[j2 + 6] = x3;
        a6[j2 + 7] = y4;
        a6[j2 + 8] = z3;
        a6[j2 + 9] = x3;
        a6[j2 + 10] = y4;
        a6[j2 + 11] = z3;
        a6[j2 + 12] = x3;
        a6[j2 + 13] = y4;
        a6[j2 + 14] = z3;
        a6[j2 + 15] = x3;
        a6[j2 + 16] = y4;
        a6[j2 + 17] = z3;
      }
      this._changedBuffers[OFFSET_BUFFER2] = true;
    }
    setRgbaArr(index, rgba) {
      let i9 = index * 24 * this._maxLetters;
      let a6 = this._rgbaArr, x3 = rgba.x, y4 = rgba.y, z3 = rgba.z, w3 = rgba.w;
      for (let q2 = 0; q2 < this._maxLetters; q2++) {
        let j2 = i9 + q2 * 24;
        a6[j2] = x3;
        a6[j2 + 1] = y4;
        a6[j2 + 2] = z3;
        a6[j2 + 3] = w3;
        a6[j2 + 4] = x3;
        a6[j2 + 5] = y4;
        a6[j2 + 6] = z3;
        a6[j2 + 7] = w3;
        a6[j2 + 8] = x3;
        a6[j2 + 9] = y4;
        a6[j2 + 10] = z3;
        a6[j2 + 11] = w3;
        a6[j2 + 12] = x3;
        a6[j2 + 13] = y4;
        a6[j2 + 14] = z3;
        a6[j2 + 15] = w3;
        a6[j2 + 16] = x3;
        a6[j2 + 17] = y4;
        a6[j2 + 18] = z3;
        a6[j2 + 19] = w3;
        a6[j2 + 20] = x3;
        a6[j2 + 21] = y4;
        a6[j2 + 22] = z3;
        a6[j2 + 23] = w3;
      }
      this._changedBuffers[RGBA_BUFFER3] = true;
    }
    setOutlineColorArr(index, rgba) {
      let i9 = index * 24 * this._maxLetters;
      let a6 = this._outlineColorArr, x3 = rgba.x, y4 = rgba.y, z3 = rgba.z, w3 = rgba.w;
      for (let q2 = 0; q2 < this._maxLetters; q2++) {
        let j2 = i9 + q2 * 24;
        a6[j2] = x3;
        a6[j2 + 1] = y4;
        a6[j2 + 2] = z3;
        a6[j2 + 3] = w3;
        a6[j2 + 4] = x3;
        a6[j2 + 5] = y4;
        a6[j2 + 6] = z3;
        a6[j2 + 7] = w3;
        a6[j2 + 8] = x3;
        a6[j2 + 9] = y4;
        a6[j2 + 10] = z3;
        a6[j2 + 11] = w3;
        a6[j2 + 12] = x3;
        a6[j2 + 13] = y4;
        a6[j2 + 14] = z3;
        a6[j2 + 15] = w3;
        a6[j2 + 16] = x3;
        a6[j2 + 17] = y4;
        a6[j2 + 18] = z3;
        a6[j2 + 19] = w3;
        a6[j2 + 20] = x3;
        a6[j2 + 21] = y4;
        a6[j2 + 22] = z3;
        a6[j2 + 23] = w3;
      }
      this._changedBuffers[OUTLINECOLOR_BUFFER] = true;
    }
    setOutlineArr(index, outline) {
      let i9 = index * 6 * this._maxLetters;
      let a6 = this._outlineArr;
      for (let q2 = 0; q2 < this._maxLetters; q2++) {
        let j2 = i9 + q2 * 6;
        a6[j2] = outline;
        a6[j2 + 1] = outline;
        a6[j2 + 2] = outline;
        a6[j2 + 3] = outline;
        a6[j2 + 4] = outline;
        a6[j2 + 5] = outline;
      }
      this._changedBuffers[OUTLINE_BUFFER] = true;
    }
    setRotationArr(index, rotation) {
      let i9 = index * 6 * this._maxLetters;
      let a6 = this._rotationArr;
      for (let q2 = 0; q2 < this._maxLetters; q2++) {
        let j2 = i9 + q2 * 6;
        a6[j2] = rotation;
        a6[j2 + 1] = rotation;
        a6[j2 + 2] = rotation;
        a6[j2 + 3] = rotation;
        a6[j2 + 4] = rotation;
        a6[j2 + 5] = rotation;
      }
      this._changedBuffers[ROTATION_BUFFER2] = true;
    }
    setVisibility(index, visibility) {
      let vArr;
      if (visibility) {
        vArr = [0, 0, 0, -1, 1, -1, 1, -1, 1, 0, 0, 0];
      } else {
        vArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      this.setVertexArr(index, vArr);
    }
    setVertexArr(index, vertexArr) {
      let i9 = index * 12 * this._maxLetters;
      let a6 = this._vertexArr;
      for (let q2 = 0; q2 < this._maxLetters; q2++) {
        let j2 = i9 + q2 * 12;
        a6[j2] = vertexArr[0];
        a6[j2 + 1] = vertexArr[1];
        a6[j2 + 2] = vertexArr[2];
        a6[j2 + 3] = vertexArr[3];
        a6[j2 + 4] = vertexArr[4];
        a6[j2 + 5] = vertexArr[5];
        a6[j2 + 6] = vertexArr[6];
        a6[j2 + 7] = vertexArr[7];
        a6[j2 + 8] = vertexArr[8];
        a6[j2 + 9] = vertexArr[9];
        a6[j2 + 10] = vertexArr[10];
        a6[j2 + 11] = vertexArr[11];
      }
      this._changedBuffers[VERTEX_BUFFER3] = true;
    }
    setFontIndexArr(index, fontIndex) {
      let i9 = index * 6 * this._maxLetters;
      let a6 = this._fontIndexArr;
      for (let q2 = 0; q2 < this._maxLetters; q2++) {
        let j2 = i9 + q2 * 6;
        a6[j2] = fontIndex;
        a6[j2 + 1] = fontIndex;
        a6[j2 + 2] = fontIndex;
        a6[j2 + 3] = fontIndex;
        a6[j2 + 4] = fontIndex;
        a6[j2 + 5] = fontIndex;
      }
      this._changedBuffers[FONTINDEX_BUFFER] = true;
    }
    createSizeBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._sizeBuffer);
      this._sizeBuffer = h8.createArrayBuffer(this._sizeArr, 1, this._sizeArr.length);
    }
    createFontIndexBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._fontIndexBuffer);
      this._fontIndexBuffer = h8.createArrayBuffer(this._fontIndexArr, 1, this._fontIndexArr.length);
    }
    createTexCoordBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._texCoordBuffer);
      this._texCoordBuffer = h8.createArrayBuffer(this._texCoordArr, 4, this._texCoordArr.length / 4);
      h8.gl.deleteBuffer(this._gliphParamBuffer);
      this._gliphParamBuffer = h8.createArrayBuffer(this._gliphParamArr, 4, this._gliphParamArr.length / 4);
    }
    createOutlineBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._outlineBuffer);
      this._outlineBuffer = h8.createArrayBuffer(this._outlineArr, 1, this._outlineArr.length);
    }
    createOutlineColorBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._outlineColorBuffer);
      this._outlineColorBuffer = h8.createArrayBuffer(this._outlineColorArr, 4, this._outlineColorArr.length / 4);
    }
    setMaxLetters(c7) {
      this._maxLetters = c7;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/shaders/pointCloud.js
  function pointCloud() {
    return new Program("pointCloud", {
      uniforms: {
        projectionViewMatrix: "mat4",
        opacity: "float",
        pointSize: "float"
      },
      attributes: {
        coordinates: "vec3",
        colors: "vec3"
      },
      vertexShader: `attribute vec3 coordinates;
            attribute vec4 colors;
            uniform mat4 projectionViewMatrix;
            uniform float opacity;
            uniform float pointSize;
            varying vec4 color;
            void main() {
                color = colors;
                color.a *= opacity;
                gl_Position = projectionViewMatrix * vec4(coordinates, 1.0);
                gl_PointSize = pointSize;
            }`,
      fragmentShader: `precision highp float;
            varying vec4 color;
            void main(void) {
                gl_FragColor = color;
            }`
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/entity/PointCloudHandler.js
  var PointCloudHandler = class _PointCloudHandler {
    constructor(entityCollection) {
      this.pickingEnabled = true;
      this.__id = _PointCloudHandler.__counter__++;
      this.pickingEnabled = true;
      this._entityCollection = entityCollection;
      this._renderer = null;
      this._pointClouds = [];
    }
    _initProgram() {
      if (this._renderer && this._renderer.handler) {
        if (!this._renderer.handler.programs.pointCloud) {
          this._renderer.handler.addProgram(pointCloud());
        }
      }
    }
    setRenderNode(renderNode) {
      this._renderer = renderNode.renderer;
      this._initProgram();
      for (let i9 = 0; i9 < this._pointClouds.length; i9++) {
        this._pointClouds[i9].setRenderNode(renderNode);
      }
    }
    add(pointCloud2) {
      if (pointCloud2._handlerIndex === -1) {
        pointCloud2._handler = this;
        pointCloud2._handlerIndex = this._pointClouds.length;
        this._pointClouds.push(pointCloud2);
        this._entityCollection && this._entityCollection.renderNode && pointCloud2.setRenderNode(this._entityCollection.renderNode);
      }
    }
    remove(pointCloud2) {
      let index = pointCloud2._handlerIndex;
      if (index !== -1) {
        pointCloud2._deleteBuffers();
        pointCloud2._handlerIndex = -1;
        pointCloud2._handler = null;
        this._pointClouds.splice(index, 1);
        this._reindexPointCloudArray(index);
      }
    }
    _reindexPointCloudArray(startIndex) {
      let pc = this._pointClouds;
      for (let i9 = startIndex; i9 < pc.length; i9++) {
        pc[i9]._handlerIndex = i9;
      }
    }
    draw() {
      let i9 = this._pointClouds.length;
      while (i9--) {
        this._pointClouds[i9].draw();
      }
    }
    drawPicking() {
      if (this.pickingEnabled) {
        let i9 = this._pointClouds.length;
        while (i9--) {
          this._pointClouds[i9].drawPicking();
        }
      }
    }
    clear() {
      let i9 = this._pointClouds.length;
      while (i9--) {
        this._pointClouds[i9]._deleteBuffers();
        this._pointClouds[i9]._handler = null;
        this._pointClouds[i9]._handlerIndex = -1;
      }
      this._pointClouds.length = 0;
      this._pointClouds = [];
    }
  };
  PointCloudHandler.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/shaders/polyline.js
  function polyline_screen() {
    return new Program("polyline_screen", {
      uniforms: {
        viewport: "vec2",
        proj: "mat4",
        view: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        uFloatParams: "vec2",
        thickness: "float",
        opacity: "float",
        depthOffset: "float"
      },
      attributes: {
        prevHigh: "vec3",
        currentHigh: "vec3",
        nextHigh: "vec3",
        prevLow: "vec3",
        currentLow: "vec3",
        nextLow: "vec3",
        order: "float",
        color: "vec4"
      },
      vertexShader: `precision highp float;

                attribute vec3 prevHigh;
                attribute vec3 currentHigh;
                attribute vec3 nextHigh;

                attribute vec3 prevLow;
                attribute vec3 currentLow;
                attribute vec3 nextLow;

                attribute float order;

                attribute vec4 color;

                uniform float thickness;
                uniform mat4 proj;
                uniform mat4 view;
                uniform vec2 viewport;
                uniform vec3 eyePositionHigh;
                uniform vec3 eyePositionLow;
                uniform float opacity;
                uniform float depthOffset;

                varying vec4 vColor;
                varying vec3 vPos;
                varying vec3 uCamPos;

                const float NEAR = -1.0;

                vec2 getIntersection(vec2 start1, vec2 end1, vec2 start2, vec2 end2){
                    vec2 dir = end2 - start2;
                    vec2 perp = vec2(-dir.y, dir.x);
                    float d2 = dot(perp, start2);
                    float seg = dot(perp, start1) - d2;
                    float prl = seg - dot(perp, end1) + d2;
                    if(prl > -1.0 && prl < 1.0){
                        return start1;
                    }
                    float u = seg / prl;
                    return start1 + u * (end1 - start1);
                }

                vec2 project(vec4 p){
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }

                void main(){

                    uCamPos = eyePositionHigh + eyePositionLow;

                    vColor = vec4(color.rgb, color.a * opacity);

                    vec3 current = currentHigh + currentLow;

                    vPos = current;

                    mat4 viewMatrixRTE = view;
                    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                    vec3 highDiff, lowDiff;

                    highDiff = currentHigh - eyePositionHigh;
                    lowDiff = currentLow - eyePositionLow;
                    vec4 vCurrent = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = prevHigh - eyePositionHigh;
                    lowDiff = prevLow - eyePositionLow;
                    vec4 vPrev = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = nextHigh - eyePositionHigh;
                    lowDiff = nextLow - eyePositionLow;
                    vec4 vNext = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    /*Clip near plane, the point behind view plane*/
                    if(vCurrent.z > NEAR) {
                        if(vPrev.z < NEAR && abs(order) == 1.0){
                            vCurrent = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);
                        } else if(vNext.z < NEAR && abs(order) == 2.0){
                            vCurrent = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);
                        }
                    }

                    vec4 dCurrent = proj * vCurrent;
                    vec2 _next = project(proj * vNext);
                    vec2 _prev = project(proj * vPrev);
                    vec2 _current = project(dCurrent);

                    if(_prev == _current){
                        if(_next == _current){
                            _next = _current + vec2(1.0, 0.0);
                            _prev = _current - _next;
                        }else{
                            _prev = _current + normalize(_current - _next);
                        }
                    }

                    if(_next == _current){
                        _next = _current + normalize(_current - _prev);
                    }

                    vec2 sNext = _next,
                         sCurrent = _current,
                         sPrev = _prev;

                    vec2 dirNext = normalize(sNext - sCurrent);
                    vec2 dirPrev = normalize(sPrev - sCurrent);
                    float dotNP = dot(dirNext, dirPrev);

                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));

                    float d = thickness * sign(order);

                    vec2 m;
                    if(dotNP >= 0.99991){
                        m = sCurrent - normalPrev * d;
                    }else{
                        m = getIntersection( sCurrent + normalPrev * d, sPrev + normalPrev * d,
                                sCurrent + normalNext * d, sNext + normalNext * d );

                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);
                            if(occw == -1.0){
                                m = sCurrent + normalPrev * d;
                            }else if(occw == 1.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == -2.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == 2.0){
                                m = sCurrent + normalPrev * d;
                            }
                        }else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){
                            m = sCurrent + normalNext * d;
                        }
                    }

                    gl_Position = vec4((2.0 * m / viewport - 1.0) * dCurrent.w, dCurrent.z + depthOffset, dCurrent.w);
                }`,
      fragmentShader: `precision highp float;
                uniform vec2 uFloatParams;
                varying vec3 uCamPos;
                varying vec4 vColor;
                varying vec3 vPos;
                void main() {
                    vec3 look = vPos - uCamPos;
                    float lookLength = length(look);
                    float a = vColor.a * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(vPos,vPos) - uFloatParams[0]));
                    gl_FragColor = vec4(vColor.rgb, a);
                }`
    });
  }
  function polyline_picking() {
    return new Program("polyline_picking", {
      uniforms: {
        viewport: "vec2",
        proj: "mat4",
        view: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        uFloatParams: "vec2",
        color: "vec4",
        thickness: "float",
        depthOffset: "float"
      },
      attributes: {
        prevHigh: "vec3",
        currentHigh: "vec3",
        nextHigh: "vec3",
        prevLow: "vec3",
        currentLow: "vec3",
        nextLow: "vec3",
        order: "float"
      },
      vertexShader: `precision highp float;
                
                attribute vec3 prevHigh;
                attribute vec3 currentHigh;
                attribute vec3 nextHigh;
                
                attribute vec3 prevLow;
                attribute vec3 currentLow;
                attribute vec3 nextLow;

                attribute float order;

                uniform float thickness;
                uniform vec4 color;
                uniform mat4 proj;
                uniform mat4 view;
                uniform vec2 viewport;
                uniform vec3 eyePositionHigh;
                uniform vec3 eyePositionLow;
                uniform float depthOffset;

                varying vec4 vColor;
                varying vec3 vPos;
                varying vec3 uCamPos;
               
                
                const float NEAR = -1.0;
                
                vec2 getIntersection(vec2 start1, vec2 end1, vec2 start2, vec2 end2){
                    vec2 dir = end2 - start2;
                    vec2 perp = vec2(-dir.y, dir.x);
                    float d2 = dot(perp, start2);
                    float seg = dot(perp, start1) - d2;
                    float prl = seg - dot(perp, end1) + d2;
                    if(prl > -1.0 && prl < 1.0){
                        return start1;
                    }
                    float u = seg / prl;
                    return start1 + u * (end1 - start1);
                }
                
                vec2 project(vec4 p){
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;
                }
                
                void main(){

                    uCamPos = eyePositionHigh + eyePositionLow;

                    vColor = color;

                    vec3 current = currentHigh + currentLow;

                    vPos = current;                    

                    vec3 highDiff, lowDiff;

                    mat4 viewMatrixRTE = view;
                    viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                    highDiff = currentHigh - eyePositionHigh;
                    lowDiff = currentLow - eyePositionLow;
                    vec4 vCurrent = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = prevHigh - eyePositionHigh;
                    lowDiff = prevLow - eyePositionLow;    
                    vec4 vPrev = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    highDiff = nextHigh - eyePositionHigh;
                    lowDiff = nextLow - eyePositionLow;    
                    vec4 vNext = viewMatrixRTE * vec4(highDiff + lowDiff, 1.0);

                    /*Clip near plane*/
                    if(vCurrent.z > NEAR) {
                        if(vPrev.z < NEAR && abs(order) == 1.0){
                            vCurrent = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);
                        } else if(vNext.z < NEAR && abs(order) == 2.0){
                            vCurrent = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);
                        }
                    }
                    
                    vec4 dCurrent = proj * vCurrent;
                    vec2 _next = project(proj * vNext);
                    vec2 _prev = project(proj * vPrev);
                    vec2 _current = project(dCurrent);
                    if(_prev == _current){
                        if(_next == _current){
                            _next = _current + vec2(1.0, 0.0);
                            _prev = _current - _next;
                        }else{
                            _prev = _current + normalize(_current - _next);
                        }
                    }
                    if(_next == _current){
                        _next = _current + normalize(_current - _prev);
                    }
                    
                    vec2 sNext = _next,
                         sCurrent = _current,
                         sPrev = _prev;

                    vec2 dirNext = normalize(sNext - sCurrent);
                    vec2 dirPrev = normalize(sPrev - sCurrent);
                    float dotNP = dot(dirNext, dirPrev);
                    
                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));
                    
                    float d = thickness * sign(order);
                    
                    vec2 m;
                    if(dotNP >= 0.99991){
                        m = sCurrent - normalPrev * d;
                    }else{
                        m = getIntersection( sCurrent + normalPrev * d, sPrev + normalPrev * d,
                                sCurrent + normalNext * d, sNext + normalNext * d );
                        
                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);
                            if(occw == -1.0){
                                m = sCurrent + normalPrev * d;
                            }else if(occw == 1.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == -2.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == 2.0){
                                m = sCurrent + normalPrev * d;
                            }
                        }
                        else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){
                            m = sCurrent + normalNext * d;
                        }
                    }
                    gl_Position = vec4((2.0 * m / viewport - 1.0) * dCurrent.w, dCurrent.z + depthOffset, dCurrent.w);
                }`,
      fragmentShader: `precision highp float;
                uniform vec2 uFloatParams;
                varying vec3 uCamPos;
                varying vec4 vColor;
                varying vec3 vPos;
                void main() {
                    vec3 look = vPos - uCamPos;
                    float lookLength = length(look);
                    float a = vColor.a * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(vPos,vPos) - uFloatParams[0]));                    
                    gl_FragColor = vec4(vColor.rgb, a);
                }`
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/entity/PolylineHandler.js
  var PolylineHandler = class _PolylineHandler {
    constructor(entityCollection) {
      this.__id = _PolylineHandler.__counter__++;
      this._entityCollection = entityCollection;
      this._renderer = null;
      this._polylines = [];
      this.pickingEnabled = true;
    }
    _initProgram() {
      if (this._renderer && this._renderer.handler) {
        if (!this._renderer.handler.programs.polyline_screen) {
          this._renderer.handler.addProgram(polyline_screen());
        }
        if (!this._renderer.handler.programs.polyline_picking) {
          this._renderer.handler.addProgram(polyline_picking());
        }
      }
    }
    setRenderNode(renderNode) {
      this._renderer = renderNode.renderer;
      this._initProgram();
      for (let i9 = 0; i9 < this._polylines.length; i9++) {
        this._polylines[i9].setRenderNode(renderNode);
      }
    }
    add(polyline) {
      if (polyline._handlerIndex === -1) {
        polyline._handler = this;
        polyline._handlerIndex = this._polylines.length;
        this._polylines.push(polyline);
        this._entityCollection && this._entityCollection.renderNode && polyline.setRenderNode(this._entityCollection.renderNode);
      }
    }
    remove(polyline) {
      let index = polyline._handlerIndex;
      if (index !== -1) {
        polyline._deleteBuffers();
        polyline._handlerIndex = -1;
        polyline._handler = null;
        this._polylines.splice(index, 1);
        this.reindexPolylineArray(index);
      }
    }
    reindexPolylineArray(startIndex) {
      let ls = this._polylines;
      for (let i9 = startIndex; i9 < ls.length; i9++) {
        ls[i9]._handlerIndex = i9;
      }
    }
    draw() {
      let i9 = this._polylines.length;
      while (i9--) {
        this._polylines[i9].draw();
      }
    }
    drawPicking() {
      if (this.pickingEnabled) {
        let i9 = this._polylines.length;
        while (i9--) {
          this._polylines[i9].drawPicking();
        }
      }
    }
    clear() {
      let i9 = this._polylines.length;
      while (i9--) {
        this._polylines[i9]._deleteBuffers();
        this._polylines[i9]._handler = null;
        this._polylines[i9]._handlerIndex = -1;
      }
      this._polylines.length = 0;
      this._polylines = [];
    }
  };
  PolylineHandler.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/shaders/ray.js
  function rayScreen() {
    return new Program("rayScreen", {
      uniforms: {
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        resolution: "float",
        uOpacity: "float"
      },
      attributes: {
        a_vertices: "vec2",
        a_startPosHigh: "vec3",
        a_startPosLow: "vec3",
        a_endPosHigh: "vec3",
        a_endPosLow: "vec3",
        a_thickness: "float",
        a_rgba: "vec4"
      },
      vertexShader: `precision highp float;

            attribute vec4 a_rgba;
            attribute vec3 a_startPosHigh;
            attribute vec3 a_startPosLow;
            attribute vec3 a_endPosHigh;
            attribute vec3 a_endPosLow;
            attribute vec2 a_vertices;
            attribute float a_thickness;

            varying vec4 v_rgba;

            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float resolution;
            uniform float uOpacity;

            void main() {

                v_rgba = vec4(a_rgba.rgb, a_rgba.a * uOpacity);

                vec3 v = (a_endPosHigh - a_startPosHigh) + (a_endPosLow - a_startPosLow);

                vec3 look = (a_startPosHigh - eyePositionHigh) + (a_startPosLow - eyePositionLow) + v * a_vertices.y;
                vec3 up = normalize(normalize(v));
                vec3 right = normalize(cross(look,up));
 
                float dist = dot(look, vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]));
                float focalSize = 2.0 * dist * resolution;
                vec3 vert = right * a_thickness * focalSize * a_vertices.x;

                vec3 highDiff;
                if(a_vertices.y == 0.0){
                    highDiff = a_startPosHigh - eyePositionHigh;
                    vert += a_startPosLow - eyePositionLow;
                }else{
                    highDiff = a_endPosHigh - eyePositionHigh;
                    vert += a_endPosLow - eyePositionLow;
                }

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);
                
                // Hack for iMac M1, looks like it doesnt 
                // work correctly with zeroes in highDiff
                // if(length(highDiff) < 1.0){
                //     highDiff = vec3(0.0);
                // }
                
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + vert, 1.0);
            }`,
      fragmentShader: `precision highp float;
            varying vec4 v_rgba;
            void main () {
                gl_FragColor = v_rgba;
            }`
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/entity/RayHandler.js
  var PICKINGCOLOR_BUFFER4 = 0;
  var START_POSITION_BUFFER = 1;
  var END_POSITION_BUFFER = 2;
  var RGBA_BUFFER4 = 3;
  var THICKNESS_BUFFER = 4;
  var VERTEX_BUFFER4 = 5;
  var RayHandler = class _RayHandler {
    constructor(entityCollection) {
      this.__id = _RayHandler.__counter__++;
      this.pickingEnabled = true;
      this._entityCollection = entityCollection;
      this._renderer = null;
      this._rays = [];
      this._vertexBuffer = null;
      this._startPositionHighBuffer = null;
      this._startPositionLowBuffer = null;
      this._endPositionHighBuffer = null;
      this._endPositionLowBuffer = null;
      this._thicknessBuffer = null;
      this._rgbaBuffer = null;
      this._pickingColorBuffer = null;
      this._vertexArr = [];
      this._startPositionHighArr = [];
      this._startPositionLowArr = [];
      this._endPositionHighArr = [];
      this._endPositionLowArr = [];
      this._thicknessArr = [];
      this._rgbaArr = [];
      this._pickingColorArr = [];
      this._buffersUpdateCallbacks = [];
      this._buffersUpdateCallbacks[VERTEX_BUFFER4] = this.createVertexBuffer;
      this._buffersUpdateCallbacks[START_POSITION_BUFFER] = this.createStartPositionBuffer;
      this._buffersUpdateCallbacks[END_POSITION_BUFFER] = this.createEndPositionBuffer;
      this._buffersUpdateCallbacks[THICKNESS_BUFFER] = this.createThicknessBuffer;
      this._buffersUpdateCallbacks[RGBA_BUFFER4] = this.createRgbaBuffer;
      this._buffersUpdateCallbacks[PICKINGCOLOR_BUFFER4] = this.createPickingColorBuffer;
      this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    }
    static concArr(dest, curr) {
      for (let i9 = 0; i9 < curr.length; i9++) {
        dest.push(curr[i9]);
      }
    }
    initProgram() {
      if (this._renderer && this._renderer.handler) {
        if (!this._renderer.handler.programs.rayScreen) {
          this._renderer.handler.addProgram(rayScreen());
        }
      }
    }
    setRenderer(renderer) {
      this._renderer = renderer;
      this.initProgram();
    }
    refresh() {
      let i9 = this._changedBuffers.length;
      while (i9--) {
        this._changedBuffers[i9] = true;
      }
    }
    _removeRays() {
      let i9 = this._rays.length;
      while (i9--) {
        let ri = this._rays[i9];
        ri._handlerIndex = -1;
        ri._handler = null;
      }
      this._rays.length = 0;
      this._rays = [];
    }
    clear() {
      this._vertexArr = null;
      this._startPositionHighArr = null;
      this._startPositionLowArr = null;
      this._endPositionHighArr = null;
      this._endPositionLowArr = null;
      this._thicknessArr = null;
      this._rgbaArr = null;
      this._vertexArr = new Float32Array([]);
      this._startPositionHighArr = new Float32Array([]);
      this._startPositionLowArr = new Float32Array([]);
      this._endPositionHighArr = new Float32Array([]);
      this._endPositionLowArr = new Float32Array([]);
      this._thicknessArr = new Float32Array([]);
      this._rgbaArr = new Float32Array([]);
      this._removeRays();
      this._deleteBuffers();
      this.refresh();
    }
    _deleteBuffers() {
      if (this._renderer) {
        let gl = this._renderer.handler.gl;
        if (gl) {
          gl.deleteBuffer(this._startPositionHighBuffer);
          gl.deleteBuffer(this._startPositionLowBuffer);
          gl.deleteBuffer(this._endPositionHighBuffer);
          gl.deleteBuffer(this._endPositionLowBuffer);
          gl.deleteBuffer(this._thicknessBuffer);
          gl.deleteBuffer(this._rgbaBuffer);
          gl.deleteBuffer(this._vertexBuffer);
        }
        this._startPositionHighBuffer = null;
        this._startPositionLowBuffer = null;
        this._endPositionHighBuffer = null;
        this._endPositionLowBuffer = null;
        this._thicknessBuffer = null;
        this._rgbaBuffer = null;
        this._vertexBuffer = null;
      }
    }
    update() {
      if (this._renderer) {
        let i9 = this._changedBuffers.length;
        while (i9--) {
          if (this._changedBuffers[i9]) {
            this._buffersUpdateCallbacks[i9].call(this);
            this._changedBuffers[i9] = false;
          }
        }
      }
    }
    add(ray) {
      if (ray._handlerIndex == -1) {
        ray._handler = this;
        ray._handlerIndex = this._rays.length;
        this._rays.push(ray);
        this._addRayToArrays(ray);
        this.refresh();
      }
    }
    _addRayToArrays(ray) {
      if (ray.getVisibility()) {
        this._vertexArr = concatArrays(this._vertexArr, [-0.5, 1, -0.5, 0, 0.5, 0, 0.5, 0, 0.5, 1, -0.5, 1]);
      } else {
        this._vertexArr = concatArrays(this._vertexArr, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      }
      let x3 = ray._startPositionHigh.x, y4 = ray._startPositionHigh.y, z3 = ray._startPositionHigh.z;
      this._startPositionHighArr = concatArrays(this._startPositionHighArr, [x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3]);
      x3 = ray._startPositionLow.x;
      y4 = ray._startPositionLow.y;
      z3 = ray._startPositionLow.z;
      this._startPositionLowArr = concatArrays(this._startPositionLowArr, [x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3]);
      x3 = ray._endPositionHigh.x;
      y4 = ray._endPositionHigh.y;
      z3 = ray._endPositionHigh.z;
      this._endPositionHighArr = concatArrays(this._endPositionHighArr, [x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3]);
      x3 = ray._endPositionLow.x;
      y4 = ray._endPositionLow.y;
      z3 = ray._endPositionLow.z;
      this._endPositionLowArr = concatArrays(this._endPositionLowArr, [x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3]);
      x3 = ray._thickness;
      this._thicknessArr = concatArrays(this._thicknessArr, [x3, x3, x3, x3, x3, x3]);
      let r0 = ray._startColor.x, g0 = ray._startColor.y, b0 = ray._startColor.z, a0 = ray._startColor.w, r1 = ray._endColor.x, g1 = ray._endColor.y, b1 = ray._endColor.z, a1 = ray._endColor.w;
      this._rgbaArr = concatArrays(this._rgbaArr, [
        r1,
        g1,
        b1,
        a1,
        r0,
        g0,
        b0,
        a0,
        r0,
        g0,
        b0,
        a0,
        r0,
        g0,
        b0,
        a0,
        r1,
        g1,
        b1,
        a1,
        r1,
        g1,
        b1,
        a1
      ]);
      x3 = ray._entity._pickingColor.x / 255;
      y4 = ray._entity._pickingColor.y / 255;
      z3 = ray._entity._pickingColor.z / 255;
      this._pickingColorArr = concatArrays(this._pickingColorArr, [x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3, x3, y4, z3]);
    }
    _displayPASS() {
      let r8 = this._renderer;
      let h8 = r8.handler;
      h8.programs.rayScreen.activate();
      let sh = h8.programs.rayScreen._program;
      let sha = sh.attributes, shu = sh.uniforms;
      let gl = h8.gl, ec = this._entityCollection;
      gl.disable(gl.CULL_FACE);
      gl.uniform1f(shu.uOpacity, ec._fadingOpacity);
      gl.uniformMatrix4fv(shu.viewMatrix, false, r8.activeCamera.getViewMatrix());
      gl.uniformMatrix4fv(shu.projectionMatrix, false, r8.activeCamera.getProjectionMatrix());
      gl.uniform3fv(shu.eyePositionHigh, r8.activeCamera.eyeHigh);
      gl.uniform3fv(shu.eyePositionLow, r8.activeCamera.eyeLow);
      gl.uniform1f(shu.resolution, r8.activeCamera._tanViewAngle_hradOneByHeight);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._startPositionHighBuffer);
      gl.vertexAttribPointer(sha.a_startPosHigh, this._startPositionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._startPositionLowBuffer);
      gl.vertexAttribPointer(sha.a_startPosLow, this._startPositionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._endPositionHighBuffer);
      gl.vertexAttribPointer(sha.a_endPosHigh, this._endPositionHighBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._endPositionLowBuffer);
      gl.vertexAttribPointer(sha.a_endPosLow, this._endPositionLowBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer);
      gl.vertexAttribPointer(sha.a_rgba, this._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._thicknessBuffer);
      gl.vertexAttribPointer(sha.a_thickness, this._thicknessBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      gl.vertexAttribPointer(sha.a_vertices, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
      gl.enable(gl.CULL_FACE);
    }
    _pickingPASS() {
    }
    draw() {
      if (this._rays.length) {
        this.update();
        this._displayPASS();
      }
    }
    drawPicking() {
      if (this._rays.length && this.pickingEnabled) {
        this._pickingPASS();
      }
    }
    reindexRaysArray(startIndex) {
      let r8 = this._rays;
      for (let i9 = startIndex; i9 < r8.length; i9++) {
        r8[i9]._handlerIndex = i9;
      }
    }
    _removeRay(ray) {
      let ri = ray._handlerIndex;
      this._rays.splice(ri, 1);
      let i9 = ri * 24;
      this._rgbaArr = spliceArray(this._rgbaArr, i9, 24);
      i9 = ri * 18;
      this._startPositionHighArr = spliceArray(this._startPositionHighArr, i9, 18);
      this._startPositionLowArr = spliceArray(this._startPositionLowArr, i9, 18);
      this._endPositionHighArr = spliceArray(this._endPositionHighArr, i9, 18);
      this._endPositionLowArr = spliceArray(this._endPositionLowArr, i9, 18);
      this._pickingColorArr = spliceArray(this._pickingColorArr, i9, 18);
      i9 = ri * 12;
      this._vertexArr = spliceArray(this._vertexArr, i9, 12);
      i9 = ri * 6;
      this._thicknessArr = spliceArray(this._thicknessArr, i9, 6);
      this.reindexRaysArray(ri);
      this.refresh();
      ray._handlerIndex = -1;
      ray._handler = null;
    }
    remove(ray) {
      if (ray._handler && this.__id === ray._handler.__id) {
        this._removeRay(ray);
      }
    }
    setStartPositionArr(index, positionHigh, positionLow) {
      let i9 = index * 18;
      let a6 = this._startPositionHighArr, x3 = positionHigh.x, y4 = positionHigh.y, z3 = positionHigh.z;
      a6[i9] = x3;
      a6[i9 + 1] = y4;
      a6[i9 + 2] = z3;
      a6[i9 + 3] = x3;
      a6[i9 + 4] = y4;
      a6[i9 + 5] = z3;
      a6[i9 + 6] = x3;
      a6[i9 + 7] = y4;
      a6[i9 + 8] = z3;
      a6[i9 + 9] = x3;
      a6[i9 + 10] = y4;
      a6[i9 + 11] = z3;
      a6[i9 + 12] = x3;
      a6[i9 + 13] = y4;
      a6[i9 + 14] = z3;
      a6[i9 + 15] = x3;
      a6[i9 + 16] = y4;
      a6[i9 + 17] = z3;
      a6 = this._startPositionLowArr;
      x3 = positionLow.x;
      y4 = positionLow.y;
      z3 = positionLow.z;
      a6[i9] = x3;
      a6[i9 + 1] = y4;
      a6[i9 + 2] = z3;
      a6[i9 + 3] = x3;
      a6[i9 + 4] = y4;
      a6[i9 + 5] = z3;
      a6[i9 + 6] = x3;
      a6[i9 + 7] = y4;
      a6[i9 + 8] = z3;
      a6[i9 + 9] = x3;
      a6[i9 + 10] = y4;
      a6[i9 + 11] = z3;
      a6[i9 + 12] = x3;
      a6[i9 + 13] = y4;
      a6[i9 + 14] = z3;
      a6[i9 + 15] = x3;
      a6[i9 + 16] = y4;
      a6[i9 + 17] = z3;
      this._changedBuffers[START_POSITION_BUFFER] = true;
    }
    setEndPositionArr(index, positionHigh, positionLow) {
      let i9 = index * 18;
      let a6 = this._endPositionHighArr, x3 = positionHigh.x, y4 = positionHigh.y, z3 = positionHigh.z;
      a6[i9] = x3;
      a6[i9 + 1] = y4;
      a6[i9 + 2] = z3;
      a6[i9 + 3] = x3;
      a6[i9 + 4] = y4;
      a6[i9 + 5] = z3;
      a6[i9 + 6] = x3;
      a6[i9 + 7] = y4;
      a6[i9 + 8] = z3;
      a6[i9 + 9] = x3;
      a6[i9 + 10] = y4;
      a6[i9 + 11] = z3;
      a6[i9 + 12] = x3;
      a6[i9 + 13] = y4;
      a6[i9 + 14] = z3;
      a6[i9 + 15] = x3;
      a6[i9 + 16] = y4;
      a6[i9 + 17] = z3;
      a6 = this._endPositionLowArr;
      x3 = positionLow.x;
      y4 = positionLow.y;
      z3 = positionLow.z;
      a6[i9] = x3;
      a6[i9 + 1] = y4;
      a6[i9 + 2] = z3;
      a6[i9 + 3] = x3;
      a6[i9 + 4] = y4;
      a6[i9 + 5] = z3;
      a6[i9 + 6] = x3;
      a6[i9 + 7] = y4;
      a6[i9 + 8] = z3;
      a6[i9 + 9] = x3;
      a6[i9 + 10] = y4;
      a6[i9 + 11] = z3;
      a6[i9 + 12] = x3;
      a6[i9 + 13] = y4;
      a6[i9 + 14] = z3;
      a6[i9 + 15] = x3;
      a6[i9 + 16] = y4;
      a6[i9 + 17] = z3;
      this._changedBuffers[END_POSITION_BUFFER] = true;
    }
    setPickingColorArr(index, color) {
      let i9 = index * 18;
      let a6 = this._pickingColorArr, x3 = color.x / 255, y4 = color.y / 255, z3 = color.z / 255;
      a6[i9] = x3;
      a6[i9 + 1] = y4;
      a6[i9 + 2] = z3;
      a6[i9 + 3] = x3;
      a6[i9 + 4] = y4;
      a6[i9 + 5] = z3;
      a6[i9 + 6] = x3;
      a6[i9 + 7] = y4;
      a6[i9 + 8] = z3;
      a6[i9 + 9] = x3;
      a6[i9 + 10] = y4;
      a6[i9 + 11] = z3;
      a6[i9 + 12] = x3;
      a6[i9 + 13] = y4;
      a6[i9 + 14] = z3;
      a6[i9 + 15] = x3;
      a6[i9 + 16] = y4;
      a6[i9 + 17] = z3;
      this._changedBuffers[PICKINGCOLOR_BUFFER4] = true;
    }
    setRgbaArr(index, startColor, endColor) {
      let i9 = index * 24;
      let a6 = this._rgbaArr, r0 = startColor.x, g0 = startColor.y, b0 = startColor.z, a0 = startColor.w, r1 = endColor.x, g1 = endColor.y, b1 = endColor.z, a1 = endColor.w;
      a6[i9] = r1;
      a6[i9 + 1] = g1;
      a6[i9 + 2] = b1;
      a6[i9 + 3] = a1;
      a6[i9 + 4] = r0;
      a6[i9 + 5] = g0;
      a6[i9 + 6] = b0;
      a6[i9 + 7] = a0;
      a6[i9 + 8] = r0;
      a6[i9 + 9] = g0;
      a6[i9 + 10] = b0;
      a6[i9 + 11] = a0;
      a6[i9 + 12] = r0;
      a6[i9 + 13] = g0;
      a6[i9 + 14] = b0;
      a6[i9 + 15] = a0;
      a6[i9 + 16] = r1;
      a6[i9 + 17] = g1;
      a6[i9 + 18] = b1;
      a6[i9 + 19] = a1;
      a6[i9 + 20] = r1;
      a6[i9 + 21] = g1;
      a6[i9 + 22] = b1;
      a6[i9 + 23] = a1;
      this._changedBuffers[RGBA_BUFFER4] = true;
    }
    setThicknessArr(index, thickness) {
      let i9 = index * 6;
      let a6 = this._thicknessArr;
      a6[i9] = thickness;
      a6[i9 + 1] = thickness;
      a6[i9 + 2] = thickness;
      a6[i9 + 3] = thickness;
      a6[i9 + 4] = thickness;
      a6[i9 + 5] = thickness;
      this._changedBuffers[THICKNESS_BUFFER] = true;
    }
    setVisibility(index, visibility) {
      let vArr;
      if (visibility) {
        vArr = [-0.5, 1, -0.5, 0, 0.5, 0, 0.5, 0, 0.5, 1, -0.5, 1];
      } else {
        vArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      this.setVertexArr(index, vArr);
    }
    setVertexArr(index, vertexArr) {
      let i9 = index * 12;
      let a6 = this._vertexArr;
      a6[i9] = vertexArr[0];
      a6[i9 + 1] = vertexArr[1];
      a6[i9 + 2] = vertexArr[2];
      a6[i9 + 3] = vertexArr[3];
      a6[i9 + 4] = vertexArr[4];
      a6[i9 + 5] = vertexArr[5];
      a6[i9 + 6] = vertexArr[6];
      a6[i9 + 7] = vertexArr[7];
      a6[i9 + 8] = vertexArr[8];
      a6[i9 + 9] = vertexArr[9];
      a6[i9 + 10] = vertexArr[10];
      a6[i9 + 11] = vertexArr[11];
      this._changedBuffers[VERTEX_BUFFER4] = true;
    }
    createStartPositionBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._startPositionHighBuffer);
      this._startPositionHighArr = makeArrayTyped(this._startPositionHighArr);
      this._startPositionHighBuffer = h8.createArrayBuffer(this._startPositionHighArr, 3, this._startPositionHighArr.length / 3, h8.gl.DYNAMIC_DRAW);
      h8.gl.deleteBuffer(this._startPositionLowBuffer);
      this._startPositionLowArr = makeArrayTyped(this._startPositionLowArr);
      this._startPositionLowBuffer = h8.createArrayBuffer(this._startPositionLowArr, 3, this._startPositionLowArr.length / 3, h8.gl.DYNAMIC_DRAW);
    }
    createEndPositionBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._endPositionHighBuffer);
      this._endPositionHighArr = makeArrayTyped(this._endPositionHighArr);
      this._endPositionHighBuffer = h8.createArrayBuffer(this._endPositionHighArr, 3, this._endPositionHighArr.length / 3, h8.gl.DYNAMIC_DRAW);
      h8.gl.deleteBuffer(this._endPositionLowBuffer);
      this._endPositionLowArr = makeArrayTyped(this._endPositionLowArr);
      this._endPositionLowBuffer = h8.createArrayBuffer(this._endPositionLowArr, 3, this._endPositionLowArr.length / 3, h8.gl.DYNAMIC_DRAW);
    }
    createRgbaBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._rgbaBuffer);
      this._rgbaArr = makeArrayTyped(this._rgbaArr);
      this._rgbaBuffer = h8.createArrayBuffer(this._rgbaArr, 4, this._rgbaArr.length / 4);
    }
    createThicknessBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._thicknessBuffer);
      this._thicknessArr = makeArrayTyped(this._thicknessArr);
      this._thicknessBuffer = h8.createArrayBuffer(this._thicknessArr, 1, this._thicknessArr.length, h8.gl.DYNAMIC_DRAW);
    }
    createVertexBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._vertexBuffer);
      this._vertexArr = makeArrayTyped(this._vertexArr);
      this._vertexBuffer = h8.createArrayBuffer(this._vertexArr, 2, this._vertexArr.length / 2, h8.gl.DYNAMIC_DRAW);
    }
    createPickingColorBuffer() {
      let h8 = this._renderer.handler;
      h8.gl.deleteBuffer(this._pickingColorBuffer);
      this._pickingColorArr = makeArrayTyped(this._pickingColorArr);
      this._pickingColorBuffer = h8.createArrayBuffer(this._pickingColorArr, 3, this._pickingColorArr.length / 3);
    }
  };
  RayHandler.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/entity/StripHandler.js
  var StripHandler = class _StripHandler {
    constructor(entityCollection) {
      this.__id = _StripHandler.__counter__++;
      this.pickingEnabled = true;
      this._entityCollection = entityCollection;
      this._renderer = null;
      this._strips = [];
    }
    _initProgram() {
      if (this._renderer && this._renderer.handler) {
        !this._renderer.handler.programs.strip && this._renderer.handler.addProgram(new Program("strip", {
          uniforms: {
            projectionMatrix: { type: "mat4" },
            viewMatrix: { type: "mat4" },
            eyePositionHigh: "vec3",
            eyePositionLow: "vec3",
            uColor: { type: "vec4" },
            uOpacity: { type: "float" }
          },
          attributes: {
            aVertexPositionHigh: { type: "vec3" },
            aVertexPositionLow: { type: "vec3" }
          },
          vertexShader: `attribute vec3 aVertexPositionHigh;
                        attribute vec3 aVertexPositionLow;
                        uniform mat4 projectionMatrix;
                        uniform mat4 viewMatrix;
                        uniform vec3 eyePositionHigh;
                        uniform vec3 eyePositionLow;
                        void main(void) {

                            vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                            vec3 lowDiff = aVertexPositionLow - eyePositionLow;

                            mat4 viewMatrixRTE = viewMatrix;
                            viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                            gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
                        }`,
          fragmentShader: `precision highp float;
                        uniform vec4 uColor;
                        uniform float uOpacity;
                        void main(void) {
                            gl_FragColor = vec4(uColor.rgb, uColor.a * uOpacity);
                        }`
        }));
      }
    }
    setRenderNode(renderNode) {
      this._renderer = renderNode.renderer;
      this._initProgram();
      for (let i9 = 0; i9 < this._strips.length; i9++) {
        this._strips[i9].setRenderNode(renderNode);
      }
    }
    add(strip) {
      if (strip._handlerIndex === -1) {
        strip._handler = this;
        strip._handlerIndex = this._strips.length;
        this._strips.push(strip);
        this._entityCollection && this._entityCollection.renderNode && strip.setRenderNode(this._entityCollection.renderNode);
      }
    }
    remove(strip) {
      let index = strip._handlerIndex;
      if (index !== -1) {
        strip._deleteBuffers();
        strip._handlerIndex = -1;
        strip._handler = null;
        this._strips.splice(index, 1);
        this.reindexStripArray(index);
      }
    }
    reindexStripArray(startIndex) {
      let pc = this._strips;
      for (let i9 = startIndex; i9 < pc.length; i9++) {
        pc[i9]._handlerIndex = i9;
      }
    }
    draw() {
      let i9 = this._strips.length;
      while (i9--) {
        this._strips[i9].draw();
      }
    }
    drawPicking() {
      if (this.pickingEnabled) {
        let i9 = this._strips.length;
        while (i9--) {
          this._strips[i9].drawPicking();
        }
      }
    }
    clear() {
      let i9 = this._strips.length;
      while (i9--) {
        this._strips[i9]._deleteBuffers();
        this._strips[i9]._handler = null;
        this._strips[i9]._handlerIndex = -1;
      }
      this._strips.length = 0;
      this._strips = [];
    }
  };
  StripHandler.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/entity/EntityCollection.js
  var EntityCollection = class _EntityCollection {
    constructor(options2 = {}) {
      this.__id = _EntityCollection.__counter__++;
      this._renderNodeIndex = -1;
      this.renderNode = null;
      this._visibility = options2.visibility == void 0 ? true : options2.visibility;
      this.polygonOffsetUnits = options2.polygonOffsetUnits != void 0 ? options2.polygonOffsetUnits : 0;
      this.billboardHandler = new BillboardHandler(this);
      this.labelHandler = new LabelHandler(this, options2.labelMaxLetters);
      this.polylineHandler = new PolylineHandler(this);
      this.rayHandler = new RayHandler(this);
      this.pointCloudHandler = new PointCloudHandler(this);
      this.stripHandler = new StripHandler(this);
      this.geoObjectHandler = new GeoObjectHandler(this);
      if (options2.pickingEnabled != void 0) {
        this.setPickingEnabled(options2.pickingEnabled);
      }
      this._entities = [];
      this.scaleByDistance = options2.scaleByDistance || [MAX32, MAX32, MAX32];
      this.pickingScale = options2.pickingScale || 1;
      this._opacity = options2.opacity == void 0 ? 1 : options2.opacity;
      this._fadingOpacity = this._opacity;
      this.events = this.rendererEvents = createEvents(ENTITYCOLLECTION_EVENTS, this);
      if (options2.entities) {
        this.addEntities(options2.entities);
      }
    }
    get id() {
      return this.__id;
    }
    isEqual(ec) {
      return this.__id === ec.__id;
    }
    /**
     * Sets collection visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
      this._visibility = visibility;
      this._fadingOpacity = this._opacity * (visibility ? 1 : 0);
      this.events.dispatch(this.events.visibilitychange, this);
    }
    /**
     * Returns collection visibility.
     * @public
     * @returns {boolean} -
     */
    getVisibility() {
      return this._visibility;
    }
    /**
     * Sets collection opacity.
     * @public
     * @param {number} opacity - Opacity.
     */
    setOpacity(opacity) {
      this._opacity = opacity;
    }
    /**
     * Sets collection picking ability.
     * @public
     * @param {boolean} enable - Picking enable flag.
     */
    setPickingEnabled(enable) {
      this.billboardHandler.pickingEnabled = enable;
      this.labelHandler.pickingEnabled = enable;
      this.polylineHandler.pickingEnabled = enable;
      this.rayHandler.pickingEnabled = enable;
      this.pointCloudHandler.pickingEnabled = enable;
      this.stripHandler.pickingEnabled = enable;
      this.geoObjectHandler.pickingEnabled = enable;
    }
    /**
     * Gets collection opacity.
     * @public
     * @returns {number} -
     */
    getOpacity() {
      return this._opacity;
    }
    /**
     * Sets scale by distance parameters.
     * @public
     * @param {number} near - Full scale entity distance.
     * @param {number} far - Zero scale entity distance.
     * @param {number} [farInvisible] - Entity visibility distance.
     */
    setScaleByDistance(near, far, farInvisible) {
      this.scaleByDistance[0] = near;
      this.scaleByDistance[1] = far;
      this.scaleByDistance[2] = farInvisible || MAX32;
    }
    appendChildEntity(entity) {
      this._addRecursively(entity);
    }
    _addRecursively(entity) {
      entity.billboard && this.billboardHandler.add(entity.billboard);
      entity.label && this.labelHandler.add(entity.label);
      entity.polyline && this.polylineHandler.add(entity.polyline);
      entity.ray && this.rayHandler.add(entity.ray);
      entity.pointCloud && this.pointCloudHandler.add(entity.pointCloud);
      entity.strip && this.stripHandler.add(entity.strip);
      entity.geoObject && this.geoObjectHandler.add(entity.geoObject);
      this.events.dispatch(this.events.entityadd, entity);
      for (let i9 = 0; i9 < entity.childrenNodes.length; i9++) {
        entity.childrenNodes[i9]._entityCollection = this;
        entity.childrenNodes[i9]._entityCollectionIndex = entity._entityCollectionIndex;
        entity.childrenNodes[i9]._pickingColor = entity._pickingColor;
        this._addRecursively(entity.childrenNodes[i9]);
      }
    }
    /**
     * Adds entity to the collection and returns collection.
     * @public
     * @param {Entity} entity - Entity.
     * @returns {EntityCollection} -
     */
    add(entity) {
      if (!entity._entityCollection) {
        entity._entityCollection = this;
        entity._entityCollectionIndex = this._entities.length;
        this._entities.push(entity);
        let rn = this.renderNode;
        if (rn) {
          rn.renderer && rn.renderer.assignPickingColor(entity);
          if (rn.ellipsoid && entity._cartesian.isZero()) {
            entity.setCartesian3v(rn.ellipsoid.lonLatToCartesian(entity._lonLat));
          }
        }
        this._addRecursively(entity);
        entity.setPickingColor();
      }
      return this;
    }
    /**
     * Adds entities array to the collection and returns collection.
     * @public
     * @param {Array.<Entity>} entities - Entities array.
     * @returns {EntityCollection} -
     */
    addEntities(entities) {
      for (let i9 = 0, len = entities.length; i9 < len; i9++) {
        this.add(entities[i9]);
      }
      return this;
    }
    /**
     * Returns true if the entity belongs this collection, otherwise returns false.
     * @public
     * @param {Entity} entity - Entity.
     * @returns {boolean} -
     */
    belongs(entity) {
      return entity._entityCollection && this._renderNodeIndex === entity._entityCollection._renderNodeIndex;
    }
    _removeRecursively(entity) {
      entity._entityCollection = null;
      entity._entityCollectionIndex = -1;
      entity.billboard && this.billboardHandler.remove(entity.billboard);
      entity.label && this.labelHandler.remove(entity.label);
      entity.polyline && this.polylineHandler.remove(entity.polyline);
      entity.ray && this.rayHandler.remove(entity.ray);
      entity.pointCloud && this.pointCloudHandler.remove(entity.pointCloud);
      entity.strip && this.stripHandler.remove(entity.strip);
      entity.geoObject && this.geoObjectHandler.remove(entity.geoObject);
      for (let i9 = 0; i9 < entity.childrenNodes.length; i9++) {
        this._removeRecursively(entity.childrenNodes[i9]);
      }
    }
    /**
     * Removes entity from this collection.
     * @public
     * @param {Entity} entity - Entity to remove.
     */
    removeEntity(entity) {
      this._entities.splice(entity._entityCollectionIndex, 1);
      this.reindexEntitiesArray(entity._entityCollectionIndex);
      if (this.renderNode && this.renderNode.renderer) {
        this.renderNode.renderer.clearPickingColor(entity);
        entity._pickingColor.clear();
      }
      if (this.belongs(entity)) {
        this._removeRecursively(entity);
      }
      this.events.dispatch(this.events.entityremove, entity);
    }
    _removeEntitySilent(entity) {
      this._entities.splice(entity._entityCollectionIndex, 1);
      this.reindexEntitiesArray(entity._entityCollectionIndex);
      if (this.renderNode && this.renderNode.renderer) {
        this.renderNode.renderer.clearPickingColor(entity);
        entity._pickingColor.clear();
      }
      if (this.belongs(entity)) {
        this._removeRecursively(entity);
      }
    }
    /**
     * Creates or refresh collected entities picking color.
     * @public
     */
    createPickingColors() {
      if (!(this.renderNode && this.renderNode.renderer))
        return;
      let e9 = this._entities;
      for (let i9 = 0; i9 < e9.length; i9++) {
        if (!e9[i9].parent) {
          this.renderNode.renderer.assignPickingColor(e9[i9]);
          e9[i9].setPickingColor();
        }
      }
    }
    /**
     * Refresh collected entities indexes from startIndex entities collection array position.
     * @public
     * @param {number} startIndex - Entities collection array index.
     */
    reindexEntitiesArray(startIndex) {
      let e9 = this._entities;
      for (let i9 = startIndex; i9 < e9.length; i9++) {
        e9[i9]._entityCollectionIndex = i9;
      }
    }
    /**
     * Adds this collection to render node.
     * @public
     * @param {RenderNode} renderNode - Render node.
     * @param {boolean} [isHidden] - Uses in vector layers that render in planet render specific function.
     * @returns {EntityCollection} -
     */
    addTo(renderNode, isHidden = false) {
      if (!this.renderNode) {
        this.renderNode = renderNode;
        if (!isHidden) {
          this._renderNodeIndex = renderNode.entityCollections.length;
          renderNode.entityCollections.push(this);
        }
        renderNode.ellipsoid && this._updateGeodeticCoordinates(renderNode.ellipsoid);
        this.bindRenderNode(renderNode);
        this.events.dispatch(this.events.add, this);
      }
      return this;
    }
    /**
     * This function is called in the RenderNode assign function.
     * @public
     * @param {RenderNode} renderNode
     */
    bindRenderNode(renderNode) {
      if (renderNode.renderer && renderNode.renderer.isInitialized()) {
        this.billboardHandler.setRenderer(renderNode.renderer);
        this.labelHandler.setRenderer(renderNode.renderer);
        this.rayHandler.setRenderer(renderNode.renderer);
        this.geoObjectHandler.setRenderNode(renderNode);
        this.polylineHandler.setRenderNode(renderNode);
        this.pointCloudHandler.setRenderNode(renderNode);
        this.stripHandler.setRenderNode(renderNode);
        this.updateBillboardsTextureAtlas();
        this.updateLabelsFontAtlas();
        this.createPickingColors();
      }
    }
    /**
     * Updates coordinates all lonLat entities in collection after collection attached to the planet node.
     * @protected
     * @param {Ellipsoid} ellipsoid - Globe ellipsoid.
     */
    _updateGeodeticCoordinates(ellipsoid) {
      let e9 = this._entities;
      let i9 = e9.length;
      while (i9--) {
        let ei = e9[i9];
        ei._lonLat && ei.setCartesian3v(ellipsoid.lonLatToCartesian(ei._lonLat));
      }
    }
    /**
     * Updates billboard texture atlas.
     * @public
     */
    updateBillboardsTextureAtlas() {
      let b4 = this.billboardHandler.billboards;
      for (let i9 = 0; i9 < b4.length; i9++) {
        b4[i9].setSrc(b4[i9].getSrc());
      }
    }
    /**
     * Updates labels font atlas.
     * @public
     */
    updateLabelsFontAtlas() {
      if (this.renderNode) {
        this.labelHandler.updateFonts();
      }
    }
    /**
     * Removes collection from render node.
     * @public
     */
    remove() {
      if (this.renderNode) {
        if (this._renderNodeIndex !== -1) {
          this.renderNode.entityCollections.splice(this._renderNodeIndex, 1);
          for (let i9 = this._renderNodeIndex; i9 < this.renderNode.entityCollections.length; i9++) {
            this.renderNode.entityCollections[i9]._renderNodeIndex = i9;
          }
        }
        this.renderNode = null;
        this._renderNodeIndex = -1;
        this.events.dispatch(this.events.remove, this);
      }
    }
    /**
     * Gets entity array.
     * @public
     * @returns {Array.<Entity>} -
     */
    getEntities() {
      return [].concat(this._entities);
    }
    /**
     * Safety entities loop.
     * @public
     * @param {function} callback - Entity callback.
     */
    each(callback) {
      let i9 = this._entities.length;
      while (i9--) {
        let ei = this._entities[i9];
        ei && callback(ei);
      }
    }
    /**
     * Removes all entities from collection and clear handlers.
     * @public
     */
    clear() {
      this.billboardHandler.clear();
      this.labelHandler.clear();
      this.polylineHandler.clear();
      this.rayHandler.clear();
      this.pointCloudHandler.clear();
      this.stripHandler.clear();
      this.geoObjectHandler.clear();
      let i9 = this._entities.length;
      while (i9--) {
        let ei = this._entities[i9];
        if (this.renderNode && this.renderNode.renderer) {
          this.renderNode.renderer.clearPickingColor(ei);
          ei._pickingColor.clear();
        }
        this._clearEntity(ei);
      }
      this._entities.length = 0;
      this._entities = [];
    }
    /**
     * Clears entity recursively.
     * @private
     * @param {Entity} entity - Entity to clear.
     */
    _clearEntity(entity) {
      entity._entityCollection = null;
      entity._entityCollectionIndex = -1;
      for (let i9 = 0; i9 < entity.childrenNodes.length; i9++) {
        this._clearEntity(entity.childrenNodes[i9]);
      }
    }
  };
  EntityCollection.__counter__ = 0;
  var ENTITYCOLLECTION_EVENTS = [
    // /**
    //  * Triggered when entity has moved.
    //  * @event EntityCollection#entitymove
    //  */
    // "entitymove",
    /**
     * Triggered when collection entities begin draw.
     * @event EntityCollection#draw
     */
    "draw",
    /**
     * Triggered after collection has drawn.
     * @event EntityCollection#drawend
     */
    "drawend",
    /**
     * Triggered when added to the render node.
     * @event EntityCollection#add
     */
    "add",
    /**
     * Triggered when removed from the render node.
     * @event EntityCollection#remove
     */
    "remove",
    /**
     * Triggered when new entity added to the collection.
     * @event EntityCollection#entityadd
     */
    "entityadd",
    /**
     * Triggered when entity removes from the collection.
     * @event EntityCollection#entityremove
     */
    "entityremove",
    /**
     * Triggered when visibility changes.
     * @event EntityCollection#visibilitychange
     */
    "visibilitychange",
    /**
     * Triggered when mouse moves over the entity.
     * @event EntityCollection#mousemove
     */
    "mousemove",
    /**
     * Triggered when mouse has entered over the entity.
     * @event EntityCollection#mouseenter
     */
    "mouseenter",
    /**
     * Triggered when mouse leaves the entity.
     * @event EntityCollection#mouseleave
     */
    "mouseleave",
    /**
     * Mouse left button clicked.
     * @event EntityCollection#lclick
     */
    "lclick",
    /**
     * Mouse right button clicked.
     * @event EntityCollection#rclick
     */
    "rclick",
    /**
     * Mouse right button clicked.
     * @event EntityCollection#mclick
     */
    "mclick",
    /**
     * Mouse left button double click.
     * @event EntityCollection#ldblclick
     */
    "ldblclick",
    /**
     * Mouse right button double click.
     * @event EntityCollection#rdblclick
     */
    "rdblclick",
    /**
     * Mouse middle button double click.
     * @event EntityCollection#mdblclick
     */
    "mdblclick",
    /**
     * Mouse left button up(stop pressing).
     * @event EntityCollection#lup
     */
    "lup",
    /**
     * Mouse right button up(stop pressing).
     * @event EntityCollection#rup
     */
    "rup",
    /**
     * Mouse middle button up(stop pressing).
     * @event EntityCollection#mup
     */
    "mup",
    /**
     * Mouse left button is just pressed down(start pressing).
     * @event EntityCollection#ldown
     */
    "ldown",
    /**
     * Mouse right button is just pressed down(start pressing).
     * @event EntityCollection#rdown
     */
    "rdown",
    /**
     * Mouse middle button is just pressed down(start pressing).
     * @event EntityCollection#mdown
     */
    "mdown",
    /**
     * Mouse left button is pressing.
     * @event EntityCollection#lhold
     */
    "lhold",
    /**
     * Mouse right button is pressing.
     * @event EntityCollection#rhold
     */
    "rhold",
    /**
     * Mouse middle button is pressing.
     * @event EntityCollection#mhold
     */
    "mhold",
    /**
     * Mouse wheel is rotated.
     * @event EntityCollection#mousewheel
     */
    "mousewheel",
    /**
     * Triggered when touch moves over the entity.
     * @event EntityCollection#touchmove
     */
    "touchmove",
    /**
     * Triggered when entity begins to touch.
     * @event EntityCollection#touchstart
     */
    "touchstart",
    /**
     * Triggered when entity ends touching.
     * @event EntityCollection#touchend
     */
    "touchend",
    /**
     * Triggered entity double touch.
     * @event EntityCollection#doubletouch
     */
    "doubletouch",
    /**
     * Triggered when touching leaves entity.
     * @event EntityCollection#touchleave
     */
    "touchleave",
    /**
     * Triggered when touch enters over the entity.
     * @event EntityCollection#touchenter
     */
    "touchenter"
  ];

  // frontend/node_modules/@openglobus/og/lib/js/quadTree/EntityCollectionNode.js
  var EntityCollectionNode = class _EntityCollectionNode {
    constructor(layer, partId, parent, extent, planet, zoom) {
      this.layer = layer;
      this.parentNode = parent;
      this.childrenNodes = [];
      this.partId = partId;
      this.nodeId = partId + (parent ? parent.nodeId * 4 + 1 : 0);
      this.state = null;
      this.extent = extent;
      this.count = 0;
      this.deferredEntities = [];
      this.entityCollection = null;
      this.zoom = zoom;
      this._inTheQueue = false;
      this.bsphere = new Sphere();
      planet && this._setExtentBounds();
    }
    insertEntity(entity, rightNow = false) {
      this.buildTree([entity], rightNow);
    }
    _addEntitiesToCollection(entities, rightNow = false) {
      if (entities.length) {
        const l4 = this.layer;
        const p4 = l4._planet;
        let ec = this.entityCollection;
        if (!ec) {
          ec = new EntityCollection({
            pickingEnabled: l4._pickingEnabled,
            labelMaxLetters: l4.labelMaxLetters
          });
          ec._layer = this.layer;
          ec.addTo(p4, true);
          ec._quadNode = this;
          l4._bindEventsDefault(ec);
          this.entityCollection = ec;
        }
        if (rightNow || !l4.async) {
          this.entityCollection.addEntities(entities);
        } else {
          this.deferredEntities.push.apply(this.deferredEntities, entities);
        }
      }
    }
    _setExtentBounds() {
      if (!this.nodeId) {
        this.bsphere.radius = this.layer._planet.ellipsoid.equatorialSize;
        this.bsphere.center = new Vec3();
      } else {
        this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent.inverseMercator());
      }
    }
    __setLonLat__(entity) {
      if (entity._lonLat.isZero() && !entity._cartesian.isZero()) {
        entity._lonLat = this.layer._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
      }
      if (Math.abs(entity._lonLat.lat) < MAX_LAT) {
        entity._lonLatMerc = entity._lonLat.forwardMercator();
      } else {
        entity._lonLatMerc = new LonLat();
      }
      return entity._lonLatMerc;
    }
    buildTree(entities, rightNow = false) {
      this.count += entities.length;
      if (entities.length > this.layer._nodeCapacity) {
        const cn = this.childrenNodes;
        if (!cn.length) {
          this.createChildrenNodes();
        }
        let en_nw = [], en_ne = [], en_sw = [], en_se = [];
        let i9 = entities.length;
        while (i9--) {
          const ei = entities[i9];
          if (cn[NW].isInside(ei)) {
            ei._nodePtr = cn[NW];
            en_nw.push(ei);
          } else if (cn[NE].isInside(ei)) {
            ei._nodePtr = cn[NE];
            en_ne.push(ei);
          } else if (cn[SW].isInside(ei)) {
            ei._nodePtr = cn[SW];
            en_sw.push(ei);
          } else if (cn[SE].isInside(ei)) {
            ei._nodePtr = cn[SE];
            en_se.push(ei);
          }
        }
        en_nw.length && cn[NW].buildTree(en_nw, rightNow);
        en_ne.length && cn[NE].buildTree(en_ne, rightNow);
        en_sw.length && cn[SW].buildTree(en_sw, rightNow);
        en_se.length && cn[SE].buildTree(en_se, rightNow);
      } else {
        this._addEntitiesToCollection(entities, rightNow);
      }
    }
    isInside(entity) {
      if (entity._lonLatMerc) {
        return this.extent.isInside(entity._lonLatMerc);
      } else {
        return false;
      }
    }
    createChildrenNodes() {
      const l4 = this.layer;
      const ext = this.extent;
      const size_x = ext.getWidth() * 0.5;
      const size_y = ext.getHeight() * 0.5;
      const ne = ext.northEast;
      const sw = ext.southWest;
      const c7 = new LonLat(sw.lon + size_x, sw.lat + size_y);
      const nd = this.childrenNodes;
      const p4 = this.layer._planet;
      const z3 = this.zoom + 1;
      nd[NW] = new _EntityCollectionNode(l4, NW, this, new Extent(new LonLat(sw.lon, sw.lat + size_y), new LonLat(sw.lon + size_x, ne.lat)), p4, z3);
      nd[NE] = new _EntityCollectionNode(l4, NE, this, new Extent(c7, new LonLat(ne.lon, ne.lat)), p4, z3);
      nd[SW] = new _EntityCollectionNode(l4, SW, this, new Extent(new LonLat(sw.lon, sw.lat), c7), p4, z3);
      nd[SE] = new _EntityCollectionNode(l4, SE, this, new Extent(new LonLat(sw.lon + size_x, sw.lat), new LonLat(ne.lon, sw.lat + size_y)), p4, z3);
    }
    collectRenderCollectionsPASS1(visibleNodes, outArr) {
      const n7 = visibleNodes[this.nodeId];
      if (n7) {
        const cn = this.childrenNodes;
        if (this.entityCollection) {
          this.renderCollection(outArr, visibleNodes);
        } else if (cn.length) {
          if (n7.state === RENDERING) {
            this.layer._secondPASS.push(this);
          } else {
            cn[NW].collectRenderCollectionsPASS1(visibleNodes, outArr);
            cn[NE].collectRenderCollectionsPASS1(visibleNodes, outArr);
            cn[SW].collectRenderCollectionsPASS1(visibleNodes, outArr);
            cn[SE].collectRenderCollectionsPASS1(visibleNodes, outArr);
          }
        }
      }
    }
    collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId) {
      const p4 = this.layer._planet;
      const cam = p4.camera;
      const altVis = cam.eye.distance(this.bsphere.center) - this.bsphere.radius < VISIBLE_DISTANCE * Math.sqrt(cam._lonLat.height) || cam._lonLat.height > 1e4;
      if (this.count > 0 && altVis && cam.frustum.containsSphere(this.bsphere)) {
        const cn = this.childrenNodes;
        if (this.entityCollection) {
          this.renderCollection(outArr, visibleNodes, renderingNodeId);
        } else if (cn.length) {
          cn[NW].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
          cn[NE].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
          cn[SW].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
          cn[SE].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
        }
      }
    }
    applyCollection() {
      this.entityCollection.addEntities(this.deferredEntities);
      this.deferredEntities.length = 0;
      this.deferredEntities = [];
      this._inTheQueue = false;
    }
    traverseTree(callback) {
      const cn = this.childrenNodes;
      if (this.entityCollection) {
        callback(this);
      } else if (cn.length) {
        cn[NW].traverseTree(callback);
        cn[NE].traverseTree(callback);
        cn[SW].traverseTree(callback);
        cn[SE].traverseTree(callback);
      }
    }
    renderCollection(outArr, visibleNodes, renderingNodeId) {
      const l4 = this.layer;
      l4._renderingNodes[this.nodeId] = true;
      if (this.deferredEntities.length && !this._inTheQueue) {
        if (l4.async) {
          l4._queueDeferredNode(this);
        } else {
          this.applyCollection();
        }
      }
      const ec = this.entityCollection;
      ec._fadingOpacity = l4._fadingOpacity;
      ec.scaleByDistance = l4.scaleByDistance;
      ec.pickingScale = l4.pickingScale;
      ec.polygonOffsetUnits = l4.polygonOffsetUnits;
      outArr.push(ec);
      if (l4.clampToGround || l4.relativeToGround) {
        const e9 = ec._entities;
        let i9 = e9.length;
        if (visibleNodes[this.nodeId] && visibleNodes[this.nodeId].state === RENDERING) {
          while (i9--) {
            let ei = e9[i9];
            this.alignEntityToTheGround(ei, visibleNodes[this.nodeId].segment);
          }
        } else if (renderingNodeId) {
          while (i9--) {
            let ei = e9[i9];
            this.alignEntityToTheGround(ei, visibleNodes[renderingNodeId].segment);
          }
        } else {
          const n7 = l4._planet._renderedNodes;
          while (i9--) {
            let ei = e9[i9];
            let j2 = n7.length;
            while (j2--) {
              if (n7[j2].segment.isEntityInside(ei)) {
                this.alignEntityToTheGround(ei, n7[j2].segment);
                break;
              }
            }
          }
        }
      }
    }
    alignEntityToTheGround(entity, segment) {
      let res = new Vec3();
      segment.getEntityTerrainPoint(entity, res);
      let alt = Number(this.layer.relativeToGround) && entity._altitude || 0;
      if (alt) {
        let n7 = this.layer._planet.ellipsoid.getSurfaceNormal3v(res);
        entity._setCartesian3vSilent(res.addA(n7.scale(alt)));
      } else {
        entity._setCartesian3vSilent(res);
      }
    }
    isVisible() {
      if (this.layer._renderingNodes[this.nodeId]) {
        return true;
      }
      return false;
    }
  };
  var EntityCollectionNodeWGS84 = class _EntityCollectionNodeWGS84 extends EntityCollectionNode {
    constructor(layer, partId, parent, extent, planet, zoom) {
      super(layer, partId, parent, extent, planet, zoom);
      this.isNorth = false;
    }
    createChildrenNodes() {
      const l4 = this.layer;
      const ext = this.extent;
      const size_x = ext.getWidth() * 0.5;
      const size_y = ext.getHeight() * 0.5;
      const ne = ext.northEast;
      const sw = ext.southWest;
      const c7 = new LonLat(sw.lon + size_x, sw.lat + size_y);
      const nd = this.childrenNodes;
      const p4 = this.layer._planet;
      const z3 = this.zoom + 1;
      nd[NW] = new _EntityCollectionNodeWGS84(l4, NW, this, new Extent(new LonLat(sw.lon, sw.lat + size_y), new LonLat(sw.lon + size_x, ne.lat)), p4, z3);
      nd[NE] = new _EntityCollectionNodeWGS84(l4, NE, this, new Extent(c7, new LonLat(ne.lon, ne.lat)), p4, z3);
      nd[SW] = new _EntityCollectionNodeWGS84(l4, SW, this, new Extent(new LonLat(sw.lon, sw.lat), c7), p4, z3);
      nd[SE] = new _EntityCollectionNodeWGS84(l4, SE, this, new Extent(new LonLat(sw.lon + size_x, sw.lat), new LonLat(ne.lon, sw.lat + size_y)), p4, z3);
    }
    _setExtentBounds() {
      if (this.extent.northEast.lat > 0) {
        this.isNorth = true;
      }
      this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent);
    }
    __setLonLat__(entity) {
      if (entity._lonLat.isZero()) {
        entity._lonLat = this.layer._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
      }
      return entity._lonLat;
    }
    isVisible() {
      if (this.isNorth && this.layer._renderingNodesNorth[this.nodeId]) {
        return true;
      } else if (this.layer._renderingNodesSouth[this.nodeId]) {
        return true;
      }
      return false;
    }
    isInside(entity) {
      return this.extent.isInside(entity._lonLat);
    }
    renderCollection(outArr, visibleNodes, renderingNode) {
      if (this.isNorth) {
        this.layer._renderingNodesNorth[this.nodeId] = true;
      } else {
        this.layer._renderingNodesSouth[this.nodeId] = true;
      }
      if (this.deferredEntities.length && !this._inTheQueue) {
        if (this.layer.async) {
          this.layer._queueDeferredNode(this);
        } else {
          this.applyCollection();
        }
      }
      const ec = this.entityCollection;
      ec._fadingOpacity = this.layer._fadingOpacity;
      ec.scaleByDistance = this.layer.scaleByDistance;
      ec.pickingScale = this.layer.pickingScale;
      outArr.push(ec);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/math/coder.js
  function decodeFloatFromRGBAArr(arr, use32 = false) {
    let s7 = 1 - step(128, arr[0]) * 2;
    let e9 = 2 * mod2(arr[0], 128) + step(128, arr[1]) - 127;
    let m5 = mod2(arr[1], 128) * 65536 + arr[2] * 256 + (use32 ? arr[3] || 0 : 0) + 8388608;
    return s7 * exp2(e9) * (m5 * 11920928955078125e-23);
  }
  function doubleToTwoFloats2(value, highLowArr) {
    if (value >= 0) {
      let doubleHigh = Math.floor(value / 65536) * 65536;
      highLowArr[0] = Math.fround(doubleHigh);
      highLowArr[1] = Math.fround(value - doubleHigh);
    } else {
      let doubleHigh = Math.floor(-value / 65536) * 65536;
      highLowArr[0] = Math.fround(-doubleHigh);
      highLowArr[1] = Math.fround(value + doubleHigh);
    }
    return highLowArr;
  }
  function doubleToTwoFloatsV2(value, highLowVec) {
    if (value >= 0) {
      let doubleHigh = Math.floor(value / 65536) * 65536;
      highLowVec.x = Math.fround(doubleHigh);
      highLowVec.y = Math.fround(value - doubleHigh);
    } else {
      let doubleHigh = Math.floor(-value / 65536) * 65536;
      highLowVec.x = Math.fround(-doubleHigh);
      highLowVec.y = Math.fround(value + doubleHigh);
    }
    return highLowVec;
  }

  // frontend/node_modules/@openglobus/og/lib/js/utils/earcut.js
  function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode)
      return triangles;
    var minX, minY, maxX, maxY, x3, y4, size;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i9 = dim; i9 < outerLen; i9 += dim) {
        x3 = data[i9];
        y4 = data[i9 + 1];
        if (x3 < minX)
          minX = x3;
        if (y4 < minY)
          minY = y4;
        if (x3 > maxX)
          maxX = x3;
        if (y4 > maxY)
          maxY = y4;
      }
      size = Math.max(maxX - minX, maxY - minY);
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, size);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise) {
    var i9, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i9 = start; i9 < end; i9 += dim)
        last = insertNode(i9, data[i9], data[i9 + 1], last);
    } else {
      for (i9 = end - dim; i9 >= start; i9 -= dim)
        last = insertNode(i9, data[i9], data[i9 + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    var p4 = start, again;
    do {
      again = false;
      if (!p4.steiner && (equals(p4, p4.next) || area(p4.prev, p4, p4.next) === 0)) {
        removeNode(p4);
        p4 = end = p4.prev;
        if (p4 === p4.next)
          return null;
        again = true;
      } else {
        p4 = p4.next;
      }
    } while (again || p4 !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear)
      return;
    if (!pass && size)
      indexCurve(ear, minX, minY, size);
    var stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(ear, triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, size, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, size);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    var a6 = ear.prev, b4 = ear, c7 = ear.next;
    if (area(a6, b4, c7) >= 0)
      return false;
    var p4 = ear.next.next;
    while (p4 !== ear.prev) {
      if (pointInTriangle(a6.x, a6.y, b4.x, b4.y, c7.x, c7.y, p4.x, p4.y) && area(p4.prev, p4, p4.next) >= 0)
        return false;
      p4 = p4.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, size) {
    var a6 = ear.prev, b4 = ear, c7 = ear.next;
    if (area(a6, b4, c7) >= 0)
      return false;
    var minTX = a6.x < b4.x ? a6.x < c7.x ? a6.x : c7.x : b4.x < c7.x ? b4.x : c7.x, minTY = a6.y < b4.y ? a6.y < c7.y ? a6.y : c7.y : b4.y < c7.y ? b4.y : c7.y, maxTX = a6.x > b4.x ? a6.x > c7.x ? a6.x : c7.x : b4.x > c7.x ? b4.x : c7.x, maxTY = a6.y > b4.y ? a6.y > c7.y ? a6.y : c7.y : b4.y > c7.y ? b4.y : c7.y;
    var minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size);
    var p4 = ear.nextZ;
    while (p4 && p4.z <= maxZ) {
      if (p4 !== ear.prev && p4 !== ear.next && pointInTriangle(a6.x, a6.y, b4.x, b4.y, c7.x, c7.y, p4.x, p4.y) && area(p4.prev, p4, p4.next) >= 0)
        return false;
      p4 = p4.nextZ;
    }
    p4 = ear.prevZ;
    while (p4 && p4.z >= minZ) {
      if (p4 !== ear.prev && p4 !== ear.next && pointInTriangle(a6.x, a6.y, b4.x, b4.y, c7.x, c7.y, p4.x, p4.y) && area(p4.prev, p4, p4.next) >= 0)
        return false;
      p4 = p4.prevZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    var p4 = start;
    do {
      var a6 = p4.prev, b4 = p4.next.next;
      if (!equals(a6, b4) && intersects(a6, p4, p4.next, b4) && locallyInside(a6, b4) && locallyInside(b4, a6)) {
        triangles.push(a6.i / dim);
        triangles.push(p4.i / dim);
        triangles.push(b4.i / dim);
        removeNode(p4);
        removeNode(p4.next);
        p4 = start = b4;
      }
      p4 = p4.next;
    } while (p4 !== start);
    return p4;
  }
  function splitEarcut(start, triangles, dim, minX, minY, size) {
    var a6 = start;
    do {
      var b4 = a6.next.next;
      while (b4 !== a6.prev) {
        if (a6.i !== b4.i && isValidDiagonal(a6, b4)) {
          var c7 = splitPolygon(a6, b4);
          a6 = filterPoints(a6, a6.next);
          c7 = filterPoints(c7, c7.next);
          earcutLinked(a6, triangles, dim, minX, minY, size);
          earcutLinked(c7, triangles, dim, minX, minY, size);
          return;
        }
        b4 = b4.next;
      }
      a6 = a6.next;
    } while (a6 !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i9, len, start, end, list;
    for (i9 = 0, len = holeIndices.length; i9 < len; i9++) {
      start = holeIndices[i9] * dim;
      end = i9 < len - 1 ? holeIndices[i9 + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i9 = 0; i9 < queue.length; i9++) {
      eliminateHole(queue[i9], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  }
  function compareX(a6, b4) {
    return a6.x - b4.x;
  }
  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
      var b4 = splitPolygon(outerNode, hole);
      filterPoints(b4, b4.next);
    }
  }
  function findHoleBridge(hole, outerNode) {
    var p4 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m5;
    do {
      if (hy <= p4.y && hy >= p4.next.y && p4.next.y !== p4.y) {
        var x3 = p4.x + (hy - p4.y) * (p4.next.x - p4.x) / (p4.next.y - p4.y);
        if (x3 <= hx && x3 > qx) {
          qx = x3;
          if (x3 === hx) {
            if (hy === p4.y)
              return p4;
            if (hy === p4.next.y)
              return p4.next;
          }
          m5 = p4.x < p4.next.x ? p4 : p4.next;
        }
      }
      p4 = p4.next;
    } while (p4 !== outerNode);
    if (!m5)
      return null;
    if (hx === qx)
      return m5.prev;
    var stop = m5, mx = m5.x, my = m5.y, tanMin = Infinity, tan;
    p4 = m5.next;
    while (p4 !== stop) {
      if (hx >= p4.x && p4.x >= mx && hx !== p4.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p4.x, p4.y)) {
        tan = Math.abs(hy - p4.y) / (hx - p4.x);
        if ((tan < tanMin || tan === tanMin && p4.x > m5.x) && locallyInside(p4, hole)) {
          m5 = p4;
          tanMin = tan;
        }
      }
      p4 = p4.next;
    }
    return m5;
  }
  function indexCurve(start, minX, minY, size) {
    var p4 = start;
    do {
      if (p4.z === null)
        p4.z = zOrder(p4.x, p4.y, minX, minY, size);
      p4.prevZ = p4.prev;
      p4.nextZ = p4.next;
      p4 = p4.next;
    } while (p4 !== start);
    p4.prevZ.nextZ = null;
    p4.prevZ = null;
    sortLinked(p4);
  }
  function sortLinked(list) {
    var i9, p4, q2, e9, tail2, numMerges, pSize, qSize, inSize = 1;
    do {
      p4 = list;
      list = null;
      tail2 = null;
      numMerges = 0;
      while (p4) {
        numMerges++;
        q2 = p4;
        pSize = 0;
        for (i9 = 0; i9 < inSize; i9++) {
          pSize++;
          q2 = q2.nextZ;
          if (!q2)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q2) {
          if (pSize !== 0 && (qSize === 0 || !q2 || p4.z <= q2.z)) {
            e9 = p4;
            p4 = p4.nextZ;
            pSize--;
          } else {
            e9 = q2;
            q2 = q2.nextZ;
            qSize--;
          }
          if (tail2)
            tail2.nextZ = e9;
          else
            list = e9;
          e9.prevZ = tail2;
          tail2 = e9;
        }
        p4 = q2;
      }
      tail2.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x3, y4, minX, minY, size) {
    x3 = 32767 * (x3 - minX) / size;
    y4 = 32767 * (y4 - minY) / size;
    x3 = (x3 | x3 << 8) & 16711935;
    x3 = (x3 | x3 << 4) & 252645135;
    x3 = (x3 | x3 << 2) & 858993459;
    x3 = (x3 | x3 << 1) & 1431655765;
    y4 = (y4 | y4 << 8) & 16711935;
    y4 = (y4 | y4 << 4) & 252645135;
    y4 = (y4 | y4 << 2) & 858993459;
    y4 = (y4 | y4 << 1) & 1431655765;
    return x3 | y4 << 1;
  }
  function getLeftmost(start) {
    var p4 = start, leftmost = start;
    do {
      if (p4.x < leftmost.x)
        leftmost = p4;
      p4 = p4.next;
    } while (p4 !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
  }
  function isValidDiagonal(a6, b4) {
    return a6.next.i !== b4.i && a6.prev.i !== b4.i && !intersectsPolygon(a6, b4) && locallyInside(a6, b4) && locallyInside(b4, a6) && middleInside(a6, b4);
  }
  function area(p4, q2, r8) {
    return (q2.y - p4.y) * (r8.x - q2.x) - (q2.x - p4.x) * (r8.y - q2.y);
  }
  function equals(p1, p22) {
    return p1.x === p22.x && p1.y === p22.y;
  }
  function intersects(p1, q1, p22, q2) {
    if (equals(p1, q1) && equals(p22, q2) || equals(p1, q2) && equals(p22, q1))
      return true;
    return area(p1, q1, p22) > 0 !== area(p1, q1, q2) > 0 && area(p22, q2, p1) > 0 !== area(p22, q2, q1) > 0;
  }
  function intersectsPolygon(a6, b4) {
    var p4 = a6;
    do {
      if (p4.i !== a6.i && p4.next.i !== a6.i && p4.i !== b4.i && p4.next.i !== b4.i && intersects(p4, p4.next, a6, b4))
        return true;
      p4 = p4.next;
    } while (p4 !== a6);
    return false;
  }
  function locallyInside(a6, b4) {
    return area(a6.prev, a6, a6.next) < 0 ? area(a6, b4, a6.next) >= 0 && area(a6, a6.prev, b4) >= 0 : area(a6, b4, a6.prev) < 0 || area(a6, a6.next, b4) < 0;
  }
  function middleInside(a6, b4) {
    var p4 = a6, inside = false, px = (a6.x + b4.x) / 2, py = (a6.y + b4.y) / 2;
    do {
      if (p4.y > py !== p4.next.y > py && p4.next.y !== p4.y && px < (p4.next.x - p4.x) * (py - p4.y) / (p4.next.y - p4.y) + p4.x)
        inside = !inside;
      p4 = p4.next;
    } while (p4 !== a6);
    return inside;
  }
  function splitPolygon(a6, b4) {
    var a22 = new Node(a6.i, a6.x, a6.y), b22 = new Node(b4.i, b4.x, b4.y), an = a6.next, bp = b4.prev;
    a6.next = b4;
    b4.prev = a6;
    a22.next = an;
    an.prev = a22;
    b22.next = a22;
    a22.prev = b22;
    bp.next = b22;
    b22.prev = bp;
    return b22;
  }
  function insertNode(i9, x3, y4, last) {
    var p4 = new Node(i9, x3, y4);
    if (!last) {
      p4.prev = p4;
      p4.next = p4;
    } else {
      p4.next = last.next;
      p4.prev = last;
      last.next.prev = p4;
      last.next = p4;
    }
    return p4;
  }
  function removeNode(p4) {
    p4.next.prev = p4.prev;
    p4.prev.next = p4.next;
    if (p4.prevZ)
      p4.prevZ.nextZ = p4.nextZ;
    if (p4.nextZ)
      p4.nextZ.prevZ = p4.prevZ;
  }
  function Node(i9, x3, y4) {
    this.i = i9;
    this.x = x3;
    this.y = y4;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  function signedArea(data, start, end, dim) {
    var sum = 0;
    for (let i9 = start, j2 = end - dim; i9 < end; i9 += dim) {
      sum += (data[j2] - data[i9]) * (data[i9 + 1] + data[j2 + 1]);
      j2 = i9;
    }
    return sum;
  }
  function flatten(data) {
    var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
    for (let i9 = 0; i9 < data.length; i9++) {
      for (let j2 = 0; j2 < data[i9].length; j2++) {
        for (let d4 = 0; d4 < dim; d4++)
          result.vertices.push(data[i9][j2][d4]);
      }
      if (i9 > 0) {
        holeIndex += data[i9 - 1].length;
        result.holes.push(holeIndex);
      }
    }
    return result;
  }

  // frontend/node_modules/@openglobus/og/lib/js/entity/GeometryHandler.js
  var POLYVERTICES_BUFFER = 0;
  var POLYINDEXES_BUFFER = 1;
  var POLYCOLORS_BUFFER = 2;
  var LINEVERTICES_BUFFER = 3;
  var LINEINDEXES_BUFFER = 4;
  var LINEORDERS_BUFFER = 5;
  var LINECOLORS_BUFFER = 6;
  var LINETHICKNESS_BUFFER = 7;
  var LINESTROKES_BUFFER = 8;
  var LINESTROKECOLORS_BUFFER = 9;
  var POLYPICKINGCOLORS_BUFFER = 10;
  var LINEPICKINGCOLORS_BUFFER = 11;
  function doubleToTwoFloats(v4, high, low) {
    let x3 = v4[0], y4 = v4[1];
    if (x3 >= 0) {
      let doubleHigh = Math.floor(x3 / 65536) * 65536;
      high.x = Math.fround(doubleHigh);
      low.x = Math.fround(x3 - doubleHigh);
    } else {
      let doubleHigh = Math.floor(-x3 / 65536) * 65536;
      high.x = Math.fround(-doubleHigh);
      low.x = Math.fround(x3 + doubleHigh);
    }
    if (y4 >= 0) {
      let doubleHigh = Math.floor(y4 / 65536) * 65536;
      high.y = Math.fround(doubleHigh);
      low.y = Math.fround(y4 - doubleHigh);
    } else {
      let doubleHigh = Math.floor(-y4 / 65536) * 65536;
      high.y = Math.fround(-doubleHigh);
      low.y = Math.fround(y4 + doubleHigh);
    }
  }
  var tempHigh = new Vec2();
  var tempLow = new Vec2();
  var tempHighLow = new Vec2();
  var GeometryHandler = class _GeometryHandler {
    constructor(layer) {
      this.__id = _GeometryHandler.__counter__++;
      this._layer = layer;
      this._handler = null;
      this._geometries = [];
      this._updatedGeometryArr = [];
      this._updatedGeometry = {};
      this._removeGeometryExtentArr = [];
      this._removeGeometryExtents = {};
      this._polyVerticesHighMerc = [];
      this._polyVerticesLowMerc = [];
      this._polyColors = [];
      this._polyPickingColors = [];
      this._polyIndexes = [];
      this._lineVerticesHighMerc = [];
      this._lineVerticesLowMerc = [];
      this._lineOrders = [];
      this._lineIndexes = [];
      this._lineColors = [];
      this._linePickingColors = [];
      this._lineThickness = [];
      this._lineStrokes = [];
      this._lineStrokeColors = [];
      this._polyVerticesHighBufferMerc = null;
      this._polyVerticesLowBufferMerc = null;
      this._polyColorsBuffer = null;
      this._polyPickingColorsBuffer = null;
      this._polyIndexesBuffer = null;
      this._lineVerticesHighBufferMerc = null;
      this._lineVerticesLowBufferMerc = null;
      this._lineColorsBuffer = null;
      this._linePickingColorsBuffer = null;
      this._lineThicknessBuffer = null;
      this._lineStrokesBuffer = null;
      this._lineStrokeColorsBuffer = null;
      this._lineOrdersBuffer = null;
      this._lineIndexesBuffer = null;
      this._buffersUpdateCallbacks = [];
      this._buffersUpdateCallbacks[POLYVERTICES_BUFFER] = this.createPolyVerticesBuffer;
      this._buffersUpdateCallbacks[POLYINDEXES_BUFFER] = this.createPolyIndexesBuffer;
      this._buffersUpdateCallbacks[POLYCOLORS_BUFFER] = this.createPolyColorsBuffer;
      this._buffersUpdateCallbacks[LINEVERTICES_BUFFER] = this.createLineVerticesBuffer;
      this._buffersUpdateCallbacks[LINEINDEXES_BUFFER] = this.createLineIndexesBuffer;
      this._buffersUpdateCallbacks[LINEORDERS_BUFFER] = this.createLineOrdersBuffer;
      this._buffersUpdateCallbacks[LINECOLORS_BUFFER] = this.createLineColorsBuffer;
      this._buffersUpdateCallbacks[LINETHICKNESS_BUFFER] = this.createLineThicknessBuffer;
      this._buffersUpdateCallbacks[LINESTROKES_BUFFER] = this.createLineStrokesBuffer;
      this._buffersUpdateCallbacks[LINESTROKECOLORS_BUFFER] = this.createLineStrokeColorsBuffer;
      this._buffersUpdateCallbacks[POLYPICKINGCOLORS_BUFFER] = this.createPolyPickingColorsBuffer;
      this._buffersUpdateCallbacks[LINEPICKINGCOLORS_BUFFER] = this.createLinePickingColorsBuffer;
      this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    }
    static appendLineData(pathArr, isClosed, color, pickingColor, thickness, strokeColor, strokeSize, outVerticesHigh, outVerticesLow, outOrders, outIndexes, outColors, outPickingColors, outThickness, outStrokeColors, outStrokes, outVerticesHigh2, outVerticesLow2) {
      var index = 0;
      if (outIndexes.length > 0) {
        index = outIndexes[outIndexes.length - 5] + 9;
        outIndexes.push(index, index);
      } else {
        outIndexes.push(0, 0);
      }
      var t9 = thickness, c7 = [color.x, color.y, color.z, color.w], s7 = strokeSize, sc = [strokeColor.x, strokeColor.y, strokeColor.z, strokeColor.w], p4 = [pickingColor.x, pickingColor.y, pickingColor.z, 1];
      for (let j2 = 0; j2 < pathArr.length; j2++) {
        var path = pathArr[j2];
        if (path.length === 0) {
          continue;
        }
        let startIndex = index;
        let last;
        if (isClosed) {
          last = path[path.length - 1];
        } else {
          let p0 = path[0], p1 = path[1];
          if (!p1) {
            p1 = p0;
          }
          last = [p0[0] + p0[0] - p1[0], p0[1] + p0[1] - p1[1]];
        }
        doubleToTwoFloats(last, tempHigh, tempLow);
        outVerticesHigh.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
        outVerticesLow.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
        outVerticesHigh2.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
        outVerticesLow2.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
        outOrders.push(1, -1, 2, -2);
        outThickness.push(t9, t9, t9, t9);
        outStrokes.push(s7, s7, s7, s7);
        outColors.push(c7[0], c7[1], c7[2], c7[3], c7[0], c7[1], c7[2], c7[3], c7[0], c7[1], c7[2], c7[3], c7[0], c7[1], c7[2], c7[3]);
        outStrokeColors.push(sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3]);
        outPickingColors.push(p4[0], p4[1], p4[2], p4[3], p4[0], p4[1], p4[2], p4[3], p4[0], p4[1], p4[2], p4[3], p4[0], p4[1], p4[2], p4[3]);
        for (let i9 = 0; i9 < path.length; i9++) {
          let cur = path[i9];
          doubleToTwoFloats(cur, tempHigh, tempLow);
          outVerticesHigh.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
          outVerticesLow.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
          outVerticesHigh2.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
          outVerticesLow2.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
          outOrders.push(1, -1, 2, -2);
          outThickness.push(t9, t9, t9, t9);
          outStrokes.push(s7, s7, s7, s7);
          outColors.push(c7[0], c7[1], c7[2], c7[3], c7[0], c7[1], c7[2], c7[3], c7[0], c7[1], c7[2], c7[3], c7[0], c7[1], c7[2], c7[3]);
          outStrokeColors.push(sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3]);
          outPickingColors.push(p4[0], p4[1], p4[2], p4[3], p4[0], p4[1], p4[2], p4[3], p4[0], p4[1], p4[2], p4[3], p4[0], p4[1], p4[2], p4[3]);
          outIndexes.push(index++, index++, index++, index++);
        }
        let first;
        if (isClosed) {
          first = path[0];
          outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
        } else {
          let p0 = path[path.length - 1], p1 = path[path.length - 2];
          if (!p1) {
            p1 = p0;
          }
          first = [p0[0] + p0[0] - p1[0], p0[1] + p0[1] - p1[1]];
          outIndexes.push(index - 1, index - 1, index - 1, index - 1);
        }
        doubleToTwoFloats(first, tempHigh, tempLow);
        outVerticesHigh.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
        outVerticesLow.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
        outVerticesHigh2.push(tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y, tempHigh.x, tempHigh.y);
        outVerticesLow2.push(tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y, tempLow.x, tempLow.y);
        outOrders.push(1, -1, 2, -2);
        outThickness.push(t9, t9, t9, t9);
        outStrokes.push(s7, s7, s7, s7);
        outColors.push(c7[0], c7[1], c7[2], c7[3], c7[0], c7[1], c7[2], c7[3], c7[0], c7[1], c7[2], c7[3], c7[0], c7[1], c7[2], c7[3]);
        outStrokeColors.push(sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3]);
        outPickingColors.push(p4[0], p4[1], p4[2], p4[3], p4[0], p4[1], p4[2], p4[3], p4[0], p4[1], p4[2], p4[3], p4[0], p4[1], p4[2], p4[3]);
        if (j2 < pathArr.length - 1) {
          index += 8;
          outIndexes.push(index, index);
        }
      }
    }
    assignHandler(handler) {
      this._handler = handler;
      this.refresh();
      if (handler.isInitialized()) {
        this.update();
      }
    }
    /**
     * @public
     * @param {Geometry} geometry - Geometry object.
     */
    add(geometry) {
      if (geometry._handlerIndex === -1) {
        geometry._handler = this;
        geometry._handlerIndex = this._geometries.length;
        this._geometries.push(geometry);
        let pickingColor = geometry._entity._pickingColor.scaleTo(1 / 255);
        geometry._polyVerticesHighMerc = [];
        geometry._polyVerticesLowMerc = [];
        geometry._lineVerticesHighMerc = [];
        geometry._lineVerticesLowMerc = [];
        if (geometry._coordinates[0].length) {
          if (geometry.type === GeometryTypeEnum.POLYGON) {
            let coordinates = geometry._coordinates;
            let ci = [];
            for (let j2 = 0; j2 < coordinates.length; j2++) {
              ci[j2] = [];
              for (let k3 = 0; k3 < coordinates[j2].length; k3++) {
                ci[j2][k3] = [forward_lon(coordinates[j2][k3][0]), forward_lat(coordinates[j2][k3][1])];
              }
            }
            let data = flatten(ci);
            let indexes = earcut(data.vertices, data.holes, 2);
            geometry._polyVerticesHandlerIndex = this._polyVerticesHighMerc.length;
            geometry._polyIndexesHandlerIndex = this._polyIndexes.length;
            for (let i9 = 0; i9 < indexes.length; i9++) {
              this._polyIndexes.push(indexes[i9] + geometry._polyVerticesHandlerIndex * 0.5);
            }
            let color = geometry._style.fillColor;
            let verticesHigh = [], verticesLow = [];
            for (let i9 = 0; i9 < data.vertices.length * 0.5; i9++) {
              this._polyColors.push(color.x, color.y, color.z, color.w);
              this._polyPickingColors.push(pickingColor.x, pickingColor.y, pickingColor.z, 1);
            }
            for (let i9 = 0; i9 < data.vertices.length; i9++) {
              doubleToTwoFloatsV2(data.vertices[i9], tempHighLow);
              verticesHigh[i9] = tempHighLow.x;
              verticesLow[i9] = tempHighLow.y;
            }
            geometry._polyVerticesHighMerc = verticesHigh;
            geometry._polyVerticesLowMerc = verticesLow;
            this._polyVerticesHighMerc.push.apply(this._polyVerticesHighMerc, verticesHigh);
            this._polyVerticesLowMerc.push.apply(this._polyVerticesLowMerc, verticesLow);
            geometry._polyVerticesLength = data.vertices.length;
            geometry._polyIndexesLength = indexes.length;
            geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
            geometry._lineOrdersHandlerIndex = this._lineOrders.length;
            geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
            geometry._lineColorsHandlerIndex = this._lineColors.length;
            geometry._lineThicknessHandlerIndex = this._lineThickness.length;
            _GeometryHandler.appendLineData(ci, true, geometry._style.lineColor, pickingColor, geometry._style.lineWidth, geometry._style.strokeColor, geometry._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesHighMerc, geometry._lineVerticesLowMerc);
            geometry._lineVerticesLength = this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
            geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
            geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
            geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
            geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;
          } else if (geometry.type === GeometryTypeEnum.MULTIPOLYGON) {
            let coordinates = geometry._coordinates;
            let vertices = [], indexes = [];
            geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
            geometry._lineOrdersHandlerIndex = this._lineOrders.length;
            geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
            geometry._lineColorsHandlerIndex = this._lineColors.length;
            geometry._lineThicknessHandlerIndex = this._lineThickness.length;
            for (let i9 = 0; i9 < coordinates.length; i9++) {
              let cci = coordinates[i9];
              let ci = [];
              for (let j2 = 0; j2 < cci.length; j2++) {
                ci[j2] = [];
                for (let k3 = 0; k3 < coordinates[i9][j2].length; k3++) {
                  ci[j2][k3] = [forward_lon(cci[j2][k3][0]), forward_lat(cci[j2][k3][1])];
                }
              }
              let data = flatten(ci);
              let dataIndexes = earcut(data.vertices, data.holes, 2);
              for (let j2 = 0; j2 < dataIndexes.length; j2++) {
                indexes.push(dataIndexes[j2] + vertices.length * 0.5);
              }
              vertices.push.apply(vertices, data.vertices);
              _GeometryHandler.appendLineData(ci, true, geometry._style.lineColor, pickingColor, geometry._style.lineWidth, geometry._style.strokeColor, geometry._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesHighMerc, geometry._lineVerticesLowMerc);
            }
            geometry._polyVerticesHandlerIndex = this._polyVerticesHighMerc.length;
            geometry._polyIndexesHandlerIndex = this._polyIndexes.length;
            for (let i9 = 0; i9 < indexes.length; i9++) {
              this._polyIndexes.push(indexes[i9] + geometry._polyVerticesHandlerIndex * 0.5);
            }
            let color = geometry._style.fillColor;
            let verticesHigh = [], verticesLow = [];
            for (let i9 = 0; i9 < vertices.length * 0.5; i9++) {
              this._polyColors.push(color.x, color.y, color.z, color.w);
              this._polyPickingColors.push(pickingColor.x, pickingColor.y, pickingColor.z, 1);
            }
            for (let i9 = 0; i9 < vertices.length; i9++) {
              doubleToTwoFloatsV2(vertices[i9], tempHighLow);
              verticesHigh[i9] = tempHighLow.x;
              verticesLow[i9] = tempHighLow.y;
            }
            geometry._polyVerticesHighMerc = verticesHigh;
            geometry._polyVerticesLowMerc = verticesLow;
            this._polyVerticesHighMerc.push.apply(this._polyVerticesHighMerc, verticesHigh);
            this._polyVerticesLowMerc.push.apply(this._polyVerticesLowMerc, verticesLow);
            geometry._polyVerticesLength = vertices.length;
            geometry._polyIndexesLength = indexes.length;
            geometry._lineVerticesLength = this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
            geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
            geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
            geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
            geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;
          } else if (geometry.type === GeometryTypeEnum.LINESTRING) {
            let coordinates = geometry._coordinates;
            let ci = new Array(coordinates.length);
            for (let j2 = 0; j2 < coordinates.length; j2++) {
              ci[j2] = [forward_lon(coordinates[j2][0]), forward_lat(coordinates[j2][1])];
            }
            geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
            geometry._lineOrdersHandlerIndex = this._lineOrders.length;
            geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
            geometry._lineColorsHandlerIndex = this._lineColors.length;
            geometry._lineThicknessHandlerIndex = this._lineThickness.length;
            _GeometryHandler.appendLineData([ci], false, geometry._style.lineColor, pickingColor, geometry._style.lineWidth, geometry._style.strokeColor, geometry._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesHighMerc, geometry._lineVerticesLowMerc);
            geometry._lineVerticesLength = this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
            geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
            geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
            geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
            geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;
          } else if (geometry.type === GeometryTypeEnum.MULTILINESTRING) {
            let coordinates = geometry._coordinates;
            let ci = [];
            for (let j2 = 0; j2 < coordinates.length; j2++) {
              ci[j2] = [];
              for (let k3 = 0; k3 < coordinates[j2].length; k3++) {
                ci[j2][k3] = [forward_lon(coordinates[j2][k3][0]), forward_lat(coordinates[j2][k3][1])];
              }
            }
            geometry._lineVerticesHandlerIndex = this._lineVerticesHighMerc.length;
            geometry._lineOrdersHandlerIndex = this._lineOrders.length;
            geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
            geometry._lineColorsHandlerIndex = this._lineColors.length;
            geometry._lineThicknessHandlerIndex = this._lineThickness.length;
            _GeometryHandler.appendLineData(ci, false, geometry._style.lineColor, pickingColor, geometry._style.lineWidth, geometry._style.strokeColor, geometry._style.strokeWidth, this._lineVerticesHighMerc, this._lineVerticesLowMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors, this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesHighMerc, geometry._lineVerticesLowMerc);
            geometry._lineVerticesLength = this._lineVerticesHighMerc.length - geometry._lineVerticesHandlerIndex;
            geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
            geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
            geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
            geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;
          }
        }
        this.setGeometryVisibility(geometry);
        !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry.__id] = true;
        this.refresh();
      }
    }
    remove(geometry) {
      const index = geometry._handlerIndex;
      if (index !== -1) {
        this._geometries.splice(index, 1);
        this._polyVerticesHighMerc.splice(geometry._polyVerticesHandlerIndex, geometry._polyVerticesLength);
        this._polyVerticesLowMerc.splice(geometry._polyVerticesHandlerIndex, geometry._polyVerticesLength);
        this._polyColors.splice(geometry._polyVerticesHandlerIndex * 2, geometry._polyVerticesLength * 2);
        this._polyPickingColors.splice(geometry._polyVerticesHandlerIndex * 2, geometry._polyVerticesLength * 2);
        this._polyIndexes.splice(geometry._polyIndexesHandlerIndex, geometry._polyIndexesLength);
        let di = geometry._polyVerticesLength * 0.5;
        for (let i9 = geometry._polyIndexesHandlerIndex; i9 < this._polyIndexes.length; i9++) {
          this._polyIndexes[i9] -= di;
        }
        this._lineVerticesHighMerc.splice(geometry._lineVerticesHandlerIndex, geometry._lineVerticesLength);
        this._lineVerticesLowMerc.splice(geometry._lineVerticesHandlerIndex, geometry._lineVerticesLength);
        this._lineOrders.splice(geometry._lineOrdersHandlerIndex, geometry._lineOrdersLength);
        this._lineColors.splice(geometry._lineColorsHandlerIndex, geometry._lineColorsLength);
        this._linePickingColors.splice(geometry._lineColorsHandlerIndex, geometry._lineColorsLength);
        this._lineStrokeColors.splice(geometry._lineColorsHandlerIndex, geometry._lineColorsLength);
        this._lineThickness.splice(geometry._lineThicknessHandlerIndex, geometry._lineThicknessLength);
        this._lineStrokes.splice(geometry._lineThicknessHandlerIndex, geometry._lineThicknessLength);
        this._lineIndexes.splice(geometry._lineIndexesHandlerIndex, geometry._lineIndexesLength);
        di = geometry._lineVerticesLength * 0.5;
        for (let i9 = geometry._lineIndexesHandlerIndex; i9 < this._lineIndexes.length; i9++) {
          this._lineIndexes[i9] -= di;
        }
        let g4 = this._geometries;
        for (let i9 = index; i9 < g4.length; i9++) {
          let gi = g4[i9];
          gi._handlerIndex = i9;
          gi._polyVerticesHandlerIndex -= geometry._polyVerticesLength;
          gi._polyIndexesHandlerIndex -= geometry._polyIndexesLength;
          gi._lineVerticesHandlerIndex -= geometry._lineVerticesLength;
          gi._lineOrdersHandlerIndex -= geometry._lineOrdersLength;
          gi._lineColorsHandlerIndex -= geometry._lineColorsLength;
          gi._lineThicknessHandlerIndex -= geometry._lineThicknessLength;
          gi._lineIndexesHandlerIndex -= geometry._lineIndexesLength;
        }
        geometry._pickingReady = false;
        geometry._handler = null;
        geometry._handlerIndex = -1;
        geometry._polyVerticesHighMerc = [];
        geometry._polyVerticesLowMerc = [];
        geometry._polyVerticesLength = -1;
        geometry._polyIndexesLength = -1;
        geometry._polyVerticesHandlerIndex = -1;
        geometry._polyIndexesHandlerIndex = -1;
        geometry._lineVerticesHighMerc = [];
        geometry._lineVerticesLowMerc = [];
        geometry._lineVerticesLength = -1;
        geometry._lineOrdersLength = -1;
        geometry._lineIndexesLength = -1;
        geometry._lineColorsLength = -1;
        geometry._lineThicknessLength = -1;
        geometry._lineVerticesHandlerIndex = -1;
        geometry._lineOrdersHandlerIndex = -1;
        geometry._lineIndexesHandlerIndex = -1;
        geometry._lineThicknessHandlerIndex = -1;
        geometry._lineColorsHandlerIndex = -1;
        !this._removeGeometryExtents[geometry.__id] && this._removeGeometryExtentArr.push(geometry.getExtent());
        this._removeGeometryExtents[geometry.__id] = true;
        this.refresh();
      }
    }
    _refreshRecursevely(geometry, treeNode) {
      if (treeNode.ready) {
        let lid = this._layer._id;
        for (let i9 = 0; i9 < treeNode.nodes.length; i9++) {
          let ni = treeNode.nodes[i9];
          if (geometry.overlaps(ni.segment.getExtentLonLat())) {
            this._refreshRecursevely(geometry, ni);
            let m5 = ni.segment.materials[lid];
            if (m5 && m5.isReady) {
              if (m5.segment.node.getState() !== RENDERING) {
                m5.layer.clearMaterial(m5);
              } else {
                m5.pickingReady = m5.pickingReady && geometry._pickingReady;
                m5.isReady = false;
                m5._updateTexture = m5.texture;
                m5._updatePickingMask = m5.pickingMask;
              }
              geometry._pickingReady = true;
            }
          }
        }
      }
    }
    _refreshRecursevelyExt(extent, treeNode) {
      if (treeNode.ready) {
        let lid = this._layer.__id;
        for (let i9 = 0; i9 < treeNode.nodes.length; i9++) {
          let ni = treeNode.nodes[i9];
          if (extent.overlaps(ni.segment.getExtentLonLat())) {
            this._refreshRecursevelyExt(extent, ni);
            let m5 = ni.segment.materials[lid];
            if (m5 && m5.isReady) {
              m5.layer.clearMaterial(m5);
            }
          }
        }
      }
    }
    _refreshPlanetNode(treeNode) {
      let i9;
      let e9 = this._removeGeometryExtentArr;
      for (i9 = 0; i9 < e9.length; i9++) {
        this._refreshRecursevelyExt(e9[i9], treeNode);
      }
      let g4 = this._updatedGeometryArr;
      for (i9 = 0; i9 < g4.length; i9++) {
        this._refreshRecursevely(g4[i9], treeNode);
      }
    }
    _updatePlanet() {
      let p4 = this._layer._planet;
      if (p4) {
        let ql = p4.quadTreeStrategy.quadTreeList;
        for (let i9 = 0; i9 < ql.length; i9++) {
          this._refreshPlanetNode(ql[i9]);
        }
      }
      this._updatedGeometryArr.length = 0;
      this._updatedGeometryArr = [];
      this._updatedGeometry = {};
      this._removeGeometryExtentArr.length = 0;
      this._removeGeometryExtentArr = [];
      this._removeGeometryExtents = {};
    }
    refresh() {
      let i9 = this._changedBuffers.length;
      while (i9--) {
        this._changedBuffers[i9] = true;
      }
    }
    update() {
      if (this._handler) {
        let needUpdate = false;
        let i9 = this._changedBuffers.length;
        while (i9--) {
          if (this._changedBuffers[i9]) {
            needUpdate = true;
            this._buffersUpdateCallbacks[i9].call(this);
            this._changedBuffers[i9] = false;
          }
        }
        needUpdate && this._updatePlanet();
      }
    }
    setGeometryVisibility(geometry) {
      let v4 = geometry.getVisibility() ? 1 : 0;
      let a6 = this._polyVerticesHighMerc, b4 = this._polyVerticesLowMerc;
      let l4 = geometry._polyVerticesLength;
      let ind = geometry._polyVerticesHandlerIndex;
      for (let i9 = 0; i9 < l4; i9++) {
        a6[ind + i9] = geometry._polyVerticesHighMerc[i9] * v4;
        b4[ind + i9] = geometry._polyVerticesLowMerc[i9] * v4;
      }
      a6 = this._lineVerticesHighMerc;
      b4 = this._lineVerticesLowMerc;
      l4 = geometry._lineVerticesLength;
      ind = geometry._lineVerticesHandlerIndex;
      for (let i9 = 0; i9 < l4; i9++) {
        a6[ind + i9] = geometry._lineVerticesHighMerc[i9] * v4;
        b4[ind + i9] = geometry._lineVerticesLowMerc[i9] * v4;
      }
      this._changedBuffers[POLYVERTICES_BUFFER] = true;
      this._changedBuffers[LINEVERTICES_BUFFER] = true;
      !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
      this._updatedGeometry[geometry.__id] = true;
    }
    setPolyColorArr(geometry, color) {
      let index = geometry._polyVerticesHandlerIndex * 2, size = index + geometry._polyVerticesLength * 2;
      let a6 = this._polyColors;
      for (let i9 = index; i9 < size; i9 += 4) {
        a6[i9] = color.x;
        a6[i9 + 1] = color.y;
        a6[i9 + 2] = color.z;
        a6[i9 + 3] = color.w;
      }
      this._changedBuffers[POLYCOLORS_BUFFER] = true;
      !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
      this._updatedGeometry[geometry.__id] = true;
    }
    setLineStrokeColorArr(geometry, color) {
      let index = geometry._lineColorsHandlerIndex, size = index + geometry._lineColorsLength;
      let a6 = this._lineStrokeColors;
      for (let i9 = index; i9 < size; i9 += 4) {
        a6[i9] = color.x;
        a6[i9 + 1] = color.y;
        a6[i9 + 2] = color.z;
        a6[i9 + 3] = color.w;
      }
      this._changedBuffers[LINESTROKECOLORS_BUFFER] = true;
      !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
      this._updatedGeometry[geometry.__id] = true;
    }
    setLineColorArr(geometry, color) {
      let index = geometry._lineColorsHandlerIndex, size = index + geometry._lineColorsLength;
      let a6 = this._lineColors;
      for (let i9 = index; i9 < size; i9 += 4) {
        a6[i9] = color.x;
        a6[i9 + 1] = color.y;
        a6[i9 + 2] = color.z;
        a6[i9 + 3] = color.w;
      }
      this._changedBuffers[LINECOLORS_BUFFER] = true;
      !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
      this._updatedGeometry[geometry.__id] = true;
    }
    setLineStrokeArr(geometry, width) {
    }
    setLineThicknessArr(geometry, width) {
      let index = geometry._lineThicknessHandlerIndex, size = index + geometry._lineThicknessLength;
      let a6 = this._lineThickness;
      for (let i9 = index; i9 < size; i9++) {
        a6[i9] = width;
      }
      this._changedBuffers[LINETHICKNESS_BUFFER] = true;
      !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
      this._updatedGeometry[geometry.__id] = true;
    }
    bringToFront(geometry) {
      let polyIndexes = this._polyIndexes.splice(geometry._polyIndexesHandlerIndex, geometry._polyIndexesLength);
      let lineIndexes = this._lineIndexes.splice(geometry._lineIndexesHandlerIndex, geometry._lineIndexesLength);
      this._geometries.splice(geometry._handlerIndex, 1);
      let g4 = this._geometries;
      for (let i9 = geometry._handlerIndex; i9 < g4.length; i9++) {
        let gi = g4[i9];
        gi._handlerIndex = i9;
        gi._polyIndexesHandlerIndex -= geometry._polyIndexesLength;
        gi._lineIndexesHandlerIndex -= geometry._lineIndexesLength;
      }
      geometry._polyIndexesHandlerIndex = this._polyIndexes.length;
      geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
      geometry._handlerIndex = this._geometries.length;
      this._geometries.push(geometry);
      this._polyIndexes.push.apply(this._polyIndexes, polyIndexes);
      this._lineIndexes.push.apply(this._lineIndexes, lineIndexes);
      this._changedBuffers[POLYINDEXES_BUFFER] = true;
      this._changedBuffers[LINEINDEXES_BUFFER] = true;
      !this._updatedGeometry[geometry.__id] && this._updatedGeometryArr.push(geometry);
      this._updatedGeometry[geometry.__id] = true;
    }
    createPolyVerticesBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._polyVerticesHighBufferMerc);
      this._polyVerticesHighBufferMerc = h8.createArrayBuffer(new Float32Array(this._polyVerticesHighMerc), 2, this._polyVerticesHighMerc.length / 2);
      h8.gl.deleteBuffer(this._polyVerticesLowBufferMerc);
      this._polyVerticesLowBufferMerc = h8.createArrayBuffer(new Float32Array(this._polyVerticesLowMerc), 2, this._polyVerticesLowMerc.length / 2);
    }
    createPolyIndexesBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._polyIndexesBuffer);
      this._polyIndexesBuffer = h8.createElementArrayBuffer(new Uint32Array(this._polyIndexes), 1, this._polyIndexes.length);
    }
    createPolyColorsBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._polyColorsBuffer);
      this._polyColorsBuffer = h8.createArrayBuffer(new Float32Array(this._polyColors), 4, this._polyColors.length / 4);
    }
    createPolyPickingColorsBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._polyPickingColorsBuffer);
      this._polyPickingColorsBuffer = h8.createArrayBuffer(new Float32Array(this._polyPickingColors), 4, this._polyPickingColors.length / 4);
    }
    createLineVerticesBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._lineVerticesHighBufferMerc);
      this._lineVerticesHighBufferMerc = h8.createArrayBuffer(new Float32Array(this._lineVerticesHighMerc), 2, this._lineVerticesHighMerc.length / 2);
      h8.gl.deleteBuffer(this._lineVerticesLowBufferMerc);
      this._lineVerticesLowBufferMerc = h8.createArrayBuffer(new Float32Array(this._lineVerticesLowMerc), 2, this._lineVerticesLowMerc.length / 2);
    }
    createLineIndexesBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._lineIndexesBuffer);
      this._lineIndexesBuffer = h8.createElementArrayBuffer(new Uint32Array(this._lineIndexes), 1, this._lineIndexes.length);
    }
    createLineOrdersBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._lineOrdersBuffer);
      this._lineOrdersBuffer = h8.createArrayBuffer(new Float32Array(this._lineOrders), 1, this._lineOrders.length / 2);
    }
    createLineColorsBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._lineColorsBuffer);
      this._lineColorsBuffer = h8.createArrayBuffer(new Float32Array(this._lineColors), 4, this._lineColors.length / 4);
    }
    createLinePickingColorsBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._linePickingColorsBuffer);
      this._linePickingColorsBuffer = h8.createArrayBuffer(new Float32Array(this._linePickingColors), 4, this._linePickingColors.length / 4);
    }
    createLineThicknessBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._lineThicknessBuffer);
      this._lineThicknessBuffer = h8.createArrayBuffer(new Float32Array(this._lineThickness), 1, this._lineThickness.length);
    }
    createLineStrokesBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._lineStrokesBuffer);
      this._lineStrokesBuffer = h8.createArrayBuffer(new Float32Array(this._lineStrokes), 1, this._lineStrokes.length);
    }
    createLineStrokeColorsBuffer() {
      let h8 = this._handler;
      h8.gl.deleteBuffer(this._lineStrokeColorsBuffer);
      this._lineStrokeColorsBuffer = h8.createArrayBuffer(new Float32Array(this._lineStrokeColors), 4, this._lineStrokeColors.length / 4);
    }
  };
  GeometryHandler.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/QueueArray.js
  var QueueArray = class {
    constructor(size = 2048) {
      this._size = size;
      this._array = new Array(this._size);
      this._popIndex = Math.floor(this._size * 0.5);
      this._shiftIndex = this._popIndex;
      this.length = 0;
    }
    reset() {
      this._popIndex = Math.floor(this._size * 0.5);
      this._shiftIndex = this._popIndex;
      this.length = 0;
    }
    clear() {
      this._array.length = 0;
      this._array = new Array(this._size);
      this._popIndex = Math.floor(this._size * 0.5);
      this._shiftIndex = this._popIndex;
      this.length = 0;
    }
    push(data) {
      this.length++;
      this._array[this._popIndex++] = data;
    }
    pop() {
      if (this.length) {
        this.length--;
        let res = this._array[--this._popIndex];
        this._array[this._popIndex] = null;
        if (!this._array[this._popIndex - 1]) {
          this._popIndex = Math.floor(this._size * 0.5);
          this._shiftIndex = this._popIndex;
        }
        return res;
      }
      return void 0;
    }
    unshift(data) {
      this.length++;
      this._array[--this._shiftIndex] = data;
    }
    shift() {
      if (this.length) {
        this.length--;
        let res = this._array[this._shiftIndex];
        this._array[this._shiftIndex++] = null;
        if (!this._array[this._shiftIndex]) {
          this._popIndex = Math.floor(this._size * 0.5);
          this._shiftIndex = this._popIndex;
        }
        return res;
      }
      return void 0;
    }
    forEach(callback) {
      for (let i9 = this._shiftIndex; i9 < this._popIndex; i9++) {
        callback(this._array[i9]);
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/layer/Vector.js
  function _entitiesConstructor(entities) {
    let res = [];
    for (let i9 = 0; i9 < entities.length; i9++) {
      let ei = entities[i9];
      if (ei.instanceName === "Entity") {
        res.push(ei);
      } else {
        res.push(new Entity(ei));
      }
    }
    return res;
  }
  var Vector = class extends Layer {
    constructor(name, options2 = {}) {
      super(name, options2);
      this.events = this.events.registerNames(VECTOR_EVENTS);
      this.isVector = true;
      this._hasImageryTiles = false;
      this.scaleByDistance = options2.scaleByDistance || [MAX32, MAX32, MAX32];
      this.pickingScale = options2.pickingScale || 1;
      this.async = options2.async !== void 0 ? options2.async : true;
      this.clampToGround = options2.clampToGround || false;
      this.relativeToGround = options2.relativeToGround || false;
      this._nodeCapacity = options2.nodeCapacity || 30;
      this._entities = _entitiesConstructor(options2.entities || []);
      this._labelMaxLetters = options2.labelMaxLetters || 24;
      this._stripEntityCollection = new EntityCollection({
        pickingEnabled: this.pickingEnabled
      });
      this._bindEventsDefault(this._stripEntityCollection);
      this._polylineEntityCollection = new EntityCollection({
        pickingEnabled: this.pickingEnabled
      });
      this._bindEventsDefault(this._polylineEntityCollection);
      this._geoObjectEntityCollection = new EntityCollection({
        pickingEnabled: this.pickingEnabled
      });
      this._bindEventsDefault(this._geoObjectEntityCollection);
      this._geometryHandler = new GeometryHandler(this);
      this._entityCollectionsTree = null;
      this._entityCollectionsTreeNorth = null;
      this._entityCollectionsTreeSouth = null;
      this._renderingNodes = {};
      this._renderingNodesNorth = {};
      this._renderingNodesSouth = {};
      this._counter = 0;
      this._deferredEntitiesPendingQueue = new QueueArray();
      this._pendingsQueue = [];
      this.setEntities(this._entities);
      this.polygonOffsetUnits = options2.polygonOffsetUnits != void 0 ? options2.polygonOffsetUnits : 0;
      this.pickingEnabled = this._pickingEnabled;
      this._secondPASS = [];
    }
    get labelMaxLetters() {
      return this._labelMaxLetters;
    }
    get instanceName() {
      return "Vector";
    }
    _bindPicking() {
      this._pickingColor.clear();
    }
    /**
     * Adds layer to the planet.
     * @public
     * @param {Planet} planet - Planet scene object.
     * @returns {Vector} -
     */
    addTo(planet) {
      if (!this._planet) {
        this._assignPlanet(planet);
        this._geometryHandler.assignHandler(planet.renderer.handler);
        this._polylineEntityCollection.addTo(planet, true);
        this._stripEntityCollection.addTo(planet, true);
        this._geoObjectEntityCollection.addTo(planet, true);
        this.setEntities(this._entities);
      }
    }
    remove() {
      super.remove();
      this._polylineEntityCollection.remove();
      this._stripEntityCollection.remove();
      this._geoObjectEntityCollection.remove();
      return this;
    }
    /**
     * Returns stored entities.
     * @public
     * @returns {Array.<Entity>} -
     */
    getEntities() {
      return [].concat(this._entities);
    }
    //_fitExtent(entity) {
    //    var ee = entity.getExtent(),
    //        e = this._extent,
    //        maxLon = -180, maxLat = -90,
    //        minLon = 180, minLat = 90;
    //    if (this._entities.length !== 0) {
    //        maxLon = e.southWest.lon;
    //        minLon = e.northEast.lon;
    //        maxLat = e.northEast.lat;
    //        minLat = e.southWest.lat;
    //    }
    //    if (ee.southWest.lon < minLon) {
    //        e.southWest.lon = ee.southWest.lon;
    //    }
    //    if (ee.southWest.lat < minLat) {
    //        e.southWest.lat = ee.southWest.lat;
    //    }
    //    if (ee.northEast.lon > maxLon) {
    //        e.northEast.lon = ee.northEast.lon;
    //    }
    //    if (ee.northEast.lat > maxLat) {
    //        e.northEast.lat = ee.northEast.lat;
    //    }
    //    this.setExtent(this._extent);
    //}
    /**
     * Adds entity to the layer.
     * @public
     * @param {Entity} entity - Entity.
     * @param {boolean} [rightNow=false] - Entity insertion option. False is default.
     * @returns {Vector} - Returns this layer.
     */
    add(entity, rightNow = false) {
      if (!(entity._layer || entity._entityCollection)) {
        entity._layer = this;
        entity._layerIndex = this._entities.length;
        this._entities.push(entity);
        this._proceedEntity(entity, rightNow);
      }
      return this;
    }
    /**
     * Adds entity to the layer in the index position.
     * @public
     * @param {Entity} entity - Entity.
     * @param {Number} index - Index position.
     * @param {boolean} [rightNow] - Entity insertion option. False is default.
     * @returns {Vector} - Returns this layer.
     */
    insert(entity, index, rightNow = false) {
      if (!(entity._layer || entity._entityCollection)) {
        entity._layer = this;
        entity._layerIndex = index;
        this._entities.splice(index, 0, entity);
        for (let i9 = index + 1, len = this._entities.length; i9 < len; i9++) {
          this._entities[i9]._layerIndex = i9;
        }
        this._proceedEntity(entity, rightNow);
      }
      return this;
    }
    _proceedEntity(entity, rightNow = false) {
      let temp = this._hasImageryTiles;
      if (entity.strip) {
        this._stripEntityCollection.add(entity);
      }
      if (entity.polyline || entity.ray) {
        this._polylineEntityCollection.add(entity);
      }
      if (entity.geoObject) {
        this._geoObjectEntityCollection.add(entity);
      }
      if (entity.geometry) {
        this._hasImageryTiles = true;
        if (this._planet) {
          this._planet.renderer.assignPickingColor(entity);
          this._geometryHandler.add(entity.geometry);
        }
      }
      if (entity.billboard || entity.label || entity.geoObject) {
        if (this._planet) {
          if (entity._cartesian.isZero() && !entity._lonLat.isZero()) {
            entity._setCartesian3vSilent(this._planet.ellipsoid.lonLatToCartesian(entity._lonLat));
          } else {
            entity._lonLat = this._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
          }
          if (entity._lonLat.lat > MAX_LAT) {
            this._entityCollectionsTreeNorth.__setLonLat__(entity);
            this._entityCollectionsTreeNorth.insertEntity(entity, rightNow);
          } else if (entity._lonLat.lat < MIN_LAT) {
            this._entityCollectionsTreeSouth.__setLonLat__(entity);
            this._entityCollectionsTreeSouth.insertEntity(entity, rightNow);
          } else {
            this._entityCollectionsTree.__setLonLat__(entity);
            this._entityCollectionsTree.insertEntity(entity, rightNow);
          }
        }
      }
      if (this._planet && this._hasImageryTiles !== temp) {
        this._planet.updateVisibleLayers();
      }
      this.events.dispatch(this.events.entityadd, entity);
    }
    /**
     * Adds entity array to the layer.
     * @public
     * @param {Array.<Entity>} entities - Entities array.
     * @param {boolean} [rightNow=false] - Entity insertion option. False is default.
     * @returns {Vector} - Returns this layer.
     */
    addEntities(entities, rightNow = false) {
      let i9 = entities.length;
      while (i9--) {
        this.add(entities[i9], rightNow);
      }
      return this;
    }
    /**
     * Remove entity from layer.
     * TODO: memory leaks.
     * @public
     * @param {Entity} entity - Entity to remove.
     * @returns {Vector} - Returns this layer.
     */
    removeEntity(entity) {
      if (entity._layer && this.isEqual(entity._layer)) {
        this._entities.splice(entity._layerIndex, 1);
        this._reindexEntitiesArray(entity._layerIndex);
        entity._layer = null;
        entity._layerIndex = -1;
        if (entity._entityCollection) {
          entity._entityCollection._removeEntitySilent(entity);
          let node = entity._nodePtr;
          while (node) {
            node.count--;
            node = node.parentNode;
          }
          if (entity._nodePtr && entity._nodePtr.count === 0 && entity._nodePtr.deferredEntities.length === 0) {
            entity._nodePtr.entityCollection = null;
          }
        } else if (entity._nodePtr && entity._nodePtr.deferredEntities.length) {
          let defEntities = entity._nodePtr.deferredEntities;
          let j2 = defEntities.length;
          while (j2--) {
            if (defEntities[j2].id === entity.id) {
              defEntities.splice(j2, 1);
              let node = entity._nodePtr;
              while (node) {
                node.count--;
                node = node.parentNode;
              }
              break;
            }
          }
        }
        if (entity.geometry) {
          if (this._planet) {
            this._geometryHandler.remove(entity.geometry);
            this._planet.renderer.clearPickingColor(entity);
          }
        }
        entity._nodePtr = void 0;
        this.events.dispatch(this.events.entityremove, entity);
      }
      return this;
    }
    /**
     * Set layer picking events active.
     * @public
     * @param {boolean} picking - Picking enable flag.
     */
    set pickingEnabled(picking) {
      this._pickingEnabled = picking;
      this._stripEntityCollection.setPickingEnabled(picking);
      this._polylineEntityCollection.setPickingEnabled(picking);
      this._geoObjectEntityCollection.setPickingEnabled(picking);
      this._entityCollectionsTree && this._entityCollectionsTree.traverseTree((node) => {
        node.entityCollection.setPickingEnabled(picking);
      });
      this._entityCollectionsTreeNorth && this._entityCollectionsTreeNorth.traverseTree((node) => {
        node.entityCollection.setPickingEnabled(picking);
      });
      this._entityCollectionsTreeSouth && this._entityCollectionsTreeSouth.traverseTree((node) => {
        node.entityCollection.setPickingEnabled(picking);
      });
    }
    /**
     * Refresh collected entities indexes from startIndex entities collection array position.
     * @protected
     * @param {number} startIndex - Entity array index.
     */
    _reindexEntitiesArray(startIndex) {
      const e9 = this._entities;
      for (let i9 = startIndex; i9 < e9.length; i9++) {
        e9[i9]._layerIndex = i9;
      }
    }
    /**
     * Removes entities from layer.
     * @public
     * @param {Array.<Entity>} entities - Entity array.
     * @returns {Vector} - Returns this layer.
     */
    removeEntities(entities) {
      let i9 = entities.length;
      while (i9--) {
        this.removeEntity(entities[i9]);
      }
      return this;
    }
    // public setScaleByDistance(near, far, farInvisible) {
    //     this.scaleByDistance[0] = near;
    //     this.scaleByDistance[1] = far;
    //     this.scaleByDistance[2] = farInvisible || math.MAX32;
    // }
    /**
     * TODO: Clear the layer.
     * @public
     */
    clear() {
      let temp = new Array(this._entities.length);
      for (let i10 = 0; i10 < temp.length; i10++) {
        temp[i10] = this._entities[i10];
      }
      let i9 = this._entities.length;
      while (i9--) {
        this._entities[i9].remove();
      }
      this._entities.length = 0;
      this._entities = [];
      for (let i10 = 0; i10 < temp.length; i10++) {
        this._entities[i10] = temp[i10];
      }
      this._entityCollectionsTree = null;
      this._entityCollectionsTreeNorth = null;
      this._entityCollectionsTreeSouth = null;
    }
    /**
     * Safety entities loop.
     * @public
     * @param {(entity: Entity, index?: number) => void} callback - Entity callback.
     */
    each(callback) {
      let e9 = this._entities;
      let i9 = e9.length;
      while (i9--) {
        callback(e9[i9], i9);
      }
    }
    /**
     * Removes current entities from layer and adds new entities.
     * @public
     * @param {Array.<Entity>} entities - New entity array.
     * @returns {Vector} - Returns layer instance.
     */
    setEntities(entities) {
      let temp = new Array(entities.length);
      for (let i9 = 0, len = entities.length; i9 < len; i9++) {
        temp[i9] = entities[i9];
      }
      this.clear();
      this._entities = new Array(temp.length);
      let entitiesForTree = [];
      for (let i9 = 0; i9 < temp.length; i9++) {
        let ei = temp[i9];
        ei._layer = this;
        ei._layerIndex = i9;
        if (ei.strip) {
          this._stripEntityCollection.add(ei);
        } else if (ei.polyline || ei.ray) {
          this._polylineEntityCollection.add(ei);
        } else if (ei.geoObject) {
          this._geoObjectEntityCollection.add(ei);
        } else if (ei.billboard || ei.label) {
          entitiesForTree.push(ei);
        }
        if (ei.geometry) {
          this._hasImageryTiles = true;
          if (this._planet) {
            this._planet.renderer.assignPickingColor(ei);
            this._geometryHandler.add(ei.geometry);
          }
        }
        this._entities[i9] = ei;
      }
      this._createEntityCollectionsTree(entitiesForTree);
      return this;
    }
    /**
     * @todo: replace to a strategy node collecting algorithm
     */
    _createEntityCollectionsTree(entitiesForTree) {
      if (this._planet) {
        this._entityCollectionsTree = new EntityCollectionNode(this, NW, null, Extent.createFromArray([-2003750834e-2, -2003750834e-2, 2003750834e-2, 2003750834e-2]), this._planet, 0);
        this._entityCollectionsTreeNorth = new EntityCollectionNodeWGS84(this, NW, null, Extent.createFromArray([-180, MAX_LAT, 180, 90]), this._planet, 0);
        this._entityCollectionsTreeSouth = new EntityCollectionNodeWGS84(this, NW, null, Extent.createFromArray([-180, -90, 180, MIN_LAT]), this._planet, 0);
        for (let i9 = 0, len = entitiesForTree.length; i9 < len; i9++) {
          let entity = entitiesForTree[i9];
          if (entity._lonLat.lat > MAX_LAT) {
            this._entityCollectionsTreeNorth.__setLonLat__(entity);
          } else if (entity._lonLat.lat < MIN_LAT) {
            this._entityCollectionsTreeSouth.__setLonLat__(entity);
          } else {
            this._entityCollectionsTree.__setLonLat__(entity);
          }
        }
        this._entityCollectionsTree.buildTree(entitiesForTree);
        this._entityCollectionsTreeNorth.buildTree(entitiesForTree);
        this._entityCollectionsTreeSouth.buildTree(entitiesForTree);
      }
    }
    /**
     * @todo (refactoring) could be used in somethig like bindEntityCollectionQuad(...)
     * @param entityCollection
     */
    _bindEventsDefault(entityCollection) {
      let ve = this.events;
      entityCollection.events.on("mousemove", (e9) => {
        ve.dispatch(ve.mousemove, e9);
      });
      entityCollection.events.on("mouseenter", (e9) => {
        ve.dispatch(ve.mouseenter, e9);
      });
      entityCollection.events.on("mouseleave", (e9) => {
        ve.dispatch(ve.mouseleave, e9);
      });
      entityCollection.events.on("lclick", (e9) => {
        ve.dispatch(ve.lclick, e9);
      });
      entityCollection.events.on("rclick", (e9) => {
        ve.dispatch(ve.rclick, e9);
      });
      entityCollection.events.on("mclick", (e9) => {
        ve.dispatch(ve.mclick, e9);
      });
      entityCollection.events.on("ldblclick", (e9) => {
        ve.dispatch(ve.ldblclick, e9);
      });
      entityCollection.events.on("rdblclick", (e9) => {
        ve.dispatch(ve.rdblclick, e9);
      });
      entityCollection.events.on("mdblclick", (e9) => {
        ve.dispatch(ve.mdblclick, e9);
      });
      entityCollection.events.on("lup", (e9) => {
        ve.dispatch(ve.lup, e9);
      });
      entityCollection.events.on("rup", (e9) => {
        ve.dispatch(ve.rup, e9);
      });
      entityCollection.events.on("mup", (e9) => {
        ve.dispatch(ve.mup, e9);
      });
      entityCollection.events.on("ldown", (e9) => {
        ve.dispatch(ve.ldown, e9);
      });
      entityCollection.events.on("rdown", (e9) => {
        ve.dispatch(ve.rdown, e9);
      });
      entityCollection.events.on("mdown", (e9) => {
        ve.dispatch(ve.mdown, e9);
      });
      entityCollection.events.on("lhold", (e9) => {
        ve.dispatch(ve.lhold, e9);
      });
      entityCollection.events.on("rhold", (e9) => {
        ve.dispatch(ve.rhold, e9);
      });
      entityCollection.events.on("mhold", (e9) => {
        ve.dispatch(ve.mhold, e9);
      });
      entityCollection.events.on("mousewheel", (e9) => {
        ve.dispatch(ve.mousewheel, e9);
      });
      entityCollection.events.on("touchmove", (e9) => {
        ve.dispatch(ve.touchmove, e9);
      });
      entityCollection.events.on("touchstart", (e9) => {
        ve.dispatch(ve.touchstart, e9);
      });
      entityCollection.events.on("touchend", (e9) => {
        ve.dispatch(ve.touchend, e9);
      });
      entityCollection.events.on("doubletouch", (e9) => {
        ve.dispatch(ve.doubletouch, e9);
      });
      entityCollection.events.on("touchleave", (e9) => {
        ve.dispatch(ve.touchleave, e9);
      });
      entityCollection.events.on("touchenter", (e9) => {
        ve.dispatch(ve.touchenter, e9);
      });
    }
    _collectStripCollectionPASS(outArr) {
      let ec = this._stripEntityCollection;
      ec._fadingOpacity = this._fadingOpacity;
      ec.scaleByDistance = this.scaleByDistance;
      ec.pickingScale = this.pickingScale;
      ec.polygonOffsetUnits = this.polygonOffsetUnits;
      outArr.push(ec);
    }
    _collectPolylineCollectionPASS(outArr) {
      let ec = this._polylineEntityCollection;
      ec._fadingOpacity = this._fadingOpacity;
      ec.scaleByDistance = this.scaleByDistance;
      ec.pickingScale = this.pickingScale;
      ec.polygonOffsetUnits = this.polygonOffsetUnits;
      outArr.push(ec);
      if (this.clampToGround || this.relativeToGround) {
        let rtg = Number(this.relativeToGround);
        const nodes = this._planet._renderedNodes;
        const visibleExtent = this._planet.getViewExtent();
        let e9 = ec._entities;
        let e_i = e9.length;
        let res = new Vec3();
        while (e_i--) {
          let p4 = e9[e_i].polyline;
          if (p4 && visibleExtent.overlaps(p4._extent)) {
            let coords = p4._pathLonLatMerc, c_j = coords.length;
            while (c_j--) {
              let c_j_h = coords[c_j].length;
              while (c_j_h--) {
                let ll = coords[c_j][c_j_h], n_k = nodes.length;
                while (n_k--) {
                  let seg = nodes[n_k].segment;
                  if (seg._extent.isInside(ll)) {
                    let cart = p4._path3v[c_j][c_j_h];
                    seg.getTerrainPoint(cart, ll, res);
                    let alt = rtg && p4.altitude || 0;
                    if (alt) {
                      let n7 = this._planet.ellipsoid.getSurfaceNormal3v(res);
                      p4.setPoint3v(res.addA(n7.scale(alt)), c_j_h, c_j, true);
                    } else {
                      p4.setPoint3v(res, c_j_h, c_j, true);
                    }
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
    _collectGeoObjectCollectionPASS(outArr) {
      let ec = this._geoObjectEntityCollection;
      ec._fadingOpacity = this._fadingOpacity;
      ec.scaleByDistance = this.scaleByDistance;
      ec.pickingScale = this.pickingScale;
      ec.polygonOffsetUnits = this.polygonOffsetUnits;
      outArr.push(ec);
    }
    collectVisibleCollections(outArr) {
      let p4 = this._planet;
      if (this._fading && this._fadingOpacity > 0 || this.minZoom <= p4.maxCurrZoom && this.maxZoom >= p4.maxCurrZoom) {
        this._renderingNodes = {};
        this._renderingNodesNorth = {};
        this._renderingNodesSouth = {};
        this._collectStripCollectionPASS(outArr);
        this._collectPolylineCollectionPASS(outArr);
        this._collectGeoObjectCollectionPASS(outArr);
        this._secondPASS = [];
        this._entityCollectionsTree && this._entityCollectionsTree.collectRenderCollectionsPASS1(p4._visibleNodes, outArr);
        let i9 = this._secondPASS.length;
        while (i9--) {
          this._secondPASS[i9].collectRenderCollectionsPASS2(p4._visibleNodes, outArr, this._secondPASS[i9].nodeId);
        }
        this._secondPASS = [];
        this._entityCollectionsTreeNorth && this._entityCollectionsTreeNorth.collectRenderCollectionsPASS1(p4._visibleNodesNorth, outArr);
        i9 = this._secondPASS.length;
        while (i9--) {
          this._secondPASS[i9].collectRenderCollectionsPASS2(p4._visibleNodesNorth, outArr, this._secondPASS[i9].nodeId);
        }
        this._secondPASS = [];
        this._entityCollectionsTreeSouth && this._entityCollectionsTreeSouth.collectRenderCollectionsPASS1(p4._visibleNodesSouth, outArr);
        i9 = this._secondPASS.length;
        while (i9--) {
          this._secondPASS[i9].collectRenderCollectionsPASS2(p4._visibleNodesSouth, outArr, this._secondPASS[i9].nodeId);
        }
      }
    }
    _queueDeferredNode(node) {
      if (this._visibility) {
        node._inTheQueue = true;
        if (this._counter >= 1) {
          this._deferredEntitiesPendingQueue.push(node);
        } else {
          this._execDeferredNode(node);
        }
      }
    }
    _execDeferredNode(node) {
      this._counter++;
      setTimeout(() => {
        node.applyCollection();
        this._counter--;
        if (this._deferredEntitiesPendingQueue.length && this._counter < 1) {
          while (this._deferredEntitiesPendingQueue.length) {
            let n7 = this._deferredEntitiesPendingQueue.pop();
            n7._inTheQueue = false;
            if (n7.isVisible()) {
              this._execDeferredNode(n7);
              return;
            }
          }
        }
      }, 0);
    }
    /**
     * Start to load tile material.
     * @public
     * @virtual
     * @param {Material} material - Current material.
     */
    loadMaterial(material) {
      const seg = material.segment;
      if (this._isBaseLayer) {
        material.texture = seg._isNorth ? seg.planet.solidTextureOne : seg.planet.solidTextureTwo;
      } else {
        material.texture = seg.planet.transparentTexture;
      }
      if (this._planet.layerLock.isFree()) {
        material.isReady = false;
        material.isLoading = true;
        this._planet._vectorTileCreator.add(material);
      }
    }
    /**
     * Abort exact material loading.
     * @public
     * @override
     * @param {Material} material - Segment material.
     */
    abortMaterialLoading(material) {
      material.isLoading = false;
      material.isReady = false;
    }
    applyMaterial(material, isForced = false) {
      if (material.isReady) {
        return [0, 0, 1, 1];
      } else {
        !material.isLoading && this.loadMaterial(material);
        const segment = material.segment;
        let pn = segment.node, notEmpty = false;
        let mId = this.__id;
        let psegm = material;
        while (pn.parentNode) {
          if (psegm && psegm.isReady) {
            notEmpty = true;
            break;
          }
          pn = pn.parentNode;
          psegm = pn.segment.materials[mId];
        }
        if (notEmpty) {
          material.appliedNodeId = pn.nodeId;
          material.texture = psegm.texture;
          material.pickingMask = psegm.pickingMask;
          const dZ2 = 1 / (2 << segment.tileZoom - pn.segment.tileZoom - 1);
          return [
            segment.tileX * dZ2 - pn.segment.tileX,
            segment.tileY * dZ2 - pn.segment.tileY,
            dZ2,
            dZ2
          ];
        } else {
          if (material.textureExists && material._updateTexture) {
            material.texture = material._updateTexture;
            material.pickingMask = material._updatePickingMask;
          } else {
            material.texture = segment.planet.transparentTexture;
            material.pickingMask = segment.planet.transparentTexture;
          }
          material.pickingReady = true;
          return [0, 0, 1, 1];
        }
      }
    }
    clearMaterial(material) {
      if (material.isReady) {
        const gl = material.segment.handler.gl;
        material.isReady = false;
        material.pickingReady = false;
        let t9 = material.texture;
        material.texture = null;
        t9 && !t9.default && gl.deleteTexture(t9);
        t9 = material.pickingMask;
        material.pickingMask = null;
        t9 && !t9.default && gl.deleteTexture(t9);
        t9 = material._updateTexture;
        material._updateTexture = null;
        t9 && !t9.default && gl.deleteTexture(t9);
        t9 = material._updatePickingMask;
        material._updatePickingMask = null;
        t9 && !t9.default && gl.deleteTexture(t9);
      }
      this.abortMaterialLoading(material);
      material.isLoading = false;
      material.textureExists = false;
    }
    update() {
      this._geometryHandler.update();
      this.events.dispatch(this.events.draw, this);
    }
  };
  var VECTOR_EVENTS = [
    // /**
    //  * Triggered when entity has moved.
    //  * @event EventsHandler<VectorEventsList>#draw
    //  */
    // "entitymove",
    /**
     * Triggered when layer begin draw.
     * @event EventsHandler<VectorEventsList>#draw
     */
    "draw",
    /**
     * Triggered when new entity added to the layer.
     * @event EventsHandler<VectorEventsList>#entityadd
     */
    "entityadd",
    /**
     * Triggered when entity removes from the collection.
     * @event EventsHandler<VectorEventsList>#entityremove
     */
    "entityremove"
  ];

  // frontend/node_modules/@openglobus/og/lib/js/control/drawing/PolygonDrawingScene.js
  var POLYGONDRAWINGSCENE_EVENTS = ["change", "startpoint"];
  var POINTER_OBJ3D = Object3d.createCylinder(1, 1, 2, 20, 1, true, false, 0, -0.5, 0);
  var NUM_SEGMENTS = 200;
  var OUTLINE_ALT = 0.3;
  var COORDINATES_COLOR = "rgb(350, 350, 0)";
  var CENTER_COLOR = "rgb(0, 350, 50)";
  var OUTLINE_COLOR = "rgb(0, 350, 50)";
  var OUTLINE_THICKNESS = 3.5;
  var CORNER_OPTIONS = {
    scale: 0.5,
    instanced: true,
    tag: "corners",
    color: COORDINATES_COLOR,
    object3d: POINTER_OBJ3D
  };
  var CENTER_OPTIONS = {
    scale: 0.4,
    instanced: true,
    tag: "centers",
    color: CENTER_COLOR,
    object3d: POINTER_OBJ3D
  };
  var OUTLINE_OPTIONS = {
    thickness: OUTLINE_THICKNESS,
    color: OUTLINE_COLOR
  };
  var PolygonDrawingScene = class extends RenderNode {
    constructor(options2) {
      super(options2.name);
      this._cornerDblClick = false;
      this._onChange = (e9) => {
        if (e9.geometryType === "POLYGON") {
          let coords = this.getCoordinates();
          let entity = new Entity({
            "geometry": {
              "type": e9.geometryType,
              "coordinates": [coords],
              "style": {
                "fillColor": "rgba(0,146,247,0.2)"
              }
            }
          });
          this._geometryLayer.clear();
          this._geometryLayer.add(entity);
        }
      };
      this._onCornerMouseEnter = (e9) => {
        e9.renderer.handler.canvas.style.cursor = "pointer";
        this.hideGhostPointer();
      };
      this._onCornerMouseLeave = (e9) => {
        e9.renderer.handler.canvas.style.cursor = "default";
        this.showGhostPointer();
      };
      this._onCenterMouseEnter = (e9) => {
        e9.renderer.handler.canvas.style.cursor = "pointer";
        this.hideGhostPointer();
      };
      this._onCenterMouseLeave = (e9) => {
        e9.renderer.handler.canvas.style.cursor = "default";
        if (!(this._pickedCenter || this._pickedCorner)) {
          this.showGhostPointer();
        }
      };
      this._onLup = (e9) => {
        this._planet.renderer.controls.mouseNavigation.activate();
        if (this._pickedCorner || this._pickedCenter) {
          this.events.dispatch(this.events.change, this);
          this.setGhostPointerPosition(this._planet.getCartesianFromPixelTerrain(e9));
          this.showGhostPointer();
          this._pickedCorner = null;
          this._pickedCenter = null;
        }
      };
      this._onCornerLdown = (e9) => {
        this._pickedCorner = this._getLdown(e9);
      };
      this._onCenterLdown = (e9) => {
        this._pickedCenter = this._getLdown(e9);
      };
      this._onMouseMove = (e9) => {
        if (this._pickedCenter) {
          this._moveCenterPoint();
        } else if (this._pickedCorner) {
          this._moveCornerPoint(e9.pos);
        } else {
          this.setGhostPointerPosition(this._planet.getCartesianFromPixelTerrain(e9.pos));
        }
      };
      this._onCornerLdblclick = (e9) => {
        this._cornerDblClick = true;
        let coords = this.getCoordinates();
        coords.splice(e9.pickingObject.layerIndex, 1);
        this.setCoordinates(coords);
      };
      this._onMouseDblClick = (e9) => {
        if (this._cornerDblClick) {
          this._cornerDblClick = false;
          return;
        }
        if (!this._showGhostPointer) {
          return;
        }
        let cart = this._planet.getCartesianFromPixelTerrain(e9);
        if (cart) {
          this._addNew(cart);
          if (!this._isStartPoint && this._cornerLayer.getEntities().length > 2) {
            this._isStartPoint = true;
            this.events.dispatch(this.events.startpoint, this);
          }
          this.events.dispatch(this.events.change, this);
        }
      };
      this.events = createEvents(POLYGONDRAWINGSCENE_EVENTS);
      this._planet = null;
      this._initCoordinates = options2.coordinates || [];
      this._pickedCorner = null;
      this._pickedCenter = null;
      this._startPos = null;
      this._startClick = new Vec2();
      this._geometryLayer = new Vector();
      this._cornerLayer = new Vector("corners", {
        pickingScale: 3,
        pickingEnabled: true,
        polygonOffsetUnits: -5,
        relativeToGround: true,
        scaleByDistance: [100, 4e6, 1]
      });
      this._centerLayer = new Vector("centers", {
        pickingScale: 3,
        pickingEnabled: true,
        polygonOffsetUnits: -5,
        relativeToGround: true,
        scaleByDistance: [100, 4e6, 1]
      });
      this._outlineLayer = new Vector("outline", {
        entities: [new Entity({
          polyline: {
            path3v: [],
            isClosed: false,
            ...OUTLINE_OPTIONS
          }
        })],
        pickingEnabled: false,
        polygonOffsetUnits: -5,
        relativeToGround: true
      });
      this._outlineLayer.getEntities()[0].polyline.altitude = OUTLINE_ALT;
      this._ghostCorner = new Entity({
        geoObject: CORNER_OPTIONS
      });
      this._ghostOutlineLayer = new Vector("ghost-pointer", {
        pickingEnabled: false,
        polygonOffsetUnits: -5,
        relativeToGround: true,
        scaleByDistance: [100, 4e6, 1],
        opacity: 0.5
      });
      this._showGhostPointer = false;
      this._isStartPoint = false;
      this._insertCornerIndex = -1;
    }
    get geometryType() {
      return "POLYGON";
    }
    getCoordinates() {
      let corners2 = this._cornerLayer.getEntities();
      if (corners2.length > 0) {
        return corners2.map((c7) => {
          let ll = c7.getLonLat();
          return [ll.lon, ll.lat, ll.height];
        });
      } else {
        return this._initCoordinates;
      }
    }
    bindPlanet(planet) {
      this._planet = planet;
    }
    init() {
      this._initEvents();
      this._initGhostLayerPointer();
      if (this._initCoordinates.length) {
        this.setCoordinates(this._initCoordinates);
      }
      this._planet.addLayer(this._outlineLayer);
      this._planet.addLayer(this._cornerLayer);
      this._planet.addLayer(this._centerLayer);
      this.showGhostPointer();
      this.startNewPoint();
      this._planet.renderer.controls.mouseNavigation.deactivateDoubleClickZoom();
      this._geometryLayer.addTo(this._planet);
      this.events.on("change", this._onChange, this);
    }
    onremove() {
      this._clearEvents();
      this.hideGhostPointer();
      this.stopNewPoint();
      this.clear();
      this._geometryLayer.remove();
    }
    clear() {
      this._geometryLayer.clear();
      let corners2 = this._cornerLayer.getEntities();
      let i9 = corners2.length;
      while (i9--) {
        corners2[i9].remove();
      }
      let centers = this._centerLayer.getEntities();
      i9 = centers.length;
      while (i9--) {
        centers[i9].remove();
      }
      let entities = this._outlineLayer.getEntities();
      i9 = entities.length;
      while (i9--) {
        entities[i9].polyline.clear();
        if (i9 > 0) {
          entities[i9].remove();
        }
      }
      this._clearGhostPointer();
    }
    setCoordinates(coords) {
      this.clear();
      for (let i9 = 0; i9 < coords.length; i9++) {
        let ci = coords[i9];
        let cart = this._planet.ellipsoid.lonLatToCartesian(new LonLat(ci[0], ci[1], ci[2]));
        this._appendCart(cart);
      }
      this.events.dispatch(this.events.change, this);
    }
    stopNewPoint() {
      if (this.renderer) {
        this.renderer.events.off("ldblclick", this._onMouseDblClick);
      }
    }
    startNewPoint() {
      this.renderer.events.on("ldblclick", this._onMouseDblClick, this);
    }
    showGhostPointer() {
      this._showGhostPointer = true;
      this._planet.addLayer(this._ghostOutlineLayer);
      this._insertCornerIndex = this._cornerLayer.getEntities().length;
    }
    hideGhostPointer() {
      this._showGhostPointer = false;
      this._ghostOutlineLayer.remove();
      this._insertCornerIndex = -1;
    }
    setGhostPointerPosition(groundPos) {
      if (groundPos) {
        this._ghostCorner.setCartesian3v(groundPos);
        this._updateGhostOutlinePointer(groundPos);
      }
    }
    _getLdown(e9) {
      this._planet.renderer.controls.mouseNavigation.deactivate();
      this._startClick.set(e9.x, e9.y);
      let coords = e9.pickingObject.getCartesian();
      this._startPos = this._planet.getPixelFromCartesian(coords);
      return e9.pickingObject;
    }
    _initEvents() {
      this._cornerLayer.events.on("ldblclick", this._onCornerLdblclick, this);
      this._cornerLayer.events.on("ldown", this._onCornerLdown, this);
      this._centerLayer.events.on("ldown", this._onCenterLdown, this);
      this.renderer.events.on("lup", this._onLup, this);
      this.renderer.events.on("mousemove", this._onMouseMove, this);
      this._cornerLayer.events.on("mouseenter", this._onCornerMouseEnter, this);
      this._cornerLayer.events.on("mouseleave", this._onCornerMouseLeave, this);
      this._centerLayer.events.on("mouseenter", this._onCenterMouseEnter, this);
      this._centerLayer.events.on("mouseleave", this._onCenterMouseLeave, this);
    }
    _clearEvents() {
      this._cornerLayer.events.off("ldblclick", this._onCornerLdblclick);
      this._cornerLayer.events.off("ldown", this._onCornerLdown);
      this._centerLayer.events.off("ldown", this._onCenterLdown);
      this.renderer.events.off("lup", this._onLup);
      this.renderer.events.off("mousemove", this._onMouseMove);
      this._cornerLayer.events.off("mouseenter", this._onCornerMouseEnter);
      this._cornerLayer.events.off("mouseleave", this._onCornerMouseLeave);
      this._centerLayer.events.off("mouseenter", this._onCenterMouseEnter);
      this._centerLayer.events.off("mouseleave", this._onCenterMouseLeave);
    }
    _drawCorners() {
      let corners2 = this._cornerLayer.getEntities();
      for (let i9 = 0; i9 < corners2.length; i9++) {
        let ai = corners2[i9];
        this._checkTerrainCollision(ai);
      }
    }
    _drawCenters() {
      let centers = this._centerLayer.getEntities();
      for (let i9 = 0; i9 < centers.length; i9++) {
        let ai = centers[i9];
        this._checkTerrainCollision(ai);
      }
    }
    _drawGhostCorner() {
      if (this._showGhostPointer) {
        this._checkTerrainCollision(this._ghostCorner);
      }
    }
    frame() {
      this._drawCorners();
      this._drawCenters();
      this._drawGhostCorner();
    }
    _checkTerrainCollision(entity) {
      let _tempTerrPoint = new Vec3();
      let nodes = this._planet._renderedNodes;
      for (let j2 = 0; j2 < nodes.length; j2++) {
        let seg = nodes[j2].segment;
        if (seg && seg._extentLonLat.isInside(entity.getLonLat())) {
          seg.getEntityTerrainPoint(entity, _tempTerrPoint);
          entity.setCartesian3v(_tempTerrPoint);
          break;
        }
      }
    }
    _moveCenterPoint() {
      let coords = this.getCoordinates(), index = this._pickedCenter.layerIndex + 1, ll = this._pickedCenter.getLonLat();
      let newCorner = [ll.lon, ll.lat, ll.height];
      coords.splice(index, 0, newCorner);
      this.setCoordinates(coords);
      this._pickedCenter = null;
      this._pickedCorner = this._cornerLayer.getEntities()[index];
    }
    _addNew(cart) {
      if (this._insertCornerIndex === -1 || this._cornerLayer.getEntities().length < 2) {
        this._appendCart(cart);
      } else {
        let area2 = this.getCoordinates(), index = this._insertCornerIndex;
        let ll = this._planet.ellipsoid.cartesianToLonLat(cart);
        let newCorner = [ll.lon, ll.lat, ll.height];
        area2.splice(index, 0, newCorner);
        this.clear();
        this.setCoordinates(area2);
      }
    }
    _appendCart(cart) {
      let corners2 = this._cornerLayer.getEntities();
      let segNum = corners2.length - 1;
      let prevCorn = corners2[segNum];
      let corner = new Entity({
        geoObject: CORNER_OPTIONS
      });
      corner.setCartesian3v(cart);
      corner.addTo(this._cornerLayer);
      this._checkTerrainCollision(corner);
      if (prevCorn) {
        let firstCart = corners2[0].getCartesian(), prevCart = prevCorn.getCartesian();
        let vecPrev = corner.getCartesian().sub(prevCart), vecFirst = corner.getCartesian().sub(firstCart);
        let distPrev = vecPrev.length(), distFirst = vecFirst.length();
        vecPrev.normalize();
        vecFirst.normalize();
        let prevPath = [], firstPath = [];
        for (let i9 = 0; i9 <= NUM_SEGMENTS; i9++) {
          let p4 = vecPrev.scaleTo(i9 * distPrev / NUM_SEGMENTS).addA(prevCart);
          prevPath.push(p4);
          let f8 = vecFirst.scaleTo(i9 * distFirst / NUM_SEGMENTS).addA(firstCart);
          firstPath.push(f8);
        }
        this._outlineLayer.getEntities()[0].polyline.setPath3v([firstPath]);
        let entity = new Entity({
          polyline: {
            path3v: [prevPath],
            isClosed: false,
            ...OUTLINE_OPTIONS
          }
        });
        entity.polyline.altitude = OUTLINE_ALT;
        this._outlineLayer.add(entity);
        let centers = this._centerLayer.getEntities();
        let firstCenter = centers[centers.length - 1];
        let prevCenterCart = vecPrev.scaleTo(distPrev * 0.5).addA(prevCart), firstCenterCart = vecFirst.scaleTo(distFirst * 0.5).addA(firstCart);
        let center = new Entity({
          geoObject: CENTER_OPTIONS
        });
        center.setCartesian3v(prevCenterCart);
        center.addTo(this._centerLayer);
        this._checkTerrainCollision(center);
        firstCenter.remove();
        firstCenter.addTo(this._centerLayer);
        firstCenter.setCartesian3v(firstCenterCart);
      } else {
        let center = new Entity({
          geoObject: CENTER_OPTIONS
        });
        center.addTo(this._centerLayer);
      }
    }
    _clearGhostPointer() {
      const g4 = this._ghostOutlineLayer;
      g4.getEntities()[0].polyline.clear();
      g4.getEntities()[1].polyline.clear();
    }
    _moveCornerPoint(e9) {
      let d4 = new Vec2(e9.x, e9.y).sub(this._startClick), p4 = this._startPos.add(d4);
      let groundCoords = this._planet.getCartesianFromPixelTerrain(p4);
      if (groundCoords) {
        this._pickedCorner.setCartesian3v(groundCoords);
        let corners2 = this._cornerLayer.getEntities();
        if (corners2.length) {
          let ind = this._pickedCorner.layerIndex;
          let size = corners2.length;
          let cartPrev = corners2[ind === 0 ? size - 1 : ind - 1].getCartesian(), cartNext = corners2[(ind + 1) % size].getCartesian();
          let vecPrev = this._pickedCorner.getCartesian().sub(cartPrev), vecNext = this._pickedCorner.getCartesian().sub(cartNext);
          let distPrev = vecPrev.length(), distNext = vecNext.length();
          vecPrev.normalize();
          vecNext.normalize();
          let pathPrev = [], pathNext = [];
          for (let i9 = 0; i9 <= NUM_SEGMENTS; i9++) {
            let p5 = vecPrev.scaleTo(i9 * distPrev / NUM_SEGMENTS).addA(cartPrev);
            pathPrev.push(p5);
            let f8 = vecNext.scaleTo(i9 * distNext / NUM_SEGMENTS).addA(cartNext);
            pathNext.push(f8);
          }
          let entities = this._outlineLayer.getEntities();
          let prevPolyline = entities[ind].polyline, nextPolyline = entities[(ind + 1) % size].polyline;
          prevPolyline?.setPath3v([pathPrev]);
          nextPolyline?.setPath3v([pathNext]);
          let centers = this._centerLayer.getEntities();
          let prevCenter = centers[ind === 0 ? size - 1 : ind - 1], nextCenter = centers[ind];
          let prevCenterCart = vecPrev.scaleTo(distPrev * 0.5).addA(cartPrev), nextCenterCart = vecNext.scaleTo(distNext * 0.5).addA(cartNext);
          prevCenter.setCartesian3v(prevCenterCart);
          this._checkTerrainCollision(prevCenter);
          nextCenter.setCartesian3v(nextCenterCart);
          this._checkTerrainCollision(nextCenter);
        }
      }
    }
    _updateGhostOutlinePointer(groundPos) {
      let corners2 = this._cornerLayer.getEntities();
      let size = corners2.length;
      if (size > 0) {
        let ind = 0;
        let minDist = MAX;
        for (let i9 = 0; i9 < size; i9++) {
          let ci = corners2[i9];
          let dist = ci.getCartesian().distance(groundPos);
          if (dist < minDist) {
            minDist = dist;
            ind = i9;
          }
        }
        let cCurr = corners2[ind].getCartesian(), cNext = corners2[(ind + 1) % size].getCartesian(), cPrev = corners2[ind === 0 ? size - 1 : ind - 1].getCartesian();
        let nPrev = cPrev.sub(cCurr).normalize(), nNext = cNext.sub(cCurr).normalize(), nGround = groundPos.sub(cCurr).normalize();
        let midVec = nPrev.add(nNext).normalize();
        let toMid = nGround.cross(midVec), up = nPrev.cross(nNext);
        if (toMid.dot(up) > 0) {
          ind--;
          if (ind < 0) {
            ind = size - 1;
          }
        }
        let temp = new Vec3();
        for (let i9 = 0; i9 < size; i9++) {
          let side = new Line3(corners2[i9].getCartesian(), corners2[(i9 + 1) % size].getCartesian());
          let u4 = side.getNearestDistancePoint(groundPos, temp);
          if (u4) {
            let dist = temp.distance(groundPos);
            if (dist < minDist) {
              minDist = dist;
              ind = i9;
            }
          }
        }
        this._insertCornerIndex = (ind + 1) % size;
        let cartPrev = corners2[ind % size].getCartesian(), cartNext = corners2[(ind + 1) % size].getCartesian();
        let vecPrev = this._ghostCorner.getCartesian().sub(cartPrev), vecNext = this._ghostCorner.getCartesian().sub(cartNext);
        let distPrev = vecPrev.length(), distNext = vecNext.length();
        vecPrev.normalize();
        vecNext.normalize();
        let pathPrev = [], pathNext = [];
        for (let i9 = 0; i9 <= NUM_SEGMENTS; i9++) {
          let p4 = vecPrev.scaleTo(i9 * distPrev / NUM_SEGMENTS).addA(cartPrev);
          pathPrev.push(p4);
          let f8 = vecNext.scaleTo(i9 * distNext / NUM_SEGMENTS).addA(cartNext);
          pathNext.push(f8);
        }
        let entities = this._ghostOutlineLayer.getEntities();
        let prevPolyline = entities[0].polyline, nextPolyline = entities[1].polyline;
        prevPolyline?.setPath3v([pathPrev]);
        nextPolyline?.setPath3v([pathNext]);
      }
    }
    _initGhostLayerPointer() {
      this._ghostOutlineLayer.setEntities([
        new Entity({
          polyline: {
            path3v: [],
            isClosed: false,
            ...OUTLINE_OPTIONS
          }
        }),
        new Entity({
          polyline: {
            path3v: [],
            isClosed: false,
            ...OUTLINE_OPTIONS
          }
        }),
        this._ghostCorner
      ]);
      const g4 = this._ghostOutlineLayer;
      g4.getEntities()[0].polyline.altitude = g4.getEntities()[1].polyline.altitude = OUTLINE_ALT;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/drawing/LineStringDrawingScene.js
  var LineStringDrawingScene = class extends PolygonDrawingScene {
    constructor(props) {
      super(props);
    }
    get geometryType() {
      return "LineString";
    }
    _addNew(cart) {
      this._appendCart(cart);
    }
    _appendCart(cart) {
      let corners2 = this._cornerLayer.getEntities();
      let segNum = corners2.length - 1;
      let prevCorn = corners2[segNum];
      let corner = new Entity({
        geoObject: CORNER_OPTIONS
      });
      corner.setCartesian3v(cart);
      corner.addTo(this._cornerLayer);
      this._checkTerrainCollision(corner);
      if (prevCorn) {
        let prevCart = prevCorn.getCartesian();
        let vecPrev = corner.getCartesian().sub(prevCart);
        let distPrev = vecPrev.length();
        vecPrev.normalize();
        let prevPath = [];
        for (let i9 = 0; i9 <= NUM_SEGMENTS; i9++) {
          let p4 = vecPrev.scaleTo(i9 * distPrev / NUM_SEGMENTS).addA(prevCart);
          prevPath.push(p4);
        }
        let entity = new Entity({
          polyline: {
            path3v: [prevPath],
            isClosed: false,
            ...OUTLINE_OPTIONS
          }
        });
        entity.polyline.altitude = OUTLINE_ALT;
        this._outlineLayer.add(entity);
        let prevCenterCart = vecPrev.scaleTo(distPrev * 0.5).addA(prevCart);
        let center = new Entity({
          geoObject: CENTER_OPTIONS
        });
        center.setCartesian3v(prevCenterCart);
        center.addTo(this._centerLayer);
        this._checkTerrainCollision(center);
      }
    }
    _clearGhostPointer() {
      this._ghostOutlineLayer.getEntities()[0].polyline.clear();
    }
    _moveCorner(indexCurrent, indexPrev, indexCenter) {
      let corners2 = this._cornerLayer.getEntities();
      if (corners2.length == 0)
        return;
      if (corners2.length == 1) {
        indexCurrent = indexPrev = indexCenter = 0;
      }
      let cartCurr = corners2[indexCurrent].getCartesian();
      let vecCurr = this._pickedCorner.getCartesian().sub(cartCurr);
      let distCurr = vecCurr.length();
      vecCurr.normalize();
      let path = [];
      for (let i9 = 0; i9 <= NUM_SEGMENTS; i9++) {
        let p4 = vecCurr.scaleTo(i9 * distCurr / NUM_SEGMENTS).addA(cartCurr);
        path.push(p4);
      }
      let entities = this._outlineLayer.getEntities();
      let prevPolyline = entities[indexPrev].polyline;
      prevPolyline?.setPath3v([path]);
      let centers = this._centerLayer.getEntities();
      let center = centers[indexCenter];
      if (center) {
        let centerCart = vecCurr.scaleTo(distCurr * 0.5).addA(cartCurr);
        center.setCartesian3v(centerCart);
        this._checkTerrainCollision(center);
      }
    }
    _moveCornerPoint(e9) {
      let d4 = new Vec2(e9.x, e9.y).sub(this._startClick), p4 = this._startPos.add(d4);
      let groundCoords = this._planet.getCartesianFromPixelTerrain(p4);
      if (groundCoords) {
        this._pickedCorner.setCartesian3v(groundCoords);
        let corners2 = this._cornerLayer.getEntities();
        if (corners2.length) {
          let ind = this._pickedCorner.layerIndex;
          if (ind === 0) {
            this._moveCorner(ind + 1, ind + 1, ind);
          } else if (ind === corners2.length - 1) {
            this._moveCorner(ind - 1, ind, ind - 1);
          } else {
            this._moveCorner(ind + 1, ind + 1, ind);
            this._moveCorner(ind - 1, ind, ind - 1);
          }
        }
      }
    }
    _updateGhostOutlinePointer(groundPos) {
      let corners2 = this._cornerLayer.getEntities();
      let size = corners2.length;
      if (size > 0) {
        let ind = size - 1;
        this._insertCornerIndex = ind;
        let cartPrev = corners2[ind].getCartesian();
        let vecPrev = this._ghostCorner.getCartesian().sub(cartPrev);
        let distPrev = vecPrev.length();
        vecPrev.normalize();
        let pathPrev = [];
        for (let i9 = 0; i9 <= NUM_SEGMENTS; i9++) {
          let p4 = vecPrev.scaleTo(i9 * distPrev / NUM_SEGMENTS).addA(cartPrev);
          pathPrev.push(p4);
        }
        let entities = this._ghostOutlineLayer.getEntities();
        let prevPolyline = entities[0].polyline;
        prevPolyline.setPath3v([pathPrev]);
      }
    }
    _initGhostLayerPointer() {
      this._ghostOutlineLayer.setEntities([
        new Entity({
          polyline: {
            path3v: [],
            isClosed: false,
            ...OUTLINE_OPTIONS
          }
        }),
        this._ghostCorner
      ]);
      this._ghostOutlineLayer.getEntities()[0].polyline.altitude = OUTLINE_ALT;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/drawing/DrawingControl.js
  var DrawingControl = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._drawingScene = new LineStringDrawingScene({
        name: `drawingScene:${this.__id}`
      });
    }
    activatePolygonDrawing() {
      this.deactivate();
      this._drawingScene = new PolygonDrawingScene({
        name: `polygonDrawingScene:${this.__id}`
      });
      this.activate();
    }
    activateLineStringDrawing() {
      this.deactivate();
      this._drawingScene = new LineStringDrawingScene({
        name: `linestringDrawingScene:${this.__id}`
      });
      this.activate();
    }
    oninit() {
    }
    onactivate() {
      this.planet && this._drawingScene.bindPlanet(this.planet);
      this.renderer && this.renderer.addNode(this._drawingScene);
    }
    ondeactivate() {
      this.renderer && this.renderer.removeNode(this._drawingScene);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/DrawingSwitcher.js
  var ICON_POLYGON_SVG = `<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 24.1.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 1024 1024" style="enable-background:new 0 0 1024 1024;" xml:space="preserve">
<g>
	<path d="M926.03,321.16c-16.02,0-31.11,3.94-44.48,10.79l-263.43-191.4c2.69-8.94,4.18-18.4,4.18-28.2
		c0-54.02-43.95-97.97-97.97-97.97c-54.03,0-97.98,43.95-97.98,97.97c0,9.81,1.49,19.27,4.18,28.21L155.75,340.18
		c-16.22-11.91-36.16-19.03-57.78-19.03C43.95,321.16,0,365.11,0,419.13c0,52.58,41.67,95.5,93.71,97.75l102.63,315.86
		c-24.28,17.85-40.13,46.52-40.13,78.9c0,54.02,43.95,97.98,97.98,97.98c37.54,0,70.18-21.25,86.62-52.34h367.26
		c16.44,31.08,49.08,52.34,86.63,52.34c54.03,0,97.98-43.95,97.98-97.98c0-32.46-15.94-61.21-40.33-79.05l104.11-320.4
		c39.15-12.84,67.54-49.68,67.54-93.07C1024,365.11,980.05,321.16,926.03,321.16z M828.05,911.65c0,8.5-3.3,16.19-8.55,22.09
		c-6.11,6.85-14.9,11.26-24.79,11.26c-13.65,0-25.37-8.26-30.52-20.02c-1.79-4.09-2.82-8.58-2.82-13.33
		c0-18.39,14.95-33.35,33.34-33.35c2.93,0,5.72,0.5,8.43,1.21c13.27,3.49,23.21,14.91,24.59,28.9
		C827.83,909.5,828.05,910.54,828.05,911.65z M790.48,813.89c-45.63,1.96-83.27,35.16-91.87,78.77H350.28
		c-8.62-43.69-46.38-76.93-92.11-78.79L155.59,498.19c24.41-17.84,40.36-46.59,40.36-79.06c0-8.9-1.3-17.49-3.53-25.7L468.57,192.8
		c15.84,11.01,35.05,17.52,55.76,17.52c20.71,0,39.92-6.5,55.76-17.52l256.56,186.4c-5.48,12.21-8.59,25.7-8.59,39.93
		c0,41.02,25.36,76.17,61.21,90.75L790.48,813.89z M254.19,945c-10.11,0-19.07-4.62-25.19-11.75c-5.01-5.84-8.15-13.32-8.15-21.6
		c0-0.91,0.2-1.76,0.27-2.66c1.14-14.18,11.08-25.8,24.43-29.41c2.78-0.75,5.64-1.28,8.65-1.28c18.38,0,33.33,14.96,33.33,33.35
		c0,4.74-1.03,9.24-2.82,13.33C279.55,936.74,267.83,945,254.19,945z M64.88,421.49c-0.06-0.79-0.24-1.55-0.24-2.35
		c0-16.41,11.93-30.01,27.55-32.76c1.89-0.33,3.8-0.58,5.78-0.58c11.94,0,22.35,6.36,28.24,15.81c3.18,5.11,5.11,11.09,5.11,17.53
		c0,15.47-10.63,28.39-24.94,32.14c-2.7,0.71-5.48,1.2-8.4,1.2C80.4,452.47,66.11,438.76,64.88,421.49z M549.41,90.62
		c5.07,5.85,8.25,13.39,8.25,21.72c0,7.32-2.44,14.03-6.45,19.54c-6.07,8.33-15.82,13.81-26.88,13.81
		c-11.07,0-20.83-5.48-26.89-13.81c-4.01-5.51-6.45-12.22-6.45-19.54c0-8.33,3.17-15.86,8.24-21.71
		c6.12-7.07,15.04-11.64,25.1-11.64C534.38,79,543.29,83.57,549.41,90.62z M959.36,419.13c0,11.94-6.36,22.35-15.82,28.24
		c-5.1,3.18-11.07,5.1-17.52,5.1c-6.08,0-11.71-1.76-16.62-4.61c-9.71-5.64-16.33-15.94-16.64-27.89c-0.01-0.29-0.09-0.56-0.09-0.85
		c0-11.75,6.14-22.05,15.36-28c5.2-3.35,11.35-5.35,17.99-5.35C944.41,385.78,959.36,400.75,959.36,419.13z"/>
</g>
</svg>`;
  var ICON_LINESTRING_SVG = `<?xml version="1.0" encoding="utf-8"?><!-- License: MIT. Made by Esri: https://github.com/Esri/calcite-ui-icons -->
    <svg width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 6h.046l-5.25 9h-.944L10 9.455V7H7v2.926L1.862 18H0v3h3v-2.926L8.138 10h1.01L14 15.545V18h3v-3h-.046l5.25-9H24V3h-3zM8 8h1v1H8zM2 20H1v-1h1zm14-3h-1v-1h1zm7-13v1h-1V4z"/></svg>`;
  var ICON_DEFAULT_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M4 0l16 12.279-6.951 1.17 4.325 8.817-3.596 1.734-4.35-8.879-5.428 4.702z"/></svg>`;
  var DrawingSwitcher = class extends Control {
    constructor(options2 = {}) {
      super({
        name: "DrawingSwitcher",
        ...options2
      });
      this.drawingControl = new DrawingControl();
    }
    oninit() {
      this.planet.addControl(this.drawingControl);
      this._createMenu();
    }
    onactivate() {
      this.drawingControl.activate();
    }
    ondeactivate() {
      this.drawingControl.deactivate();
    }
    _createMenu() {
      let defaultBtn = new ToggleButton({
        classList: ["og-map-button", "og-drawing-default_button"],
        icon: ICON_DEFAULT_SVG,
        name: "default",
        isActive: true
      });
      let polyBtn = new ToggleButton({
        classList: ["og-map-button", "og-drawing-polygon_button"],
        icon: ICON_POLYGON_SVG,
        name: "polygon"
      });
      let lineBtn = new ToggleButton({
        classList: ["og-map-button", "og-drawing-linestring_button"],
        icon: ICON_LINESTRING_SVG,
        name: "linestring"
      });
      let buttons = new ButtonGroup({
        buttons: [
          defaultBtn,
          polyBtn,
          lineBtn
        ]
      });
      buttons.events.on("change", (btn) => {
        this.drawingControl.deactivate();
        switch (btn.name) {
          case "polygon":
            this.drawingControl.activatePolygonDrawing();
            break;
          case "linestring":
            this.drawingControl.activateLineStringDrawing();
            break;
        }
      });
      defaultBtn.appendTo(this.renderer.div);
      polyBtn.appendTo(this.renderer.div);
      lineBtn.appendTo(this.renderer.div);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/units.js
  var units_exports = {};
  __export(units_exports, {
    ELL: () => ELL,
    GND: () => GND,
    MSL: () => MSL,
    _tenth: () => _tenth,
    convert: () => convert,
    convertExt: () => convertExt,
    ft: () => ft,
    fts: () => fts,
    h: () => h,
    heightMode: () => heightMode,
    km: () => km,
    kmh: () => kmh,
    m: () => m,
    ms: () => ms,
    s: () => s,
    toString: () => toString
  });
  var ELL = 0;
  var MSL = 1;
  var GND = 2;
  var heightMode = {
    "ell": ELL,
    "msl": MSL,
    "gnd": GND
  };
  var KM_to_M = 1e3;
  var M_to_KM = 1 / KM_to_M;
  var FT_to_M = 0.3048;
  var M_to_FT = 1 / FT_to_M;
  var MS_to_KMH = 3.6;
  var KMH_to_MS = 1 / MS_to_KMH;
  var MS_to_FTS = 3.28084;
  var FT_to_KM = FT_to_M * M_to_KM;
  var KM_to_FT = 1 / FT_to_KM;
  var m = 0;
  var km = 1;
  var ft = 2;
  var s = 3;
  var h = 4;
  var ms = 5;
  var kmh = 6;
  var fts = 7;
  var DEFAULT_NAN = "--";
  var _abbr = ["m", "km", "ft", "s", "h", "m/s", "km/h", "ft/s"];
  var _tenth = [0, 2, 0, 0, 0, 0, 0, 0];
  var _convFn = [];
  _convFn[m] = [];
  _convFn[m][m] = (v4) => v4;
  _convFn[m][km] = (v4) => v4 * M_to_KM;
  _convFn[m][ft] = (v4) => v4 * M_to_FT;
  _convFn[ft] = [];
  _convFn[ft][m] = (v4) => v4 * FT_to_M;
  _convFn[ft][km] = (v4) => v4 * FT_to_KM;
  _convFn[ft][ft] = (v4) => v4;
  _convFn[km] = [];
  _convFn[km][m] = (v4) => v4 * KM_to_M;
  _convFn[km][km] = (v4) => v4;
  _convFn[km][ft] = (v4) => v4 * KM_to_FT;
  _convFn[ms] = [];
  _convFn[ms][ms] = (v4) => v4;
  _convFn[ms][kmh] = (v4) => v4 * MS_to_KMH;
  _convFn[ms][fts] = (v4) => v4 * MS_to_FTS;
  _convFn[kmh] = [];
  _convFn[kmh][ms] = (v4) => v4 * KMH_to_MS;
  _convFn[kmh][kmh] = (v4) => v4;
  function convert(from, to, val) {
    return _convFn[from][to](val);
  }
  function convertExt(isNotNaN, unitFrom, unitTo, val, fixed) {
    if (isNotNaN) {
      return convert(unitFrom, unitTo, val).toFixed(fixed || _tenth[unitTo]);
    }
    return DEFAULT_NAN;
  }
  function toString(u4) {
    return _abbr[u4];
  }

  // frontend/node_modules/@openglobus/og/lib/js/control/EarthCoordinates.js
  var DECIMAL_TEMPLATE = `<div class="og-lat-side"></div><div class="og-lat-val"></div>
    <div class="og-lon-side"></div><div class="og-lon-val"></div>
    <div class="og-height"></div>
    <div class="og-units-height"></div>`;
  var DEGREE_TEMPLATE = `<div class="og-lat-side"></div><div class="og-lat-val"></div>
    <div class="og-lon-side"></div><div class="og-lon-val"></div>
    <div class="og-height"></div>
    <div class="og-units-height"></div>`;
  var CENTER_SVG = '<svg width="12" height="12"><g><path stroke-width="1" stroke-opacity="1" d="M6 0L6 12M0 6L12 6" stroke="#337ab7"></path></g></svg>';
  var TYPE_HTML = [DECIMAL_TEMPLATE, DEGREE_TEMPLATE];
  var EarthCoordinates = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._type = options2.type || 0;
      this._TYPE_FUNC = [this._SHOW_DECIMAL, this._SHOW_DEGREE];
      this._showFn = null;
      this._el = null;
      this._latSideEl = null;
      this._lonSideEl = null;
      this._latValEl = null;
      this._lonValEl = null;
      this._heightEl = null;
      this._altUnitVal = options2.altitudeUnit || "m";
      this._heightModeVal = options2.heightMode || "ell";
      this._altUnit = units_exports[this._altUnitVal];
      this._heightMode = heightMode[this._heightModeVal];
      this._lonLat = null;
      this._centerMode = options2.centerMode != void 0 ? options2.centerMode : true;
    }
    _SHOW_DECIMAL(ll) {
      if (ll) {
        let lat = ll.lat, lon = ll.lon;
        if (lat >= 0) {
          this._latSideEl.innerHTML = "N";
        } else {
          this._latSideEl.innerHTML = "S";
        }
        if (lon >= 0) {
          this._lonSideEl.innerHTML = "E";
        } else {
          this._lonSideEl.innerHTML = "W";
        }
        this._latValEl.innerHTML = Math.abs(lat).toFixed(7) + "\xB0";
        this._lonValEl.innerHTML = Math.abs(lon).toFixed(7) + "\xB0";
      }
    }
    _SHOW_DEGREE(ll) {
      if (ll) {
        let lat = ll.lat, lon = ll.lon;
        if (lat >= 0) {
          this._latSideEl.innerHTML = "N";
        } else {
          this._latSideEl.innerHTML = "S";
        }
        if (lon >= 0) {
          this._lonSideEl.innerHTML = "E";
        } else {
          this._lonSideEl.innerHTML = "W";
        }
        let t9 = 0;
        let deg = lat < 0 ? Math.ceil(lat) : Math.floor(lat);
        let min = Math.floor(t9 = Math.abs(lat - deg) * 60);
        let sec = Math.floor((t9 - min) * 6e3) / 100;
        this._latValEl.innerHTML = Math.abs(deg) + "\xB0" + min + "'" + sec.toFixed(0) + '"';
        deg = lon < 0 ? Math.ceil(lon) : Math.floor(lon);
        min = Math.floor(t9 = Math.abs(lon - deg) * 60);
        sec = Math.floor((t9 - min) * 6e3) / 100;
        this._lonValEl.innerHTML = Math.abs(deg) + "\xB0" + min + "'" + sec.toFixed(0) + '"';
      }
    }
    _createCenterEl() {
      let el = document.createElement("div");
      el.className = "og-center-icon";
      el.innerHTML = CENTER_SVG;
      return el;
    }
    _updateUnits() {
      this._heightMode = heightMode[this._heightModeVal];
      this._altUnit = units_exports[this._altUnitVal];
      this._el.querySelector(".og-units-height").innerHTML = toString(this._altUnit);
      this._showHeight();
    }
    _refreshCoordinates() {
      if (this._type >= this._TYPE_FUNC.length) {
        this._type = 0;
      }
      let el = this._el;
      el.innerHTML = TYPE_HTML[this._type];
      this._latSideEl = el.querySelector(".og-lat-side");
      this._lonSideEl = el.querySelector(".og-lon-side");
      this._latValEl = el.querySelector(".og-lat-val");
      this._lonValEl = el.querySelector(".og-lon-val");
      this._heightEl = el.querySelector(".og-height");
      this._showFn = this._TYPE_FUNC[this._type];
      this._showFn(this._lonLat);
    }
    oninit() {
      this._el = document.createElement("div");
      this._el.classList.add("og-coordinates");
      this.renderer.div.appendChild(this._el);
      this._el.addEventListener("click", () => {
        this._type++;
        this._refreshCoordinates();
        this._updateUnits();
        this._showHeight();
      });
      if (this._centerMode) {
        this.renderer.div.appendChild(this._createCenterEl());
        this.planet.camera.events.on("moveend", this._grabCoordinates, this);
        this.planet.camera.events.on("moveend", throttle(() => this._showHeight(), 400, true), this);
      } else {
        this.renderer.events.on("mousemove", this._grabCoordinates, this);
        this.renderer.events.on("mousestop", throttle(() => this._showHeight(), 400, true), this);
      }
      this._refreshCoordinates();
      this._updateUnits();
    }
    _grabCoordinates(e9) {
      let px = e9.pos;
      let scrPx;
      let r8 = this.renderer;
      if (this._centerMode) {
        scrPx = r8.handler.getCenter();
      } else {
        scrPx = px;
      }
      this._lonLat = this.planet.getLonLatFromPixelTerrain(scrPx) || null;
      this._showFn(this._lonLat);
    }
    async _showHeight() {
      if (this._lonLat && this.planet) {
        let alt = 0;
        this._heightEl.style.opacity = "0.7";
        if (this._heightMode === heightMode.ell) {
          alt = await this.planet.getHeightAboveELL(this._lonLat);
          alt = Number(convertExt(true, m, this._altUnit, alt));
        } else if (this._heightMode === heightMode.msl) {
          alt = await this.planet.getHeightDefault(this._lonLat);
          alt = Number(convertExt(true, m, this._altUnit, alt));
        }
        this._heightEl.style.opacity = "1.0";
        this._heightEl.innerHTML = alt.toString();
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/EarthNavigation.js
  var TouchExt = class {
    constructor() {
      this.x = 0;
      this.y = 0;
      this.prev_x = 0;
      this.prev_y = 0;
      this.grabbedPoint = new Vec3();
      this.grabbedSpheroid = new Sphere();
    }
    dX() {
      return this.x - this.prev_x;
    }
    dY() {
      return this.y - this.prev_y;
    }
  };
  var EarthNavigation = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this.grabbedPoint = new Vec3();
      this.grabbedDir = new Vec3();
      this.inertia = 7e-3;
      this.grabbedSpheroid = new Sphere();
      this.planet = null;
      this._vRot = new Quat();
      this._hRot = new Quat();
      this._a = 0;
      this.scaleRot = 0;
      this.currState = 0;
      this.positionState = [
        { h: 17119745303455353e-9, max: 0.98, min: -0.98 },
        { h: 6866011, max: 0.98, min: -0.98 },
        { h: 3e6, max: 0.98, min: -0.98 },
        { h: 1e6, max: 0.98, min: -0.98 },
        { h: 5e5, max: 0.98, min: -0.98 }
      ];
      this.touches = [new TouchExt(), new TouchExt()];
    }
    switchZoomState(wheelDelta) {
      this.stopRotation();
      if (wheelDelta > 0) {
        this.currState++;
      } else {
        this.currState--;
      }
      if (this.currState <= 0)
        this.currState = 0;
      if (this.currState >= this.positionState.length) {
        this.currState = this.positionState.length - 1;
      }
      this.planet.stopFlying();
      const ll = this.planet.camera._lonLat;
      this.planet.flyLonLat(new LonLat(ll.lon, ll.lat, this.positionState[this.currState].h));
    }
    onMouseWheel(event) {
      this.switchZoomState(event.wheelDelta);
    }
    oninit() {
      this.activate();
    }
    onactivate() {
      let r8 = this.renderer;
      r8.events.on("mousewheel", this.onMouseWheel, this);
      r8.events.on("lhold", this.onMouseLeftButtonDown, this);
      r8.events.on("ldown", this.onMouseLeftButtonClick, this);
      r8.events.on("lup", this.onMouseLeftButtonUp, this);
      r8.events.on("touchstart", this.onTouchStart, this);
      r8.events.on("touchend", this.onTouchEnd, this);
      r8.events.on("touchmove", this.onTouchMove, this);
      r8.events.on("draw", this.onDraw, this);
    }
    onTouchStart(e9) {
      if (e9.sys.touches.length == 1) {
        const t9 = this.touches[0];
        t9.x = e9.sys.touches.item(0).pageX - e9.sys.offsetLeft;
        t9.y = e9.sys.touches.item(0).pageY - e9.sys.offsetTop;
        t9.prev_x = e9.sys.touches.item(0).pageX - e9.sys.offsetLeft;
        t9.prev_y = e9.sys.touches.item(0).pageY - e9.sys.offsetTop;
        t9.grabbedPoint = this.planet.getCartesianFromPixelTerrain(new Vec2(t9.x, t9.y)) || null;
        if (t9.grabbedPoint) {
          t9.grabbedSpheroid.radius = t9.grabbedPoint.length();
          this.stopRotation();
        }
      }
    }
    onTouchEnd(e9) {
      if (e9.sys.touches.length == 0) {
        this.scaleRot = 1;
        if (Math.abs(this.touches[0].x - this.touches[0].prev_x) < 3 && Math.abs(this.touches[0].y - this.touches[0].prev_y) < 3)
          this.stopRotation();
      }
    }
    onTouchMove(e9) {
      if (e9.sys.touches.length == 1) {
        let cam = this.planet.camera;
        let t9 = this.touches[0];
        t9.prev_x = t9.x;
        t9.prev_y = t9.y;
        t9.x = e9.sys.touches.item(0).pageX - e9.sys.offsetLeft;
        t9.y = e9.sys.touches.item(0).pageY - e9.sys.offsetTop;
        if (!t9.grabbedPoint)
          return;
        let direction = cam.unproject(t9.x, t9.y);
        let targetPoint = new Ray(cam.eye, direction).hitSphere(t9.grabbedSpheroid);
        if (targetPoint) {
          this._a = Math.acos(t9.grabbedPoint.y / t9.grabbedSpheroid.radius) - Math.acos(targetPoint.y / t9.grabbedSpheroid.radius);
          this._vRot = Quat.axisAngleToQuat(cam._u, this._a);
          this._hRot = Quat.getRotationBetweenVectors(new Vec3(targetPoint.x, 0, targetPoint.z).normal(), new Vec3(t9.grabbedPoint.x, 0, t9.grabbedPoint.z).normal());
          let rot = this._hRot.mul(this._vRot);
          let state = this.positionState[this.currState];
          let lim = rot.mulVec3(cam.eye).normal().dot(Vec3.NORTH);
          if (lim > state.max || lim < state.min) {
            rot = Quat.yRotation(rot.getYaw());
          }
          cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, Vec3.NORTH);
          cam.update();
        }
      }
    }
    onMouseLeftButtonClick(e9) {
      this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
      this.grabbedPoint = this.planet.getCartesianFromMouseTerrain() || null;
      this.grabbedDir.copy(e9.direction);
      if (this.grabbedPoint) {
        this.grabbedSpheroid.radius = this.grabbedPoint.length();
        this.stopRotation();
      }
    }
    stopRotation() {
      this.scaleRot = 0;
      this._a = 0;
      this._vRot.clear();
      this._hRot.clear();
    }
    onMouseLeftButtonUp(e9) {
      this.scaleRot = 1;
      this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
      if (Math.abs(e9.x - e9.prev_x) < 3 && Math.abs(e9.y - e9.prev_y) < 3)
        this.stopRotation();
    }
    onMouseLeftButtonDown(e9) {
      let cam = this.planet.camera;
      if (!this.grabbedPoint || cam.isFlying())
        return;
      if (this.renderer.events.mouseState.moving) {
        let targetPoint = new Ray(cam.eye, e9.direction).hitSphere(this.grabbedSpheroid);
        if (targetPoint) {
          this._a = Math.acos(this.grabbedPoint.y / this.grabbedSpheroid.radius) - Math.acos(targetPoint.y / this.grabbedSpheroid.radius);
          let rot = this._vRot = Quat.axisAngleToQuat(cam._u, this._a);
          cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, rot.mulVec3(cam.getUp()));
          this._hRot = Quat.getRotationBetweenVectors(new Vec3(targetPoint.x, 0, targetPoint.z).normal(), new Vec3(this.grabbedPoint.x, 0, this.grabbedPoint.z).normal());
          rot = this._hRot;
          cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, rot.mulVec3(cam.getUp()));
          cam.update();
        }
      } else {
        this.scaleRot = 0;
      }
    }
    onDraw() {
      let r8 = this.renderer;
      let cam = this.planet.camera;
      if (r8.events.mouseState.leftButtonDown || !this.scaleRot || cam.isFlying())
        return;
      this.scaleRot -= this.inertia;
      if (this.scaleRot <= 0) {
        this.scaleRot = 0;
      } else {
        this._vRot = Quat.axisAngleToQuat(cam._u, this._a);
        let rot = this._vRot.mul(this._hRot);
        let lim = rot.mulVec3(cam.eye).normal().dot(Vec3.NORTH);
        let state = this.positionState[this.currState];
        if (lim > state.max || lim < state.min) {
          rot = Quat.yRotation(rot.getYaw());
        }
        r8.controlsBag.scaleRot = this.scaleRot;
        rot = rot.slerp(Quat.IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot).normalize();
        if (!(rot.x || rot.y || rot.z)) {
          this.scaleRot = 0;
        }
        cam.set(rot.mulVec3(cam.eye), Vec3.ZERO, Vec3.NORTH);
        cam.update();
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/layer/BaseGeoImage.js
  var BASEGEOIMAGE_EVENTS = [
    /**
     * Triggered when image data is loaded
     * @event EventsHandler<BaseGeoImageEventsList>#loadend
     */
    "loadend"
  ];
  var BaseGeoImage = class extends Layer {
    constructor(name, options2 = {}) {
      super(name, options2);
      this.events = this.events.registerNames(BASEGEOIMAGE_EVENTS);
      this._projType = 0;
      this._frameWidth = 256;
      this._frameHeight = 256;
      this._sourceReady = false;
      this._sourceTexture = null;
      this._materialTexture = null;
      this._gridBufferLow = null;
      this._gridBufferHigh = null;
      this._extentWgs84ParamsHigh = new Float32Array(4);
      this._extentWgs84ParamsLow = new Float32Array(4);
      this._extentMercParamsHigh = new Float32Array(4);
      this._extentMercParamsLow = new Float32Array(4);
      this._refreshFrame = true;
      this._frameCreated = false;
      this._sourceCreated = false;
      this._animate = false;
      this._ready = false;
      this._creationProceeding = false;
      this._isRendering = false;
      this._extentWgs84 = new Extent();
      this._cornersWgs84 = [];
      this._cornersMerc = [];
      this._isFullExtent = options2.fullExtent ? 1 : 0;
      this.rendering = this._renderingProjType0.bind(this);
      this._onLoadend_ = null;
      options2.corners && this.setCorners(options2.corners);
    }
    get isIdle() {
      return super.isIdle && this._ready;
    }
    addTo(planet) {
      this._onLoadend_ = this._onLoadend.bind(this);
      this.events.on("loadend", this._onLoadend_, this);
      return super.addTo(planet);
    }
    _onLoadend() {
      if (this._planet) {
        this._planet.events.dispatch(this._planet.events.layerloadend, this);
      }
    }
    remove() {
      this.events.off("loadend", this._onLoadend_);
      this._onLoadend_ = null;
      return super.remove();
    }
    get instanceName() {
      return "BaseGeoImage";
    }
    /**
     * Gets corners coordinates.
     * @public
     * @return {Array.<LonLat>} - (exactly 4 entries)
     */
    getCornersLonLat() {
      let c7 = this._cornersWgs84;
      return [
        new LonLat(c7[0].lon, c7[0].lat),
        new LonLat(c7[1].lon, c7[1].lat),
        new LonLat(c7[2].lon, c7[2].lat),
        new LonLat(c7[3].lon, c7[3].lat)
      ];
    }
    /**
     * Gets corners coordinates.
     * @public
     * @return {Array.<Array<number>>} - (exactly 3 entries)
     */
    getCorners() {
      let c7 = this._cornersWgs84;
      return [
        [c7[0].lon, c7[0].lat],
        [c7[1].lon, c7[1].lat],
        [c7[2].lon, c7[2].lat],
        [c7[3].lon, c7[3].lat]
      ];
    }
    /**
     * Sets geoImage geographical corners coordinates.
     * @public
     * @param {Array.<Array.<number>>} corners - GeoImage corners coordinates. Where first coordinate (exactly 3 entries)
     * coincedents to the left top image corner, secont to the right top image corner, third to the right bottom
     * and fourth - left bottom image corner.
     */
    setCorners(corners2) {
      this.setCornersLonLat(LonLat.join(corners2));
    }
    /**
     * Sets geoImage geographical corners coordinates.
     * @public
     * @param {Array.<LonLat>} corners - GeoImage corners coordinates. Where first coordinate
     * coincedents to the left top image corner, secont to the right top image corner, third to the right bottom
     * and fourth - left bottom image corner. (exactly 4 entries)
     */
    setCornersLonLat(corners2) {
      this._refreshFrame = true;
      this._cornersWgs84 = [
        corners2[0].clone(),
        corners2[1].clone(),
        corners2[2].clone(),
        corners2[3].clone()
      ];
      for (let i9 = 0; i9 < this._cornersWgs84.length; i9++) {
        if (this._cornersWgs84[i9].lat >= 89.9) {
          this._cornersWgs84[i9].lat = 89.9;
        }
        if (this._cornersWgs84[i9].lat <= -89.9) {
          this._cornersWgs84[i9].lat = -89.9;
        }
      }
      this._extent.setByCoordinates(this._cornersWgs84);
      let me = this._extent;
      if (me.southWest.lat > MAX_LAT || me.northEast.lat < MIN_LAT) {
        this._projType = 0;
        this.rendering = this._renderingProjType0;
      } else {
        this._projType = 1;
        this.rendering = this._renderingProjType1;
      }
      if (this._ready && !this._creationProceeding) {
        this._planet._geoImageCreator.add(this);
      }
    }
    /**
     * Creates geoImage frame.
     * @protected
     */
    _createFrame() {
      this._extentWgs84 = this._extent.clone();
      this._cornersMerc = [
        this._cornersWgs84[0].forwardMercatorEPS01(),
        this._cornersWgs84[1].forwardMercatorEPS01(),
        this._cornersWgs84[2].forwardMercatorEPS01(),
        this._cornersWgs84[3].forwardMercatorEPS01()
      ];
      this._extentMerc = new Extent(this._extentWgs84.southWest.forwardMercatorEPS01(), this._extentWgs84.northEast.forwardMercatorEPS01());
      let tempArr2 = new Float32Array(2);
      if (this._projType === 0) {
        doubleToTwoFloats2(this._extentWgs84.southWest.lon, tempArr2);
        this._extentWgs84ParamsHigh[0] = tempArr2[0];
        this._extentWgs84ParamsLow[0] = tempArr2[1];
        doubleToTwoFloats2(this._extentWgs84.southWest.lat, tempArr2);
        this._extentWgs84ParamsHigh[1] = tempArr2[0];
        this._extentWgs84ParamsLow[1] = tempArr2[1];
        this._extentWgs84ParamsHigh[2] = 2 / this._extentWgs84.getWidth();
        this._extentWgs84ParamsHigh[3] = 2 / this._extentWgs84.getHeight();
      } else {
        doubleToTwoFloats2(this._extentMerc.southWest.lon, tempArr2);
        this._extentMercParamsHigh[0] = tempArr2[0];
        this._extentMercParamsLow[0] = tempArr2[1];
        doubleToTwoFloats2(this._extentMerc.southWest.lat, tempArr2);
        this._extentMercParamsHigh[1] = tempArr2[0];
        this._extentMercParamsLow[1] = tempArr2[1];
        this._extentMercParamsHigh[2] = 2 / this._extentMerc.getWidth();
        this._extentMercParamsHigh[3] = 2 / this._extentMerc.getHeight();
      }
      if (this._planet) {
        let p4 = this._planet, h8 = p4.renderer.handler, gl = h8.gl;
        gl.deleteTexture(this._materialTexture);
        this._materialTexture = h8.createEmptyTexture_l(this._frameWidth, this._frameHeight);
        let gridBufferArr = this._planet._geoImageCreator.createGridBuffer(this._cornersWgs84, this._projType === 1);
        this._gridBufferHigh = gridBufferArr[0];
        this._gridBufferLow = gridBufferArr[1];
        this._refreshFrame = false;
      }
    }
    /**
     * @public
     * @override
     * @param {Material} material - GeoImage material.
     */
    abortMaterialLoading(material) {
      this._creationProceeding = false;
      material.isLoading = false;
      material.isReady = false;
    }
    /**
     * Clear layer material.
     * @public
     * @override
     */
    clear() {
      let p4 = this._planet;
      if (p4) {
        let gl = p4.renderer.handler.gl;
        this._creationProceeding && p4._geoImageCreator.remove(this);
        p4._clearLayerMaterial(this);
        if (gl) {
          gl.deleteBuffer(this._gridBufferHigh);
          gl.deleteBuffer(this._gridBufferLow);
          gl.deleteTexture(this._sourceTexture);
          this._materialTexture && !this._materialTexture.default && gl.deleteTexture(this._materialTexture);
        }
      }
      this._sourceTexture = null;
      this._materialTexture = null;
      this._gridBufferHigh = null;
      this._gridBufferLow = null;
      this._refreshFrame = true;
      this._sourceCreated = false;
      this._ready = false;
      this._creationProceeding = false;
    }
    /**
     * Sets layer visibility.
     * @public
     * @override
     * @param {boolean} visibility - GeoImage visibility.
     */
    setVisibility(visibility) {
      if (visibility !== this._visibility) {
        super.setVisibility(visibility);
        if (this._planet && this._sourceReady) {
          if (visibility) {
            this._planet._geoImageCreator.add(this);
          } else {
            this._planet._geoImageCreator.remove(this);
          }
        }
      }
    }
    /**
     * @public
     * @param {Material} material - GeoImage material.
     */
    clearMaterial(material) {
      material.texture = null;
      material.isLoading = false;
      material.isReady = false;
    }
    /**
     * @public
     * @override
     * @returns {Array<number>} -
     */
    applyMaterial(material) {
      let segment = material.segment;
      if (this._ready) {
        material.applyTexture(this._materialTexture);
      } else {
        material.texture = this._planet.transparentTexture;
        !this._creationProceeding && this.loadMaterial(material);
      }
      let v0s, v0t;
      if (this._projType === 0) {
        v0s = this._extentWgs84;
        v0t = segment._extent;
      } else {
        v0s = this._extentMerc;
        v0t = segment.getExtentMerc();
      }
      let sSize_x = v0s.northEast.lon - v0s.southWest.lon;
      let sSize_y = v0s.northEast.lat - v0s.southWest.lat;
      let dV0s_x = (v0t.southWest.lon - v0s.southWest.lon) / sSize_x;
      let dV0s_y = (v0s.northEast.lat - v0t.northEast.lat) / sSize_y;
      let dSize_x = (v0t.northEast.lon - v0t.southWest.lon) / sSize_x;
      let dSize_y = (v0t.northEast.lat - v0t.southWest.lat) / sSize_y;
      return [dV0s_x, dV0s_y, dSize_x, dSize_y];
    }
    /**
     * Gets frame width size in pixels.
     * @public
     * @returns {Number} Frame width.
     */
    get getFrameWidth() {
      return this._frameWidth;
    }
    /**
     * Gets frame height size in pixels.
     * @public
     * @returns {Number} Frame height.
     */
    get getFrameHeight() {
      return this._frameHeight;
    }
    /**
     * Method depends on GeoImage instance
     * @protected
     */
    _createSourceTexture() {
    }
    _renderingProjType1() {
      let p4 = this._planet, h8 = p4.renderer.handler, gl = h8.gl, creator = p4._geoImageCreator;
      this._refreshFrame && this._createFrame();
      this._createSourceTexture();
      let f8 = creator._framebuffer;
      f8.setSize(this._frameWidth, this._frameHeight);
      f8.activate();
      h8.programs.geoImageTransform.activate();
      let sh = h8.programs.geoImageTransform._program;
      let sha = sh.attributes, shu = sh.uniforms;
      gl.disable(gl.CULL_FACE);
      f8.bindOutputTexture(this._materialTexture);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.uniform1i(shu.isFullExtent, this._isFullExtent);
      gl.bindBuffer(gl.ARRAY_BUFFER, creator._texCoordsBuffer);
      gl.vertexAttribPointer(sha.texCoords, 2, gl.UNSIGNED_SHORT, true, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBufferHigh);
      gl.vertexAttribPointer(sha.cornersHigh, this._gridBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBufferLow);
      gl.vertexAttribPointer(sha.cornersLow, this._gridBufferLow.itemSize, gl.FLOAT, false, 0, 0);
      gl.uniform4fv(shu.extentParamsHigh, this._extentMercParamsHigh);
      gl.uniform4fv(shu.extentParamsLow, this._extentMercParamsLow);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
      gl.uniform1i(shu.sourceTexture, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, creator._indexBuffer);
      gl.drawElements(gl.TRIANGLE_STRIP, creator._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
      f8.deactivate();
      gl.enable(gl.CULL_FACE);
      this._ready = true;
      this._creationProceeding = false;
    }
    _renderingProjType0() {
      let p4 = this._planet, h8 = p4.renderer.handler, gl = h8.gl, creator = p4._geoImageCreator;
      this._refreshFrame && this._createFrame();
      this._createSourceTexture();
      let f8 = creator._framebuffer;
      f8.setSize(this._frameWidth, this._frameHeight);
      f8.activate();
      h8.programs.geoImageTransform.activate();
      let sh = h8.programs.geoImageTransform._program;
      let sha = sh.attributes, shu = sh.uniforms;
      gl.disable(gl.CULL_FACE);
      f8.bindOutputTexture(this._materialTexture);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.bindBuffer(gl.ARRAY_BUFFER, creator._texCoordsBuffer);
      gl.vertexAttribPointer(sha.texCoords, 2, gl.UNSIGNED_SHORT, true, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBufferHigh);
      gl.vertexAttribPointer(sha.cornersHigh, this._gridBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._gridBufferLow);
      gl.vertexAttribPointer(sha.cornersLow, this._gridBufferLow.itemSize, gl.FLOAT, false, 0, 0);
      gl.uniform4fv(shu.extentParamsHigh, this._extentWgs84ParamsHigh);
      gl.uniform4fv(shu.extentParamsLow, this._extentWgs84ParamsLow);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
      gl.uniform1i(shu.sourceTexture, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, creator._indexBuffer);
      gl.drawElements(gl.TRIANGLE_STRIP, creator._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
      f8.deactivate();
      gl.enable(gl.CULL_FACE);
      this._ready = true;
      this._creationProceeding = false;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/GeoImageDragControl.js
  var ICON_BUTTON_SVG3 = `<?xml version="1.0" encoding="UTF-8" standalone="no"?> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M16 13l6.964 4.062-2.973.85 2.125 3.681-1.732 1-2.125-3.68-2.223 2.15L16 13zm-2-7h2v2h5a1 1 0 0 1 1 1v4h-2v-3H10v10h4v2H9a1 1 0 0 1-1-1v-5H6v-2h2V9a1 1 0 0 1 1-1h5V6zM4 14v2H2v-2h2zm0-4v2H2v-2h2zm0-4v2H2V6h2zm0-4v2H2V2h2zm4 0v2H6V2h2zm4 0v2h-2V2h2zm4 0v2h-2V2h2z" fill="#000"/></svg>`;
  var GeoImageDragControl = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._cornerIndex = -1;
      this._catchCorner = false;
      this._toggleBtn = new ToggleButton({
        classList: ["og-map-button", "og-geoimagegrag_button"],
        icon: ICON_BUTTON_SVG3
      });
    }
    oninit() {
      this._toggleBtn.appendTo(this.renderer.div);
      this.planet.events.on("layeradd", (e9) => {
        if (this.isActive()) {
          this._bindLayer(e9);
        }
      }, this);
      this._toggleBtn.events.on("change", (isActive) => {
        if (isActive) {
          this.activate();
        } else {
          this.deactivate();
        }
      });
    }
    onactivate() {
      super.onactivate();
      const p4 = this.planet;
      for (let i9 = 0; i9 < p4.layers.length; i9++) {
        this._bindLayer(p4.layers[i9]);
      }
    }
    ondeactivate() {
      super.ondeactivate();
      const p4 = this.planet;
      for (let i9 = 0; i9 < p4.layers.length; i9++) {
        this._unbindLayer(p4.layers[i9]);
      }
    }
    _bindLayer(layer) {
      if (layer instanceof BaseGeoImage) {
        layer.events.on("mousemove", this._onMouseMove, this);
        layer.events.on("mouseleave", this._onMouseLeave, this);
        layer.events.on("ldown", this._onLDown, this);
        layer.events.on("lup", this._onLUp, this);
      }
    }
    _unbindLayer(layer) {
      if (layer instanceof BaseGeoImage) {
        layer.events.off("mousemove", this._onMouseMove);
        layer.events.off("mouseleave", this._onMouseLeave);
        layer.events.off("ldown", this._onLDown);
        layer.events.off("lup", this._onLUp);
      }
    }
    _onLUp(ms2) {
      this._catchCorner = false;
      ms2.renderer.controls.mouseNavigation.activate();
    }
    _onLDown(ms2) {
      if (this._cornerIndex !== -1) {
        this._catchCorner = true;
        ms2.renderer.controls.mouseNavigation.deactivate();
      }
    }
    _onMouseLeave() {
      document.body.style.cursor = "auto";
    }
    _onMouseMove(ms2) {
      let layer = ms2.pickingObject;
      const p4 = this.planet;
      if (this._catchCorner) {
        let corners2 = layer.getCornersLonLat();
        corners2[this._cornerIndex] = p4.getLonLatFromPixelTerrain(ms2);
        layer.setCornersLonLat(corners2);
      } else {
        this._cornerIndex = -1;
        for (let i9 = 0; i9 < layer._cornersWgs84.length; i9++) {
          let ground = p4.getLonLatFromPixelTerrain(ms2);
          if (ground && p4.ellipsoid.getGreatCircleDistance(layer._cornersWgs84[i9], ground) / p4.getDistanceFromPixel(ms2) <= 0.05) {
            this._cornerIndex = i9;
            document.body.style.cursor = "move";
            break;
          } else {
            document.body.style.cursor = "auto";
          }
        }
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/input/input.js
  var input = {
    MB_LEFT: 0,
    MB_RIGHT: 2,
    MB_MIDDLE: 1,
    KEY_CTRL: 17,
    KEY_ALT: 18,
    KEY_SHIFT: 16,
    KEY_SPACE: 32,
    KEY_PGUP: 33,
    KEY_PGDN: 34,
    KEY_LEFT: 37,
    KEY_UP: 38,
    KEY_RIGHT: 39,
    KEY_DOWN: 40,
    KEY_PRINTSCREEN: 44,
    KEY_EQUALS: 61,
    KEY_A: 65,
    KEY_C: 67,
    KEY_D: 68,
    KEY_E: 69,
    KEY_F: 70,
    KEY_H: 72,
    KEY_I: 73,
    KEY_K: 75,
    KEY_L: 76,
    KEY_N: 78,
    KEY_O: 79,
    KEY_P: 80,
    KEY_Q: 81,
    KEY_R: 82,
    KEY_S: 83,
    KEY_V: 86,
    KEY_W: 87,
    KEY_X: 88,
    KEY_Z: 90,
    KEY_PLUS: 107,
    KEY_F1: 112,
    KEY_MINUS: 173,
    KEY_APOSTROPHE: 192,
    KEY_BACK_SLASH: 220,
    KEY_MORE: 190,
    KEY_SLASH: 191,
    KEY_LESS: 188,
    KEY_LEFT_SQUARE_BRACKET: 219,
    KEY_RIGHT_SQUARE_BRACKET: 221,
    KEY_SINGLE_QUOTE: 222
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/KeyboardNavigation.js
  var KeyboardNavigation = class extends Control {
    constructor(options2 = {}) {
      options2 = options2 || {};
      super({ name: "KeyboardNavigation", ...options2 });
      this.step = options2.step || 250;
    }
    onactivate() {
      let r8 = this.renderer;
      r8.events.on("keypress", input.KEY_PGUP, this.onCameraMoveForward, this);
      r8.events.on("keypress", input.KEY_PGDN, this.onCameraMoveBackward, this);
      r8.events.on("keypress", input.KEY_PLUS, this.onCameraMoveForward, this);
      r8.events.on("keypress", input.KEY_EQUALS, this.onCameraMoveForward, this);
      r8.events.on("keypress", input.KEY_MINUS, this.onCameraMoveBackward, this);
      r8.events.on("keypress", input.KEY_W, this.onCameraMoveForward, this);
      r8.events.on("keypress", input.KEY_S, this.onCameraMoveBackward, this);
      r8.events.on("keypress", input.KEY_A, this.onCameraStrifeLeft, this);
      r8.events.on("keypress", input.KEY_D, this.onCameraStrifeRight, this);
      r8.events.on("keypress", input.KEY_UP, this.onCameraLookUp, this);
      r8.events.on("keypress", input.KEY_DOWN, this.onCameraLookDown, this);
      r8.events.on("keypress", input.KEY_LEFT, this.onCameraLookLeft, this);
      r8.events.on("keypress", input.KEY_RIGHT, this.onCameraLookRight, this);
      r8.events.on("keypress", input.KEY_Q, this.onCameraRollLeft, this);
      r8.events.on("keypress", input.KEY_E, this.onCameraRollRight, this);
      r8.events.on("keypress", input.KEY_N, this.onCameraRollNorth, this);
    }
    ondeactivate() {
      let r8 = this.renderer;
      r8.events.off("keypress", input.KEY_PGUP, this.onCameraMoveForward);
      r8.events.off("keypress", input.KEY_PGDN, this.onCameraMoveBackward);
      r8.events.off("keypress", input.KEY_PLUS, this.onCameraMoveForward);
      r8.events.off("keypress", input.KEY_EQUALS, this.onCameraMoveForward);
      r8.events.off("keypress", input.KEY_MINUS, this.onCameraMoveBackward);
      r8.events.off("keypress", input.KEY_W, this.onCameraMoveForward);
      r8.events.off("keypress", input.KEY_S, this.onCameraMoveBackward);
      r8.events.off("keypress", input.KEY_A, this.onCameraStrifeLeft);
      r8.events.off("keypress", input.KEY_D, this.onCameraStrifeRight);
      r8.events.off("keypress", input.KEY_UP, this.onCameraLookUp);
      r8.events.off("keypress", input.KEY_DOWN, this.onCameraLookDown);
      r8.events.off("keypress", input.KEY_LEFT, this.onCameraLookLeft);
      r8.events.off("keypress", input.KEY_RIGHT, this.onCameraLookRight);
      r8.events.off("keypress", input.KEY_Q, this.onCameraRollLeft);
      r8.events.off("keypress", input.KEY_E, this.onCameraRollRight);
      r8.events.off("keypress", input.KEY_N, this.onCameraRollNorth);
    }
    oninit() {
      this.activate();
    }
    onCameraMoveForward() {
      let cam = this.planet.camera;
      cam.slide(0, 0, -cam.getAltitude() / this.step);
    }
    onCameraMoveBackward() {
      let cam = this.planet.camera;
      cam.slide(0, 0, cam.getAltitude() / this.step);
    }
    onCameraStrifeLeft() {
      let cam = this.planet.camera;
      cam.slide(-cam.getAltitude() / this.step, 0, 0);
    }
    onCameraStrifeRight() {
      let cam = this.planet.camera;
      cam.slide(cam.getAltitude() / this.step, 0, 0);
    }
    onCameraLookUp() {
      let cam = this.planet.camera;
      if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
        cam.pitch(15 / this.renderer.handler.deltaTime);
      } else {
        cam.rotateVertical(cam.getAltitude() / 3e6 * RADIANS, Vec3.ZERO);
      }
    }
    onCameraLookDown() {
      let cam = this.planet.camera;
      if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
        cam.pitch(-15 / this.renderer.handler.deltaTime);
      } else {
        cam.rotateVertical(-cam.getAltitude() / 3e6 * RADIANS, Vec3.ZERO);
      }
    }
    onCameraLookLeft() {
      let cam = this.planet.camera;
      if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
        cam.roll(15 / this.renderer.handler.deltaTime);
      } else {
        cam.rotateHorizontal(cam.getAltitude() / 3e6 * RADIANS);
      }
    }
    onCameraLookRight() {
      let cam = this.planet.camera;
      if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
        cam.roll(-15 / this.renderer.handler.deltaTime);
      } else {
        cam.rotateHorizontal(-cam.getAltitude() / 3e6 * RADIANS);
      }
    }
    onCameraTurnLeft() {
      let cam = this.planet.camera;
      if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
        cam.yaw(15 / this.renderer.handler.deltaTime);
      } else {
        cam.rotateHorizontal(cam.getAltitude() / 3e6 * RADIANS);
      }
    }
    onCameraTurnRight() {
      let cam = this.planet.camera;
      if (this.renderer.events.isKeyPressed(input.KEY_SHIFT)) {
        cam.yaw(-15 / this.renderer.handler.deltaTime);
      } else {
        cam.rotateHorizontal(-cam.getAltitude() / 3e6 * RADIANS, false, Vec3.ZERO);
      }
    }
    // from CompassButton._onClick()
    onCameraRollNorth() {
      let c7 = this.planet.getCartesianFromPixelTerrain(this.renderer.handler.getCenter());
      if (c7) {
        this.planet.flyCartesian(c7.normal().scaleTo(c7.length() + c7.distance(this.planet.camera.eye)), null, null, 0, null, null, () => {
          this.planet.camera.look;
        });
      } else {
        this.planet.flyCartesian(this.planet.camera.eye);
      }
    }
    onCameraRollLeft() {
      this.planet.camera.roll(-15 / this.renderer.handler.deltaTime);
    }
    onCameraRollRight() {
      this.planet.camera.roll(15 / this.renderer.handler.deltaTime);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/LayerAnimation.js
  var LAYERANIMATION_EVENTS = ["change", "idle", "play", "pause", "stop"];
  var LayerAnimation = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._currVisibleIndex = 0;
      this._onViewchange = () => {
        this._timeoutStart = performance.now();
      };
      this._onVisibilityChange = (isVisible) => {
        if (!isVisible) {
          this.pause();
        }
      };
      this._onLayerLoadend = (layer) => {
        let currLayer = this._layersArr[this._currentIndex];
        if (currLayer && currLayer.isEqual(layer)) {
          let currFrame = this._getFrameIndex(this._currentIndex);
          let from = currFrame * this._frameSize, to = this._currentIndex;
          for (let i9 = from; i9 < to; i9++) {
            let li = this._layersArr[i9];
            li.opacity = 0;
            li.setVisibility(false);
          }
          currLayer.opacity = 1;
          let currVisibleLayer = this._layersArr[this._currVisibleIndex];
          if (currVisibleLayer) {
            currVisibleLayer.opacity = 0;
            currVisibleLayer.setVisibility(false);
            let prevFrame = this._getFrameIndex(this._currVisibleIndex);
            if (this._getFrameIndex(this._currentIndex) !== prevFrame) {
              this._removeFrameFromPlanet(prevFrame);
            }
          }
          this.events.dispatch(this.events.idle, currLayer);
        }
      };
      this.events = createEvents(LAYERANIMATION_EVENTS);
      this._name = options2.name || `layerAnimation-${this.__id}`;
      this._layersArr = options2.layers ? [].concat(options2.layers) : [];
      this._currentIndex = -1;
      this._playInterval = options2.playInterval || 120;
      this._playIntervalHandler = -1;
      this._playIndex = 0;
      this._frameSize = options2.frameSize || 50;
      this.repeat = options2.repeat != void 0 ? options2.repeat : true;
      this.skipTimeout = options2.skipTimeout || 5e3;
      this._timeoutStart = 0;
    }
    _getFramesNum() {
      return Math.ceil(this._layersArr.length / this._frameSize);
    }
    _setFrame(frameIndex) {
      for (let i9 = 0, len = this._getFramesNum(); i9 < len; i9++) {
        if (i9 !== frameIndex) {
          this._removeFrameFromPlanet(i9);
        } else {
          this._appendFrameToPlanet(i9);
        }
      }
    }
    _getFrameIndex(layerIndex) {
      return Math.floor(layerIndex / this._frameSize);
    }
    _appendFrameToPlanet(frameIndex) {
      if (this.planet) {
        let minIndex = frameIndex * this._frameSize;
        let maxIndex = minIndex + this._frameSize;
        for (let i9 = minIndex, len = maxIndex > this._layersArr.length ? this._layersArr.length : maxIndex; i9 < len; i9++) {
          this.planet.addLayer(this._layersArr[i9]);
        }
      }
    }
    _removeFrameFromPlanet(frameIndex) {
      if (this.planet) {
        let minIndex = frameIndex * this._frameSize;
        let maxIndex = minIndex + this._frameSize;
        for (let i9 = minIndex, len = maxIndex > this._layersArr.length ? this._layersArr.length : maxIndex; i9 < len; i9++) {
          this._layersArr[i9].abortLoading();
          this._layersArr[i9].remove();
          this._layersArr[i9].setVisibility(false);
        }
      }
    }
    oninit() {
      super.oninit();
      this.onactivate();
      this._initLayers();
      this.planet.events.on("layerloadend", this._onLayerLoadend);
      this._setCurrentIndexAsync(0, false, true);
    }
    onactivate() {
      super.onactivate();
      this.planet.camera.events.on("viewchange", this._onViewchange);
      this.planet.renderer.handler.events.on("visibilitychange", this._onVisibilityChange);
    }
    ondeactivate() {
      super.ondeactivate();
      this.planet.camera.events.off("viewchange", this._onViewchange);
      for (let i9 = 0; i9 < this._layersArr.length; i9++) {
        this._layersArr[i9].setVisibility(false);
      }
      this.planet.events.off("layerloadend", this._onLayerLoadend);
      this.planet.renderer.handler.events.off("visibilitychange", this._onVisibilityChange);
    }
    clear() {
      this.stop();
      this._currentIndex = -1;
      this._currVisibleIndex = -1;
      let layersToRemove = this._layersArr;
      this._layersArr = [];
      for (let i9 = 0; i9 < layersToRemove.length; i9++) {
        layersToRemove[i9].remove();
      }
    }
    _initLayers() {
      if (this.planet) {
        for (let i9 = 0, len = this._layersArr.length; i9 < len; i9++) {
          let li = this._layersArr[i9];
          li.setVisibility(false);
          li.setBaseLayer(false);
          li.opacity = 0;
        }
        this._appendFrameToPlanet(0);
      }
    }
    setLayers(layers) {
      this.clear();
      this._layersArr = [].concat(layers);
      this._initLayers();
    }
    appendLayer(layer) {
      this._layersArr.push(layer);
      layer.setVisibility(false);
      layer.setBaseLayer(false);
      layer.opacity = 0;
      this.planet?.addLayer(layer);
    }
    /**
     * warning: Use XYZ.isIdle in requestAnimationFrame(after setVisibility)
     * @returns Returns true if current layer is idle
     */
    get isIdle() {
      let currLayer = this._layersArr[this._currentIndex];
      return currLayer && currLayer.isIdle || !currLayer;
    }
    get playInterval() {
      return this._playInterval;
    }
    set playInterval(val) {
      if (val !== this._playInterval) {
        this._playInterval = val;
        if (this.isPlaying) {
          this.pause();
          this.play();
        }
      }
    }
    get isPlaying() {
      return this._playIntervalHandler !== -1;
    }
    get layers() {
      return this._layersArr;
    }
    _checkEnd() {
      if (this._playIndex > this._layersArr.length) {
        if (this.repeat) {
          this._playIndex = 0;
        } else {
          this.pause();
        }
      }
    }
    play() {
      if (!this.isPlaying) {
        if (this._currentIndex >= this._layersArr.length - 1) {
          this.stop();
        }
        this._timeoutStart = performance.now();
        this._playIntervalHandler = setInterval(() => {
          this._checkEnd();
          this._setCurrentIndexAsync(this._playIndex, false, false);
          requestAnimationFrame(() => {
            if (this.isIdle || performance.now() - this._timeoutStart > this.skipTimeout) {
              this._playIndex++;
              this._timeoutStart = performance.now();
            }
          });
        }, this._playInterval);
        this.events.dispatch(this.events.play);
      }
    }
    stop() {
      if (this._playIndex > 0) {
        this._clearInterval();
        this._playIndex = 0;
        this.setCurrentIndex(0);
        this.events.dispatch(this.events.stop);
      }
    }
    pause() {
      if (this.isPlaying) {
        this._clearInterval();
        this.events.dispatch(this.events.pause);
      }
    }
    _clearInterval() {
      clearInterval(this._playIntervalHandler);
      this._playIntervalHandler = -1;
    }
    /**
     * Function sets layer index visible.
     * @param {number} index
     * @param {boolean} [stopPropagation=false]
     */
    setCurrentIndex(index, stopPropagation = false) {
      this._setCurrentIndexAsync(index, true, stopPropagation);
    }
    /**
     * Function sets layer index visible. If the layer is idle (all visible tiles loaded), sets opacity to one,
     * otherwise to ZERO it means that when all visible tiles will be loaded the opacity becomes ONE. So, previous
     * layer remains not transparent (opacity = 1) till current layer is loading.
     */
    _setCurrentIndexAsync(index, forceVisibility = false, stopPropagation = false) {
      if (index != this._currentIndex && index >= 0 && index < this._layersArr.length) {
        let prevCurrIndex = this._currentIndex;
        this._currentIndex = index;
        this._playIndex = index;
        let prevCurrFrame = this._getFrameIndex(prevCurrIndex);
        let currFrame = this._getFrameIndex(this._currentIndex);
        let prevCurrLayer = this._layersArr[prevCurrIndex], currLayer = this._layersArr[index];
        let frameChanged = currFrame != prevCurrFrame;
        if (frameChanged) {
          this._appendFrameToPlanet(currFrame);
        }
        if (prevCurrLayer) {
          if (prevCurrLayer.isIdle) {
            this._currVisibleIndex = prevCurrIndex;
          } else {
            prevCurrLayer.opacity = 0;
            prevCurrLayer.setVisibility(false);
          }
        }
        if (currLayer) {
          currLayer.opacity = 0;
          currLayer.setVisibility(true);
          requestAnimationFrame(() => {
            if (currLayer.isIdle || forceVisibility) {
              currLayer.opacity = 1;
              if (frameChanged) {
                this._removeFrameFromPlanet(prevCurrFrame);
              }
              if (prevCurrLayer) {
                prevCurrLayer.opacity = 0;
                prevCurrLayer.setVisibility(false);
              }
              let currVisibleLayer = this._layersArr[this._currVisibleIndex];
              if (currVisibleLayer) {
                currVisibleLayer.opacity = 0;
                currVisibleLayer.setVisibility(false);
              }
            }
          });
          if (!stopPropagation) {
            this.events.dispatch(this.events.change, this._currentIndex, prevCurrIndex);
          }
        }
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/LayerSwitcher.js
  var ICON_BUTTON_SVG4 = `<?xml version="1.0" encoding="utf-8"?>
<!-- Svg Vector Icons : http://www.onlinewebfonts.com/icon -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000" xml:space="preserve">
<metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>
<g><path d="M500,573.5c-3.2,0-6.5-0.6-9.5-1.9L25,375.6c-9.1-3.8-15-12.7-15-22.6s5.9-18.8,15-22.6l465.5-196c6.1-2.5,12.9-2.5,19,0l465.5,196c9.1,3.8,15,12.7,15,22.6s-5.9,18.8-15,22.6l-465.5,196C506.5,572.9,503.2,573.5,500,573.5L500,573.5z M97.6,353L500,522.4L902.4,353L500,183.6L97.6,353L97.6,353z"/><path d="M500,720.5c-3.2,0-6.5-0.6-9.5-1.9L25,522.6c-12.4-5.2-18.3-19.6-13.1-32.1c5.2-12.5,19.6-18.3,32.1-13.1l456,192l456-192c12.4-5.2,26.9,0.6,32.1,13.1s-0.6,26.9-13.1,32.1l-465.5,196C506.5,719.9,503.2,720.5,500,720.5L500,720.5z"/><path d="M500,867.5c-3.2,0-6.5-0.6-9.5-1.9L25,669.6c-12.4-5.2-18.3-19.6-13.1-32.1c5.2-12.5,19.6-18.3,32.1-13.1l456,192l456-192c12.4-5.2,26.9,0.6,32.1,13.1c5.2,12.5-0.6,26.8-13.1,32.1l-465.5,196C506.5,866.9,503.2,867.5,500,867.5L500,867.5z"/></g>
</svg>`;
  var TEMPLATE3 = `<div class="og-layerSwitcher">
      <div class="og-layerSwitcher__title">Base Layers</div>
      <div class="og-layerSwitcher__list og-layerSwitcher__baseLayers"></div>        
        
      <div class="og-layerSwitcher__title">Overlays</div>
      <div class="og-layerSwitcher__list og-layerSwitcher__overlays"></div>
         
    </div>`;
  var LAYER_BUTTON_TEMPLATE = `<button title={title} class="og-layerSwitcher__layerButton">{icon}<div class="og-layerSwitcher__name">{name}</div></button>`;
  var LayerButtonView = class extends View {
    constructor(params) {
      super({
        template: stringTemplate(LAYER_BUTTON_TEMPLATE, {
          title: params.model.name,
          name: params.model.name,
          icon: params.model.iconSrc ? `<img src="${params.model.iconSrc}" />` : ""
        }),
        ...params
      });
      this._onVisibilityChange = (layer) => {
        if (this.el) {
          if (this.model.getVisibility()) {
            this.el.classList.add("og-layerSwitcher__visible");
          } else {
            this.el.classList.remove("og-layerSwitcher__visible");
          }
        }
      };
      this._onClick = () => {
        if (this.model.isBaseLayer()) {
          this.model.setVisibility(true);
        } else {
          this.model.setVisibility(!this.model.getVisibility());
        }
      };
      this._onDblClick = () => {
        this.model.flyExtent();
      };
    }
    render(params) {
      super.render(params);
      this.model.events.on("visibilitychange", this._onVisibilityChange);
      this._onVisibilityChange(this.model);
      this.el.addEventListener("click", this._onClick);
      this.el.addEventListener("dblclick", this._onDblClick);
      return this;
    }
    remove() {
      super.remove();
      this.model.events.off("visibilitychange", this._onVisibilityChange);
    }
  };
  var LayerSwitcher = class extends Control {
    constructor(options2 = {}) {
      super({
        name: "LayerSwitcher",
        ...options2
      });
      this.addLayer = (layer) => {
        if (!layer.hideInLayerSwitcher) {
          let layerView = this._createLayerButton(layer);
          this._layerViews.push(layerView);
          if (layer.isBaseLayer()) {
            layerView.appendTo(this.$baseLayers);
          } else {
            layerView.appendTo(this.$overlays);
          }
        }
      };
      this.removeLayer = (layer) => {
        for (let i9 = 0; i9 < this._layerViews.length; i9++) {
          let li = this._layerViews[i9];
          if (li.model.isEqual(layer)) {
            li.remove();
            this._layerViews.splice(i9, 1);
            break;
          }
        }
      };
      this._dialog = new Dialog({
        title: "Layer Switcher",
        top: 15,
        useHide: true,
        visible: false,
        width: 300,
        maxHeight: 500
      });
      this._panel = new View({
        template: TEMPLATE3
      });
      this._toggleBtn = new ToggleButton({
        classList: ["og-map-button", "og-layerSwitcher_button"],
        icon: ICON_BUTTON_SVG4
      });
      this.$baseLayers = null;
      this.$overlays = null;
      this._layerViews = [];
    }
    oninit() {
      this._toggleBtn.appendTo(this.renderer.div);
      this._dialog.appendTo(this.planet.renderer.div);
      this._panel.appendTo(this._dialog.container);
      this.$baseLayers = this._panel.el.querySelector(".og-layerSwitcher__baseLayers");
      this.$overlays = this._panel.el.querySelector(".og-layerSwitcher__overlays");
      this._dialog.setPosition(this.planet.renderer.div.clientWidth - this._dialog.width - 67);
      this._dialog.events.on("visibility", (v4) => {
        this._toggleBtn.setActive(v4);
      });
      this._toggleBtn.events.on("change", (isActive) => {
        this._dialog.setVisibility(isActive);
      });
      this.planet.events.on("layeradd", this.addLayer, this);
      this.planet.events.on("layerremove", this.removeLayer, this);
      this._initLayers();
    }
    _initLayers() {
      let layers = this.planet.layers;
      for (let i9 = 0; i9 < layers.length; i9++) {
        this.addLayer(layers[i9]);
      }
    }
    _createLayerButton(layer) {
      return new LayerButtonView({
        model: layer
      });
    }
    onactivate() {
    }
    ondeactivate() {
      this._dialog.hide();
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/ui/Slider.js
  var SLIDER_EVENTS = ["change"];
  var TEMPLATE4 = `<div class="og-slider">
      <div class="og-slider-label">{label}</div>
      <div class="og-slider-panel">
        <div class="og-slider-progress"></div>      
        <div class="og-slider-pointer"></div>
      </div>
      <input type="number"/>
    </div>`;
  var Slider = class extends View {
    constructor(options2 = {}) {
      super({
        template: stringTemplate(TEMPLATE4, {
          label: options2.label || ""
        })
      });
      this._onResize = () => {
        this._setOffset((this._value - this._min) * this.$panel.clientWidth / (this._max - this._min));
      };
      this._onMouseWheel = (e9) => {
        e9 = e9 || window.event;
        e9.preventDefault();
        e9.stopPropagation();
        this.value = this._value + Math.sign(e9.wheelDelta) * (this._max - this._min) / 100;
      };
      this._onMouseWheelFF = (e9) => {
        this._onMouseWheel(e9);
      };
      this._onInput = (e9) => {
        e9 = e9 || window.event;
        e9.preventDefault();
        e9.stopPropagation();
        this.value = parseFloat(e9.target.value);
      };
      this._onMouseDown = (e9) => {
        e9 = e9 || window.event;
        e9.preventDefault();
        this._startPosX = e9.clientX;
        this.value = this._min + (this._max - this._min) * (e9.offsetX / this.$panel.clientWidth);
        document.addEventListener("mousemove", this._onMouseMove);
        document.addEventListener("mouseup", this._onMouseUp);
      };
      this._onMouseMove = (e9) => {
        e9 = e9 || window.event;
        e9.preventDefault();
        e9.stopPropagation();
        let rect = this.$panel.getBoundingClientRect();
        let clientX = clamp(e9.clientX, rect.left, rect.right);
        let dx = this._startPosX - clientX;
        this._startPosX = clientX;
        this.value = this._value - dx * (this._max - this._min) / this.$panel.clientWidth;
      };
      this._onMouseUp = () => {
        document.removeEventListener("mouseup", this._onMouseUp);
        document.removeEventListener("mousemove", this._onMouseMove);
      };
      this.events = this.events.registerNames(SLIDER_EVENTS);
      this._value = options2.value || 0;
      this._min = options2.min || 0;
      this._max = options2.max || 1;
      this._resizeObserver = new ResizeObserver(this._onResize);
      this._startPosX = 0;
      this.$label = null;
      this.$pointer = null;
      this.$progress = null;
      this.$input = null;
      this.$panel = null;
    }
    render(params) {
      super.render(params);
      this.$label = this.select(".og-slider-label");
      if (this.$label.innerHTML === "") {
        this.$label.style.display = "none";
      }
      this.$pointer = this.select(".og-slider-pointer");
      this.$progress = this.select(".og-slider-progress");
      this.$panel = this.select(".og-slider-panel");
      this.$input = this.select("input");
      this._resizeObserver.observe(this.el);
      this._initEvents();
      return this;
    }
    set value(val) {
      if (val !== this._value) {
        this._value = clamp(val, this._min, this._max);
        this.$input.value = this._value.toString();
        this._setOffset((this._value - this._min) * this.$panel.clientWidth / (this._max - this._min));
        this.events.dispatch(this.events.change, this._value, this);
      }
    }
    get value() {
      return this._value;
    }
    _initEvents() {
      this.$panel.addEventListener("mousedown", this._onMouseDown);
      this.$panel.addEventListener("mousewheel", this._onMouseWheel);
      this.$panel.addEventListener("wheel", this._onMouseWheelFF);
      this.$input.addEventListener("input", this._onInput);
    }
    _clearEvents() {
      this.$panel.removeEventListener("mousedown", this._onMouseDown);
      this.$panel.removeEventListener("mousewheel", this._onMouseWheel);
      this.$panel.removeEventListener("wheel", this._onMouseWheelFF);
      this.$input.removeEventListener("input", this._onInput);
    }
    _setOffset(x3) {
      if (x3 >= 0 && x3 <= this.$panel.clientWidth) {
        this.$pointer.style.left = this.$progress.style.width = `${x3 * 100 / this.$panel.clientWidth}%`;
      }
    }
    remove() {
      this._clearEvents();
      super.remove();
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/ui/Color.js
  var COLOR_EVENTS = ["input"];
  var TEMPLATE5 = `<div class="og-color">
      <label for="{id}" class="og-color-label">{label}</label>
      <input type="color" name="{id}" value="{value}"/>
    </div>`;
  var __labelCounter__ = 0;
  var Color = class extends View {
    constructor(options2 = {}) {
      super({
        template: stringTemplate(TEMPLATE5, {
          id: `color-${__labelCounter__++}`,
          label: options2.label || ""
        })
      });
      this._onInput = (e9) => {
        this.value = e9.target.value;
      };
      this.events = this.events.registerNames(COLOR_EVENTS);
      this._value = options2.value || "blue";
      this.$label = null;
      this.$input = null;
    }
    render(params) {
      super.render(params);
      this.$label = this.select(".og-color-label");
      if (this.$label.innerHTML === "") {
        this.$label.style.display = "none";
      }
      this.$input = this.select("input");
      this._initEvents();
      return this;
    }
    set value(val) {
      if (val !== this._value) {
        this._value = val;
        this.$input.value = this._value;
        this.events.dispatch(this.events.input, this._value, this);
      }
    }
    get value() {
      return this._value;
    }
    _initEvents() {
      this.$input.addEventListener("input", this._onInput);
    }
    _clearEvents() {
      this.$input.removeEventListener("input", this._onInput);
    }
    remove() {
      this._clearEvents();
      super.remove();
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/Lighting.js
  var SUN_STOP_SVG_ICON = `<?xml version="1.0" encoding="utf-8"?><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 122.88 70.41" style="enable-background:new 0 0 122.88 70.41" xml:space="preserve"><g><path d="M60.91,19.12c6.95,0,13.24,2.95,17.8,7.72c4.55,4.77,7.37,11.37,7.37,18.64c0,1.94-0.2,3.83-0.58,5.65h31.61 c2.1,0,2.62,1.16,2.62,2.59c0,1.43-0.52,2.59-2.62,2.59H7.09c-2.1,0-2.62-1.16-2.62-2.59c0-1.43,0.52-2.59,2.62-2.59h29.23 c-0.38-1.82-0.58-3.71-0.58-5.65c0-7.28,2.82-13.87,7.37-18.64C47.67,22.08,53.96,19.12,60.91,19.12L60.91,19.12L60.91,19.12z M63.4,70.41c-2.1,0-2.62-1.16-2.62-2.59s0.52-2.59,2.62-2.59h56.86c2.1,0,2.62,1.16,2.62,2.59s-0.52,2.59-2.62,2.59H63.4 L63.4,70.41z M2.62,70.41c-2.1,0-2.62-1.16-2.62-2.59s0.52-2.59,2.62-2.59h29.51c2.1,0,2.62,1.16,2.62,2.59s-0.52,2.59-2.62,2.59 H2.62L2.62,70.41z M38.39,9.46c-0.78-1.35-0.32-3.07,1.03-3.85c1.35-0.78,3.07-0.32,3.85,1.03l3.62,6.27 c0.78,1.35,0.32,3.07-1.03,3.85c-1.35,0.78-3.07,0.32-3.85-1.03L38.39,9.46L38.39,9.46L38.39,9.46z M58.67,2.83 c0-1.56,1.27-2.83,2.83-2.83c1.56,0,2.83,1.27,2.83,2.83v7.24c0,1.56-1.27,2.83-2.83,2.83c-1.56,0-2.83-1.26-2.83-2.83V2.83 L58.67,2.83L58.67,2.83z M79.56,7.23c0.77-1.35,2.49-1.81,3.84-1.04c1.35,0.77,1.81,2.49,1.04,3.84l-3.62,6.27 c-0.77,1.35-2.49,1.81-3.84,1.04c-1.35-0.77-1.81-2.49-1.04-3.84L79.56,7.23L79.56,7.23L79.56,7.23z M95.45,21.48 c1.35-0.78,3.07-0.32,3.85,1.03c0.78,1.35,0.32,3.07-1.03,3.85L92,29.98c-1.35,0.78-3.07,0.32-3.85-1.03 c-0.78-1.35-0.32-3.07,1.03-3.85L95.45,21.48L95.45,21.48L95.45,21.48z M102.08,41.76c1.56,0,2.83,1.27,2.83,2.83 c0,1.56-1.27,2.83-2.83,2.83h-7.24c-1.56,0-2.83-1.26-2.83-2.83s1.26-2.83,2.83-2.83H102.08L102.08,41.76L102.08,41.76z M19.74,46.25c-1.56,0-2.83-1.27-2.83-2.83c0-1.56,1.27-2.83,2.83-2.83h7.24c1.56,0,2.83,1.26,2.83,2.83s-1.27,2.83-2.83,2.83 H19.74L19.74,46.25L19.74,46.25z M24.14,25.35c-1.35-0.77-1.81-2.49-1.04-3.84c0.77-1.35,2.49-1.81,3.84-1.04l6.27,3.62 c1.35,0.77,1.81,2.49,1.04,3.84c-0.77,1.35-2.49,1.81-3.84,1.04L24.14,25.35L24.14,25.35L24.14,25.35z"/></g></svg>`;
  var SUN_ACTIVE_SVG_ICON = `<?xml version="1.0"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
    <path style="text-indent:0;text-align:start;line-height:normal;text-transform:none;block-progression:tb;-inkscape-font-specification:Sans" d="M 16 4 C 9.3844277 4 4 9.3844277 4 16 C 4 22.615572 9.3844277 28 16 28 C 22.615572 28 28 22.615572 28 16 C 28 9.3844277 22.615572 4 16 4 z M 16 6 C 16.389823 6 16.778223 6.0506339 17.15625 6.09375 C 18.631659 7.6568432 21 10.9245 21 16 C 21 21.0755 18.631659 24.343157 17.15625 25.90625 C 16.778223 25.949366 16.389823 26 16 26 C 10.465308 26 6 21.534692 6 16 C 6 10.465308 10.465308 6 16 6 z" overflow="visible" font-family="Sans"/>
</svg>
`;
  var LIGHTING_ENABLED_SVG_ICON = `<?xml version="1.0" encoding="utf-8"?>
<!-- Generated by IcoMoon.io -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="512" height="512" viewBox="0 0 512 512">
<g>
</g>
	<path d="M257.894 156.948c-53.258 0-96.42 43.561-96.42 97.26 0 53.719 43.161 97.249 96.42 97.249 53.197 0 96.379-43.53 96.379-97.25 0-53.698-43.182-97.26-96.379-97.26zM257.894 309.873c-30.464 0-55.163-24.945-55.163-55.665s24.699-55.624 55.163-55.624c30.423 0 55.101 24.904 55.101 55.624s-24.688 55.665-55.101 55.665z" fill="#000000" />
	<path d="M241.808 43.499h32.144v79.575h-32.144v-79.575z" fill="#000000" />
	<path d="M417.209 115.897l-22.723-22.917-55.757 56.279 22.723 22.907z" fill="#000000" />
	<path d="M389.468 238.407h78.899v32.389h-78.899v-32.389z" fill="#000000" />
	<path d="M396.012 416.86l22.723-22.917-55.767-56.259-22.712 22.897z" fill="#000000" />
	<path d="M242.473 388.915h32.144v79.575h-32.144v-79.575z" fill="#000000" />
	<path d="M96.266 396.073l22.722 22.938 55.778-56.289-22.692-22.928z" fill="#000000" />
	<path d="M43.633 240.537h78.879v32.43h-78.879v-32.43z" fill="#000000" />
	<path d="M115.394 93.051l-22.681 22.907 55.757 56.258 22.702-22.917z" fill="#000000" />
</svg>`;
  var ATMOSPHERE_SVG_ICON = `<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path fill="#000000" d="M135.688 18.5c-6.798 74.842-23.842 85.39-107.907 59.656 84.85 52.022 73.57 64.954-6.843 96.938 87.743-10.27 103.29 4.89 70.75 87.594 17.805-27.56 32.5-44.498 46.282-54.47-11.813 28.26-18.345 59.274-18.345 91.813 0 84.184 43.71 157.96 109.656 200.376-41.624-43.834-67.686-102.7-67.686-167.875 0-134.923 109.45-244.405 244.375-244.405 30.92 0 60.76 5.762 88 16.25-38.584-26.87-85.517-42.625-136.064-42.625-55.257 0-106.14 18.802-146.562 50.375 4.627-18.783 17.39-38.073 41.03-60.906C190.18 90.942 153.53 95.634 135.69 18.5zm10.03 77.188c5.67.002 11.428 1.247 16.876 3.874 14.506 6.998 22.72 21.81 22 36.938-10.26 10.87-19.507 22.696-27.594 35.344-9.035 2.753-19.075 2.27-28.25-2.156-19.37-9.343-27.5-32.6-18.156-51.97 6.715-13.92 20.638-22.036 35.125-22.03z"/></svg>`;
  var TEMPLATE6 = `<div class="og-lighing og-options-container">

         <div class="og-option">
           <div class="og-suncontrol"></div>
         </div>        
         
         <div class="og-option og-atmosphere-opacity">
         </div>
         
         <div class="og-option og-simpleskybackground">
         </div>
         
        <div class="og-lighting-emptyline"></div>

         <div class="og-option og-gamma"></div>         
         <div class="og-option og-exposure"></div>
       
        <div class="og-lighting-emptyline"></div>

         <div class="og-option">
         <div class="og-layers">
           <div class="og-caption">Select layer:</div>
           <select id="layers"></select>
         </div>
         </div>

         <div class="og-option og-opacity">
         </div>
         
         <div class="og-option og-night">
         </div>
         
         <div class="og-lighting-emptyline"></div>

         <div class="og-option og-diffuse">
         </div>
      
         <div class="og-option og-ambient">
         </div>

         <div class="og-option og-specular">
         </div>        

    </div>`;
  var ICON_BUTTON_SVG5 = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="256" height="256" viewBox="0 0 256 256" xml:space="preserve">

<defs>
</defs>
<g style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; opacity: 1;" transform="translate(1.4065934065934016 1.4065934065934016) scale(2.81 2.81)" >
	<path d="M 45 68 c -12.682 0 -23 -10.317 -23 -23 c 0 -12.682 10.318 -23 23 -23 c 12.683 0 23 10.318 23 23 C 68 57.683 57.683 68 45 68 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 45 17.556 c -1.657 0 -3 -1.343 -3 -3 V 3 c 0 -1.657 1.343 -3 3 -3 c 1.657 0 3 1.343 3 3 v 11.556 C 48 16.212 46.657 17.556 45 17.556 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 45 90 c -1.657 0 -3 -1.343 -3 -3 V 75.444 c 0 -1.657 1.343 -3 3 -3 c 1.657 0 3 1.343 3 3 V 87 C 48 88.657 46.657 90 45 90 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 14.556 48 H 3 c -1.657 0 -3 -1.343 -3 -3 c 0 -1.657 1.343 -3 3 -3 h 11.556 c 1.657 0 3 1.343 3 3 C 17.556 46.657 16.212 48 14.556 48 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 87 48 H 75.444 c -1.657 0 -3 -1.343 -3 -3 c 0 -1.657 1.343 -3 3 -3 H 87 c 1.657 0 3 1.343 3 3 C 90 46.657 88.657 48 87 48 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 66.527 26.473 c -0.768 0 -1.535 -0.293 -2.121 -0.878 c -1.172 -1.172 -1.172 -3.071 0 -4.243 l 8.171 -8.171 c 1.172 -1.172 3.07 -1.171 4.242 0 c 1.172 1.172 1.172 3.071 0 4.243 l -8.171 8.171 C 68.063 26.18 67.295 26.473 66.527 26.473 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 15.302 77.698 c -0.768 0 -1.536 -0.293 -2.121 -0.879 c -1.172 -1.171 -1.172 -3.071 0 -4.242 l 8.171 -8.171 c 1.171 -1.172 3.071 -1.172 4.242 0 c 1.172 1.171 1.172 3.071 0 4.242 l -8.171 8.171 C 16.837 77.405 16.069 77.698 15.302 77.698 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 23.473 26.473 c -0.768 0 -1.536 -0.293 -2.121 -0.878 l -8.171 -8.171 c -1.172 -1.172 -1.172 -3.071 0 -4.243 c 1.172 -1.172 3.072 -1.171 4.243 0 l 8.171 8.171 c 1.172 1.172 1.172 3.071 0 4.243 C 25.008 26.18 24.24 26.473 23.473 26.473 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
	<path d="M 74.698 77.698 c -0.768 0 -1.535 -0.293 -2.121 -0.879 l -8.171 -8.171 c -1.172 -1.171 -1.172 -3.071 0 -4.242 c 1.172 -1.172 3.07 -1.172 4.242 0 l 8.171 8.171 c 1.172 1.171 1.172 3.071 0 4.242 C 76.233 77.405 75.466 77.698 74.698 77.698 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
</g>
</svg>`;
  var MAX_COLOR = 5;
  var Lighting = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._selectedLayer = null;
      this._toggleBtn = new ToggleButton({
        classList: ["og-map-button", "og-lighting_button"],
        icon: ICON_BUTTON_SVG5
      });
      this._dialog = new Dialog({
        title: "Lighting Parameters",
        visible: false,
        useHide: true,
        top: 60,
        left: 60,
        width: 600
      });
      this._dialog.events.on("visibility", (v4) => {
        this._toggleBtn.setActive(v4);
      });
      this._panel = new View({
        template: TEMPLATE6
      });
      this.$gamma = null;
      this.$exposure = null;
      this.$night = null;
      this.$opacity = null;
      this.$diffuse = null;
      this.$ambient = null;
      this.$specular = null;
      this.$atmosphereOpacity = null;
      this.$simpleSkyBackground = null;
      this._atmosphereMaxOpacity = new Slider({
        label: "Max.opacity",
        max: 5
      });
      this._atmosphereMinOpacity = new Slider({
        label: "Min.opacity",
        max: 5
      });
      this._simpleSkyBackgroundColorOne = new Color({
        label: "Color One"
      });
      this._simpleSkyBackgroundColorTwo = new Color({
        label: "Color Two"
      });
      this._gamma = new Slider({
        label: "Gamma",
        max: 5
      });
      this._exposure = new Slider({
        label: "Exposure",
        max: 5
      });
      this._night = new Slider({
        label: "Nightlight",
        max: 5
      });
      this._opacity = new Slider({
        label: "Opacity",
        max: 1
      });
      this._diffuse_r = new Slider({
        label: "Diffuse R",
        max: MAX_COLOR
      });
      this._diffuse_g = new Slider({
        label: "Diffuse G",
        max: MAX_COLOR
      });
      this._diffuse_b = new Slider({
        label: "Diffuse B",
        max: MAX_COLOR
      });
      this._ambient_r = new Slider({
        label: "Ambient R",
        max: MAX_COLOR
      });
      this._ambient_g = new Slider({
        label: "Ambient G",
        max: MAX_COLOR
      });
      this._ambient_b = new Slider({
        label: "Ambient B",
        max: MAX_COLOR
      });
      this._specular_r = new Slider({
        label: "Specular R",
        max: 0.2
      });
      this._specular_g = new Slider({
        label: "Specular G",
        max: 0.2
      });
      this._specular_b = new Slider({
        label: "Specular B",
        max: 0.2
      });
      this._shininess = new Slider({
        label: "Shininess",
        max: 100
      });
    }
    bindLayer(layer) {
      this._selectedLayer = layer;
      this._opacity.value = layer.opacity;
      this._update();
    }
    oninit() {
      this._toggleBtn.appendTo(this.renderer.div);
      this._dialog.appendTo(this.renderer.div);
      this._panel.appendTo(this._dialog.container);
      if (this._panel.el) {
        this.$atmosphereOpacity = this._panel.el.querySelector(".og-atmosphere-opacity");
        this.$simpleSkyBackground = this._panel.el.querySelector(".og-simpleskybackground");
        this.$gamma = this._panel.el.querySelector(".og-option.og-gamma");
        this.$exposure = this._panel.el.querySelector(".og-option.og-exposure");
        this.$opacity = this._panel.el.querySelector(".og-option.og-opacity");
        this.$diffuse = this._panel.el.querySelector(".og-option.og-diffuse");
        this.$ambient = this._panel.el.querySelector(".og-option.og-ambient");
        this.$specular = this._panel.el.querySelector(".og-option.og-specular");
        this.$night = this._panel.el.querySelector(".og-option.og-night");
      }
      this._toggleBtn.events.on("change", (isActive) => {
        this._dialog.setVisibility(isActive);
      });
      let $suncontrol = this._dialog.select(".og-suncontrol");
      let sunStopBtn = new ToggleButton({
        classList: ["og-suncontrol-button"],
        isActive: true,
        icon: SUN_STOP_SVG_ICON,
        title: "Star/stop the Sun from following the camera"
      });
      sunStopBtn.appendTo($suncontrol);
      let sunActiveBtn = new ToggleButton({
        classList: ["og-suncontrol-button"],
        isActive: true,
        icon: SUN_ACTIVE_SVG_ICON,
        title: "Activate/deactivate the Sun current time positioning"
      });
      sunActiveBtn.appendTo($suncontrol);
      sunStopBtn.events.on("change", (isActive) => {
        const sun = this.planet.renderer.controls.sun;
        if (isActive) {
          sun.start();
        } else {
          sun.stop();
        }
      });
      sunActiveBtn.events.on("change", (isActive) => {
        const sun = this.planet.renderer.controls.sun;
        if (isActive) {
          sun.activate();
        } else {
          sun.deactivate();
        }
      });
      let lightingEnabledBtn = new ToggleButton({
        classList: ["og-suncontrol-button"],
        isActive: this.planet.lightEnabled,
        icon: LIGHTING_ENABLED_SVG_ICON,
        title: "Enable/disable planet lighting"
      });
      lightingEnabledBtn.appendTo($suncontrol);
      lightingEnabledBtn.events.on("change", (isActive) => {
        this.planet.lightEnabled = isActive;
      });
      let atmosphereEnabledBtn = new ToggleButton({
        classList: ["og-suncontrol-button"],
        isActive: this.planet.atmosphereEnabled,
        icon: ATMOSPHERE_SVG_ICON,
        title: "Enable/disable atmosphere scattering"
      });
      atmosphereEnabledBtn.appendTo($suncontrol);
      if (this.planet.atmosphereEnabled) {
        this.$atmosphereOpacity.style.display = "block";
        this.$simpleSkyBackground.style.display = "none";
      } else {
        this.$atmosphereOpacity.style.display = "none";
        this.$simpleSkyBackground.style.display = "flex";
      }
      atmosphereEnabledBtn.events.on("change", (isActive) => {
        this.planet.atmosphereEnabled = isActive;
        if (this.planet.atmosphereEnabled) {
          this.$atmosphereOpacity.style.display = "block";
          this.$simpleSkyBackground.style.display = "none";
        } else {
          this.$atmosphereOpacity.style.display = "none";
          this.$simpleSkyBackground.style.display = "flex";
        }
      });
      this._atmosphereMaxOpacity.appendTo(this.$atmosphereOpacity);
      this._atmosphereMinOpacity.appendTo(this.$atmosphereOpacity);
      this._simpleSkyBackgroundColorOne.appendTo(this.$simpleSkyBackground);
      this._simpleSkyBackgroundColorTwo.appendTo(this.$simpleSkyBackground);
      this._gamma.appendTo(this.$gamma);
      this._exposure.appendTo(this.$exposure);
      this._night.appendTo(this.$night);
      this._opacity.appendTo(this.$opacity);
      this._diffuse_r.appendTo(this.$diffuse);
      this._diffuse_g.appendTo(this.$diffuse);
      this._diffuse_b.appendTo(this.$diffuse);
      this._ambient_r.appendTo(this.$ambient);
      this._ambient_g.appendTo(this.$ambient);
      this._ambient_b.appendTo(this.$ambient);
      this._specular_r.appendTo(this.$specular);
      this._specular_g.appendTo(this.$specular);
      this._specular_b.appendTo(this.$specular);
      this._shininess.appendTo(this.$specular);
      this._gamma.value = this.planet.renderer.gamma;
      this._gamma.events.on("change", (val) => {
        this.planet.renderer.gamma = val;
      });
      this._exposure.value = this.planet.renderer.exposure;
      this._exposure.events.on("change", (val) => {
        this.planet.renderer.exposure = val;
      });
      this._atmosphereMinOpacity.value = this.planet.atmosphereMinOpacity;
      this._atmosphereMinOpacity.events.on("change", (val) => {
        this.planet.atmosphereMinOpacity = val;
      });
      this._atmosphereMaxOpacity.value = this.planet.atmosphereMaxOpacity;
      this._atmosphereMaxOpacity.events.on("change", (val) => {
        this.planet.atmosphereMaxOpacity = val;
        let atmos = this.planet.renderer.controls.Atmosphere;
        atmos.opacity = val;
      });
      let simpleSkyBackgroundControl = this.planet.renderer.controls.SimpleSkyBackground;
      if (simpleSkyBackgroundControl) {
        this._simpleSkyBackgroundColorOne.value = simpleSkyBackgroundControl.colorOne;
        this._simpleSkyBackgroundColorTwo.value = simpleSkyBackgroundControl.colorTwo;
      }
      this._simpleSkyBackgroundColorOne.events.on("input", (val) => {
        let simpleSkyBackgroundControl2 = this.planet.renderer.controls.SimpleSkyBackground;
        if (simpleSkyBackgroundControl2) {
          simpleSkyBackgroundControl2.colorOne = val;
        }
      });
      this._simpleSkyBackgroundColorTwo.events.on("input", (val) => {
        let simpleSkyBackgroundControl2 = this.planet.renderer.controls.SimpleSkyBackground;
        if (simpleSkyBackgroundControl2) {
          simpleSkyBackgroundControl2.colorTwo = val;
        }
      });
      this._panel.el.querySelector("#layers").addEventListener("change", (e9) => {
        const l4 = this.planet.getLayerByName(e9.target.value);
        if (l4) {
          this.bindLayer(l4);
        }
      });
      this._night.events.on("change", (val) => {
        if (this._selectedLayer) {
          this._selectedLayer.nightTextureCoefficient = val;
        }
      });
      this._opacity.events.on("change", (val) => {
        if (this._selectedLayer)
          this._selectedLayer.opacity = val;
      });
      this._ambient_r.events.on("change", (val) => {
        if (this._selectedLayer && this._selectedLayer._ambient)
          this._selectedLayer._ambient[0] = val;
      });
      this._ambient_g.events.on("change", (val) => {
        if (this._selectedLayer && this._selectedLayer._ambient)
          this._selectedLayer._ambient[1] = val;
      });
      this._ambient_b.events.on("change", (val) => {
        if (this._selectedLayer && this._selectedLayer._ambient)
          this._selectedLayer._ambient[2] = val;
      });
      this._diffuse_r.events.on("change", (val) => {
        if (this._selectedLayer && this._selectedLayer._diffuse)
          this._selectedLayer._diffuse[0] = val;
      });
      this._diffuse_g.events.on("change", (val) => {
        if (this._selectedLayer && this._selectedLayer._diffuse)
          this._selectedLayer._diffuse[1] = val;
      });
      this._diffuse_b.events.on("change", (val) => {
        if (this._selectedLayer && this._selectedLayer._diffuse)
          this._selectedLayer._diffuse[2] = val;
      });
      this._specular_r.events.on("change", (val) => {
        if (this._selectedLayer && this._selectedLayer._specular)
          this._selectedLayer._specular[0] = val;
      });
      this._specular_g.events.on("change", (val) => {
        if (this._selectedLayer && this._selectedLayer._specular)
          this._selectedLayer._specular[1] = val;
      });
      this._specular_b.events.on("change", (val) => {
        if (this._selectedLayer && this._selectedLayer._specular)
          this._selectedLayer._specular[2] = val;
      });
      this._shininess.events.on("change", (val) => {
        if (this._selectedLayer && this._selectedLayer._specular)
          this._selectedLayer._specular[3] = val;
      });
      if (this.planet) {
        this.planet.events.on("layeradd", this._onLayerAdd, this);
        this.planet.events.on("layerremove", this._onLayerRemove, this);
      }
      this._fetchLayers();
    }
    _update() {
      let l4 = this._selectedLayer;
      this._opacity.value = l4 && l4.opacity ? l4.opacity : 0;
      this._night.value = l4 && l4.nightTextureCoefficient ? l4.nightTextureCoefficient : this.planet.nightTextureCoefficient;
      let a6 = l4 && l4._ambient ? l4._ambient : this.planet._ambient;
      this._ambient_r.value = a6[0];
      this._ambient_g.value = a6[1];
      this._ambient_b.value = a6[2];
      let d4 = l4 && l4._diffuse ? l4._diffuse : this.planet._diffuse;
      this._diffuse_r.value = d4[0];
      this._diffuse_g.value = d4[1];
      this._diffuse_b.value = d4[2];
      let s7 = l4 && l4._specular ? l4._specular : this.planet._specular;
      this._specular_r.value = s7[0];
      this._specular_g.value = s7[1];
      this._specular_b.value = s7[2];
      this._shininess.value = s7[3];
    }
    _fetchLayers() {
      if (this.planet) {
        for (let i9 = 0; i9 < this.planet.layers.length; i9++) {
          this._onLayerAdd(this.planet.layers[i9]);
        }
      }
    }
    _onLayerAdd(e9) {
      this.bindLayer(e9);
      let opt = document.createElement("option");
      opt.value = e9.name;
      opt.innerText = e9.name;
      this._panel.el.querySelector("#layers").appendChild(opt);
      this._panel.el.querySelector("#layers").value = e9.name;
    }
    _onLayerRemove(e9) {
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/Lock.js
  var Lock = class {
    constructor() {
      this._lock = 0;
    }
    lock(key) {
      this._lock |= 1 << key.id;
    }
    free(key) {
      this._lock &= ~(1 << key.id);
    }
    isFree() {
      return this._lock === 0;
    }
    isLocked() {
      return this._lock !== 0;
    }
  };
  var Key = class _Key {
    constructor() {
      this.__id = _Key.__counter__++;
    }
    get id() {
      return this.__id;
    }
  };
  Key.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/control/MouseNavigation.js
  var MouseNavigation = class _MouseNavigation extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._deactivate = false;
      this._shiftBusy = false;
      this._name = "mouseNavigation";
      this.grabbedPoint = new Vec3();
      this._eye0 = new Vec3();
      this.pointOnEarth = new Vec3();
      this.earthUp = new Vec3();
      this.inertia = 7e-3;
      this.grabbedSpheroid = new Sphere();
      this.qRot = new Quat();
      this.scaleRot = 0;
      this.distDiff = 0.3;
      this.stepsCount = 8;
      this.stepsForward = null;
      this.stepIndex = 0;
      this._lmbDoubleClickActive = true;
      this.minSlope = options2.minSlope || 0.1;
      this._wheelDirection = 1;
      this._keyLock = new Key();
    }
    static getMovePointsFromPixelTerrain(cam, planet, stepsCount, delta, point, forward2, dir) {
      const steps = [];
      let eye = cam.eye.clone(), n7 = cam._b.clone(), u4 = cam._r.clone(), v4 = cam._u.clone();
      let a6 = planet.getCartesianFromPixelTerrain(point);
      if (!a6) {
        a6 = planet.getCartesianFromPixelTerrain(planet.renderer.handler.getCenter());
      }
      if (a6) {
        if (!dir) {
          dir = Vec3.sub(a6, cam.eye).normalize();
        }
        let d4 = delta * cam.eye.distance(a6) / stepsCount;
        if (forward2) {
          d4 = -1.25 * d4;
        } else {
          d4 *= 2;
        }
        const scaled_n = n7.scaleTo(d4);
        const slope = dir.dot(cam.eye.normal().negate());
        if (slope >= 0.1) {
          const grabbedSpheroid = new Sphere();
          grabbedSpheroid.radius = a6.length();
          let rotArr = [], eyeArr = [];
          let breaked = false;
          for (let i9 = 0; i9 < stepsCount; i9++) {
            eye.addA(scaled_n);
            const b4 = new Ray(eye, dir).hitSphere(grabbedSpheroid);
            eyeArr[i9] = eye.clone();
            if (b4) {
              rotArr[i9] = new Mat4().rotateBetweenVectors(a6.normal(), b4.normal());
            } else {
              breaked = true;
              break;
            }
          }
          if (!breaked) {
            for (let i9 = 0; i9 < stepsCount; i9++) {
              let rot = rotArr[i9];
              steps[i9] = {
                eye: rot.mulVec3(eyeArr[i9]),
                v: rot.mulVec3(v4),
                u: rot.mulVec3(u4),
                n: rot.mulVec3(n7)
              };
            }
          } else {
            eye = cam.eye.clone();
            for (let i9 = 0; i9 < stepsCount; i9++) {
              steps[i9] = {
                eye: eye.addA(scaled_n).clone(),
                v: v4,
                u: u4,
                n: n7
              };
            }
          }
        } else {
          for (let i9 = 0; i9 < stepsCount; i9++) {
            steps[i9] = {
              eye: eye.addA(dir.scaleTo(-d4)).clone(),
              v: v4,
              u: u4,
              n: n7
            };
          }
        }
        return steps;
      }
    }
    onactivate() {
      if (this.renderer) {
        this.renderer.events.on("mousewheel", this.onMouseWheel, this);
        this.renderer.events.on("lhold", this.onMouseLeftButtonDown, this);
        this.renderer.events.on("rhold", this.onMouseRightButtonDown, this);
        this.renderer.events.on("ldown", this.onMouseLeftButtonClick, this);
        this.renderer.events.on("lup", this.onMouseLeftButtonUp, this);
        this.renderer.events.on("rdown", this.onMouseRightButtonClick, this);
        this.renderer.events.on("draw", this.onDraw, this, -1e3);
        this.renderer.events.on("mousemove", this.onMouseMove, this);
        this.renderer.events.on("mouseleave", this.onMouseLeave, this);
        this.renderer.events.on("mouseenter", this.onMouseEnter, this);
        if (this._lmbDoubleClickActive) {
          this.renderer.events.on("ldblclick", this.onMouseLeftButtonDoubleClick, this);
        }
      }
    }
    ondeactivate() {
      if (this.renderer) {
        this.renderer.events.off("mousewheel", this.onMouseWheel);
        this.renderer.events.off("lhold", this.onMouseLeftButtonDown);
        this.renderer.events.off("rhold", this.onMouseRightButtonDown);
        this.renderer.events.off("ldown", this.onMouseLeftButtonClick);
        this.renderer.events.off("lup", this.onMouseLeftButtonUp);
        this.renderer.events.off("rdown", this.onMouseRightButtonClick);
        this.renderer.events.off("draw", this.onDraw);
        this.renderer.events.off("ldblclick", this.onMouseLeftButtonDoubleClick);
        this.renderer.events.off("mouseleave", this.onMouseLeave);
        this.renderer.events.off("mouseenter", this.onMouseEnter);
      }
    }
    activateDoubleClickZoom() {
      if (!this._lmbDoubleClickActive) {
        this._lmbDoubleClickActive = true;
        this.renderer && this.renderer.events.on("ldblclick", this.onMouseLeftButtonDoubleClick, this);
      }
    }
    deactivateDoubleClickZoom() {
      if (this._lmbDoubleClickActive) {
        this._lmbDoubleClickActive = false;
        this.renderer && this.renderer.events.off("ldblclick", this.onMouseLeftButtonDoubleClick);
      }
    }
    onMouseEnter(e9) {
      const renderEvents = this.renderer.events;
      if (renderEvents.isKeyPressed(input.KEY_ALT)) {
        renderEvents.releaseKeys();
      }
      renderEvents.updateButtonsStates(e9.sys.buttons);
      if (renderEvents.mouseState.leftButtonDown) {
        this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
      } else {
        this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
      }
    }
    onMouseLeave() {
      if (this.renderer.events.mouseState.leftButtonDown) {
        this.scaleRot = 0;
      }
      this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
    }
    onMouseWheel(e9) {
      if (this.stepIndex) {
        return;
      }
      this.planet.stopFlying();
      this.stopRotation();
      this._deactivate = true;
      this.lockPlanet(true);
      this.stepsForward = _MouseNavigation.getMovePointsFromPixelTerrain(this.planet.camera, this.planet, this.stepsCount, this.distDiff, e9.pos, e9.wheelDelta > 0, e9.direction) || null;
      this._wheelDirection = e9.wheelDelta;
      if (this.stepsForward) {
        this.stepIndex = this.stepsCount;
      }
    }
    oninit() {
      this.activate();
      if (this.renderer) {
        this.renderer.events.on("keyfree", input.KEY_ALT, this.onShiftFree, this);
        this.renderer.events.on("keyfree", input.KEY_PRINTSCREEN, this.onShiftFree, this);
      }
    }
    onMouseLeftButtonDoubleClick(e9) {
      this.planet.stopFlying();
      this.stopRotation();
      const p4 = this.planet.getCartesianFromPixelTerrain(e9.pos);
      if (p4) {
        const cam = this.planet.camera;
        let maxAlt = cam.maxAltitude + this.planet.ellipsoid.polarSize;
        let minAlt = cam.minAltitude + this.planet.ellipsoid.polarSize;
        const camAlt = cam.eye.length();
        const g4 = this.planet.ellipsoid.cartesianToLonLat(p4);
        if (camAlt > maxAlt || camAlt < minAlt) {
          this.planet.flyLonLat(new LonLat(g4.lon, g4.lat));
          return;
        }
        if (this.renderer.events.isKeyPressed(input.KEY_ALT)) {
          this.planet.flyLonLat(new LonLat(g4.lon, g4.lat, cam.eye.distance(p4) * 2));
        } else {
          this.planet.flyLonLat(new LonLat(g4.lon, g4.lat, cam.eye.distance(p4) * 0.57));
        }
      }
    }
    onMouseLeftButtonClick() {
      if (this._active) {
        this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
        this.grabbedPoint = this.planet.getCartesianFromMouseTerrain();
        if (this.grabbedPoint) {
          this._eye0.copy(this.planet.camera.eye);
          this.grabbedSpheroid.radius = this.grabbedPoint.length();
          this.stopRotation();
        }
      }
    }
    stopRotation() {
      this.qRot.clear();
      this.freePlanet();
    }
    onMouseLeftButtonUp(e9) {
      this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
      if (e9.x === e9.prev_x && e9.y === e9.prev_y) {
        this.scaleRot = 0;
      }
    }
    onMouseLeftButtonDown(e9) {
      if (this._active) {
        if (!this.grabbedPoint) {
          return;
        }
        this.planet.stopFlying();
        if (e9.moving) {
          let cam = this.planet.camera;
          if (cam.slope > 0.2) {
            const targetPoint = new Ray(cam.eye, e9.direction).hitSphere(this.grabbedSpheroid);
            if (targetPoint) {
              this.scaleRot = 1;
              this.qRot = Quat.getRotationBetweenVectors(targetPoint.normal(), this.grabbedPoint.normal());
              let rot = this.qRot;
              cam.eye = rot.mulVec3(cam.eye);
              cam._u = rot.mulVec3(cam._u);
              cam._r = rot.mulVec3(cam._r);
              cam._b = rot.mulVec3(cam._b);
            }
          } else {
            let p0 = this.grabbedPoint, p1 = Vec3.add(p0, cam._r), p22 = Vec3.add(p0, p0.normal());
            let px = new Vec3();
            if (new Ray(cam.eye, e9.direction).hitPlane(p0, p1, p22, px) === Ray.INSIDE) {
              cam.eye = this._eye0.addA(px.subA(p0).negate());
            }
          }
        }
      }
    }
    onMouseRightButtonClick(e9) {
      this.stopRotation();
      this.planet.stopFlying();
      this.pointOnEarth = this.planet.getCartesianFromPixelTerrain(e9.pos);
      if (this.pointOnEarth) {
        this.earthUp = this.pointOnEarth.normal();
      }
    }
    onMouseRightButtonDown(e9) {
      const cam = this.planet.camera;
      if (this.pointOnEarth && e9.moving) {
        this.renderer.controlsBag.scaleRot = 1;
        let l4 = 0.5 / cam.eye.distance(this.pointOnEarth) * cam._lonLat.height * RADIANS;
        if (l4 > 7e-3) {
          l4 = 7e-3;
        } else if (l4 < 3e-3) {
          l4 = 3e-3;
        }
        cam.rotateHorizontal(l4 * (e9.x - e9.prev_x), false, this.pointOnEarth, this.earthUp);
        cam.rotateVertical(l4 * (e9.y - e9.prev_y), this.pointOnEarth, this.minSlope);
      }
    }
    onShiftFree() {
      this._shiftBusy = false;
    }
    onMouseMove(e9) {
      if (this._active && this.renderer.events.isKeyPressed(input.KEY_ALT)) {
        if (!this._shiftBusy) {
          this._shiftBusy = true;
          this.onMouseRightButtonClick(e9);
        }
        this.onMouseRightButtonDown(e9);
      }
    }
    onDraw() {
      if (this._active) {
        const r8 = this.renderer;
        const cam = this.planet.camera;
        let prevEye = cam.eye.clone();
        if (this.stepIndex) {
          r8.controlsBag.scaleRot = 1;
          const sf = this.stepsForward[this.stepsCount - this.stepIndex--];
          cam.eye = sf.eye;
          cam._u = sf.v;
          cam._r = sf.u;
          cam._b = sf.n;
        } else {
          if (this._deactivate) {
            this._deactivate = false;
            this.freePlanet();
          }
        }
        if (r8.events.mouseState.leftButtonDown || !this.scaleRot) {
          return;
        }
        this.scaleRot -= this.inertia;
        if (this.scaleRot <= 0) {
          this.scaleRot = 0;
        } else {
          r8.controlsBag.scaleRot = this.scaleRot;
          let rot = this.qRot.slerp(Quat.IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot).normalize();
          if (!(rot.x || rot.y || rot.z)) {
            this.scaleRot = 0;
          }
          cam.eye = rot.mulVec3(cam.eye);
          cam._u = rot.mulVec3(cam._u);
          cam._r = rot.mulVec3(cam._r);
          cam._b = rot.mulVec3(cam._b);
        }
        if (cam.eye.distance(prevEye) / cam.getAltitude() > 0.01) {
          this.lockPlanet();
        } else {
          this.freePlanet();
        }
      }
    }
    lockPlanet(skipTerrain) {
      this.planet.layerLock.lock(this._keyLock);
      !skipTerrain && this.planet.terrainLock.lock(this._keyLock);
      this.planet._normalMapCreator.lock(this._keyLock);
    }
    freePlanet() {
      this.planet.layerLock.free(this._keyLock);
      this.planet.terrainLock.free(this._keyLock);
      this.planet._normalMapCreator.free(this._keyLock);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/MouseWheelZoomControl.js
  var MouseWheelZoomControl = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._name = "MouseWheelZoomControl";
      this.grabbedPoint = new Vec3();
      this._eye0 = new Vec3();
      this.pointOnEarth = new Vec3();
      this.earthUp = new Vec3();
      this.inertia = 7e-3;
      this.grabbedSpheroid = new Sphere();
      this.planet = null;
      this.qRot = new Quat();
      this.scaleRot = 0;
      this.distDiff = 0.3;
      this.stepsCount = 8;
      this.stepsForward = null;
      this.stepIndex = 0;
      this._lmbDoubleClickActive = true;
      this.minSlope = options2.minSlope || 0.1;
      this._keyLock = new Key();
      this._deactivate = false;
      this._move = 0;
    }
    oninit() {
      let zoomDiv = document.createElement("div"), btnZoomIn = document.createElement("button"), btnZoomOut = document.createElement("button");
      zoomDiv.className = "ogZoomControl";
      btnZoomIn.className = "ogZoomButton ogZoomIn";
      btnZoomOut.className = "ogZoomButton ogZoomOut";
      zoomDiv.appendChild(btnZoomIn);
      zoomDiv.appendChild(btnZoomOut);
      this.renderer.div.appendChild(zoomDiv);
      btnZoomIn.addEventListener("mousedown", () => this.zoomIn());
      btnZoomIn.addEventListener("mouseup", () => this.stopZoom());
      btnZoomOut.addEventListener("mousedown", () => this.zoomOut());
      btnZoomOut.addEventListener("mouseup", () => this.stopZoom());
      btnZoomIn.addEventListener("touchstart", (e9) => {
        e9.preventDefault();
        this.zoomIn();
      });
      btnZoomIn.addEventListener("touchend", (e9) => {
        e9.preventDefault();
        this.stopZoom();
      });
      btnZoomIn.addEventListener("touchcancel", (e9) => {
        e9.preventDefault();
        this.stopZoom();
      });
      btnZoomOut.addEventListener("touchstart", (e9) => {
        e9.preventDefault();
        this.zoomOut();
      });
      btnZoomOut.addEventListener("touchend", (e9) => {
        e9.preventDefault();
        this.stopZoom();
      });
      btnZoomOut.addEventListener("touchcancel", (e9) => {
        e9.preventDefault();
        this.stopZoom();
      });
      this.renderer.events.on("draw", this._draw, this);
    }
    /**
     * Planet zoom in.
     * @public
     */
    zoomIn() {
      if (this.stepIndex) {
        return;
      }
      this.planet.stopFlying();
      this.stopRotation();
      this._deactivate = true;
      this.planet.layerLock.lock(this._keyLock);
      this.planet.terrainLock.lock(this._keyLock);
      this.planet._normalMapCreator.lock(this._keyLock);
      this.stepsForward = MouseNavigation.getMovePointsFromPixelTerrain(this.planet.camera, this.planet, this.stepsCount, this.distDiff, this.renderer.handler.getCenter(), true, null) || null;
      if (this.stepsForward) {
        this.stepIndex = this.stepsCount;
      }
    }
    /**
     * Planet zoom out.
     * @public
     */
    zoomOut() {
      if (this.stepIndex) {
        return;
      }
      this.planet.stopFlying();
      this.stopRotation();
      this._deactivate = true;
      this.planet.layerLock.lock(this._keyLock);
      this.planet.terrainLock.lock(this._keyLock);
      this.planet._normalMapCreator.lock(this._keyLock);
      this.stepsForward = MouseNavigation.getMovePointsFromPixelTerrain(this.planet.camera, this.planet, this.stepsCount, this.distDiff, this.renderer.handler.getCenter(), false, null) || null;
      if (this.stepsForward) {
        this.stepIndex = this.stepsCount;
      }
    }
    stopRotation() {
      this.qRot.clear();
      this.planet.layerLock.free(this._keyLock);
      this.planet.terrainLock.free(this._keyLock);
      this.planet._normalMapCreator.free(this._keyLock);
    }
    stopZoom() {
      this._move = 0;
      this.planet.layerLock.free(this._keyLock);
      this.planet.terrainLock.free(this._keyLock);
      this.planet._normalMapCreator.free(this._keyLock);
    }
    _draw() {
      if (this._active) {
        let r8 = this.renderer;
        let cam = this.planet.camera;
        let prevEye = cam.eye.clone();
        if (this.stepIndex) {
          r8.controlsBag.scaleRot = 1;
          let sf = this.stepsForward[this.stepsCount - this.stepIndex--];
          let maxAlt = cam.maxAltitude + this.planet.ellipsoid.equatorialSize;
          let minAlt = cam.minAltitude + this.planet.ellipsoid.equatorialSize;
          const camAlt = sf.eye.length();
          if (camAlt > maxAlt || camAlt < minAlt) {
            return;
          }
          cam.eye = sf.eye;
          cam._u = sf.v;
          cam._r = sf.u;
          cam._b = sf.n;
          cam.checkTerrainCollision();
          cam.update();
        } else {
          if (this._deactivate) {
            this._deactivate = false;
            this.planet.layerLock.free(this._keyLock);
            this.planet.terrainLock.free(this._keyLock);
            this.planet._normalMapCreator.free(this._keyLock);
          }
        }
        if (r8.events.mouseState.leftButtonDown || !this.scaleRot) {
          return;
        }
        this.scaleRot -= this.inertia;
        if (this.scaleRot <= 0) {
          this.scaleRot = 0;
        } else {
          r8.controlsBag.scaleRot = this.scaleRot;
          let rot = this.qRot.slerp(Quat.IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot).normalize();
          if (!(rot.x || rot.y || rot.z)) {
            this.scaleRot = 0;
          }
          cam.eye = rot.mulVec3(cam.eye);
          cam._u = rot.mulVec3(cam._u);
          cam._r = rot.mulVec3(cam._r);
          cam._b = rot.mulVec3(cam._b);
          cam.checkTerrainCollision();
          cam.update();
        }
        if (cam.eye.distance(prevEye) / cam.getAltitude() > 0.01) {
          this.planet.layerLock.lock(this._keyLock);
          this.planet.terrainLock.lock(this._keyLock);
          this.planet._normalMapCreator.lock(this._keyLock);
        } else {
          this.planet.layerLock.free(this._keyLock);
          this.planet.terrainLock.free(this._keyLock);
          this.planet._normalMapCreator.free(this._keyLock);
        }
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/ruler/RulerScene.js
  var OUTLINE_COUNT = 120;
  var distanceFormat = (v4) => {
    if (v4 > 1e3) {
      return `${(v4 / 1e3).toFixed(1)} km`;
    } else if (v4 > 9) {
      return `${Math.round(v4)} m`;
    } else {
      return `${v4.toFixed(1)} m`;
    }
  };
  var obj3d = Object3d.createCylinder(1.1, 0, 2.7, 20, 1, true, false, 0, 0, 0);
  var LABEL_OPTIONS = {
    text: "",
    size: 11,
    color: "rgba(455,455,455,1.0)",
    outlineColor: "rgba(0,0,0,0.34)",
    outline: 0.23,
    align: "center",
    offset: [0, 20, 0]
  };
  var RULER_CORNER_OPTIONS = {
    scale: 1,
    instanced: true,
    tag: "ruler",
    color: "rgb(0,305,0)",
    object3d: obj3d
  };
  var RulerScene = class extends RenderNode {
    constructor(options2 = {}) {
      super(options2.name);
      this._onCornerLdown = (e9) => {
        if (!this._startLonLat) {
          this.renderer?.controls.mouseNavigation?.deactivate();
          this._startClick.set(e9.x, e9.y);
          let coords = e9.pickingObject.getCartesian();
          this._startPos = this._planet.getPixelFromCartesian(coords);
          this._pickedCorner = e9.pickingObject;
          if (e9.pickingObject.properties.name == "start") {
            this._anchorLonLat = this._cornerEntity[1].getLonLat().clone();
          } else {
            this._anchorLonLat = this._cornerEntity[0].getLonLat().clone();
          }
        }
      };
      this._onLUp = () => {
        if (this._pickedCorner) {
          this.renderer.controls.mouseNavigation?.activate();
          this._pickedCorner = null;
          this._anchorLonLat = null;
        }
      };
      this._onCornerLup = () => {
        this._onLUp();
      };
      this._onCornerEnter = (e9) => {
        e9.renderer.handler.canvas.style.cursor = "pointer";
      };
      this._onCornerLeave = (e9) => {
        e9.renderer.handler.canvas.style.cursor = "default";
      };
      this._onLdblclick = () => {
        this._preventClick = true;
      };
      this._onLclick = (e9) => {
        let startLonLat = this._planet.getLonLatFromPixelTerrain(e9.pos);
        if (!startLonLat)
          return;
        this._timeout = setTimeout(() => {
          if (!this._preventClick) {
            if (!this._startLonLat) {
              this.setVisibility(true);
              this._stopDrawing = false;
              this._startLonLat = startLonLat;
            } else {
              this._startLonLat = null;
            }
          }
          this._preventClick = false;
          this._stopDrawing = false;
          clearTimeout(this._timeout);
        }, 200);
        if (this._startLonLat) {
          this._stopDrawing = true;
        }
      };
      this._onMouseMove = (e9) => {
        if (this._startLonLat && !this._stopDrawing) {
          this._propsLabel.label.setVisibility(true);
          let endLonLat = this._planet.getLonLatFromPixelTerrain(e9.pos);
          if (!endLonLat)
            return;
          this._drawLine(this._startLonLat, endLonLat);
        } else if (this._pickedCorner) {
          let newLonLat = this._planet.getLonLatFromPixelTerrain(e9.pos);
          if (newLonLat) {
            if (this._pickedCorner.properties.name === "start") {
              this._drawLine(newLonLat, this._anchorLonLat);
            } else {
              this._drawLine(this._anchorLonLat, newLonLat);
            }
          }
        }
      };
      this.events = createEvents(RULERSCENE_EVENTS);
      this._ignoreTerrain = options2.ignoreTerrain != void 0 ? options2.ignoreTerrain : true;
      this._planet = options2.planet || null;
      this._startLonLat = null;
      this._preventClick = false;
      this._stopDrawing = false;
      this._pickedCorner = null;
      this._startPos = null;
      this._startClick = new Vec2();
      this._anchorLonLat = null;
      this._heading = 0;
      this._trackLayer = new Vector("track", {
        entities: [],
        pickingEnabled: false,
        polygonOffsetUnits: -1,
        relativeToGround: true,
        hideInLayerSwitcher: true
      });
      this._labelLayer = new Vector("ruler-label", {
        entities: [],
        pickingEnabled: false,
        polygonOffsetUnits: -100,
        relativeToGround: true,
        hideInLayerSwitcher: true
      });
      this._cornersLayer = new Vector("corners", {
        entities: [],
        pickingEnabled: true,
        hideInLayerSwitcher: true,
        scaleByDistance: [100, 4e6, 1],
        pickingScale: 2
      });
      this._propsLabel = new Entity({
        name: "propsLabel",
        label: LABEL_OPTIONS
      });
      this._trackEntity = new Entity({
        polyline: {
          path3v: [],
          thickness: 4.8,
          color: "rgb(255,131,0)",
          isClosed: false
        }
      });
      this._trackEntity.polyline.altitude = 0.01;
      this._cornerEntity = [
        new Entity({
          geoObject: RULER_CORNER_OPTIONS,
          properties: {
            name: "start"
          }
        }),
        new Entity({
          geoObject: RULER_CORNER_OPTIONS,
          properties: {
            name: "end"
          }
        })
      ];
    }
    set ignoreTerrain(v4) {
      this._ignoreTerrain = v4;
      if (v4) {
      }
    }
    bindPlanet(planet) {
      this._planet = planet;
    }
    _createCorners() {
      this._cornersLayer.addEntities(this._cornerEntity);
    }
    init() {
      this._createCorners();
      this._trackLayer.addEntities([this._trackEntity]);
      this._labelLayer.addEntities([this._propsLabel]);
      this._planet.addLayer(this._labelLayer);
      this._planet.addLayer(this._trackLayer);
      this._planet.addLayer(this._cornersLayer);
      this._activate();
    }
    onremove() {
      this._deactivate();
    }
    _activate() {
      this._propsLabel.label.setVisibility(false);
      this.setVisibility(false);
      this.renderer.events.on("lclick", this._onLclick, this);
      this.renderer.events.on("mousemove", this._onMouseMove, this);
      this.renderer.events.on("ldblclick", this._onLdblclick, this);
      this.renderer.events.on("lup", this._onLUp, this);
      this._cornersLayer.events.on("mouseenter", this._onCornerEnter, this);
      this._cornersLayer.events.on("mouseleave", this._onCornerLeave, this);
      this._cornersLayer.events.on("ldown", this._onCornerLdown, this);
      this._cornersLayer.events.on("lup", this._onCornerLup, this);
    }
    _deactivate() {
      this._startLonLat = null;
      this._preventClick = false;
      this._stopDrawing = false;
      this._pickedCorner = null;
      this.renderer.events.off("lclick", this._onLclick);
      this.renderer.events.off("mousemove", this._onMouseMove);
      this.renderer.events.off("lup", this._onLUp);
      this._cornersLayer.events.off("mouseenter", this._onCornerEnter);
      this._cornersLayer.events.off("mouseleave", this._onCornerLeave);
      this._cornersLayer.events.off("ldown", this._onCornerLdown);
      this._cornersLayer.events.off("lup", this._onCornerLup);
      this.clear();
    }
    setVisibility(visibility) {
      this._cornersLayer.setVisibility(visibility);
      this._trackLayer.setVisibility(visibility);
      this._labelLayer.setVisibility(visibility);
    }
    _drawLine(startLonLat, endLonLat, startPos) {
      if (!startPos) {
        startPos = this._planet.ellipsoid.lonLatToCartesian(startLonLat);
      }
      let endPos = this._planet.ellipsoid.lonLatToCartesian(endLonLat);
      let res = this._planet.ellipsoid.inverse(startLonLat, endLonLat);
      let length = res.distance;
      this._heading = res.initialAzimuth;
      let path = [];
      let dir = endPos.sub(startPos);
      let dist = dir.length();
      dir.normalize();
      for (let i9 = 0; i9 < OUTLINE_COUNT; i9++) {
        let f8 = dir.scaleTo(i9 * dist / OUTLINE_COUNT).addA(startPos);
        path.push(f8);
      }
      path.push(endPos);
      this._trackEntity.polyline.setPath3v([path]);
      if (this._ignoreTerrain) {
        this._propsLabel.setCartesian3v(path[Math.floor(path.length / 2)]);
        this._propsLabel.label.setText(`${distanceFormat(length)}, ${Math.round(this._heading)} deg`);
      }
    }
    clear() {
      this._trackEntity.remove();
      this._cornerEntity[0].remove();
      this._cornerEntity[1].remove();
      this._propsLabel.remove();
      this._planet.removeLayer(this._trackLayer);
      this._planet.removeLayer(this._cornersLayer);
    }
    isCornersPositionChanged() {
      let t9 = this._trackEntity.polyline.getPath3v()[0];
      if (t9) {
        const startPos = t9[0].clone(), endPos = t9[t9.length - 1].clone();
        return this._cornerEntity[0].getCartesian().equal(startPos) && this._cornerEntity[1].getCartesian().equal(endPos);
      }
      return false;
    }
    frame() {
      let t9 = this._trackEntity.polyline.getPath3v()[0];
      if (t9) {
        const startPos = t9[0].clone(), endPos = t9[t9.length - 1].clone();
        if (!this.isCornersPositionChanged()) {
          this._cornerEntity[0].setCartesian3v(startPos);
          this._cornerEntity[1].setCartesian3v(endPos);
          if (!this._ignoreTerrain) {
            let res = 0;
            for (let i9 = 0, len = t9.length - 1; i9 < len; i9++) {
              res += t9[i9 + 1].distance(t9[i9]);
            }
            this._propsLabel.setCartesian3v(t9[Math.floor(t9.length / 2)]);
            this._propsLabel.label.setText(`${distanceFormat(res)}, ${Math.round(this._heading)} deg`);
          }
        }
      }
    }
    get ellipsoid() {
      return this._planet ? this._planet.ellipsoid : null;
    }
  };
  var RULERSCENE_EVENTS = [
    "add",
    "remove",
    "mousemove",
    "mouseenter",
    "mouseleave",
    "lclick",
    "rclick",
    "mclick",
    "ldblclick",
    "rdblclick",
    "mdblclick",
    "lup",
    "rup",
    "mup",
    "ldown",
    "rdown",
    "mdown",
    "lhold",
    "rhold",
    "mhold",
    "mousewheel",
    "touchmove",
    "touchstart",
    "touchend",
    "doubletouch",
    "touchleave",
    "touchenter"
  ];

  // frontend/node_modules/@openglobus/og/lib/js/control/ruler/Ruler.js
  var Ruler = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._rulerScene = new RulerScene({
        name: `rulerScene:${this.__id}`,
        ignoreTerrain: options2.ignoreTerrain
      });
    }
    set ignoreTerrain(v4) {
      this._rulerScene.ignoreTerrain = v4;
    }
    oninit() {
      this._rulerScene.bindPlanet(this.planet);
    }
    onactivate() {
      this.renderer && this.renderer.addNode(this._rulerScene);
    }
    ondeactivate() {
      this.renderer && this.renderer.removeNode(this._rulerScene);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/heightRuler/HeightRulerScene.js
  var obj3d2 = Object3d.createCylinder(1.1, 0, 2, 6, 1, true, true, 0, 0, 0);
  var RAYS_OPTIONS = {
    startColor: "rgb(255,131,0)",
    endColor: "rgb(255,131,0)",
    thickness: 5
  };
  var LABEL_OPTIONS2 = {
    text: "",
    size: 11,
    color: "rgba(455,455,455,1.0)",
    outlineColor: "rgba(0,0,0,0.34)",
    outline: 0.23,
    align: "center",
    offset: [0, 18, 0]
  };
  var RULER_CORNER_OPTIONS2 = {
    scale: 1,
    instanced: true,
    tag: "height-ruler",
    color: "rgb(255,131,0)",
    object3d: obj3d2
  };
  var HeightRulerScene = class extends RulerScene {
    constructor(options2 = {}) {
      super(options2);
      this._geoRulerLayer = new Vector("rayHeightRuler", {
        entities: [],
        pickingEnabled: false,
        polygonOffsetUnits: -2,
        relativeToGround: false,
        hideInLayerSwitcher: true
      });
      this._rayV = new Entity({
        name: "verticalRay",
        ray: RAYS_OPTIONS
      });
      this._rayH = new Entity({
        name: "heightRay",
        ray: RAYS_OPTIONS
      });
      this._heightLabels = [
        new Entity({
          name: "startCornerLabel",
          label: {
            ...LABEL_OPTIONS2
          }
        }),
        new Entity({
          name: "endCornerLabel",
          label: {
            ...LABEL_OPTIONS2
          }
        }),
        new Entity({
          name: "deltaLabel",
          label: {
            ...LABEL_OPTIONS2
          }
        })
      ];
    }
    setVisibility(visibility) {
      super.setVisibility(visibility);
      this._geoRulerLayer.setVisibility(visibility);
    }
    get deltaLabel() {
      return this._heightLabels[2];
    }
    get startLabel() {
      return this._heightLabels[0];
    }
    get endLabel() {
      return this._heightLabels[1];
    }
    get corners() {
      return this._cornerEntity;
    }
    get startCorner() {
      return this.corners[0];
    }
    get endCorner() {
      return this.corners[1];
    }
    get startCornerLonLat() {
      return this.startCorner.getLonLat();
    }
    get startCornerHeight() {
      return this.startCornerLonLat.height;
    }
    get endCornerLonLat() {
      return this.endCorner.getLonLat();
    }
    get endCornerHeight() {
      return this.endCornerLonLat.height;
    }
    get maxHeightCornerLonLat() {
      if (this.startCornerHeight <= this.endCornerHeight) {
        return this.endCornerLonLat;
      } else {
        return this.startCornerLonLat;
      }
    }
    get minHeightCornerLonLat() {
      if (this.startCornerHeight > this.endCornerHeight) {
        return this.endCornerLonLat;
      } else {
        return this.startCornerLonLat;
      }
    }
    get deltaHeight() {
      return Math.abs(this.startCornerHeight - this.endCornerHeight);
    }
    _drawLine(startLonLat, endLonLat, startPos) {
      super._drawLine(startLonLat, endLonLat, startPos);
      this._updateHeightRaysAndLabels();
    }
    async _updateHeightRaysAndLabels() {
      const middleLonLat = this.minHeightCornerLonLat.clone();
      middleLonLat.height = this.maxHeightCornerLonLat.height;
      this._rayH.ray.setStartPosition3v(this._planet.ellipsoid.lonLatToCartesian(this.maxHeightCornerLonLat));
      this._rayH.ray.setEndPosition3v(this._planet.ellipsoid.lonLatToCartesian(middleLonLat));
      this._rayV.ray.setStartPosition3v(this._planet.ellipsoid.lonLatToCartesian(this.minHeightCornerLonLat));
      this._rayV.ray.setEndPosition3v(this._planet.ellipsoid.lonLatToCartesian(middleLonLat));
      middleLonLat.height = this.minHeightCornerLonLat.height + this.deltaHeight / 2;
      this.deltaLabel.setLonLat(middleLonLat);
      this.startLabel.setLonLat(this.startCornerLonLat);
      this.endLabel.setLonLat(this.endCornerLonLat);
      const startHeight = await this._planet.getHeightDefault(this.startCornerLonLat), endHeight = await this._planet.getHeightDefault(this.endCornerLonLat);
      this.deltaLabel.label.setText(`\u0394 ${Math.abs(startHeight - endHeight).toFixed(1)} m`);
      this.startLabel.label.setText(`P1 ${startHeight.toFixed(1)} m`);
      this.endLabel.label.setText(`P2 ${endHeight.toFixed(1)} m`);
    }
    clear() {
      this._rayH.remove();
      this._rayV.remove();
      this.startCorner.remove();
      this.endCorner.remove();
      this.startLabel.remove();
      this.endLabel.remove();
      this.deltaLabel.remove();
      super.clear();
      this._planet.removeLayer(this._geoRulerLayer);
    }
    _createCorners() {
      this._cornerEntity = [
        new Entity({
          geoObject: RULER_CORNER_OPTIONS2,
          properties: {
            name: "start"
          }
        }),
        new Entity({
          geoObject: RULER_CORNER_OPTIONS2,
          properties: {
            name: "end"
          }
        })
      ];
      this._cornersLayer.setEntities(this._cornerEntity);
    }
    init() {
      super.init();
      this._createCorners();
      this._labelLayer.addEntities(this._heightLabels);
      this._geoRulerLayer.addEntities([this._rayH, this._rayV]);
      this._planet.addLayer(this._geoRulerLayer);
    }
    frame() {
      super.frame();
      this._updateHeightRaysAndLabels();
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/heightRuler/HeightRuler.js
  var HeightRuler = class extends Ruler {
    constructor(options2 = {}) {
      super(options2);
      this._rulerScene = new HeightRulerScene({
        name: `heightRulerScene:${this.__id}`,
        ignoreTerrain: false
      });
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/RulerSwitcher.js
  var ICON_BUTTON_SVG6 = `<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg fill="#000000" height="800px" width="800px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 512 512" xml:space="preserve">
<g>
	<g>
		<path d="M369.151,0L0.001,369.15L142.85,512l369.149-369.15L369.151,0z M47.286,369.15l10.908-10.908l47.782,47.782l23.642-23.642
			L81.837,334.6l10.909-10.909l23.711,23.711L140.1,323.76l-23.711-23.711l10.909-10.909l23.711,23.711l23.642-23.642
			l-23.711-23.711l10.909-10.909l47.782,47.782l23.642-23.642l-47.782-47.782l10.908-10.908l23.71,23.71l23.642-23.642l-23.71-23.71
			l10.908-10.908l23.711,23.711l23.642-23.642l-23.711-23.711l10.909-10.909l47.782,47.782l23.642-23.642l-47.782-47.782
			l10.908-10.908l23.71,23.711l23.642-23.642l-23.711-23.71L334.6,81.837l23.711,23.71l23.642-23.642l-23.711-23.712l10.908-10.908
			l95.564,95.564L142.85,464.714L47.286,369.15z"/>
	</g>
</g>
</svg>`;
  var RulerSwitcher = class extends Control {
    constructor(options2 = {}) {
      super({
        name: "RulerSwitcher",
        ...options2
      });
      this.ruler = new HeightRuler({
        ignoreTerrain: options2.ignoreTerrain
      });
    }
    oninit() {
      this.planet.addControl(this.ruler);
      this._createMenuBtn();
    }
    onactivate() {
      this.ruler.activate();
    }
    ondeactivate() {
      this.ruler.deactivate();
    }
    _createMenuBtn() {
      let btn = new ToggleButton({
        classList: ["og-map-button", "og-ruler_button"],
        icon: ICON_BUTTON_SVG6
      });
      btn.appendTo(this.renderer.div);
      btn.events.on("change", (isActive) => {
        if (isActive) {
          this.onactivate();
        } else {
          this.ondeactivate();
        }
      });
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/ScaleControl.js
  var scale = [
    1,
    2,
    3,
    5,
    10,
    20,
    30,
    50,
    100,
    200,
    300,
    500,
    1e3,
    2e3,
    3e3,
    5e3,
    1e4,
    2e4,
    3e4,
    5e4,
    1e5,
    2e5,
    3e5,
    5e5,
    1e6,
    2e6,
    3e6,
    5e6,
    1e7
  ];
  var TEMPLATE7 = `<div class="og-scale-container">
      <div class="og-scale-label"></div>
      <div class="og-scale-ruler"></div>
    </div>`;
  var ScaleControl = class extends Control {
    constructor(options2 = {}) {
      if (!options2.name || options2.name === "") {
        options2.name = "scaleControl";
      }
      super(options2);
      this._template = TEMPLATE7;
      this._minWidth = 100;
      this._maxWidth = 150;
      this._isCenter = options2.isCenter != void 0 ? options2.isCenter : true;
      this._mPx = 0;
      this.currWidth = 0;
      this._metersInMinSize = 0;
      this.el = null;
      this._scaleLabelEl = null;
    }
    _renderTemplate() {
      return parseHTML(this._template)[0];
    }
    oninit() {
      this.el = this._renderTemplate();
      this._scaleLabelEl = this.el.querySelector(".og-scale-label");
      this.renderer.div.appendChild(this.el);
      if (this._isCenter) {
        this.planet.camera.events.on("moveend", () => {
          this._drawScreen(this.planet.renderer.handler.getCenter());
        });
        !this.planet.terrain.isEmpty && this.planet.terrain.events.on("loadend", () => {
          this._drawScreen(this.planet.renderer.handler.getCenter());
        });
      } else {
        this.renderer.events.on("mousemove", (e9) => {
          if (!e9.leftButtonHold && !e9.rightButtonHold) {
            this._drawScreen(e9.pos);
          }
        });
        this.planet.camera.events.on("moveend", () => {
          let ms2 = this.renderer.events.mouseState;
          if (!ms2.leftButtonHold && !ms2.rightButtonHold) {
            this._drawScreen(ms2.pos);
          }
        });
      }
    }
    _drawScreen(px) {
      let cam = this.planet.camera;
      let s0 = px;
      let dist = this.planet.getDistanceFromPixel(s0) || 0;
      if (dist === 0) {
        s0 = cam.project(Vec3.ZERO);
        dist = this.planet.getDistanceFromPixel(s0) || 0;
      }
      let p0 = cam.getForward().scaleTo(dist).addA(cam.eye);
      let tempSize = dist * Math.tan(cam.viewAngle * RADIANS);
      let p1 = p0.add(cam.getRight().scaleTo(tempSize));
      let s1 = cam.project(p1);
      this._mPx = tempSize / s1.distance(s0);
      let metersInMinSize = this._mPx * this._minWidth;
      let index = binarySearch(scale, metersInMinSize, (a6, b4) => a6 - b4);
      if (index < 0) {
        index = ~index;
      }
      let minMeters = scale[index], maxMeters = scale[index + 1];
      let t9 = (minMeters - metersInMinSize) / (maxMeters - minMeters);
      this.currWidth = this._minWidth + t9 * (this._maxWidth - this._minWidth);
      if (minMeters > 1e3) {
        this._scaleLabelEl.innerText = `${minMeters / 1e3} km`;
      } else {
        this._scaleLabelEl.innerText = `${minMeters} m`;
      }
      this._metersInMinSize = metersInMinSize;
      this.el.style.width = this.currWidth + "px";
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/ShowFps.js
  var ShowFps = class extends Control {
    constructor(options2) {
      super(options2);
    }
    oninit() {
      let d4 = document.createElement("div");
      d4.className = "defaultText ";
      d4.id = "ogShowFpsControl";
      document.body.appendChild(d4);
      this.renderer.events.on("draw", this._draw, this);
    }
    _draw() {
      print2d("ogShowFpsControl", (1e3 / this.renderer.handler.deltaTime).toFixed(1), this.renderer.handler.canvas.clientWidth - 60, 0);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/SimpleNavigation.js
  var SimpleNavigation = class extends Control {
    constructor(options2 = {}) {
      super({
        name: "SimpleNavigation",
        autoActivate: true,
        ...options2
      });
      this.speed = options2.speed || 1;
    }
    oninit() {
    }
    onactivate() {
      super.onactivate();
      let r8 = this.renderer;
      r8.events.on("keypress", input.KEY_W, this.onCameraMoveForward, this);
      r8.events.on("keypress", input.KEY_S, this.onCameraMoveBackward, this);
      r8.events.on("keypress", input.KEY_A, this.onCameraStrifeLeft, this);
      r8.events.on("keypress", input.KEY_D, this.onCameraStrifeRight, this);
      r8.events.on("keypress", input.KEY_UP, this.onCameraLookUp, this);
      r8.events.on("keypress", input.KEY_DOWN, this.onCameraLookDown, this);
      r8.events.on("keypress", input.KEY_LEFT, this.onCameraTurnLeft, this);
      r8.events.on("keypress", input.KEY_RIGHT, this.onCameraTurnRight, this);
      r8.events.on("keypress", input.KEY_Q, this.onCameraRollLeft, this);
      r8.events.on("keypress", input.KEY_E, this.onCameraRollRight, this);
    }
    ondeactivate() {
      super.ondeactivate();
      let r8 = this.renderer;
      r8.events.off("keypress", input.KEY_W, this.onCameraMoveForward);
      r8.events.off("keypress", input.KEY_S, this.onCameraMoveBackward);
      r8.events.off("keypress", input.KEY_A, this.onCameraStrifeLeft);
      r8.events.off("keypress", input.KEY_D, this.onCameraStrifeRight);
      r8.events.off("keypress", input.KEY_UP, this.onCameraLookUp);
      r8.events.off("keypress", input.KEY_DOWN, this.onCameraLookDown);
      r8.events.off("keypress", input.KEY_LEFT, this.onCameraTurnLeft);
      r8.events.off("keypress", input.KEY_RIGHT, this.onCameraTurnRight);
      r8.events.off("keypress", input.KEY_Q, this.onCameraRollLeft);
      r8.events.off("keypress", input.KEY_E, this.onCameraRollRight);
    }
    onCameraMoveForward() {
      if (this._active) {
        let cam = this.renderer.activeCamera;
        cam.slide(0, 0, -this.speed);
        cam.update();
      }
    }
    onCameraMoveBackward() {
      let cam = this.renderer.activeCamera;
      cam.slide(0, 0, this.speed);
      cam.update();
    }
    onCameraStrifeLeft() {
      let cam = this.renderer.activeCamera;
      cam.slide(-this.speed, 0, 0);
      cam.update();
    }
    onCameraStrifeRight() {
      let cam = this.renderer.activeCamera;
      cam.slide(this.speed, 0, 0);
      cam.update();
    }
    onCameraLookUp() {
      let cam = this.renderer.activeCamera;
      cam.pitch(0.5);
      cam.update();
    }
    onCameraLookDown() {
      let cam = this.renderer.activeCamera;
      cam.pitch(-0.5);
      cam.update();
    }
    onCameraTurnLeft() {
      let cam = this.renderer.activeCamera;
      cam.yaw(0.5);
      cam.update();
    }
    onCameraTurnRight() {
      let cam = this.renderer.activeCamera;
      cam.yaw(-0.5);
      cam.update();
    }
    onCameraRollLeft() {
      let cam = this.renderer.activeCamera;
      cam.roll(-0.5);
      cam.update();
    }
    onCameraRollRight() {
      let cam = this.renderer.activeCamera;
      cam.roll(0.5);
      cam.update();
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/SimpleSkyBackground.js
  var SimpleSkyBackground = class extends Control {
    constructor(options2 = {}) {
      super({
        name: "SimpleSkyBackground",
        ...options2
      });
      this._colorOne = new Float32Array([128 / 255, 223 / 255, 255 / 255]);
      this._colorTwo = new Float32Array([10 / 255, 15 / 255, 56 / 255]);
    }
    get colorOne() {
      let c7 = this._colorOne;
      let arr = [Math.round(c7[0] * 255), Math.round(c7[1] * 255), Math.round(c7[2] * 255)];
      return rgbToStringHTML(arr);
    }
    get colorTwo() {
      let c7 = this._colorTwo;
      let arr = [Math.round(c7[0] * 255), Math.round(c7[1] * 255), Math.round(c7[2] * 255)];
      return rgbToStringHTML(arr);
    }
    set colorOne(htmlColor) {
      let rgb = htmlColorToRgb(htmlColor);
      this._colorOne[0] = rgb.x;
      this._colorOne[1] = rgb.y;
      this._colorOne[2] = rgb.z;
    }
    set colorTwo(htmlColor) {
      let rgb = htmlColorToRgb(htmlColor);
      this._colorTwo[0] = rgb.x;
      this._colorTwo[1] = rgb.y;
      this._colorTwo[2] = rgb.z;
    }
    oninit() {
      this.renderer.handler.addProgram(simpleSkyBackgroundShader());
      this.activate();
    }
    onactivate() {
      super.onactivate();
      this.planet.events.on("draw", this._drawBackground, this);
    }
    ondeactivate() {
      super.ondeactivate();
      this.planet.events.off("draw", this._drawBackground);
    }
    _drawBackground() {
      let h8 = this.renderer.handler;
      let sh = h8.programs.simpleSkyBackground, p4 = sh._program, shu = p4.uniforms, gl = h8.gl;
      let cam = this.planet.camera;
      gl.disable(gl.DEPTH_TEST);
      sh.activate();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.renderer.screenFramePositionBuffer);
      gl.vertexAttribPointer(p4.attributes.corners, 2, gl.FLOAT, false, 0, 0);
      gl.uniform3fv(shu.camPos, [cam.eye.x, cam.eye.y, cam.eye.z]);
      gl.uniform2fv(shu.iResolution, [h8.getWidth(), h8.getHeight()]);
      gl.uniform1f(shu.fov, cam.getViewAngle());
      gl.uniform1f(shu.earthRadius, this.planet.ellipsoid.getPolarSize() + 1);
      gl.uniform3fv(shu.colorOne, this._colorOne);
      gl.uniform3fv(shu.colorTwo, this._colorTwo);
      gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.enable(gl.DEPTH_TEST);
    }
  };
  function simpleSkyBackgroundShader() {
    return new Program("simpleSkyBackground", {
      uniforms: {
        iResolution: "vec2",
        fov: "float",
        camPos: "vec3",
        earthRadius: "float",
        viewMatrix: "mat4",
        colorOne: "vec3",
        colorTwo: "vec3"
      },
      attributes: {
        corners: "vec3"
      },
      vertexShader: `attribute vec2 corners;
                        
            varying vec2 tc;
            
            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`,
      fragmentShader: `precision highp float;
            
            #define MAX 10e10
            #define PI 3.14159265359
            #define rad(x) x * PI / 180.
            #define ZERO vec3(0.0)          
           
            #define RED vec4(1.0, 0.0, 0.0, 1.0)
            #define GREEN vec4(0.0, 1.0, 0.0, 1.0)         
            
            uniform vec3 camPos;            
            uniform vec2 iResolution;
            uniform float fov;
            uniform float earthRadius;
            uniform mat4 viewMatrix;
            
            uniform vec3 colorOne;
            uniform vec3 colorTwo;
                         
            varying vec2 tc;
                        
            // compute the view ray in the camera coordinate
            vec3 computeView(vec2 uv){
                float w_h_ratio = iResolution.x / iResolution.y;   
                float h = tan(rad(fov/2.));
                return normalize(vec3(-w_h_ratio * h, -h, -1.) + vec3(uv.x * 2. * h * w_h_ratio, uv.y*2.*h, 0.));
            }

            // sphere of size ra centered at point ce
            vec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )
            {
                vec3 oc = ro - ce;
                float b = dot( oc, rd );
                float c = dot( oc, oc ) - ra * ra;
                float h = b * b - c;
                if( h < 0.0 ) return vec2(MAX); // no intersection
                h = sqrt( h );
                return vec2( -b-h, -b+h );
            }
            
            mat3 transpose(mat3 matrix) {
                vec3 row0 = matrix[0];
                vec3 row1 = matrix[1];
                vec3 row2 = matrix[2];
                mat3 result = mat3(
                    vec3(row0.x, row1.x, row2.x),
                    vec3(row0.y, row1.y, row2.y),
                    vec3(row0.z, row1.z, row2.z)
                );
                return result;
            }
            
            float det(mat2 matrix) {
                return matrix[0].x * matrix[1].y - matrix[0].y * matrix[1].x;
            }
            
            mat3 inverse(mat3 matrix) {
                vec3 row0 = matrix[0];
                vec3 row1 = matrix[1];
                vec3 row2 = matrix[2];
            
                vec3 minors0 = vec3(
                    det(mat2(row1.y, row1.z, row2.y, row2.z)),
                    det(mat2(row1.z, row1.x, row2.z, row2.x)),
                    det(mat2(row1.x, row1.y, row2.x, row2.y))
                );
                vec3 minors1 = vec3(
                    det(mat2(row2.y, row2.z, row0.y, row0.z)),
                    det(mat2(row2.z, row2.x, row0.z, row0.x)),
                    det(mat2(row2.x, row2.y, row0.x, row0.y))
                );
                vec3 minors2 = vec3(
                    det(mat2(row0.y, row0.z, row1.y, row1.z)),
                    det(mat2(row0.z, row0.x, row1.z, row1.x)),
                    det(mat2(row0.x, row0.y, row1.x, row1.y))
                );
            
                mat3 adj = transpose(mat3(minors0, minors1, minors2));
            
                return (1.0 / dot(row0, minors0)) * adj;
            }
            
            void main(void) {
            
                vec3 dir = computeView(tc);
                dir = inverse(mat3(viewMatrix)) * dir;
                
                vec2 ER = sphIntersect(camPos, dir, vec3(0.0), earthRadius);
                
                float bigRadius = earthRadius * 2.5;
                vec3 bigCenter = normalize(camPos) * bigRadius * 1.3;                
                               
                vec2 BIG = sphIntersect(camPos, dir, bigCenter, bigRadius);
                
                float Ix = distance(camPos + dir * BIG.y, ZERO);               
                
                float maxI = sqrt(bigRadius * bigRadius + bigRadius * bigRadius);
                                   
                gl_FragColor = vec4(mix(colorOne, colorTwo, Ix / maxI), 1.0);
            }`
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/astro/astro.js
  var J2000_OBLIQUITY = 23.4392911;
  var AU_TO_METERS = 14959787e4;

  // frontend/node_modules/@openglobus/og/lib/js/astro/earth.js
  function getSunPosition(jDate) {
    var d4 = jDate - J2000;
    var w3 = 282.9404 + 470935e-10 * d4;
    var e9 = 0.016709 - 1151e-12 * d4;
    var M3 = rev(356.047 + 0.9856002585 * d4);
    var oblecl = J2000_OBLIQUITY - 3563e-10 * d4;
    var E5 = M3 + DEGREES * e9 * Math.sin(M3 * RADIANS) * (1 + e9 * Math.cos(M3 * RADIANS));
    var x3 = Math.cos(E5 * RADIANS) - e9;
    var y4 = Math.sin(E5 * RADIANS) * Math.sqrt(1 - e9 * e9);
    var r8 = Math.sqrt(x3 * x3 + y4 * y4);
    var v4 = Math.atan2(y4, x3) * DEGREES;
    var lon = rev(v4 + w3);
    x3 = r8 * Math.cos(lon * RADIANS);
    y4 = r8 * Math.sin(lon * RADIANS);
    var xequat = x3;
    var yequat = y4 * Math.cos(oblecl * RADIANS);
    var zequat = y4 * Math.sin(oblecl * RADIANS);
    var theta = TWO_PI * (d4 * 24 / 23.9344694 - 259.853 / 360);
    return Quat.zRotation(-theta).mulVec3(new Vec3(-xequat * AU_TO_METERS, -yequat * AU_TO_METERS, zequat * AU_TO_METERS));
  }

  // frontend/node_modules/@openglobus/og/lib/js/light/LightSource.js
  var LightSource = class _LightSource {
    constructor(name, params) {
      this._name = name || "light_" + _LightSource.__counter__++;
      this._renderNode = null;
      this._position = params.position || new Vec3();
      this.directional = params.directional != void 0 ? params.directional : true;
      this._ambient = params.ambient || new Vec3();
      this._diffuse = params.diffuse || new Vec3(0.8, 0.8, 0.8);
      this._specular = params.specular || new Vec3(0.18, 0.18, 0.18);
      this._shininess = params.shininess != void 0 ? params.shininess : 3.3;
      this._active = true;
      this._tempAmbient = this._ambient.clone();
      this._tempDiffuse = this._diffuse.clone();
      this._tempSpecular = this._specular.clone();
      this._tempShininess = this._shininess;
    }
    /**
     * Creates clone of the current light object.
     * @todo: TODO
     * @public
     * @returns {LightSource}
     */
    clone() {
    }
    /**
     * Set light activity. If activity is false the light doesn't shine.
     * @public
     * @param {boolean} active - Light activity.
     */
    setActive(active) {
      if (active && !this._active) {
        const rn = this._renderNode;
        if (rn) {
          let index = rn._lightsNames.indexOf(this._name);
          this._shininess = rn._lightsParamsf[index] = this._tempShininess;
          if (index != -1) {
            index *= 9;
            this._ambient.x = rn._lightsParamsv[index] = this._tempAmbient.x;
            this._ambient.y = rn._lightsParamsv[index + 1] = this._tempAmbient.y;
            this._ambient.z = rn._lightsParamsv[index + 2] = this._tempAmbient.z;
            this._diffuse.x = rn._lightsParamsv[index + 3] = this._tempDiffuse.x;
            this._diffuse.y = rn._lightsParamsv[index + 4] = this._tempDiffuse.y;
            this._diffuse.z = rn._lightsParamsv[index + 5] = this._tempDiffuse.z;
            this._specular.x = rn._lightsParamsv[index + 6] = this._tempSpecular.x;
            this._specular.y = rn._lightsParamsv[index + 7] = this._tempSpecular.y;
            this._specular.z = rn._lightsParamsv[index + 8] = this._tempSpecular.z;
          }
        }
        this._active = true;
      } else if (!active && this._active) {
        this._tempAmbient = this._ambient.clone();
        this._tempDiffuse = this._diffuse.clone();
        this._tempSpecular = this._specular.clone();
        this._tempShininess = this._shininess;
        this.setBlack();
        this._active = false;
      }
    }
    /**
     * Gets light activity.
     * @public
     * @returns {boolean}
     */
    isActive() {
      return this._active;
    }
    /**
     * Set light source position, or if it is a directional type sets light direction vector.
     * @public
     * @param {Vec3} position - Light position or direction vector.
     */
    setPosition3v(position2) {
      this._position.x = position2.x;
      this._position.y = position2.y;
      this._position.z = position2.z;
    }
    /**
     * Set light source position, or if it is a directional type sets light direction vector.
     * @public
     */
    setPosition(x3, y4, z3) {
      this._position.x = x3;
      this._position.y = y4;
      this._position.z = z3;
    }
    /**
     * Returns light source position, or if it is a directional type sets light direction vector.
     * @public
     * @returns {Vec3} - Light source position/direction.
     */
    getPosition() {
      return this._position.clone();
    }
    /**
     * Set ambient color.
     * @public
     * @param {Vec3} rgb - Ambient color.
     */
    setAmbient3v(rgb) {
      this.setAmbient(rgb.x, rgb.y, rgb.z);
    }
    /**
     * Set diffuse color.
     * @public
     * @param {Vec3} rgb - Diffuse color.
     */
    setDiffuse3v(rgb) {
      this.setDiffuse(rgb.x, rgb.y, rgb.z);
    }
    /**
     * Set specular color.
     * @public
     * @param {Vec3} rgb - Specular color.
     */
    setSpecular3v(rgb) {
      this.setSpecular(rgb.x, rgb.y, rgb.z);
    }
    /**
     * Set ambient color.
     * @public
     */
    setAmbient(r8, g4, b4) {
      this._ambient.set(r8, g4, b4);
      const rn = this._renderNode;
      if (rn) {
        let index = 9 * rn._lightsNames.indexOf(this._name);
        if (index != -1) {
          rn._lightsParamsv[index] = r8;
          rn._lightsParamsv[index + 1] = g4;
          rn._lightsParamsv[index + 2] = b4;
        }
      }
    }
    /**
     * Set diffuse color.
     * @public
     */
    setDiffuse(r8, g4, b4) {
      this._diffuse.set(r8, g4, b4);
      const rn = this._renderNode;
      if (rn) {
        let index = 9 * rn._lightsNames.indexOf(this._name);
        if (index != -1) {
          rn._lightsParamsv[index + 3] = r8;
          rn._lightsParamsv[index + 4] = g4;
          rn._lightsParamsv[index + 5] = b4;
        }
      }
    }
    /**
     * Set specular color.
     * @public
     */
    setSpecular(r8, g4, b4) {
      this._specular.set(r8, g4, b4);
      const rn = this._renderNode;
      if (rn) {
        let index = 9 * rn._lightsNames.indexOf(this._name);
        if (index != -1) {
          rn._lightsParamsv[index + 6] = r8;
          rn._lightsParamsv[index + 7] = g4;
          rn._lightsParamsv[index + 8] = b4;
        }
      }
    }
    /**
     * Set material shininess.
     * @public
     */
    setShininess(shininess) {
      this._shininess = shininess;
      const rn = this._renderNode;
      if (rn) {
        let index = rn._lightsNames.indexOf(this._name);
        if (index != -1) {
          rn._lightsParamsf[index] = shininess;
        }
      }
    }
    /**
     * Sets light to black.
     * @public
     */
    setBlack() {
      this._ambient.clear();
      this._diffuse.clear();
      this._specular.clear();
      this._shininess = 0;
      const rn = this._renderNode;
      if (rn) {
        let index = 9 * rn._lightsNames.indexOf(this._name);
        if (index !== -1) {
          rn._lightsParamsv[index] = rn._lightsParamsv[index + 1] = rn._lightsParamsv[index + 2] = rn._lightsParamsv[index + 3] = rn._lightsParamsv[index + 4] = rn._lightsParamsv[index + 5] = rn._lightsParamsv[index + 6] = rn._lightsParamsv[index + 7] = rn._lightsParamsv[index + 8] = 0;
        }
      }
    }
    /**
     * Adds current light to the render node scene.
     * @public
     * @param {RenderNode} renderNode - Render node scene.
     */
    addTo(renderNode) {
      this._renderNode = renderNode;
      renderNode._lights.push(this);
      renderNode._lightsNames.push(this._name);
      renderNode._lightsParamsf.push(this._shininess);
      renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._ambient.toArray());
      renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._diffuse.toArray());
      renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._specular.toArray());
      renderNode.transformLights();
    }
    /**
     * Removes from render node scene.
     * @public
     */
    remove() {
      const rn = this._renderNode;
      if (rn) {
      }
      this._renderNode = null;
    }
  };
  LightSource.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/control/Sun.js
  var Sun = class extends Control {
    constructor(options2 = {}) {
      super({ autoActivate: true, ...options2 });
      this._name = "sun";
      this.activationHeight = options2.activationHeight || 12079e3;
      this.offsetVertical = options2.offsetVertical || -5e6;
      this.offsetHorizontal = options2.offsetHorizontal || 5e6;
      this.sunlight = new LightSource("Sun", {
        ambient: new Vec3(0.15, 0.15, 0.25),
        diffuse: new Vec3(0.9, 0.9, 0.8),
        specular: new Vec3(0.1, 0.1, 0.06),
        shininess: 110
      });
      this._currDate = 0;
      this._prevDate = 0;
      this._clockPtr = null;
      this._lightOn = false;
      this._f = 0;
      this._k = 0;
      this._stopped = options2.stopped || false;
    }
    oninit() {
      this.planet.lightEnabled = true;
      this.sunlight.addTo(this.planet);
      this.renderer.events.on("draw", this._draw, this);
      if (!this._clockPtr) {
        this._clockPtr = this.renderer.handler.defaultClock;
      }
    }
    stop() {
      this._stopped = true;
      this.deactivate();
    }
    start() {
      this._stopped = false;
      this.activate();
    }
    onactivate() {
      super.onactivate();
      this._stopped = false;
    }
    bindClock(clock) {
      this._clockPtr = clock;
    }
    _draw() {
      if (!this._clockPtr)
        return;
      this._currDate = this._clockPtr.currentDate;
      if (!this._stopped) {
        let cam = this.planet.camera;
        if (cam.getHeight() < this.activationHeight || !this._active) {
          this._lightOn = true;
          this._f = 1;
          let n7 = cam.eye.normal(), u4 = cam.getForward();
          u4.scale(Math.sign(cam._u.dot(n7)));
          if (cam.slope > 0.99) {
            u4 = cam._u;
          }
          let tu = Vec3.proj_b_to_plane(u4, n7, u4).normalize().scale(this.offsetVertical);
          let tr = Vec3.proj_b_to_plane(cam._r, n7, cam._r).normalize().scale(this.offsetHorizontal);
          let d4 = tu.add(tr);
          let pos = cam.eye.add(d4);
          if (this._k > 0) {
            this._k -= 0.01;
            let rot = Quat.getRotationBetweenVectors(this.sunlight._position.normal(), pos.normal());
            let r8 = rot.slerp(Quat.IDENTITY, this._k).normalize();
            this.sunlight.setPosition3v(r8.mulVec3(this.sunlight._position));
          } else {
            this.sunlight.setPosition3v(pos);
          }
        } else {
          this._k = 1;
          if (this._f > 0) {
            this._f -= 0.01;
            let rot = Quat.getRotationBetweenVectors(this.sunlight._position.normal(), getSunPosition(this._currDate).normal());
            let r8 = rot.slerp(Quat.IDENTITY, this._f).normalize();
            this.sunlight.setPosition3v(r8.mulVec3(this.sunlight._position));
          } else {
            if (Math.abs(this._currDate - this._prevDate) > 34e-5 && this._active || this._lightOn) {
              this._lightOn = false;
              this._prevDate = this._currDate;
              this.sunlight.setPosition3v(getSunPosition(this._currDate));
              this._f = 0;
            }
          }
        }
      } else {
        this.sunlight.setPosition3v(getSunPosition(this._currDate));
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/ToggleWireframe.js
  var ToggleWireframe = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._isActive = false;
      this.toogleWireframe = () => {
        if (this.renderer && this.renderer.handler.gl) {
          if (this.planet.drawMode === this.renderer.handler.gl.LINE_STRIP) {
            this.planet.setDrawMode(this.renderer.handler.gl.TRIANGLE_STRIP);
          } else {
            this.planet.setDrawMode(this.renderer.handler.gl.LINE_STRIP);
          }
        }
      };
      this._isActive = options2.isActive || false;
    }
    oninit() {
      this.renderer.events.on("charkeypress", input.KEY_X, this.toogleWireframe, this);
      if (this._isActive) {
        this.planet.setDrawMode(this.renderer.handler.gl.LINE_STRIP);
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/TouchNavigation.js
  var TouchExt2 = class {
    constructor() {
      this.x = 0;
      this.y = 0;
      this.prev_x = 0;
      this.prev_y = 0;
      this.grabbedPoint = null;
      this.grabbedSpheroid = new Sphere();
      this._vec = new Vec2();
      this._vecPrev = new Vec2();
    }
    get dY() {
      return this.y - this.prev_y;
    }
    get dX() {
      return this.x - this.prev_x;
    }
    get vec() {
      return this._vec.set(this.x, this.y);
    }
    get vecPrev() {
      return this._vecPrev.set(this.prev_x, this.prev_y);
    }
  };
  var TouchNavigation = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._name = "touchNavigation";
      this.grabbedPoint = new Vec3();
      this.inertia = 7e-3;
      this.grabbedSpheroid = new Sphere();
      this.planet = null;
      this.qRot = new Quat();
      this.scaleRot = 0;
      this.rot = 1;
      this._eye0 = new Vec3();
      this.pointOnEarth = null;
      this.earthUp = null;
      this.touches = [new TouchExt2(), new TouchExt2()];
      this._keyLock = new Key();
      this._touching = false;
    }
    oninit() {
      if (this.renderer) {
        this.renderer.events.on("touchstart", this.onTouchStart, this);
        this.renderer.events.on("touchend", this.onTouchEnd, this);
        this.renderer.events.on("doubletouch", this.onDoubleTouch, this);
        this.renderer.events.on("touchcancel", this.onTouchCancel, this);
        this.renderer.events.on("touchmove", this.onTouchMove, this);
        this.renderer.events.on("draw", this.onDraw, this);
      }
    }
    onTouchStart(e9) {
      const handler = this.renderer.handler;
      this._touching = true;
      if (e9.sys.touches.length === 2) {
        const t0 = this.touches[0];
        const t1 = this.touches[1];
        t0.x = (e9.sys.touches.item(0).clientX - e9.sys.offsetLeft) * handler.pixelRatio;
        t0.y = (e9.sys.touches.item(0).clientY - e9.sys.offsetTop) * handler.pixelRatio;
        t0.prev_x = t0.x;
        t0.prev_y = t0.y;
        t0.grabbedPoint = this.planet.getCartesianFromPixelTerrain(new Vec2(t0.x, t0.y)) || null;
        t1.x = (e9.sys.touches.item(1).clientX - e9.sys.offsetLeft) * handler.pixelRatio;
        t1.y = (e9.sys.touches.item(1).clientY - e9.sys.offsetTop) * handler.pixelRatio;
        t1.prev_x = t1.x;
        t1.prev_y = t1.y;
        t1.grabbedPoint = this.planet.getCartesianFromPixelTerrain(new Vec2(t1.x, t1.y)) || null;
        this.pointOnEarth = this.planet.getCartesianFromPixelTerrain(this.renderer.handler.getCenter()) || null;
        if (this.pointOnEarth) {
          this.earthUp = this.pointOnEarth.normal();
        }
        if (t0.grabbedPoint && t1.grabbedPoint) {
          t0.grabbedSpheroid.radius = t0.grabbedPoint.length();
          t1.grabbedSpheroid.radius = t1.grabbedPoint.length();
          this.stopRotation();
        }
      } else if (e9.sys.touches.length === 1) {
        this._startTouchOne(e9);
      }
    }
    _startTouchOne(e9) {
      const t9 = this.touches[0];
      const handler = this.renderer.handler;
      t9.x = (e9.sys.touches.item(0).clientX - e9.sys.offsetLeft) * handler.pixelRatio;
      t9.y = (e9.sys.touches.item(0).clientY - e9.sys.offsetTop) * handler.pixelRatio;
      t9.prev_x = t9.x;
      t9.prev_y = t9.y;
      t9.grabbedPoint = this.planet.getCartesianFromPixelTerrain(e9) || null;
      this._eye0.copy(this.planet.camera.eye);
      if (t9.grabbedPoint) {
        t9.grabbedSpheroid.radius = t9.grabbedPoint.length();
        this.stopRotation();
      }
    }
    stopRotation() {
      this.qRot.clear();
      this.planet.layerLock.free(this._keyLock);
      this.planet.terrainLock.free(this._keyLock);
      this.planet._normalMapCreator.free(this._keyLock);
    }
    onDoubleTouch(e9) {
      this.planet.stopFlying();
      this.stopRotation();
      const p4 = this.planet.getCartesianFromPixelTerrain(e9);
      if (p4) {
        const g4 = this.planet.ellipsoid.cartesianToLonLat(p4);
        this.planet.flyLonLat(new LonLat(g4.lon, g4.lat, this.planet.camera.eye.distance(p4) * 0.57));
      }
    }
    onTouchEnd(e9) {
      if (e9.sys.touches.length === 0) {
        this._touching = false;
      }
      if (e9.sys.touches.length === 1) {
        this._startTouchOne(e9);
      }
      if (Math.abs(this.touches[0].x - this.touches[0].prev_x) < 3 && Math.abs(this.touches[0].y - this.touches[0].prev_y) < 3) {
        this.scaleRot = 0;
      }
    }
    onTouchCancel(e9) {
    }
    onTouchMove(e9) {
      let cam = this.planet.camera;
      const handler = this.renderer.handler;
      if (e9.sys.touches.length === 2) {
        this.renderer.controlsBag.scaleRot = 1;
        let t0 = this.touches[0], t1 = this.touches[1];
        if (!t0.grabbedPoint || !t1.grabbedPoint) {
          return;
        }
        this.planet.stopFlying();
        t0.prev_x = t0.x;
        t0.prev_y = t0.y;
        t0.x = (e9.sys.touches.item(0).clientX - e9.sys.offsetLeft) * handler.pixelRatio;
        t0.y = (e9.sys.touches.item(0).clientY - e9.sys.offsetTop) * handler.pixelRatio;
        t1.prev_x = t1.x;
        t1.prev_y = t1.y;
        t1.x = (e9.sys.touches.item(1).clientX - e9.sys.offsetLeft) * handler.pixelRatio;
        t1.y = (e9.sys.touches.item(1).clientY - e9.sys.offsetTop) * handler.pixelRatio;
        const middle = t0.vec.add(t1.vec).scale(0.5);
        const earthMiddlePoint = this.planet.getCartesianFromPixelTerrain(middle);
        if (earthMiddlePoint) {
          this.pointOnEarth = earthMiddlePoint;
          const prevAngle = Math.atan2(t0.prev_y - t1.prev_y, t0.prev_x - t1.prev_x);
          const curAngle = Math.atan2(t0.y - t1.y, t0.x - t1.x);
          const deltaAngle = curAngle - prevAngle;
          const distanceToPointOnEarth = cam.eye.distance(this.pointOnEarth);
          const zoomCur = t0.vec.sub(t1.vec);
          const zoomPrev = t0.vecPrev.sub(t1.vecPrev);
          const scale2 = zoomCur.length() / zoomPrev.length();
          let d4 = distanceToPointOnEarth * -(1 - scale2);
          cam.eye.addA(cam.getForward().scale(d4));
          cam.rotateAround(-deltaAngle, false, this.pointOnEarth, this.earthUp);
          const panCur = t0.vec.add(t1.vec).scale(0.5);
          const panPrev = t0.vecPrev.add(t1.vecPrev).scale(0.5);
          const panOffset = panCur.sub(panPrev).scale(-1);
          var l4 = 0.5 / distanceToPointOnEarth * cam._lonLat.height * math_exports.RADIANS;
          if (l4 > 3e-3)
            l4 = 3e-3;
          cam.rotateHorizontal(l4 * -panOffset.x, false, this.pointOnEarth, this.earthUp);
          cam.rotateVertical(l4 * -panOffset.y, this.pointOnEarth);
          cam.checkTerrainCollision();
          cam.update();
        }
        this.scaleRot = 0;
      } else if (e9.sys.touches.length === 1) {
        let t9 = this.touches[0];
        t9.prev_x = t9.x;
        t9.prev_y = t9.y;
        t9.x = (e9.sys.touches.item(0).clientX - e9.sys.offsetLeft) * handler.pixelRatio;
        t9.y = (e9.sys.touches.item(0).clientY - e9.sys.offsetTop) * handler.pixelRatio;
        if (!t9.grabbedPoint) {
          return;
        }
        this.planet.stopFlying();
        let direction = e9.direction;
        let targetPoint = new Ray(cam.eye, direction).hitSphere(t9.grabbedSpheroid);
        if (targetPoint) {
          if (cam.slope > 0.2) {
            this.qRot = Quat.getRotationBetweenVectors(targetPoint.normal(), t9.grabbedPoint.normal());
            let rot = this.qRot;
            cam.eye = rot.mulVec3(cam.eye);
            cam._r = rot.mulVec3(cam._r);
            cam._u = rot.mulVec3(cam._u);
            cam._b = rot.mulVec3(cam._b);
            cam.checkTerrainCollision();
            cam.update();
            this.scaleRot = 1;
          } else {
            let p0 = t9.grabbedPoint, p1 = Vec3.add(p0, cam._u), p22 = Vec3.add(p0, p0.normal());
            let dir = cam.unproject(t9.x, t9.y);
            let px = new Vec3();
            if (new Ray(cam.eye, dir).hitPlane(p0, p1, p22, px) === Ray.INSIDE) {
              cam.eye = this._eye0.addA(px.subA(p0).negate());
              cam.checkTerrainCollision();
              cam.update();
              this.scaleRot = 0;
            }
          }
        }
      }
    }
    onDraw() {
      const r8 = this.renderer;
      r8.controlsBag.scaleRot = this.scaleRot;
      if (this._touching) {
        return;
      }
      let cam = this.planet.camera;
      let prevEye = cam.eye.clone();
      if (r8.events.mouseState.leftButtonDown || !this.scaleRot) {
        return;
      }
      this.scaleRot -= this.inertia;
      if (this.scaleRot <= 0) {
        this.scaleRot = 0;
      } else {
        r8.controlsBag.scaleRot = this.scaleRot;
        let rot = this.qRot.slerp(Quat.IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot).normalize();
        if (!(rot.x || rot.y || rot.z)) {
          this.scaleRot = 0;
        }
        cam.eye = rot.mulVec3(cam.eye);
        cam._r = rot.mulVec3(cam._r);
        cam._u = rot.mulVec3(cam._u);
        cam._b = rot.mulVec3(cam._b);
        cam.checkTerrainCollision();
        cam.update();
      }
      if (cam.eye.distance(prevEye) / cam.getAltitude() > 0.01) {
        this.planet.layerLock.lock(this._keyLock);
        this.planet.terrainLock.lock(this._keyLock);
        this.planet._normalMapCreator.lock(this._keyLock);
      } else {
        this.planet.layerLock.free(this._keyLock);
        this.planet.terrainLock.free(this._keyLock);
        this.planet._normalMapCreator.free(this._keyLock);
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/ZoomControl.js
  var ICON_PLUS_SVG = '<?xml version="1.0"?><svg width=24 height=24 xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">    <path d="M 11 5 L 11 11 L 5 11 L 5 13 L 11 13 L 11 19 L 13 19 L 13 13 L 19 13 L 19 11 L 13 11 L 13 5 L 11 5 z"/></svg>';
  var ICON_MINUS_SVG = '<?xml version="1.0"?><svg width=24 height=24 xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">    <path d="M 5 11 L 5 13 L 19 13 L 19 11 L 5 11 z"/></svg>';
  var ZoomControl = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._keyLock = new Key();
      this._move = 0;
      this._targetPoint = null;
    }
    oninit() {
      let zoomInBtn = new Button({
        classList: ["og-map-button", "og-zoomin-button"],
        icon: ICON_PLUS_SVG
      });
      zoomInBtn.appendTo(this.renderer.div);
      let zoomOutBtn = new Button({
        classList: ["og-map-button", "og-zoomout-button"],
        icon: ICON_MINUS_SVG
      });
      zoomOutBtn.appendTo(this.renderer.div);
      zoomInBtn.events.on("mousedown", () => this.zoomIn());
      zoomInBtn.events.on("mouseup", () => this.stopZoom());
      zoomOutBtn.events.on("mousedown", () => this.zoomOut());
      zoomOutBtn.events.on("mouseup", () => this.stopZoom());
      zoomInBtn.events.on("touchstart", () => this.zoomIn());
      zoomInBtn.events.on("touchend", () => this.stopZoom());
      zoomInBtn.events.on("touchcancel", () => this.stopZoom());
      zoomOutBtn.events.on("touchstart", () => this.zoomOut());
      zoomOutBtn.events.on("touchend", () => this.stopZoom());
      zoomOutBtn.events.on("touchcancel", () => this.stopZoom());
      this.renderer.events.on("draw", this._draw, this);
    }
    /**
     * Planet zoom in.
     * @public
     */
    zoomIn() {
      this.planet.layerLock.lock(this._keyLock);
      this.planet.terrainLock.lock(this._keyLock);
      this.planet._normalMapCreator.lock(this._keyLock);
      this._targetPoint = this.renderer.getCenter();
      this._move = 1;
    }
    /**
     * Planet zoom out.
     * @public
     */
    zoomOut() {
      this.planet.layerLock.lock(this._keyLock);
      this.planet.terrainLock.lock(this._keyLock);
      this.planet._normalMapCreator.lock(this._keyLock);
      this._targetPoint = this.renderer.getCenter();
      this._move = -1;
    }
    stopZoom() {
      this._move = 0;
      this.planet.layerLock.free(this._keyLock);
      this.planet.terrainLock.free(this._keyLock);
      this.planet._normalMapCreator.free(this._keyLock);
    }
    _draw(e9) {
      const cam = this.planet.camera;
      if (this._move !== 0) {
        const pos = this.planet.getCartesianFromPixelTerrain(e9.getCenter());
        if (pos) {
          let d4 = cam.eye.distance(pos) * 0.035;
          cam.eye.addA(cam.getForward().scale(this._move * d4));
          cam.checkTerrainCollision();
          cam.update();
        }
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/selection/SelectionScene.js
  var OUTLINE_COUNT2 = 120;
  function distanceFormat2(v4) {
    if (v4 > 1e3) {
      return `${(v4 / 1e3).toFixed(1)} km`;
    } else if (v4 > 9) {
      return `${Math.round(v4)} m`;
    } else {
      return `${v4.toFixed(1)} m`;
    }
  }
  var SelectionScene = class extends RenderNode {
    constructor(options2 = {}) {
      super(options2.name);
      this._ignoreTerrain = false;
      this.events = new Events(EVENT_NAMES);
      this._ignoreTerrain = options2.ignoreTerrain != void 0 ? options2.ignoreTerrain : true;
      this._onSelect = options2.onSelect || null;
      this._autoSelectionHide = options2.autoSelectionHide || false;
      this._planet = options2.planet || null;
      this._startLonLat = null;
      this._heading = 0;
      this._propsLabel = new Entity({
        "name": "propsLabel",
        "label": {
          text: "",
          size: 11,
          color: "rgba(455,455,455,1.0)",
          outlineColor: "rgba(0,0,0,0.34)",
          outline: 0.23,
          align: "center",
          offset: [0, 18]
        }
      });
      this._propsLabel?.label?.setVisibility(false);
      this._trackEntity = new Entity({
        polyline: {
          path3v: [],
          thickness: 3.8,
          color: "rgb(455,455,455)",
          isClosed: false
        }
      });
      this._trackEntity.polyline.altitude = 0.01;
      let obj3d3 = Object3d.createCylinder(1.1, 0, 2.7, 20, 1, true, false, 0, 0, 0);
      this._cornerEntity = [
        new Entity({
          geoObject: {
            scale: 1,
            instanced: true,
            tag: "selection",
            color: "rgb(0,305,0)",
            object3d: obj3d3
          },
          properties: {
            name: "start"
          }
        }),
        new Entity({
          geoObject: {
            scale: 1,
            instanced: true,
            tag: "selection",
            color: "rgb(455,0,0)",
            object3d: obj3d3
          },
          properties: {
            name: "end"
          }
        })
      ];
      this._trackLayer = new Vector("track", {
        entities: [this._trackEntity, this._propsLabel],
        pickingEnabled: false,
        polygonOffsetUnits: -1,
        relativeToGround: true,
        hideInLayerSwitcher: false
      });
      this._cornersLayer = new Vector("corners", {
        entities: [this._cornerEntity[0], this._cornerEntity[1]],
        pickingEnabled: true,
        hideInLayerSwitcher: true,
        scaleByDistance: [1, 4e6, 0.01],
        pickingScale: 2
      });
    }
    set ignoreTerrain(v4) {
      this._ignoreTerrain = v4;
      if (v4) {
      }
    }
    bindPlanet(planet) {
      this._planet = planet;
    }
    init() {
      this._activate();
    }
    onremove() {
      this._deactivate();
    }
    _activate() {
      this._propsLabel?.label?.setVisibility(false);
      this._onMouseMove_ = this._onMouseMove.bind(this);
      this.renderer?.events.on("mousemove", this._onMouseMove_, this);
      this._onMouseLdown_ = this._onMouseLdown.bind(this);
      this.renderer?.events.on("ldown", this._onMouseLdown_, this);
      this._onMouseLup_ = this._onMouseLup.bind(this);
      this.renderer?.events.on("lup", this._onMouseLup_, this);
      this._planet.addLayer(this._trackLayer);
      this._planet.addLayer(this._cornersLayer);
    }
    _deactivate() {
      this._startLonLat = null;
      this._trackLayer.remove();
      this._cornersLayer.remove();
      this.renderer?.events.off("mousemove", this._onMouseMove_);
      this.renderer?.events.off("ldown", this._onMouseLdown_);
      this.renderer?.events.off("lup", this._onMouseLup_);
      this.clear();
      this._onMouseMove_ = null;
      this._onMouseLdown_ = null;
      this._onMouseLup_ = null;
    }
    _onMouseLdown(e9) {
      e9.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
      e9.renderer.handler.canvas.style.cursor = "pointer";
      if (!this._startLonLat) {
        this._propsLabel.label?.setVisibility(false);
        this._trackEntity.polyline?.setPath3v([]);
        this._cornerEntity[0].geoObject?.setVisibility(true);
        this._cornerEntity[1].geoObject?.setVisibility(true);
        this.renderer?.controls.mouseNavigation?.deactivate();
        this._startLonLat = this._planet.getLonLatFromPixelTerrain(e9);
        let startPos = this._planet.ellipsoid.lonLatToCartesian(this._startLonLat);
        this._cornerEntity[0].setCartesian3v(startPos);
        this._cornerEntity[1].setCartesian3v(startPos);
      }
    }
    _onMouseLup(e9) {
      if (this._startLonLat) {
        this._pickedCorner = null;
        this._anchorLonLat = null;
        this._propsLabel.label?.setVisibility(true);
        if (this._onSelect && typeof this._onSelect === "function") {
          let startLonLat = this._cornerEntity[0].getLonLat();
          let endLonLat = this._cornerEntity[1].getLonLat();
          let extent = [
            Math.min(startLonLat.lon, endLonLat.lon),
            Math.min(startLonLat.lat, endLonLat.lat),
            Math.max(startLonLat.lon, endLonLat.lon),
            Math.max(startLonLat.lat, endLonLat.lat)
          ];
          this._onSelect(extent);
        }
        if (this._autoSelectionHide) {
          this.clear();
        }
        this._startLonLat = null;
      }
      e9.renderer.handler.canvas.style.cursor = "default";
      this.renderer?.controls.mouseNavigation?.activate();
    }
    _drawLine(startLonLat, endLonLat, startPos) {
      if (!startPos) {
        startPos = this._planet.ellipsoid.lonLatToCartesian(startLonLat);
      }
      let endPos = this._planet.ellipsoid.lonLatToCartesian(endLonLat);
      let res = this._planet.ellipsoid.direct(startLonLat, endLonLat);
      this._heading = res.initialAzimuth;
      let path = [];
      this._cornerEntity[0].setCartesian3v(startPos);
      this._cornerEntity[1].setCartesian3v(endPos);
      let corners2 = [
        startPos,
        this._planet.ellipsoid.lonLatToCartesian(new LonLat(endLonLat.lon, startLonLat.lat, startLonLat.height)),
        endPos,
        this._planet.ellipsoid.lonLatToCartesian(new LonLat(startLonLat.lon, endLonLat.lat, startLonLat.height)),
        startPos
      ];
      path.push(startPos);
      let createPath = (sideA, sideB) => {
        let dir = sideB.sub(sideA);
        let dist = dir.length();
        dir.normalize();
        for (let i9 = 0; i9 < OUTLINE_COUNT2; i9++) {
          let f8 = dir.scaleTo(i9 * dist / OUTLINE_COUNT2).addA(sideA);
          path.push(f8);
        }
      };
      for (let i9 = 0; i9 < corners2.length - 1; i9++) {
        createPath(corners2[i9], corners2[i9 + 1]);
      }
      this._trackEntity.polyline?.setPath3v([path]);
      if (this._ignoreTerrain) {
      }
    }
    _onMouseMove(e9) {
      if (this._startLonLat) {
        this._propsLabel.label?.setVisibility(true);
        let endLonLat = this._planet.getLonLatFromPixelTerrain(e9);
        if (!endLonLat)
          return;
        this._drawLine(this._startLonLat, endLonLat);
      }
    }
    clear() {
      this._trackEntity.polyline?.clear();
      this._cornerEntity[0].geoObject?.setVisibility(false);
      this._cornerEntity[1].geoObject?.setVisibility(false);
    }
    frame() {
      let t9 = this._trackEntity.polyline?.getPath3v()[0];
      if (t9) {
        if (!this._ignoreTerrain) {
          let res = 0;
          for (let i9 = 0, len = t9.length - 1; i9 < len; i9++) {
            res += t9[i9 + 1].distance(t9[i9]);
          }
          this._propsLabel.setCartesian3v(t9[Math.floor(t9.length / 2)]);
          this._propsLabel.label?.setText(`${distanceFormat2(res)}, ${Math.round(this._heading)} deg`);
        }
      }
    }
    get ellipsoid() {
      return this._planet ? this._planet.ellipsoid : null;
    }
  };
  var EVENT_NAMES = [
    "add",
    "remove",
    "mousemove",
    "mouseenter",
    "mouseleave",
    "lclick",
    "rclick",
    "mclick",
    "ldblclick",
    "rdblclick",
    "mdblclick",
    "lup",
    "rup",
    "mup",
    "ldown",
    "rdown",
    "mdown",
    "lhold",
    "rhold",
    "mhold",
    "mousewheel",
    "touchmove",
    "touchstart",
    "touchend",
    "doubletouch",
    "touchleave",
    "touchenter"
  ];

  // frontend/node_modules/@openglobus/og/lib/js/control/selection/Selection.js
  var ICON_BUTTON_SVG7 = `<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M2.1 0v1.914H0v6h3V3h5.1V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h6V0h-6zm9 0v3h1.8v1.2h3V0h-4.8zm1.8 7.2v6h3v-6h-3zM0 10.913v6h3v-6H0zM66.9 16.2v6h3v-6h-3zM0 19.914v6h3v-6H0zM66.9 25.2v6h3v-6h-3zM0 28.914v6h3v-6H0zM66.9 34.2v6h3v-6h-3zM0 37.914v6h3v-6H0zM66.9 43.2v6h3v-6h-3zM0 46.914v6h3v-6H0zM66.9 52.2v6h3v-6h-3zM0 55.914v5.191h3.809v-3H3v-2.19H0zm6.809 2.191v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9 0v3h6v-3h-6zm9.648 1.899a2.076 2.076 0 0 0-2.19 2.324l3.137 33.676c.2 1.635 2.135 2.399 3.397 1.34l6.623-5.371l2.969 5.142c1.707 2.958 4.417 3.684 7.375 1.977c2.957-1.708 3.684-4.417 1.976-7.375l-2.959-5.125l7.848-3.008c1.548-.564 1.855-2.62.539-3.611L71.576 60.416a2.073 2.073 0 0 0-1.119-.412z" fill="#000000"></path></svg>`;
  var Selection = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this._selectorScene = new SelectionScene({
        name: `selectionScene:${this.__id}`,
        ignoreTerrain: options2.ignoreTerrain,
        onSelect: options2.onSelect,
        autoSelectionHide: options2.autoSelectionHide
      });
      this._toggleBtn = new ToggleButton({
        classList: ["og-map-button", "og-selection_button"],
        icon: ICON_BUTTON_SVG7
      });
    }
    set ignoreTerrain(v4) {
      this._selectorScene.ignoreTerrain = v4;
    }
    oninit() {
      this._toggleBtn.appendTo(this.renderer.div);
      this._toggleBtn.events.on("change", (isActive) => {
        if (isActive) {
          this.activate();
        } else {
          this.deactivate();
        }
      });
      this._selectorScene.bindPlanet(this.planet);
    }
    onactivate() {
      this.renderer.addNode(this._selectorScene);
    }
    ondeactivate() {
      this.renderer.removeNode(this._selectorScene);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/timeline/timelineUtils.js
  function addSeconds(date, seconds) {
    return new Date(+date + seconds * 1e3);
  }
  function dateToStr(date, showTime = true, showMilliseconds = false) {
    let month = MONTHS[date.getMonth()], day = date.getUTCDate(), year = date.getUTCFullYear();
    if (showTime) {
      let h8 = date.getUTCHours().toString().padStart(2, "0"), m5 = date.getUTCMinutes().toString().padStart(2, "0"), s7 = date.getUTCSeconds().toString().padStart(2, "0");
      if (showMilliseconds) {
        let ms2 = date.getUTCMilliseconds().toString().padStart(3, "0");
        return `${month} ${day} ${year} ${h8}:${m5}:${s7}.${ms2}`;
      }
      return `${month} ${day} ${year} ${h8}:${m5}:${s7}`;
    }
    return `${month} ${day} ${year}`;
  }
  function createCanvasHTML() {
    return document.createElement("canvas");
  }
  function getNearestTimeLeft(t9, div) {
    return t9 - t9 % div;
  }
  function drawNotch(ctx, xOffset = 0, size = 10, thickness = 2, color = "white") {
    ctx.lineWidth = thickness;
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.moveTo(xOffset, 0);
    ctx.lineTo(xOffset, size);
    ctx.stroke();
  }
  function drawText(ctx, text, x3, y4, font = "12px Arial", fillStyle = "black", align = "left", baseLine = "bottom", rotDeg = 0) {
    ctx.save();
    ctx.translate(x3, y4);
    ctx.rotate(rotDeg * RADIANS);
    ctx.fillStyle = fillStyle;
    ctx.textBaseline = baseLine;
    ctx.font = font;
    ctx.textAlign = align;
    ctx.fillText(text, 0, 0);
    ctx.restore();
  }
  var SCALES = [
    [1e-3, 10],
    [2e-3, 10],
    [5e-3, 10],
    [0.01, 10],
    [0.02, 10],
    [0.05, 10],
    [0.1, 10],
    [0.25, 10],
    [0.5, 5],
    [1, 10],
    [2, 10],
    [5, 5],
    [10, 10],
    [15, 15],
    [30, 6],
    [60, 12],
    // 1min
    [120, 12],
    // 2min
    [300, 5],
    // 5min
    [600, 10],
    // 10min
    [900, 15],
    // 15min
    [1800, 6],
    // 30min
    [3600, 12],
    // 1hr
    [7200, 10],
    // 2hr
    [14400, 4],
    // 4hr
    [21600, 6],
    // 6hr
    [43200, 12],
    // 12hr
    [86400, 24],
    // 24hr
    [172800, 2],
    // 2days
    [345600, 4],
    // 4days
    [604800, 7],
    // 7days
    [1296e3, 15],
    // 15days
    [2592e3, 5],
    // 30days
    [5184e3, 6],
    // 60days
    [7776e3, 9],
    // 90days
    [15552e3, 18],
    // 180days
    [31536e3, 12],
    // 365days
    [63072e3, 2],
    // 2years
    [126144e3, 4],
    // 4years
    [15768e4, 5],
    // 5years
    [31536e4, 10],
    // 10years
    [63072e4, 2],
    // 20years
    [126144e4, 4],
    // 40years
    [15768e5, 5],
    // 50years
    [31536e5, 10],
    // 100years
    [63072e5, 2],
    // 200years
    [126144e5, 4],
    // 400years
    [15768e6, 5],
    // 500years
    [31536e6, 10]
    // 1000years
  ];
  function getScale(seconds) {
    for (let i9 = 0, len = SCALES.length; i9 < len; i9++) {
      if (SCALES[i9][0] > seconds) {
        return SCALES[i9 - 1];
      }
    }
  }
  var MONTHS = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];

  // frontend/node_modules/@openglobus/og/lib/js/control/timeline/TimelineModel.js
  var TIMELINE_EVENTS = [
    "change",
    "current"
    /*, "tick"*/
  ];
  var TimelineModel = class {
    constructor(options2 = {}) {
      this.events = createEvents(TIMELINE_EVENTS);
      this._current = options2.current || /* @__PURE__ */ new Date();
      this._rangeStart = options2.rangeStart || /* @__PURE__ */ new Date();
      this._rangeEnd = options2.rangeEnd || addSeconds(this._rangeStart, 3600);
      this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
      this._minDate = options2.minDate || null;
      this._maxDate = options2.maxDate || null;
      this.multiplier = options2.multiplier != void 0 ? options2.multiplier : 1;
      this._requestAnimationFrameId = 0;
      this._prevNow = 0;
      this.dt = 0;
    }
    play() {
      if (!this._requestAnimationFrameId) {
        this._prevNow = window.performance.now();
        this._animationFrameCallback();
      }
    }
    stop() {
      if (this._requestAnimationFrameId) {
        window.cancelAnimationFrame(this._requestAnimationFrameId);
        this._requestAnimationFrameId = 0;
      }
    }
    stopped() {
      return this._requestAnimationFrameId == 0;
    }
    _animationFrameCallback() {
      this._requestAnimationFrameId = window.requestAnimationFrame(() => {
        this._frame();
        this._animationFrameCallback();
      });
    }
    _frame() {
      let now = window.performance.now();
      this.dt = now - this._prevNow;
      this._prevNow = now;
      this.current = new Date(this.currentTime + this.dt * this.multiplier);
    }
    get range() {
      return this._range;
    }
    set(rangeStart, rangeEnd) {
      if (rangeStart !== this._rangeStart || rangeEnd !== this._rangeEnd) {
        this._rangeStart = rangeStart;
        this._rangeEnd = rangeEnd;
        this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
        this.events.dispatch(this.events.change, rangeStart, rangeEnd);
      }
    }
    get current() {
      return this._current;
    }
    get rangeStart() {
      return this._rangeStart;
    }
    get rangeEnd() {
      return this._rangeEnd;
    }
    get rangeStartTime() {
      return this._rangeStart.getTime();
    }
    get rangeEndTime() {
      return this._rangeEnd.getTime();
    }
    get currentTime() {
      return this._current.getTime();
    }
    set current(current) {
      if (current !== this._current) {
        if (this._maxDate && current > this._maxDate) {
          this._current = this._maxDate;
        } else if (this._minDate && current < this._minDate) {
          this._current = this._minDate;
        } else {
          this._current = current;
        }
        this.events.dispatch(this.events.current, this._current);
      }
    }
    set rangeStart(date) {
      if (date !== this._rangeStart) {
        this._rangeStart = date;
        this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
        this.events.dispatch(this.events.change, date);
      }
    }
    set rangeEnd(date) {
      if (date !== this._rangeEnd) {
        this._rangeEnd = date;
        this._range = this._rangeEnd.getTime() - this._rangeStart.getTime();
        this.events.dispatch(this.events.change, date);
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/timeline/TimelineView.js
  var SECONDS_TO_MILLISECONDS = 1e3;
  var MILLISECONDS_TO_SECONDS = 1 / SECONDS_TO_MILLISECONDS;
  var TIMELINEVIEW_EVENTS = [
    "startdrag",
    "stopdrag",
    "startdragcurrent",
    "stopdragcurrent",
    "setcurrent",
    "reset",
    "play",
    "playback",
    "pause",
    "visibility"
  ];
  var ICON_PLAY_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8 5v14l11-7z" style="fill: black;"/></svg>';
  var ICON_PAUSE_SVG = `<?xml version="1.0" ?><!DOCTYPE svg  PUBLIC '-//W3C//DTD SVG 1.1//EN'  'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'><svg enable-background="new 0 0 512 512" height="512px" version="1.1" viewBox="0 0 512 512" width="512px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Layer_6"><rect fill="#252525" height="320" width="60" x="153" y="96"/><rect fill="#252525" height="320" width="60" x="299" y="96"/></g></svg>`;
  var SCALE_FILL_COLOR = "rgba(64, 59, 59, 1.0)";
  var SCALE_NOTCH_COLOR = "#bfbfbf";
  var SCALE_TIME_COLOR = "#bfbfbf";
  var TEMPLATE8 = `<div class="og-timeline">

  <div class="og-timeline-top">
  </div>

  <div class="og-timeline-frame">
    <div class="og-timeline-current">
      <div class="og-timeline-current-spin">
        <div class="og-timeline-current-arrow"></div>
      </div>
    </div>
    <div class="og-timeline-scale"></div>
  </div>

  <div class="og-timeline-bottom">
    <div class="og-timeline-controls">
    </div>
  </div>

</div>`;
  var TimelineView = class extends View {
    constructor(options2 = {}) {
      super({
        template: TEMPLATE8,
        model: new TimelineModel({
          rangeStart: options2.rangeStart,
          rangeEnd: options2.rangeEnd,
          current: options2.currentDate,
          minDate: options2.minDate,
          maxDate: options2.maxDate
        })
      });
      this._onMouseWheel = (e9) => {
        if (this._isMouseOver) {
          let rect = this._canvasEl.getBoundingClientRect();
          let pointerPosX = e9.clientX - rect.left, pointerCenterOffsetX = -(pointerPosX - this.clientWidth * 0.5);
          let pointerTime = this.model.rangeStartTime + this._millisecondsInPixel * pointerPosX;
          this._zoom(pointerTime, pointerCenterOffsetX, Math.sign(e9.wheelDelta));
        } else if (this._isCurrentMouseOver) {
          let pointerCenterOffsetX = -((this.model.currentTime - this.model.rangeStartTime) / this._millisecondsInPixel - this.clientWidth * 0.5);
          this._zoom(this.model.currentTime, pointerCenterOffsetX, Math.sign(e9.wheelDelta));
        }
      };
      this._onMouseWheelFF = (e9) => {
        this._onMouseWheel(e9);
      };
      this._onMouseDown = (e9) => {
        if (this._isMouseOver) {
          this._isDragging = true;
          document.body.classList.add("og-timeline-unselectable");
          this._clickPosX = e9.clientX;
          this._clickTime = Date.now();
          this._clickRangeStart = this.model.rangeStart;
          this._clickRangeEnd = this.model.rangeEnd;
          this.events.dispatch(this.events.startdrag, e9);
        } else if (this._isCurrentMouseOver) {
          this._isCurrentDragging = true;
          document.body.classList.add("og-timeline-unselectable");
          this._clickPosX = e9.clientX;
          this._clickCurrentDate = this.model.current;
          this.events.dispatch(this.events.startdragcurrent, e9);
        }
      };
      this._onMouseUp = (e9) => {
        if (this._isDragging) {
          this._isDragging = false;
          document.body.classList.remove("og-timeline-unselectable");
          if (this._clickPosX === e9.clientX && Date.now() - this._clickTime < this._clickDelay) {
            let rect = this._canvasEl.getBoundingClientRect();
            let current = new Date(this.model.rangeStartTime + (e9.clientX - rect.left) * this._millisecondsInPixel);
            this.model.current = current;
            this.events.dispatch(this.events.stopdrag, current);
            this.events.dispatch(this.events.setcurrent, current);
          } else {
            this.events.dispatch(this.events.stopdrag, this.model.current);
          }
        } else if (this._isCurrentDragging) {
          this._isCurrentDragging = false;
          document.body.classList.remove("og-timeline-unselectable");
          this.events.dispatch(this.events.stopdragcurrent, this.model.current);
        }
      };
      this._onMouseEnter = () => {
        this._isMouseOver = true;
      };
      this._onMouseOut = () => {
        this._isMouseOver = false;
      };
      this._onCurrentMouseEnter = () => {
        this._isCurrentMouseOver = true;
      };
      this._onCurrentMouseOut = () => {
        this._isCurrentMouseOver = false;
      };
      this._onMouseMove = (e9) => {
        if (this._isDragging) {
          let offsetSec = (this._clickPosX - e9.clientX) * this._millisecondsInPixel * MILLISECONDS_TO_SECONDS;
          this.model.set(addSeconds(this._clickRangeStart, offsetSec), addSeconds(this._clickRangeEnd, offsetSec));
        } else if (this._isCurrentDragging) {
          let offsetSec = (this._clickPosX - e9.clientX) * this._millisecondsInPixel * MILLISECONDS_TO_SECONDS;
          let newCurrent = addSeconds(this._clickCurrentDate, -offsetSec);
          if (newCurrent >= this.model.rangeStart && newCurrent <= this.model.rangeEnd) {
            this.model.current = addSeconds(this._clickCurrentDate, -offsetSec);
          }
        }
      };
      this.events = this.events.registerNames(TIMELINEVIEW_EVENTS);
      this.fillStyle = options2.fillStyle || SCALE_FILL_COLOR;
      this.$controls = null;
      this._frameEl = null;
      this._currentEl = null;
      this._canvasEl = createCanvasHTML();
      this._ctx = this._canvasEl.getContext("2d");
      this._isMouseOver = false;
      this._isDragging = false;
      this._isCurrentDragging = false;
      this._isCurrentMouseOver = false;
      this._minWidth = 330;
      this._canvasScale = 2;
      this._millisecondsInPixel = 0;
      this._clickPosX = 0;
      this._clickRangeStart = /* @__PURE__ */ new Date();
      this._clickRangeEnd = /* @__PURE__ */ new Date();
      this._clickCurrentDate = /* @__PURE__ */ new Date();
      this._clickTime = 0;
      this._clickDelay = 450;
      this._onResizeObserver_ = this._onResizeObserver.bind(this);
      this._resizeObserver = new ResizeObserver(this._onResizeObserver_);
      this._pauseBtn = new ToggleButton({
        classList: ["og-timeline-control_button"],
        icon: ICON_PAUSE_SVG,
        name: "pause"
      });
      this._playBtn = new ToggleButton({
        classList: ["og-timeline-control_button"],
        icon: ICON_PLAY_SVG,
        name: "play"
      });
      this._buttons = new ButtonGroup({
        buttons: [this._pauseBtn, this._playBtn]
      });
      this._visibility = false;
    }
    _onResizeObserver() {
      this.resize();
    }
    get canvasScale() {
      return this._canvasScale;
    }
    set canvasScale(scale2) {
      if (scale2 !== this._canvasScale) {
        this._canvasScale = scale2;
        this.resize();
      }
    }
    resize() {
      this._resize();
      this.draw();
    }
    afterRender(parentNode) {
      this.resize();
    }
    render() {
      super.render();
      this.$controls = this.select(".og-timeline-controls");
      this._frameEl = this.select(".og-timeline-frame");
      this._currentEl = this.select(".og-timeline-current");
      this.select(".og-timeline-frame .og-timeline-scale").appendChild(this._canvasEl);
      this._resizeObserver.observe(this.el);
      this.model.events.on("change", () => {
        this.draw();
      });
      this.model.events.on("current", (d4) => {
        this._drawCurrent();
        this.events.dispatch(this.events.setcurrent, d4);
      });
      this._canvasEl.addEventListener("mouseenter", this._onMouseEnter);
      this._canvasEl.addEventListener("mouseout", this._onMouseOut);
      this._currentEl.addEventListener("mouseenter", this._onCurrentMouseEnter);
      this._currentEl.addEventListener("mouseout", this._onCurrentMouseOut);
      document.body.addEventListener("mousemove", this._onMouseMove);
      document.body.addEventListener("mousedown", this._onMouseDown);
      document.body.addEventListener("mouseup", this._onMouseUp);
      document.body.addEventListener("wheel", this._onMouseWheelFF);
      this._playBtn.appendTo(this.$controls);
      this._pauseBtn.appendTo(this.$controls);
      if (this.model.stopped()) {
        this._pauseBtn.setActive(true, true);
        this._pauseBtn.preventClick = true;
      } else {
        this._playBtn.setActive(true, true);
        this._playBtn.preventClick = true;
      }
      this._buttons.events.on("change", (btn) => {
        switch (btn.name) {
          case "play":
            this.play();
            break;
          case "pause":
            this.pause();
            break;
        }
      });
      this.setVisibility(true);
      return this;
    }
    setVisibility(visibility) {
      if (visibility !== this._visibility) {
        this._visibility = visibility;
        if (this.el) {
          if (visibility) {
            this.el.style.display = "block";
          } else {
            this.el.style.display = "none";
          }
        }
        this.events.dispatch(this.events.visibility, visibility);
      }
    }
    reset() {
      this.model.stop();
      this.events.dispatch(this.events.reset, this.model);
    }
    play() {
      this.model.multiplier = Math.abs(this.model.multiplier);
      this.model.play();
      this.events.dispatch(this.events.play, this.model);
    }
    pause() {
      this.model.stop();
      this.events.dispatch(this.events.pause, this.model);
    }
    playBack() {
      this.model.multiplier = -1 * Math.abs(this.model.multiplier);
      this.model.play();
      this.events.dispatch(this.events.playback, this.model);
    }
    _zoom(pointerTime, pointerCenterOffsetX, dir) {
      let centerTime = this.model.rangeStartTime + 0.5 * this.model.range;
      let centerTimeOffset = (pointerTime - centerTime) * MILLISECONDS_TO_SECONDS;
      let rangeStart = addSeconds(this.model.rangeStart, centerTimeOffset), rangeEnd = addSeconds(this.model.rangeEnd, centerTimeOffset);
      let delta = (rangeEnd.getTime() - rangeStart.getTime()) / 20 * MILLISECONDS_TO_SECONDS;
      let newRangeStart = addSeconds(rangeStart, delta * dir);
      let newRangeEnd = addSeconds(rangeEnd, -delta * dir);
      let msPx = (newRangeEnd.getTime() - newRangeStart.getTime()) / this.clientWidth;
      if (msPx < 31536e6 && msPx > 0.1) {
        let timeOffset = msPx * pointerCenterOffsetX * MILLISECONDS_TO_SECONDS;
        this.model.set(addSeconds(newRangeStart, timeOffset), addSeconds(newRangeEnd, timeOffset));
      }
    }
    get clientWidth() {
      return this._canvasEl ? this._canvasEl.width / this._canvasScale : 0;
    }
    get clientHeight() {
      return this._canvasEl ? this._canvasEl.height / this._canvasScale : 0;
    }
    _resize() {
      if (this._frameEl) {
        this._canvasEl.width = this._frameEl.clientWidth * this._canvasScale;
        this._canvasEl.height = this._frameEl.clientHeight * this._canvasScale;
        this._canvasEl.style.width = `${this._frameEl.clientWidth}px`;
        this._canvasEl.style.height = `${this._frameEl.clientHeight}px`;
      }
    }
    getOffsetByTime(milliseconds) {
      return (milliseconds - this.model.rangeStartTime) / this._millisecondsInPixel;
    }
    remove() {
      super.remove();
      this.model.stop();
    }
    _clearCanvas() {
      this._ctx.fillStyle = this.fillStyle;
      this._ctx.fillRect(0, 0, this.clientWidth * this._canvasScale, this.clientHeight * this._canvasScale);
    }
    _drawCurrent() {
      let curPosX = (this.model.currentTime - this.model.rangeStartTime) / this._millisecondsInPixel;
      if (this.model.current < this.model.rangeStart || this.model.current > this.model.rangeEnd) {
        this._currentEl.style.display = "none";
      } else {
        this._currentEl.style.display = "block";
        this._currentEl.style.transform = `translateX(${curPosX}px)`;
      }
    }
    draw() {
      this._millisecondsInPixel = this.model.range / this.clientWidth;
      let minWidthMs = this._minWidth * this._millisecondsInPixel;
      let scaleData = getScale(minWidthMs * MILLISECONDS_TO_SECONDS);
      if (scaleData) {
        this._clearCanvas();
        let scaleMs = scaleData[0] * SECONDS_TO_MILLISECONDS, scalePx = scaleMs / this._millisecondsInPixel, segCount = scaleData[1];
        let originTime = getNearestTimeLeft(this.model.rangeStartTime, scaleMs);
        let showMilliseconds = scaleData[0] < 1, showTime = scaleData[0] < 86400;
        for (let i9 = originTime, rangeEnd = this.model.rangeEndTime + scaleMs; i9 < rangeEnd; i9 += scaleMs) {
          let x3 = this.getOffsetByTime(i9);
          if (x3 >= 0 && x3 <= this.clientWidth * this._canvasScale) {
            drawNotch(this._ctx, x3 * this._canvasScale, 10 * this._canvasScale, 2 * this._canvasScale, SCALE_NOTCH_COLOR);
          }
          for (let j2 = 1; j2 < segCount; j2++) {
            let xx = x3 + j2 * (scalePx / segCount);
            if (xx >= 0 && xx <= this.clientWidth * this._canvasScale) {
              drawNotch(this._ctx, xx * this._canvasScale, 5 * this._canvasScale, 1 * this._canvasScale, SCALE_NOTCH_COLOR);
            }
          }
          drawText(this._ctx, dateToStr(new Date(i9), showTime, showMilliseconds), x3 * this._canvasScale, 26 * this._canvasScale, "24px monospace", SCALE_TIME_COLOR, "center");
        }
        this._drawCurrent();
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/timeline/TimelineControl.js
  function addHours(date, hours) {
    const temp = new Date(date);
    temp.setHours(temp.getHours() + hours);
    return temp;
  }
  var ICON_BUTTON_SVG8 = `<?xml version="1.0" encoding="utf-8"?>
<!-- Svg Vector Icons : http://www.onlinewebfonts.com/icon -->
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000" xml:space="preserve">
    <metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>
    <g><path d="M500,10C229.4,10,10,229.4,10,500s219.4,490,490,490s490-219.4,490-490S770.6,10,500,10z M800.3,800.3c-39,39-84.5,69.7-135,91C613,913.5,557.4,924.7,500,924.7s-112.9-11.2-165.3-33.3c-50.5-21.3-95.9-52-135-91c-39-39-69.7-84.5-91-135C86.5,612.9,75.3,557.4,75.3,500s11.2-112.9,33.3-165.3c21.3-50.5,52-95.9,91-135c39-39,84.5-69.7,135-91C387.1,86.5,442.6,75.3,500,75.3s112.9,11.2,165.3,33.3c50.5,21.3,95.9,52,135,91c39,39,69.7,84.5,91,135c22.1,52.3,33.3,107.9,33.3,165.3s-11.2,112.9-33.3,165.3C869.9,715.8,839.3,761.2,800.3,800.3z"/><path d="M761.3,532.7H532.7V304c0-18.1-14.6-32.7-32.7-32.7s-32.7,14.6-32.7,32.7v261.3l0,0c0,18.1,14.6,32.7,32.7,32.7h261.3c18.1,0,32.7-14.6,32.7-32.7l0,0C794,547.3,779.4,532.7,761.3,532.7z"/></g>
</svg>`;
  var TimelineControl = class extends Control {
    constructor(options2 = {}) {
      super({
        name: "timeline",
        ...options2
      });
      let currentDate = options2.current || /* @__PURE__ */ new Date();
      let startDate = options2.rangeStart || addHours(currentDate, -12);
      let endDate = options2.rangeEnd || addHours(currentDate, 12);
      this._timelineView = new TimelineView({
        rangeStart: startDate,
        rangeEnd: endDate,
        currentDate
      });
      this._toggleBtn = new ToggleButton({
        classList: ["og-map-button", "og-timeline_button"],
        icon: ICON_BUTTON_SVG8
      });
      this._dialog = new Dialog({
        title: "Timeline",
        visible: false,
        resizable: true,
        useHide: true,
        top: 10,
        left: 60,
        width: 600,
        height: 115,
        minHeight: 115,
        maxHeight: 110
      });
      this._dialog.events.on("visibility", (v4) => {
        this._toggleBtn.setActive(v4);
      });
    }
    oninit() {
      let $container = this.renderer.div;
      this._toggleBtn.appendTo($container);
      this._dialog.appendTo($container);
      this._toggleBtn.events.on("change", (isActive) => {
        this._dialog.setVisibility(isActive);
        if (isActive) {
          this._timelineView.resize();
        }
      });
      this._timelineView.appendTo(this._dialog.container);
      this._timelineView.events.on("setcurrent", (d4) => {
        this.renderer && this.renderer.handler.defaultClock.setDate(d4);
      });
      this._timelineView.events.on("startdrag", () => {
        this.renderer && this.renderer.controls.mouseNavigation.deactivate();
      });
      this._timelineView.events.on("stopdrag", () => {
        this.renderer && this.renderer.controls.mouseNavigation.activate();
      });
      this._timelineView.events.on("startdragcurrent", () => {
        this.renderer && this.renderer.controls.mouseNavigation.deactivate();
      });
      this._timelineView.events.on("stopdragcurrent", () => {
        this.renderer && this.renderer.controls.mouseNavigation.activate();
      });
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/Deferred.js
  var Deferred = class {
    constructor() {
      this.resolve = () => {
      };
      this.reject = () => {
      };
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
      Object.freeze(this);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/elevationProfile/ElevationProfile.js
  var DEFAULT_WARNING_HEIGHT_LEVEL = 5;
  var ELEVATIONPROFILE_EVENTS = ["startcollecting", "profilecollected", "clear"];
  var SAFE = 0;
  var WARNING = 1;
  var COLLISION = 2;
  var TRACK = 0;
  var GROUND = 1;
  var SEGMMENT_LENGTH = 1;
  var GROUND_OFFSET = 1;
  var BOTTOM_PADDING = 0.1;
  var TOP_PADDING = 0.2;
  var HEIGHT_EPS = 0.1;
  var ElevationProfile = class {
    constructor(options2 = {}) {
      this.events = createEvents(ELEVATIONPROFILE_EVENTS);
      this.planet = options2.planet || null;
      this._warningHeightLevel = DEFAULT_WARNING_HEIGHT_LEVEL;
      this._pointsReady = false;
      this._isWarning = false;
      this._minX = 0;
      this._planeDistance = this._maxX = 1e3;
      this._minY = 0;
      this._maxY = 200;
      this._drawData = [[], []];
      this._promiseArr = [];
      this._promiseCounter = 0;
      this._pMaxY = 0;
      this._pMinY = 0;
      this._pDist = 0;
      this._pTrackCoords = [];
      this._pGroundCoords = [];
      this._pIndex = 0;
    }
    bindPlanet(planet) {
      this.planet = planet;
    }
    setWarningHeightLevel(warningHeight = 0) {
      this._warningHeightLevel = warningHeight;
    }
    setRange(minX, maxX, minY, maxY) {
      this._minX = minX;
      this._maxX = maxX;
      if (minY) {
        this._minY = minY;
      }
      if (maxY) {
        this._maxY = maxY;
      }
    }
    _getHeightAsync(ll, pIndex, promiseCounter) {
      let def = new Deferred();
      if (this.planet) {
        let msl = this.planet.terrain.geoid.getHeightLonLat(ll);
        this.planet.terrain.getHeightAsync(ll, (elv) => {
          if (this.planet && promiseCounter === this._promiseCounter) {
            elv += msl;
            this._pGroundCoords[pIndex][1] = elv;
            this._pGroundCoords[pIndex][2] = SAFE;
            this._pGroundCoords[pIndex][3] = ll.height;
            if (elv > this._pMaxY)
              this._pMaxY = elv;
            if (elv < this._pMinY)
              this._pMinY = elv;
            this._updatePointType(pIndex);
            def.resolve(elv);
          } else {
            def.reject();
          }
        });
      } else {
        def.reject();
      }
      return def.promise;
    }
    _collectCoordsBetweenTwoTrackPoints(index, internalPoints, scaleFactor, p0, trackDir, promiseCounter) {
      if (!this.planet)
        return;
      for (let j2 = 1; j2 <= internalPoints; j2++) {
        this._pDist += SEGMMENT_LENGTH;
        this._pIndex++;
        let dirSegLen = j2 * scaleFactor;
        let pjd = p0.add(trackDir.scaleTo(dirSegLen));
        let llx = this.planet.ellipsoid.cartesianToLonLat(pjd);
        this._pGroundCoords[this._pIndex] = [this._pDist, 0, SAFE, 0, index];
        ((lonlat, index2) => {
          this._promiseArr.push(this._getHeightAsync(lonlat, index2, promiseCounter));
        })(llx, this._pIndex);
      }
    }
    _collectAllPoints(pointsLonLat, promiseCounter) {
      if (!this.planet)
        return;
      if (promiseCounter !== this._promiseCounter)
        return;
      let p0 = new Vec3(), p1 = new Vec3();
      for (let i9 = 1, len = pointsLonLat.length; i9 < len; i9++) {
        let lonlat0 = pointsLonLat[i9 - 1], lonlat1 = pointsLonLat[i9];
        this.planet.ellipsoid.lonLatToCartesianRes(lonlat0, p0);
        this.planet.ellipsoid.lonLatToCartesianRes(lonlat1, p1);
        let trackDir = p1.sub(p0);
        let dirLength = trackDir.length();
        let n0 = this.planet.ellipsoid.getSurfaceNormal3v(p0);
        let proj = Vec3.proj_b_to_plane(trackDir, n0);
        let projLen = proj.length();
        let internalPoints = Math.floor(projLen / SEGMMENT_LENGTH);
        let scaleFactor = SEGMMENT_LENGTH * dirLength / projLen;
        this._getGroundElevation(lonlat0, i9 - 1, promiseCounter);
        proj.normalize();
        trackDir.normalize();
        this._collectCoordsBetweenTwoTrackPoints(i9 - 1, internalPoints, scaleFactor, p0, trackDir, promiseCounter);
        this._pDist += projLen - internalPoints * SEGMMENT_LENGTH;
        this._pIndex++;
        let elv = lonlat1.height;
        if (elv > this._pMaxY)
          this._pMaxY = elv;
        if (elv < this._pMinY)
          this._pMinY = elv;
        this._pTrackCoords[i9] = [this._pDist, elv, this._pIndex];
      }
    }
    _getGroundElevation(lonLat, index, promiseCounter) {
      this._pGroundCoords[this._pIndex] = [this._pDist, 0, SAFE, 0, index];
      this._promiseArr.push(this._getHeightAsync(lonLat, this._pIndex, promiseCounter));
    }
    _calcPointsAsync(pointsLonLat, promiseCounter) {
      return new Promise((resolve, reject) => {
        this._pTrackCoords = [[0, pointsLonLat[0].height, 0]];
        this._pMaxY = pointsLonLat[0].height;
        this._pMinY = this._pMaxY;
        this._pDist = 0;
        this._pGroundCoords = [];
        this._pIndex = 0;
        this._promiseArr = [];
        this._collectAllPoints(pointsLonLat, promiseCounter);
        this._getGroundElevation(pointsLonLat[pointsLonLat.length - 1], pointsLonLat.length - 1, promiseCounter);
        Promise.all(this._promiseArr).then(() => {
          resolve({
            dist: this._pDist,
            minY: this._pMinY,
            maxY: this._pMaxY,
            trackCoords: this._pTrackCoords,
            groundCoords: this._pGroundCoords
          });
        });
      });
    }
    get minX() {
      return this._minX;
    }
    get planeDistance() {
      return this._planeDistance;
    }
    get maxX() {
      return this._maxX;
    }
    get minY() {
      return this._minY;
    }
    get maxY() {
      return this._maxY;
    }
    get pointsReady() {
      return this._pointsReady;
    }
    get isWarningOrCollision() {
      return this._isWarning;
    }
    get drawData() {
      return this._drawData;
    }
    collectProfile(pointsLonLat) {
      let def = new Deferred();
      if (!this.planet)
        def.reject();
      this._pointsReady = false;
      this._isWarning = false;
      if (!pointsLonLat || !pointsLonLat.length) {
        def.reject();
        return def.promise;
      }
      this.events.dispatch(this.events.startcollecting, this);
      this._promiseCounter++;
      ((counter) => {
        this._calcPointsAsync(pointsLonLat, counter).then((p4) => {
          if (counter === this._promiseCounter) {
            this._planeDistance = p4.dist;
            this.setRange(0, p4.dist, p4.minY - BOTTOM_PADDING * Math.abs(p4.minY), p4.maxY + Math.abs(p4.maxY) * TOP_PADDING);
            this._pointsReady = true;
            this._drawData = [p4.trackCoords, p4.groundCoords];
            this.events.dispatch(this.events.profilecollected, this._drawData, this);
            def.resolve(this._drawData);
          }
        });
      })(this._promiseCounter);
      return def.promise;
    }
    _updatePointType(pIndex) {
      if (this._pGroundCoords[pIndex][3] >= this._pGroundCoords[pIndex][1] && this._pGroundCoords[pIndex][3] < this._pGroundCoords[pIndex][1] + this._warningHeightLevel - HEIGHT_EPS) {
        this._pGroundCoords[pIndex][2] = WARNING;
      }
      if (this._pGroundCoords[pIndex][3] <= this._pGroundCoords[pIndex][1] + GROUND_OFFSET) {
        this._pGroundCoords[pIndex][2] = COLLISION;
      }
      if (this._pGroundCoords[pIndex][2] === WARNING || this._pGroundCoords[pIndex][2] === COLLISION) {
        this._isWarning = true;
      }
    }
    /**
     * @deprecated
     */
    _setPointsType() {
      this._isWarning = false;
      this._pTrackCoords = this._drawData[TRACK];
      this._pGroundCoords = this._drawData[GROUND];
      for (let i9 = 0; i9 < this._pGroundCoords.length; i9++) {
        this._updatePointType(i9);
      }
      this._drawData[GROUND] = this._pGroundCoords;
      this.events.dispatch(this.events.profilecollected, this._drawData, this);
    }
    clear() {
      this._promiseCounter = 0;
      this._pointsReady = false;
      this._isWarning = false;
      this._drawData = [[], []];
      this._pMaxY = 0;
      this._pMinY = 0;
      this._pDist = 0;
      this._pTrackCoords = [];
      this._pGroundCoords = [];
      this._pIndex = 0;
      this.events.dispatch(this.events.clear, this._drawData, this);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/elevationProfile/ElevationProfileView.js
  var FILL_COLOR = "rgb(63, 63, 63)";
  var TRACK_COLOR = "rgb(0, 255, 50)";
  var TERRAIN_COLOR = "rgb(198, 198, 198)";
  var TERRAIN_FILL_COLOR = "rgb(64, 68, 82)";
  var WARNING_COLOR = "rgb(255, 255, 0)";
  var COLLISION_COLOR = "rgb(255, 0, 0)";
  var LINE_COLORS = [TERRAIN_COLOR, WARNING_COLOR, COLLISION_COLOR];
  var TERRAIN_ALPHA = 0.5;
  var LINE_WIDTH = 5;
  var ELEVATIONPROFILEVIEW_EVENTS = ["startdrag", "stopdrag", "pointer", "mouseenter", "mouseleave", "dblclick", "tracklength", "groundlength", "warninglength", "collisionlength"];
  var TEMPLATE9 = `<div class="og-elevationprofile">
      <div class="og-elevationprofile-loading" style="display: none;">
        <div class="loadingio-spinner-bars-r354qqyl5v">
          <div class="ldio-p0v5a1f6oz">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
          </div>
        </div> 
      </div>     
    </div>`;
  var ElevationProfileView = class extends View {
    constructor(options2 = {}) {
      super({
        template: TEMPLATE9,
        model: new ElevationProfile()
      });
      this._onMouseDblClick = (e9) => {
        let rect = this.$canvas.getBoundingClientRect();
        let x3 = e9.clientX - rect.left;
        let pointerDistance = this._leftDistance + (this._rightDistance - this._leftDistance) * x3 / this.clientWidth;
        let groundData = this.model.drawData[1];
        let trackData = this.model.drawData[0];
        let groundPoiIndex;
        if (pointerDistance < 0) {
          groundPoiIndex = 1;
          pointerDistance = 0;
          x3 = (0 - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
        } else if (pointerDistance > this.model.planeDistance) {
          groundPoiIndex = groundData.length - 1;
          pointerDistance = this.model.planeDistance;
          x3 = (pointerDistance - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
        } else {
          groundPoiIndex = -1 - binarySearch(groundData, pointerDistance, (a6, b4) => {
            return a6 - b4[0];
          });
        }
        let gp0 = groundData[groundPoiIndex - 1], gp1 = groundData[groundPoiIndex];
        let d4 = (pointerDistance - gp0[0]) / (gp1[0] - gp0[0]);
        let groundElv = gp0[1] + d4 * (gp1[1] - gp0[1]);
        let trackPoiIndex = gp0[4];
        let tp0 = trackData[trackPoiIndex], tp1 = trackData[trackPoiIndex + 1];
        d4 = (pointerDistance - tp0[0]) / (tp1[0] - tp0[0]);
        let trackElv = tp0[1] + d4 * (tp1[1] - tp0[1]);
        this.events.dispatch(this.events.dblclick, pointerDistance, tp0, tp1, gp0, gp1, trackPoiIndex, groundPoiIndex - 1, trackElv - groundElv);
      };
      this._onMouseEnter = (e9) => {
        this._isMouseOver = true;
        this.events.dispatch(this.events.mouseenter, e9);
      };
      this._onMouseOut = (e9) => {
        this._isMouseOver = false;
        this.events.dispatch(this.events.mouseleave, e9);
      };
      this._onMouseDown = (e9) => {
        if (this._isMouseOver) {
          this._isDragging = true;
          document.body.classList.add("og-timeline-unselectable");
          this._clickPosX = e9.clientX;
          if (!this._customFrame) {
            this._leftDistance = this.model.minX;
            this._rightDistance = this.model.maxX;
          }
          this._clickLeftDistance = this._leftDistance;
          this._clickRightDistance = this._rightDistance;
          this.events.dispatch(this.events.startdrag, e9);
        }
      };
      this._onMouseUp = (e9) => {
        if (this._isDragging) {
          this._isDragging = false;
          document.body.classList.remove("og-timeline-unselectable");
          this.events.dispatch(this.events.stopdrag, e9);
        }
      };
      this._onCanvasMouseMove = (e9) => {
        if (this.model.pointsReady) {
          if (!this._isDragging) {
            if (!this._customFrame) {
              this._leftDistance = this.model.minX;
              this._rightDistance = this.model.maxX;
            }
            let rect = this.$pointerCanvas.getBoundingClientRect();
            let x3 = e9.clientX - rect.left;
            this.redrawPointerCanvas(x3);
          } else {
            this.clearPointerCanvas();
          }
        }
      };
      this._onMouseMove = (e9) => {
        if (this._isDragging && this.model.pointsReady) {
          let offset = this._clickPosX - e9.clientX;
          let distanceOffset = offset * this._canvasScale / this._pixelsInMeter_x;
          this.setFrame(this._clickLeftDistance + distanceOffset, this._clickRightDistance + distanceOffset);
        }
      };
      this._onMouseWheelFF = (e9) => {
        this._onMouseWheel(e9);
      };
      this._onMouseWheel = (e9) => {
        if (this._isMouseOver && this.model.pointsReady) {
          if (!this._customFrame) {
            this._leftDistance = this.model.minX;
            this._rightDistance = this.model.maxX;
          }
          this._customFrame = true;
          let padDist = Math.sign(e9.wheelDelta) * (this._rightDistance - this._leftDistance) / 20;
          let rect = this.$canvas.getBoundingClientRect();
          let pointerPosX = e9.clientX - rect.left, pointerCenterOffsetX = pointerPosX - this.$canvas.clientWidth * 0.5;
          let distanceCenterOffsetX = pointerCenterOffsetX * this._canvasScale / this._pixelsInMeter_x;
          let leftDistance = distanceCenterOffsetX + this._leftDistance + padDist;
          let rightDistance = distanceCenterOffsetX + this._rightDistance - padDist;
          distanceCenterOffsetX = -pointerCenterOffsetX * (rightDistance - leftDistance) / this.clientWidth;
          this.setFrame(leftDistance + distanceCenterOffsetX, rightDistance + distanceCenterOffsetX);
          this.redrawPointerCanvas(pointerPosX);
        }
      };
      this.events = this.events.registerNames(ELEVATIONPROFILEVIEW_EVENTS);
      this.fillStyle = options2.fillStyle || FILL_COLOR;
      this._customFrame = false;
      this._leftDistance = 0;
      this._rightDistance = 0;
      this._pixelsInMeter_x = 0;
      this._pixelsInMeter_y = 0;
      this._canvasScale = 2;
      this.$canvas = document.createElement("canvas");
      this.$canvas.style.position = "absolute";
      this._ctx = this.$canvas.getContext("2d");
      this.$pointerCanvas = document.createElement("canvas");
      this.$pointerCanvas.style.pointerEvents = "none";
      this.$pointerCanvas.style.position = "absolute";
      this._pointerCtx = this.$pointerCanvas.getContext("2d");
      this.$loading = null;
      this._isMouseOver = false;
      this._isDragging = false;
      this._clickPosX = 0;
      this._clickLeftDistance = 0;
      this._clickRightDistance = 0;
      this._timeStartHandler = 0;
      this._onResizeObserver_ = this._onResizeObserver.bind(this);
      this._resizeObserver = new ResizeObserver(this._onResizeObserver_);
    }
    _onResizeObserver() {
      this.resize();
    }
    get canvasScale() {
      return this._canvasScale;
    }
    set canvasScale(scale2) {
      if (scale2 !== this._canvasScale) {
        this._canvasScale = scale2;
        this.resize();
      }
    }
    resize() {
      this._resize();
      this.draw();
    }
    render() {
      super.render();
      this._resizeObserver.observe(this.el);
      this.el.appendChild(this.$canvas);
      this.el.appendChild(this.$pointerCanvas);
      this.model.events.on("profilecollected", (data) => {
        this._hideLoading();
        this.clearPointerCanvas();
        this.draw();
      });
      this.model.events.on("startcollecting", () => {
        clearTimeout(this._timeStartHandler);
        this._timeStartHandler = setTimeout(() => {
          this._showLoading();
        }, 450);
      });
      this.model.events.on("clear", () => {
        this._customFrame = false;
        this._leftDistance = 0;
        this.clearCanvas();
        this.clearPointerCanvas();
      });
      this.$loading = this.select(".og-elevationprofile-loading");
      this.$canvas.addEventListener("mouseenter", this._onMouseEnter);
      this.$canvas.addEventListener("mouseout", this._onMouseOut);
      this.$canvas.addEventListener("dblclick", this._onMouseDblClick);
      this.$canvas.addEventListener("mousemove", this._onCanvasMouseMove);
      document.body.addEventListener("mousemove", this._onMouseMove);
      document.body.addEventListener("mousedown", this._onMouseDown);
      document.body.addEventListener("mouseup", this._onMouseUp);
      document.body.addEventListener("wheel", this._onMouseWheelFF);
      return this;
    }
    _hideLoading() {
      clearTimeout(this._timeStartHandler);
      this.$loading.style.display = "none";
    }
    _showLoading() {
      this.$loading.style.display = "flex";
    }
    redrawPointerCanvas(x3) {
      this.clearPointerCanvas();
      let pointerDistance = this._leftDistance + (this._rightDistance - this._leftDistance) * x3 / this.clientWidth;
      let groundData = this.model.drawData[1];
      let trackData = this.model.drawData[0];
      let groundPoiIndex;
      if (pointerDistance < 0) {
        groundPoiIndex = 1;
        pointerDistance = 0;
        x3 = (0 - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
      } else if (pointerDistance > this.model.planeDistance) {
        groundPoiIndex = groundData.length - 1;
        pointerDistance = this.model.planeDistance;
        x3 = (pointerDistance - this._leftDistance) * this.clientWidth / (this._rightDistance - this._leftDistance);
      } else {
        groundPoiIndex = -1 - binarySearch(groundData, pointerDistance, (a6, b4) => {
          return a6 - b4[0];
        });
      }
      let gp0 = groundData[groundPoiIndex - 1], gp1 = groundData[groundPoiIndex];
      let d4 = (pointerDistance - gp0[0]) / (gp1[0] - gp0[0]);
      let groundElv = gp0[1] + d4 * (gp1[1] - gp0[1]);
      let trackPoiIndex = gp0[4];
      let tp0 = trackData[trackPoiIndex], tp1 = trackData[trackPoiIndex + 1];
      d4 = (pointerDistance - tp0[0]) / (tp1[0] - tp0[0]);
      let trackElv = tp0[1] + d4 * (tp1[1] - tp0[1]);
      let trackY = (this.model.maxY - trackElv) * this._pixelsInMeter_y;
      let groundY = (this.model.maxY - groundElv) * this._pixelsInMeter_y;
      this.events.dispatch(this.events.pointer, pointerDistance, tp0, tp1, gp0, gp1, trackPoiIndex, groundPoiIndex - 1, trackElv - groundElv);
      let ctx = this._pointerCtx;
      ctx.lineWidth = 3;
      ctx.strokeStyle = "rgba(64,64,64,0.6)";
      ctx.beginPath();
      ctx.moveTo(x3 * this._canvasScale, 0);
      ctx.lineTo(x3 * this._canvasScale, this.clientHeight * this._canvasScale);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x3 * this._canvasScale, groundY, 4, 0, 2 * Math.PI, false);
      ctx.fillStyle = "#FFB277";
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#FFB277";
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x3 * this._canvasScale, trackY, 4, 0, 2 * Math.PI, false);
      ctx.fillStyle = "#FFB277";
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#FFB277";
      ctx.stroke();
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#FFB277";
      ctx.beginPath();
      ctx.moveTo(x3 * this._canvasScale, groundY);
      ctx.lineTo(x3 * this._canvasScale, trackY);
      ctx.stroke();
      ctx.fillStyle = "white";
      ctx.font = `${28 / devicePixelRatio}px Arial`;
      ctx.textBaseline = "middle";
      ctx.textAlign = "left";
      ctx.fillText(`${Math.round(trackElv - groundElv).toString()} m`, (x3 + 5) * this._canvasScale, groundY + (trackY - groundY) * 0.5);
      ctx.fillStyle = "white";
      ctx.font = `${28 / devicePixelRatio}px Arial`;
      ctx.textAlign = "right";
      let distStr = distanceFormatExt(pointerDistance);
      ctx.fillText(`${distStr[0]} ${distStr[1]}`, (x3 - 5) * this._canvasScale, (this.clientHeight - 7) * this._canvasScale);
    }
    get clientWidth() {
      return this.$canvas ? this.$canvas.width / this._canvasScale : 0;
    }
    get clientHeight() {
      return this.$canvas ? this.$canvas.height / this._canvasScale : 0;
    }
    _resize() {
      if (this.el) {
        this.$canvas.width = this.el.clientWidth * this._canvasScale;
        this.$canvas.height = this.el.clientHeight * this._canvasScale;
        this.$canvas.style.width = `${this.el.clientWidth}px`;
        this.$canvas.style.height = `${this.el.clientHeight}px`;
        this.$pointerCanvas.width = this.el.clientWidth * this._canvasScale;
        this.$pointerCanvas.height = this.el.clientHeight * this._canvasScale;
        this.$pointerCanvas.style.width = `${this.el.clientWidth}px`;
        this.$pointerCanvas.style.height = `${this.el.clientHeight}px`;
        if (this._customFrame) {
          this._pixelsInMeter_x = this._canvasScale * this.clientWidth / (this._rightDistance - this._leftDistance);
        }
      }
    }
    clearPointerCanvas() {
      this._pointerCtx.fillStyle = "rgba(0,0,0,0)";
      this._pointerCtx.clearRect(0, 0, this.clientWidth * this._canvasScale, this.clientHeight * this._canvasScale);
    }
    clearCanvas() {
      const grd = this._ctx.createLinearGradient(0, 0, 0, this.clientHeight * this._canvasScale);
      grd.addColorStop(0, "black");
      grd.addColorStop(1, this.fillStyle);
      this._ctx.fillStyle = grd;
      this._ctx.fillRect(0, 0, this.clientWidth * this._canvasScale, this.clientHeight * this._canvasScale);
    }
    setFrame(leftDistance, rightDistance) {
      this._leftDistance = leftDistance;
      this._rightDistance = rightDistance;
      this._customFrame = true;
      this._pixelsInMeter_x = this._canvasScale * this.clientWidth / (this._rightDistance - this._leftDistance);
      this.model.setRange(leftDistance, rightDistance);
      this.draw();
    }
    _updateUnits() {
      if (!this._customFrame) {
        this._pixelsInMeter_x = this._canvasScale * this.clientWidth / (this.model.maxX - this.model.minX);
      }
      this._pixelsInMeter_y = this._canvasScale * this.clientHeight / (this.model.maxY - this.model.minY);
    }
    clear() {
      this.model.clear();
      this.clearCanvas();
    }
    draw() {
      let trackCoords = this.model.drawData[0];
      if (trackCoords.length > 1) {
        this._updateUnits();
        this.clearCanvas();
        let groundCoords = this.model.drawData[1];
        this._drawTrack(trackCoords, groundCoords);
        this._drawTerrain(groundCoords);
        this._drawWarningAndCollision(groundCoords);
        this._drawLabels(trackCoords, groundCoords);
      } else {
        this.clearCanvas();
      }
    }
    _drawLabels(coords, groundCoords) {
      let ctx = this._ctx;
      if (ctx) {
        let p0 = coords[0];
        const maxY = this.model.maxY;
        let x3 = (-this._leftDistance + p0[0]) * this._pixelsInMeter_x, yt = (maxY - p0[1]) * this._pixelsInMeter_y, yg = (maxY - groundCoords[p0[2]][1]) * this._pixelsInMeter_y;
        ctx.beginPath();
        ctx.fillStyle = "#F7F718";
        ctx.fillRect(x3 - 4, yt - 4, 8, 8);
        ctx.stroke();
        ctx.fillStyle = "white";
        ctx.font = `${26 / devicePixelRatio}px Arial`;
        ctx.textBaseline = "bottom";
        ctx.textAlign = "left";
        ctx.fillText(`${Math.round(p0[1] - groundCoords[p0[2]][1]).toString()} m`, x3 + 1, yt - 10);
        ctx.stroke();
        for (let i9 = 1, len = coords.length; i9 < len; i9++) {
          let pi = coords[i9];
          x3 = (-this._leftDistance + pi[0]) * this._pixelsInMeter_x;
          yt = (maxY - pi[1]) * this._pixelsInMeter_y;
          yg = (maxY - groundCoords[pi[2]][1]) * this._pixelsInMeter_y;
          ctx.beginPath();
          ctx.fillStyle = "#F7F718";
          ctx.fillRect(x3 - 4, yt - 4, 8, 8);
          ctx.stroke();
          ctx.fillStyle = "white";
          ctx.fillText(`${Math.round(pi[1] - groundCoords[pi[2]][1]).toString()} m`, x3 + 1, yt - 10);
          ctx.stroke();
        }
      }
    }
    _drawTrack(coords, groundCoords) {
      let p0 = coords[0];
      let ctx = this._ctx;
      if (ctx) {
        const maxY = this.model.maxY;
        ctx.lineWidth = LINE_WIDTH;
        ctx.strokeStyle = TRACK_COLOR;
        ctx.beginPath();
        ctx.moveTo((-this._leftDistance + p0[0]) * this._pixelsInMeter_x, (maxY - p0[1]) * this._pixelsInMeter_y);
        let trackLength = 0;
        for (let i9 = 1, len = coords.length; i9 < len; i9++) {
          let pi = coords[i9];
          ctx.lineTo((-this._leftDistance + pi[0]) * this._pixelsInMeter_x, (maxY - pi[1]) * this._pixelsInMeter_y);
          let prevP = coords[i9 - 1];
          let a6 = pi[0] - prevP[0], b4 = pi[1] - prevP[1], aa = a6 * a6, bb = b4 * b4;
          trackLength += Math.sqrt(aa + bb);
        }
        ctx.stroke();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(255,255,255,0.7)";
        ctx.beginPath();
        let x3 = (-this._leftDistance + p0[0]) * this._pixelsInMeter_x, yt = (maxY - p0[1]) * this._pixelsInMeter_y, yg = (maxY - groundCoords[p0[2]][1]) * this._pixelsInMeter_y;
        ctx.moveTo(x3, yt);
        ctx.lineTo(x3, yg);
        for (let i9 = 1, len = coords.length; i9 < len; i9++) {
          let pi = coords[i9];
          x3 = (-this._leftDistance + pi[0]) * this._pixelsInMeter_x;
          yt = (maxY - pi[1]) * this._pixelsInMeter_y;
          yg = (maxY - groundCoords[pi[2]][1]) * this._pixelsInMeter_y;
          ctx.strokeStyle = "rgba(255,255,255,0.7)";
          ctx.moveTo(x3, yt);
          ctx.lineTo(x3, yg);
        }
        ctx.stroke();
        this.events.dispatch(this.events.tracklength, trackLength);
      }
    }
    _drawTerrain(coords) {
      let p0 = coords[0];
      let ctx = this._ctx;
      if (ctx) {
        const maxY = this.model.maxY;
        ctx.lineWidth = LINE_WIDTH;
        ctx.strokeStyle = TERRAIN_COLOR;
        ctx.beginPath();
        ctx.moveTo((-this._leftDistance + p0[0]) * this._pixelsInMeter_x, this.$canvas.height);
        ctx.lineTo((-this._leftDistance + p0[0]) * this._pixelsInMeter_x, (maxY - p0[1]) * this._pixelsInMeter_y);
        let groundLength = 0;
        for (let i9 = 1, len = coords.length; i9 < len; i9++) {
          let pi = coords[i9];
          ctx.lineTo((-this._leftDistance + pi[0]) * this._pixelsInMeter_x, (maxY - pi[1]) * this._pixelsInMeter_y);
          let prevP = coords[i9 - 1];
          let a6 = pi[0] - prevP[0], b4 = pi[1] - prevP[1], aa = a6 * a6, bb = b4 * b4;
          groundLength += Math.sqrt(aa + bb);
        }
        ctx.lineTo((-this._leftDistance + coords[coords.length - 1][0]) * this._pixelsInMeter_x, this.$canvas.height);
        ctx.closePath();
        ctx.stroke();
        ctx.save();
        ctx.fillStyle = TERRAIN_FILL_COLOR;
        ctx.globalAlpha = TERRAIN_ALPHA;
        ctx.fill();
        ctx.restore();
        ctx.globalAlpha = 1;
        this.events.dispatch(this.events.groundlength, groundLength);
      }
    }
    _drawWarningAndCollision(coords) {
      let ctx = this._ctx;
      if (ctx && coords.length > 1) {
        let maxY = this.model.maxY;
        ctx.lineWidth = LINE_WIDTH;
        ctx.beginPath();
        let warningLength = 0, collisionLength = 0;
        for (let i9 = 0, len = coords.length - 1; i9 < len; i9++) {
          let pi0 = coords[i9], pi1 = coords[i9 + 1];
          if (pi0[2] !== SAFE && pi1[2] !== SAFE) {
            let a6 = pi1[0] - pi0[0], b4 = pi1[1] - pi0[1], aa = a6 * a6, bb = b4 * b4;
            if (pi0[2] === COLLISION) {
              ctx.stroke();
              ctx.beginPath();
              ctx.strokeStyle = LINE_COLORS[COLLISION];
              collisionLength += Math.sqrt(aa + bb);
            } else if (pi0[2] === WARNING) {
              ctx.stroke();
              ctx.beginPath();
              ctx.strokeStyle = LINE_COLORS[WARNING];
              warningLength += Math.sqrt(aa + bb);
            }
            ctx.moveTo((-this._leftDistance + pi0[0]) * this._pixelsInMeter_x, (maxY - pi0[1]) * this._pixelsInMeter_y);
            ctx.lineTo((-this._leftDistance + pi1[0]) * this._pixelsInMeter_x, (maxY - pi1[1]) * this._pixelsInMeter_y);
          }
        }
        ctx.stroke();
        this.events.dispatch(this.events.warninglength, warningLength);
        this.events.dispatch(this.events.collisionlength, collisionLength);
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/elevationProfile/ElevationProfileScene.js
  var groundObj3d = Object3d.createCylinder(0.33, 0, 1, 20, 1, true, false, 0, 0, 0);
  var headObj3d = Object3d.createCylinder(0.33, 0.33, 1.1, 20, 1, true, true, 0, -0.55, 0);
  var POINTER_RAY_OPTIONS = {
    startPosition: new Vec3(),
    endPosition: new Vec3(),
    startColor: "rgba(255,131,0,0.2)",
    endColor: "rgba(255,131,0,1.0)",
    thickness: 2.7
  };
  var POINTER_BILLBOARD_OPTIONS = {
    src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjEuNBNAaMQAAAiLSURBVHhe7Z0r0BxFEMcjIhAIRERERAQCgUAgEBEIBAIRiUAgIiIQiAgEIlUREQgEIgIREYFAIBCIiAgEIiIiAoGIoHimqPAKz5CP/t23/8vcbe89d/dmZ/pf9avLdZK72e6+ee3M7Imjo6Opc8o4b7xn3DIeGEOJz+Y7+C6+k+/2yjQZXOMEOGdcNe4anv4wvjV+m73bT3wGn8VneqIMlIUyeWXNGteYKTj4feNrI9W/xi/HfxxVfCffnYqyUcbJJINrzIjTxjvGV0aqn43fj/+YhSgLZUpFmd81uAbv2rLANWbAC8ZHxp+GxC8ufZ+rKGNaI1FLcC1ck3etB8U1HhCqzk8N6T/jENV7X6LsXIN008iqeXCNB+B54zND+tt4ePzHIsS1cE0SicA1e74YFdc4IgyjrhvqTP3TvJas9Bq59oP2EVzjCJw03jI0TCMBcurUDS1qBCU9PnjbwCeerwbFNQ4MVd9tQ5pyG7+v0mvHJ6N3FF3jgFwy1JPvmlipUfIFvmHY6/luEFzjANDO0fGRfm1eQ0+UzlriqzOG58tecY0985LxnYH+al5D3ZKP8Bm+83zaG66xRy4a6uzU3NZvK/nqkUEH0fNtL7jGHqBH+4EhTWEGL2ddMwYZJbjGPaGgHxuIDA7tJ/mQGdLek8A17sHTxucGiva+P6kGxbf42PP9TrjGHUmDH1V+/xokCVzjDkTwx1HvSeAat4R2SWP8CP7wko9ZmrZ3n8A1bok6fBH88SRf4/u9ksA1bgFr4ZDG+qHxpLuKLFD1YrMRrnFDLhjocfMaGl8aIjLh5sVoLa5xA140+lhxG+pHNAk7TRu7xjXQ+9TK3Jru4ecqxYB7B88YXsw6cY1rUKcv7ujlI907YLbQi1knrnEFavej05ef1ClkpZUXOxfX2AH3p6Pdz1/E6FnDi2EL19iBVu3Gbd18pdgwU+jFsIVrdHjDQHGDJ39pkojm2ovlAq5xCXqWWtETmo7uG2t3L7vGJTTbF73+6UhNARtVvZjOcY0JZ42Y45+uGK2t7BC6xoQbBoqO3/SkGpt5Gy+2M1xjw3MGGZRubgxNS5qv6dxw4hob9OuPsf90pWnizlrANRpM+sSvvwypFqBGb8W6ZWjgHjOKtn/6Ug3OMv1WrFsG4ykjqv3yxGiudbdw4U2DbvjEuL8cqSZv7TJaeNOg1b2h8nTHWIj3whuDSQOUHmcSKkPagr5wNE0afLhioOj8lSc16QvTw2nwYfk8vlB5YjnfPOZp8FX9x8kd5Uqju3kzkCYAPUQU1X+5UjPACaatBEiPcAmVrfmKIQU/Jn/qEpNCs82lSgCOL0U/Na+hcvVD8/qKMU8AjiZDsdGjfCnGl415AnyCJVSVZptIlAD3sISqEgt9ZwnAHSIU07/1SMv7T5EA7CpFPzavofKljuA5EkCbPmICqB4p1m+SAPQGQ3XqMgnAQwtCdeo6CRBTwPXqJgnAKpFQnbpDAsQcQL26RwLEzt96dZ8ECFWsSIDKFQlQuSIBKlckQOUiAThLJlSnZqOAmAeoV7N5gJgJrFd3SQCePBGqU7dIgLgbWK9mdwO1ITRUn66QADoQIlYE1SPF+gIJEGsC69PCmkDOk0WxKrgeaQf4aRIA9AiYUD2a7wuA2BlUn1gKOE8A9ouj2BtYvh42r4z+5gnATlEUHcHy9X3z+poxT4A4H6Aecfxv63wAiOXh9ah1QgioHxAnhJYr1fKz9h/SBOA0aRSnhJUrJQCP/m0lAMQ5geWr85xA0I2haAbKk4b4K08KVTMQ08LlSU37vPqHNPgiVgiVK5r4hXgvvGm4aKC4PVyOFMuNnhfABEFMCpWnjZ8YAjxfBkUiTF/q/LH0rxXrlqFBJ4friVOh6Uod+oUHRYiWIYFnzaG4QzhdqefPo/+9GK9MAJ42SQ0QtcB0pV//wtAvxTUmqBaIiaHpSff9Z0fCduEaE+gLxBNEpyliRuzctl+4xiU0Ioh5gelIsfrQ8GI6xzUuwdjxgRGalojZacOL6RzX6KDNI0wmhPKWev6tWT8P19jBFwaKDmG+0pD9tnHS8OK4gGvsgDuFUQPkr7UdvxTXuAI9Wk7nzYfykX6clwwvdi6ucQ3MKqEYFeQjxYKFvRtV/cI1roG9hDpdNNYPHl6KAWc9re31L+MaN4DHzMUUcT4iFi8bXqxW4ho3RP2Bx81raHw9al557J8Xo7W4xi24ZqAYHYwv+XztbN8qXOMW0OFQpzBuG48n+XrrTt8yrnFLWELGViMUSTC85GN8Ptvftw+ucQcYGTD7hCIJhpN8y8rtrXv8Hq5xR7hpdNdAkQT9Sz7Fx70EH1zjHlAl6Z5BdAz7k3xJLdta2bsPrnFP0j5BzBXsL/mwlzZ/GdfYA/RMbxgo5gl2l3yHL/fq7XfhGnskfSpp3DvYXKmvZs/5HwrX2DOcP6QVRVqoGOqWfMSmnFcNz6e94RoH4IyhziGLFeMmUlv4RItv8RU+83zZK65xIGjDOH9AnZoYKj6RfIFvrhqDtPcernFg2KTwpSHVvMQsvXa2bnNus+ezwXCNI6DaQOPbGoeLumZ8gC9G+9WnuMYRYeOJdh+hGiaP0mvkiF584PlmFFzjAWAxgzqJqMRESK+Ja91pAUffuMYDwvGlaSJQTU65j0DZ0+aNaztveNd+EFxjBjB3QPWYOm9Kh1WkZeUa2KDJNXnXelBcY0bQPnKs2fIj7nOsFZbLRJkp+0Hb+HW4xgzhMGuqTubEl2sC9igcYpqZ71zeH0HZKCNlpczetWSFa8wcJQO7lrtONiUQ3xh9TDbxGXxWVxNEGSjLZIKe4honxlnjdYMFqnSyhhxB8Nl8B9/Fd/LdXpkmg2ssANpdfpEsXacdZq6BJ6Tya+VZyWnnUsLG3/Fv+Lf8H/4vn8FnZd2W78bRif8BxMOwtJg5Ph4AAAAASUVORK5CYII=",
    color: "rgb(255,131,0)",
    size: [8, 8]
  };
  var POINTER_LABEL_OPTIONS = {
    text: "",
    size: 10.5,
    color: "rgba(455,455,455,1.0)",
    outlineColor: "rgba(0,0,0,0.34)",
    outline: 0.23,
    align: "left",
    offset: [5, 15, -5]
  };
  var LABEL_OPTIONS3 = {
    text: "",
    size: 10.5,
    color: "rgba(455,455,455,1.0)",
    outlineColor: "rgba(0,0,0,0.34)",
    outline: 0.23,
    align: "right",
    offset: [-47, 25, 0]
  };
  var GROUND_POINTER_OPTIONS = {
    instanced: true,
    tag: "ground-pointer",
    color: "rgb(0,305,0)",
    object3d: groundObj3d
  };
  var HEAD_POINTER_OPTIONS = {
    instanced: true,
    tag: "head-pointer",
    color: "rgb(305,305,0)",
    object3d: headObj3d
  };
  var ElevationProfileScene = class extends RenderNode {
    constructor(options2 = {}) {
      super("ElevationProfileScene");
      this._onLClick = (e9) => {
        let groundPos = this._planet.getCartesianFromPixelTerrain(e9.pos);
        if (groundPos) {
          this.addGroundPoint3vAsync(groundPos);
        }
      };
      this._onMouseMove = (e9) => {
        let mouseCart = this._planet.getCartesianFromMouseTerrain();
        if (this._pickedGroundEntity) {
          let d4 = new Vec2(e9.x, e9.y).sub(this._startClickPos), p4 = this._startEntityPos.add(d4);
          let groundCart = this._planet.getCartesianFromPixelTerrain(p4);
          if (groundCart) {
            this.setGroundPointCartesian3v(this._pickedGroundEntity.properties.index, groundCart);
          }
        } else if (this._pickedHeadEntity) {
          let cam = this._planet.camera;
          let p0 = this._pickedHeadEntity.properties.groundEntity.getCartesian();
          let groundNormal = this._planet.ellipsoid.getSurfaceNormal3v(p0);
          let p1 = p0.add(groundNormal);
          let p22 = p0.add(cam.getRight());
          let px = new Vec3();
          if (new Ray(cam.eye, e9.direction).hitPlane(p0, p1, p22, px) === Ray.INSIDE) {
            let h8 = Vec3.proj_b_to_a(px, p0);
            let s7 = h8.sub(p0).dot(p0);
            let headPos = p0.add(groundNormal.scale(Math.sign(s7) * h8.distance(p0)));
            this.setHeadPointCartesian3v(this._pickedHeadEntity.properties.index, headPos);
          }
        }
      };
      this._onLUp = (e9) => {
      };
      this._onGroundPointerEnter = (e9) => {
        e9.renderer.handler.canvas.style.cursor = "pointer";
      };
      this._onGroundPointerLeave = (e9) => {
        e9.renderer.handler.canvas.style.cursor = "default";
      };
      this._onGroundPointerLDown = (e9) => {
        this._clampToGround = false;
        this.renderer.controls.mouseNavigation.deactivate();
        this._pickedGroundEntity = e9.pickingObject;
        const coords = this._pickedGroundEntity.getCartesian();
        this._startClickPos.set(e9.x, e9.y);
        this._startEntityPos = this._planet.getPixelFromCartesian(coords);
      };
      this._onGroundPointerLUp = (e9) => {
        this._clampToGround = true;
        this.renderer.controls.mouseNavigation.activate();
        this._pickedGroundEntity = null;
      };
      this._onHeadPointerEnter = (e9) => {
        e9.renderer.handler.canvas.style.cursor = "pointer";
      };
      this._onHeadPointerLeave = (e9) => {
        e9.renderer.handler.canvas.style.cursor = "default";
      };
      this._onHeadPointerLDown = (e9) => {
        this.renderer.controls.mouseNavigation.deactivate();
        this._pickedHeadEntity = e9.pickingObject;
      };
      this._onHeadPointerLUp = (e9) => {
        this.renderer.controls.mouseNavigation.activate();
        this._pickedHeadEntity = null;
      };
      this.events = createEvents(ELEVATIONPROFILESCENE_EVENTS);
      this._planet = options2.planet || null;
      this._pickedGroundEntity = null;
      this._pickedHeadEntity = null;
      this._startClickPos = new Vec2();
      this._startEntityPos = new Vec2();
      this._clampToGround = true;
      this._trackLayer = new Vector("track", {
        entities: [],
        pickingEnabled: false,
        polygonOffsetUnits: -1,
        relativeToGround: true,
        hideInLayerSwitcher: true
      });
      this._groundPointersLayer = new Vector("ground-pointers", {
        entities: [],
        pickingEnabled: true,
        hideInLayerSwitcher: true,
        scaleByDistance: [1, 5e3, 0.02],
        pickingScale: 1.5
      });
      this._headPointersLayer = new Vector("head-pointers", {
        entities: [],
        pickingEnabled: true,
        hideInLayerSwitcher: true,
        scaleByDistance: [1, 1e4, 0.02],
        pickingScale: 1
      });
      this._columnPointersLayer = new Vector("column-pointers", {
        entities: [],
        pickingEnabled: false,
        hideInLayerSwitcher: true
      });
      this._trackEntity = new Entity({
        polyline: {
          path3v: [],
          thickness: 3.8,
          color: "rgba(0,305,0,0.8)",
          isClosed: false
        }
      });
      this._trackLayer = new Vector("column-pointers", {
        entities: [this._trackEntity],
        pickingEnabled: false,
        hideInLayerSwitcher: true
      });
      this._heightsLayer = new Vector("heights-labels", {
        entities: [],
        pickingEnabled: false,
        hideInLayerSwitcher: true
      });
      this._pointerHeadEntity = new Entity({
        cartesian: new Vec3(),
        billboard: POINTER_BILLBOARD_OPTIONS
      });
      this._pointerLabelEntity = new Entity({
        cartesian: new Vec3(),
        label: POINTER_LABEL_OPTIONS
      });
      this._pointerRayEntity = new Entity({
        cartesian: new Vec3(),
        ray: POINTER_RAY_OPTIONS
      });
      this._pointerLayer = new Vector("pointer", {
        entities: [this._pointerHeadEntity, this._pointerLabelEntity, this._pointerRayEntity],
        pickingEnabled: false,
        hideInLayerSwitcher: true
      });
    }
    flyExtent() {
      let entities = this._headPointersLayer.getEntities();
      let minLon = 180, minLat = 180, maxLon = -180, maxLat = -180, maxHeight = -1e6;
      if (entities.length > 1) {
        for (let i9 = 0; i9 < entities.length; i9++) {
          let ll = entities[i9].getLonLat();
          if (ll.lon < minLon)
            minLon = ll.lon;
          if (ll.lat < minLat)
            minLat = ll.lat;
          if (ll.lon > maxLon)
            maxLon = ll.lon;
          if (ll.lat > maxLat)
            maxLat = ll.lat;
          if (ll.height > maxHeight)
            maxHeight = ll.height;
        }
        this._planet.camera.flyExtent(new Extent(new LonLat(minLon, minLat), new LonLat(maxLon, maxLat)), maxHeight, null, 0);
      }
    }
    get planet() {
      return this._planet;
    }
    _createGroundPointer(groundCart, altitude = 10) {
      let surfaceNormal = this.ellipsoid.getSurfaceNormal3v(groundCart);
      let headCart = groundCart.add(surfaceNormal.scale(altitude));
      let columnEntity = new Entity({
        ray: {
          startPosition: groundCart,
          endPosition: headCart,
          startColor: "rgba(255,255,255,0.2)",
          endColor: "rgba(355,355,355,1.0)",
          thickness: 3.2
        }
      });
      let groundEntity = new Entity({
        cartesian: groundCart,
        geoObject: GROUND_POINTER_OPTIONS
      });
      let headEntity = new Entity({
        cartesian: headCart,
        geoObject: HEAD_POINTER_OPTIONS,
        properties: {}
      });
      let heightLabelEntity = new Entity({
        cartesian: headCart,
        label: LABEL_OPTIONS3
      });
      heightLabelEntity.appendChild(new Entity({
        cartesian: headCart,
        label: { ...LABEL_OPTIONS3, offset: [-47, 45, 0] }
      }));
      const index = this._groundPointersLayer.getEntities().length;
      columnEntity.properties = groundEntity.properties = headEntity.properties = {
        index,
        altitude,
        lonLatEll: new LonLat(),
        headEntity,
        groundEntity,
        columnEntity,
        heightLabelEntity
      };
      return { headEntity, groundEntity, columnEntity, heightLabelEntity };
    }
    setPointerCartesian3v(p4, height) {
      this._pointerLabelEntity.setCartesian3v(p4);
      this._pointerLabelEntity.label.setText(`${Math.round(height).toString()} m`);
      this._pointerRayEntity.ray.setEndPosition3v(p4);
      let n7 = this._planet.ellipsoid.getSurfaceNormal3v(p4);
      this._pointerRayEntity.ray.setStartPosition3v(p4.add(n7.scale(-height)));
      this._pointerHeadEntity.setCartesian3v(p4);
    }
    bindPlanet(planet) {
      this._planet = planet;
    }
    init() {
      this._activate();
    }
    onremove() {
      this._deactivate();
    }
    _activate() {
      this._planet.addLayer(this._trackLayer);
      this._planet.addLayer(this._groundPointersLayer);
      this._planet.addLayer(this._columnPointersLayer);
      this._planet.addLayer(this._headPointersLayer);
      this._planet.addLayer(this._heightsLayer);
      this._planet.addLayer(this._pointerLayer);
      this.renderer.events.on("ldblclick", this._onLClick);
      this.renderer.events.on("mousemove", this._onMouseMove);
      this.renderer.events.on("lup", this._onLUp);
      this._groundPointersLayer.events.on("mouseenter", this._onGroundPointerEnter);
      this._groundPointersLayer.events.on("mouseleave", this._onGroundPointerLeave);
      this._groundPointersLayer.events.on("ldown", this._onGroundPointerLDown);
      this._groundPointersLayer.events.on("lup", this._onGroundPointerLUp);
      this._headPointersLayer.events.on("mouseenter", this._onHeadPointerEnter);
      this._headPointersLayer.events.on("mouseleave", this._onHeadPointerLeave);
      this._headPointersLayer.events.on("ldown", this._onHeadPointerLDown);
      this._headPointersLayer.events.on("lup", this._onHeadPointerLUp);
      this.setPointerVisibility(false);
    }
    getPointLonLat(index) {
      let entity = this._headPointersLayer.getEntities()[index];
      if (entity) {
        return entity.getLonLat();
      }
    }
    getPointsLonLat() {
      let entities = this._headPointersLayer.getEntities();
      let points = new Array(entities.length);
      for (let i9 = 0, len = points.length; i9 < len; i9++) {
        let ei = entities[i9];
        points[i9] = ei.getLonLat();
      }
      return points;
    }
    getHeightMSL(lonLat) {
      if (this._planet && this._planet.terrain.geoid) {
        return this._planet.terrain.geoid.getHeightLonLat(lonLat);
      }
      return 0;
    }
    getHeightELLAsync(lonLat) {
      return new Promise((resolve, reject) => {
        this._planet.terrain.getHeightAsync(lonLat, (hGnd) => {
          if (this._planet) {
            let hMsl = this.getHeightMSL(lonLat);
            resolve(hGnd + hMsl);
          } else {
            reject();
          }
        });
      });
    }
    addPointLonLatArrayAsync(lonLatArr, stopPropagation = false) {
      if (!this._planet) {
        throw new Error("Planet is not defined");
      }
      let ell = this._planet.ellipsoid;
      for (let i9 = 0, len = lonLatArr.length - 1; i9 < len; i9++) {
        let p0 = ell.lonLatToCartesian(lonLatArr[i9]), p1 = ell.lonLatToCartesian(lonLatArr[i9 + 1]);
        if (p0.distance(p1) > 1e5) {
          throw new Error("Track is too long! 100 km is maximum.");
        }
      }
      let res = new Array(lonLatArr.length);
      for (let i9 = 0, len = lonLatArr.length; i9 < len; i9++) {
        res[i9] = this.addPointLonLatAsync(lonLatArr[i9], true);
      }
      Promise.all(res).then(() => {
        if (!stopPropagation) {
          this.events.dispatch(this.events.change, this);
        }
      });
      return res;
    }
    addPointLonLatAsync(lonLat, stopPropagation = false) {
      let headPos = this._planet.ellipsoid.lonLatToCartesian(lonLat);
      let n7 = this._planet.ellipsoid.getSurfaceNormal3v(headPos);
      let ellLonLat = new LonLat(lonLat.lon, lonLat.lat);
      let ellPos = this._planet.ellipsoid.lonLatToCartesian(ellLonLat);
      let { headEntity, groundEntity, columnEntity, heightLabelEntity } = this._createGroundPointer(ellPos);
      this._groundPointersLayer.add(groundEntity);
      this._columnPointersLayer.add(columnEntity);
      this._headPointersLayer.add(headEntity);
      this._heightsLayer.add(heightLabelEntity);
      this._trackEntity.polyline.appendPoint3v(headEntity.getCartesian());
      groundEntity.properties.lonLatEll.lon = ellLonLat.lon;
      groundEntity.properties.lonLatEll.lat = ellLonLat.lat;
      groundEntity.properties.lonLatEll.height = ellLonLat.height;
      return new Promise((resolve) => {
        this.getHeightELLAsync(lonLat).then((hEll) => {
          groundEntity.properties.lonLatEll.height = hEll;
          let altitude = 10, groundPos;
          if (lonLat.height === 0) {
            groundPos = headPos.add(n7.scaleTo(hEll));
            headPos = groundPos.add(n7.scaleTo(altitude));
          } else {
            altitude = lonLat.height - hEll;
            groundPos = headPos.sub(n7.scaleTo(altitude));
          }
          groundEntity.setCartesian3v(groundPos);
          heightLabelEntity.setCartesian3v(headPos);
          heightLabelEntity.label.setText(`${hEll.toFixed(1)} m`);
          heightLabelEntity.childrenNodes[0].label.setText(`${altitude.toFixed(1)} m`);
          headEntity.properties.altitude = altitude;
          headEntity.setCartesian3v(headPos);
          headEntity.properties.columnEntity.ray.setStartPosition3v(groundPos);
          headEntity.properties.columnEntity.ray.setEndPosition3v(headPos);
          this._trackEntity.polyline?.setPoint3v(headPos, headEntity.properties.index);
          if (!stopPropagation) {
            this.events.dispatch(this.events.addpoint, headEntity, this);
            this.events.dispatch(this.events.change, this);
          }
          resolve(headEntity);
        });
      });
    }
    addGroundPointLonLatAsync(lonLat, altitude = 10, stopPropagation = false) {
      let groundPos = this._planet.ellipsoid.lonLatToCartesian(lonLat);
      return this._addPoint(groundPos, lonLat, altitude, stopPropagation);
    }
    addGroundPoint3vAsync(groundPos, altitude = 10, stopPropagation = false) {
      let lonLat = this._planet.ellipsoid.cartesianToLonLat(groundPos);
      return this._addPoint(groundPos, lonLat, altitude, stopPropagation);
    }
    _addPoint(groundPos, lonLat, altitude, stopPropagation = false) {
      return new Promise((resolve, reject) => {
        let { headEntity, groundEntity, columnEntity, heightLabelEntity } = this._createGroundPointer(groundPos, altitude);
        this._groundPointersLayer.add(groundEntity);
        this._columnPointersLayer.add(columnEntity);
        this._headPointersLayer.add(headEntity);
        this._heightsLayer.add(heightLabelEntity);
        this._trackEntity.polyline.appendPoint3v(headEntity.getCartesian());
        groundEntity.properties.lonLatEll.lon = lonLat.lon;
        groundEntity.properties.lonLatEll.lat = lonLat.lat;
        groundEntity.properties.lonLatEll.height = lonLat.height;
        this.getHeightELLAsync(lonLat).then((hEll) => {
          groundEntity.properties.lonLatEll.height = lonLat.height = hEll;
          let groundPos2 = this._planet.ellipsoid.lonLatToCartesian(lonLat);
          let groundNormal = this._planet.ellipsoid.getSurfaceNormal3v(groundPos2);
          let headPos = groundPos2.add(groundNormal.scale(altitude));
          heightLabelEntity.setCartesian3v(headPos);
          heightLabelEntity.label.setText(`${hEll.toFixed(1)} m`);
          heightLabelEntity.childrenNodes[0].label.setText(`${altitude.toFixed(1)} m`);
          headEntity.setCartesian3v(headPos);
          headEntity.properties.columnEntity.ray.setEndPosition3v(headPos);
          this._trackEntity.polyline?.setPoint3v(headPos, headEntity.properties.index);
          if (!stopPropagation) {
            this.events.dispatch(this.events.addpoint, headEntity, this);
            this.events.dispatch(this.events.change, this);
          }
          resolve(headEntity);
        });
      });
    }
    setHeadPointCartesian3v(entityIndex, headPos) {
      const headEntity = this._headPointersLayer.getEntities()[entityIndex];
      if (headEntity) {
        let groundPos = this._planet.ellipsoid.lonLatToCartesian(headEntity.properties.lonLatEll);
        let altitude = headPos.length() - groundPos.length();
        if (altitude <= 0) {
          headPos = groundPos;
          altitude = 0;
        }
        headEntity.properties.altitude = altitude;
        headEntity.setCartesian3v(headPos);
        headEntity.properties.columnEntity.ray.setEndPosition3v(headPos);
        headEntity.properties.heightLabelEntity.setCartesian3v(headPos);
        headEntity.properties.heightLabelEntity.childrenNodes[0].label.setText(`${altitude.toFixed(1)} m`);
        this._trackEntity.polyline.setPoint3v(headPos, entityIndex);
        this.events.dispatch(this.events.change, this._pickedHeadEntity);
      }
    }
    setGroundPointCartesian3v(entityIndex, groundPos) {
      let groundEntity = this._groundPointersLayer.getEntities()[entityIndex];
      if (groundEntity) {
        let lonLat = this._planet.ellipsoid.cartesianToLonLat(groundPos);
        groundEntity.properties.lonLatEll.lon = lonLat.lon;
        groundEntity.properties.lonLatEll.lat = lonLat.lat;
        groundEntity.properties.lonLatEll.height = lonLat.height;
        let groundNormal = this._planet.ellipsoid.getSurfaceNormal3v(groundPos);
        let headEntity = groundEntity.properties.headEntity;
        let heightLabelEntity = groundEntity.properties.heightLabelEntity;
        let altitude = groundEntity.properties.altitude;
        groundEntity.setCartesian3v(groundPos);
        let headPos = groundPos.add(groundNormal.scale(altitude));
        headEntity.setCartesian3v(headPos);
        headEntity.properties.columnEntity.ray.setStartPosition3v(groundPos);
        headEntity.properties.columnEntity.ray.setEndPosition3v(headPos);
        this._trackEntity.polyline?.setPoint3v(headPos, headEntity.properties.index);
        heightLabelEntity.setCartesian3v(headPos);
        heightLabelEntity.label.setText(`${lonLat.height.toFixed(1)} m`);
        heightLabelEntity.childrenNodes[0].label.setText(`${altitude.toFixed(1)} m`);
        this.events.dispatch(this.events.change, groundEntity.properties.headEntity);
      }
    }
    _deactivate() {
      this.renderer.events.off("ldblclick", this._onLClick);
      this.renderer.events.off("mousemove", this._onMouseMove);
      this.renderer.events.off("lup", this._onLUp);
      this._groundPointersLayer.events.off("mouseenter", this._onGroundPointerEnter);
      this._groundPointersLayer.events.off("mouseleave", this._onGroundPointerLeave);
      this._groundPointersLayer.events.off("ldown", this._onGroundPointerLDown);
      this._groundPointersLayer.events.off("lup", this._onGroundPointerLUp);
      this._headPointersLayer.events.off("mouseenter", this._onHeadPointerEnter);
      this._headPointersLayer.events.off("mouseleave", this._onHeadPointerLeave);
      this._headPointersLayer.events.off("ldown", this._onHeadPointerLDown);
      this._headPointersLayer.events.off("lup", this._onHeadPointerLUp);
      this._trackLayer.remove();
      this._groundPointersLayer.remove();
      this._headPointersLayer.remove();
      this._columnPointersLayer.remove();
      this._trackLayer.remove();
      this._heightsLayer.remove();
      this._pointerLayer.remove();
      this.clear();
    }
    setPointerVisibility(visibility) {
      this._pointerLayer.setVisibility(visibility);
    }
    setVisibility(visibility) {
      this._groundPointersLayer.setVisibility(visibility);
      this._trackLayer.setVisibility(visibility);
      this._columnPointersLayer.setVisibility(visibility);
      this._headPointersLayer.setVisibility(visibility);
      this._trackLayer.setVisibility(visibility);
      this._heightsLayer.setVisibility(visibility);
      this._pointerLayer.setVisibility(visibility);
    }
    clear() {
      this._headPointersLayer.setEntities([]);
      this._groundPointersLayer.setEntities([]);
      this._columnPointersLayer.setEntities([]);
      this._heightsLayer.setEntities([]);
      this._trackEntity.polyline.setPath3v([]);
    }
    frame() {
      if (this._clampToGround) {
        let __tempVec__ = new Vec3();
        const nodes = this._planet._renderedNodes;
        const entities = this._groundPointersLayer.getEntities();
        for (let i9 = 0; i9 < entities.length; i9++) {
          let ei = entities[i9];
          for (let j2 = 0; j2 < nodes.length; j2++) {
            let nj = nodes[j2];
            if (nj.segment.isEntityInside(ei)) {
              nj.segment.getEntityTerrainPoint(ei, __tempVec__);
              ei.setCartesian3v(__tempVec__);
              ei.properties.columnEntity.ray.setStartPosition3v(__tempVec__);
              break;
            }
          }
        }
      }
    }
    get ellipsoid() {
      return this._planet ? this._planet.ellipsoid : null;
    }
  };
  var ELEVATIONPROFILESCENE_EVENTS = [
    "change",
    "addpoint"
  ];

  // frontend/node_modules/@openglobus/og/lib/js/control/elevationProfile/ElevationProfileButtonsView.js
  var TEMPLATE10 = '<div class="og-elevationprofile-buttons"></div>';
  var RESET_SVG_ICON = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="30" height="30" viewBox="0 0 30 30" version="1.1">
  <g transform="translate(0,-289.0625)">
    <path d="M 15 6 C 10.041282 6 6 10.04128 6 15 C 6 19.95872 10.041282 24 15 24 C 16.586491 24 18.07668 23.58246 19.373047 22.857422 L 17.888672 21.375 C 17.00816 21.772814 16.032235 22 15 22 C 11.122162 22 8 18.87784 8 15 C 8 11.12216 11.122162 8 15 8 C 18.877838 8 22 11.12216 22 15 L 19 15 L 23 20 L 27 15 L 24 15 C 24 10.04128 19.958718 6 15 6 z " transform="translate(0,289.0625)" />
  </g>
</svg>`;
  var LIST_SVG_ICON = `<?xml version="1.0" encoding="utf-8"?><svg width="800px" height="800px" viewBox="0 0 32 32" id="icon" xmlns="http://www.w3.org/2000/svg"><defs><style>.cls-1{fill:none;}</style></defs><title>list</title><rect x="10" y="6" width="18" height="2"/><rect x="10" y="24" width="18" height="2"/><rect x="10" y="15" width="18" height="2"/><rect x="4" y="15" width="2" height="2"/><rect x="4" y="6" width="2" height="2"/><rect x="4" y="24" width="2" height="2"/></svg>`;
  var LOCATION_SVG_ICON = `<?xml version="1.0" encoding="utf-8"?>
<!-- Svg Vector Icons : http://www.onlinewebfonts.com/icon -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 256 256" enable-background="new 0 0 256 256" xml:space="preserve">
<metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>
<g><g><path fill="#000000" d="M127,169.4c23.7,0,42.8-18.3,42.8-41s-19.2-41-42.8-41c-23.7,0-42.8,18.4-42.8,41S103.4,169.4,127,169.4z"/><path fill="#000000" d="M221.7,120.2c-3.8-44-40.9-78.9-87-82V15h-16.3v23.6c-44.8,4-80.3,38.5-84.1,81.7H10v15.6h24.3c3.8,43.1,39.3,77.4,84.1,81.7V241h16.3v-23.2c46-3.1,83.2-37.9,87-82H246v-15.6H221.7L221.7,120.2L221.7,120.2z M128,201.6c-42.5,0-76.7-33-76.7-73.4c0-40.4,34.5-73.4,76.7-73.4c42.5,0,76.7,33,76.7,73.4C204.7,168.5,170.5,201.6,128,201.6L128,201.6z"/></g></g>
</svg>`;
  var ELEVATIONPROFILEBUTTONSVIEW_EVENTS = ["reset", "list", "location"];
  var ElevationProfileButtonsView = class extends View {
    constructor(params = {}) {
      super({
        ...params,
        template: TEMPLATE10
      });
      this.events = this.events.registerNames(ELEVATIONPROFILEBUTTONSVIEW_EVENTS);
      this.pointListBtn = new ToggleButton({
        classList: ["og-elevationprofile-button"],
        icon: LIST_SVG_ICON,
        title: "Point List"
      });
      this.pointListBtn.events.on("change", (isActive) => {
        this.events.dispatch(this.events.list, isActive);
      });
    }
    render(params) {
      super.render(params);
      let resetBtn = new Button({
        classList: ["og-elevationprofile-button"],
        icon: RESET_SVG_ICON,
        title: "Reset"
      });
      resetBtn.appendTo(this.el);
      resetBtn.events.on("click", () => {
        this.model.clear();
        this.events.dispatch(this.events.reset, this);
      });
      this.pointListBtn.appendTo(this.el);
      let locationBtn = new Button({
        classList: ["og-elevationprofile-button", "og-elevationprofile-button__location"],
        icon: LOCATION_SVG_ICON,
        title: "View bounds"
      });
      locationBtn.appendTo(this.el);
      locationBtn.events.on("click", () => {
        this.events.dispatch(this.events.location, this);
      });
      return this;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/elevationProfile/PointListDialog.js
  var LIST_TEMPLATE = `<div class="og-elevationprofile-list">
        <textarea placeholder="[[lon, lat, height], [lon, lat, height], ..., [lon, lat, height]]"></textarea>
        <div class="og-elevationprofile-list-buttons"></div>
    </div>`;
  var PointListDialog = class extends Dialog {
    constructor(params) {
      super({
        title: "Points List",
        visible: false,
        resizable: true,
        useHide: true,
        top: 150,
        left: 200,
        width: 400,
        height: 300,
        minHeight: 100,
        minWidth: 100,
        ...params
      });
      this._onApplyClick = () => {
        try {
          this.model.clear();
          let coordsArr = JSON.parse(this.$textarea.value);
          let lonLatArr = new Array(coordsArr.length);
          for (let i9 = 0; i9 < coordsArr.length; i9++) {
            let ci = coordsArr[i9];
            lonLatArr[i9] = new LonLat(ci[0], ci[1], ci[2]);
          }
          this.model.addPointLonLatArrayAsync(lonLatArr);
        } catch (err) {
          console.error(err);
        }
      };
      this.$textarea = null;
    }
    render(params) {
      super.render(params);
      let view = new View({
        template: LIST_TEMPLATE
      });
      view.appendTo(this.container);
      let applyBtn = new Button({
        classList: ["og-elevationprofile-list-apply"],
        icon: "Apply"
      });
      applyBtn.appendTo(view.select(".og-elevationprofile-list-buttons"));
      applyBtn.events.on("click", this._onApplyClick);
      this.$textarea = view.select("textarea");
      return this;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/elevationProfile/ElevationProfileLegend.js
  var TEMPLATE11 = `<div class="og-elevationprofile-legend">
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__track">
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__ground">
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__warning">        
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
        <div class="og-elevationprofile-legend__row og-elevationprofile-legend__collision">
          <div class="og-elevationprofile-square"></div>
          <div class="og-elevationprofile-value">0</div>
          <div class="og-elevationprofile-units">m</div>
        </div>
      </div>`;
  var ElevationProfileLegend = class extends View {
    constructor(params = {}) {
      super({
        ...params,
        template: TEMPLATE11
      });
      this.$groundValue = null;
      this.$trackValue = null;
      this.$warningValue = null;
      this.$collisionValue = null;
      this.$trackUnits = null;
      this.$groundUnits = null;
      this.$warningUnits = null;
      this.$collisionUnits = null;
    }
    render(params) {
      super.render(params);
      this.$trackValue = this.select(".og-elevationprofile-legend__track .og-elevationprofile-value");
      this.$groundValue = this.select(".og-elevationprofile-legend__ground .og-elevationprofile-value");
      this.$warningValue = this.select(".og-elevationprofile-legend__warning .og-elevationprofile-value");
      this.$collisionValue = this.select(".og-elevationprofile-legend__collision .og-elevationprofile-value");
      this.$trackUnits = this.select(".og-elevationprofile-legend__track .og-elevationprofile-units");
      this.$groundUnits = this.select(".og-elevationprofile-legend__ground .og-elevationprofile-units");
      this.$warningUnits = this.select(".og-elevationprofile-legend__warning .og-elevationprofile-units");
      this.$collisionUnits = this.select(".og-elevationprofile-legend__collision .og-elevationprofile-units");
      return this;
    }
    clear() {
      this.$trackValue && (this.$trackValue.innerText = "0");
      this.$trackUnits && (this.$trackUnits.innerText = "m");
      this.$groundValue && (this.$groundValue.innerText = "0");
      this.$groundUnits && (this.$groundUnits.innerText = "m");
      this.$warningValue && (this.$warningValue.innerText = "0");
      this.$warningUnits && (this.$warningUnits.innerText = "m");
      this.$collisionValue && (this.$collisionValue.innerText = "0");
      this.$collisionUnits && (this.$collisionUnits.innerText = "m");
    }
    setTrackLength(trackLength) {
      let dist = distanceFormatExt(trackLength);
      this.$trackValue.innerText = dist[0];
      this.$trackUnits.innerText = dist[1];
    }
    setGroundLength(groundLength) {
      let dist = distanceFormatExt(groundLength);
      this.$groundValue.innerText = dist[0];
      this.$groundUnits.innerText = dist[1];
    }
    setWarningLength(warningLength) {
      let warningDist = distanceFormatExt(warningLength);
      this.$warningValue.innerText = warningDist[0];
      this.$warningUnits.innerText = warningDist[1];
    }
    setCollisionLength(collisionLength) {
      let collisionDist = distanceFormatExt(collisionLength);
      this.$collisionValue.innerText = collisionDist[0];
      this.$collisionUnits.innerText = collisionDist[1];
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/elevationProfile/ElevationProfileControl.js
  var TEMPLATE12 = `<div class="og-elevationprofile__container">
      <div class="og-elevationprofile__menu"></div>
      <div class="og-elevationprofile__graph"></div>
    </div>`;
  var ICON_BUTTON_SVG9 = `<svg style="width: 2em; height: 2em;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M128 896v-158.293333l331.946667-191.573334 160.853333 93.866667L896 480V896H128M896 381.44l-275.2 159.146667-160.853333-92.586667L128 640v-94.293333l331.946667-191.573334 160.853333 93.866667L896 288v93.44z" fill="" /></svg>`;
  var ElevationProfileControl = class extends Control {
    constructor(options2 = {}) {
      super({
        name: "ElevationProfileControl",
        ...options2
      });
      this._onSceneChange = () => {
        this._collectProfileThrottled();
      };
      this._onElevationProfilePointer = (pointerDistance, tp0, tp1, gp0, gp1, trackPoiIndex, groundPoiIndex, elevation) => {
        let lonLat0 = this._elevationProfileScene.getPointLonLat(trackPoiIndex);
        let lonLat1 = this._elevationProfileScene.getPointLonLat(trackPoiIndex + 1);
        let cart0 = this.planet.ellipsoid.lonLatToCartesian(lonLat0), cart1 = this.planet.ellipsoid.lonLatToCartesian(lonLat1);
        let d4 = (pointerDistance - tp0[0]) / (tp1[0] - tp0[0]);
        let dir = cart1.sub(cart0);
        this._elevationProfileScene.setPointerCartesian3v(cart0.add(dir.scale(d4)), elevation);
      };
      this._onElevationProfileDblClick = (pointerDistance, tp0, tp1, gp0, gp1, trackPoiIndex, groundPoiIndex, elevation) => {
        let lonLat0 = this._elevationProfileScene.getPointLonLat(trackPoiIndex);
        let lonLat1 = this._elevationProfileScene.getPointLonLat(trackPoiIndex + 1);
        let cart0 = this.planet.ellipsoid.lonLatToCartesian(lonLat0), cart1 = this.planet.ellipsoid.lonLatToCartesian(lonLat1);
        let d4 = (pointerDistance - tp0[0]) / (tp1[0] - tp0[0]);
        let dir = cart1.sub(cart0);
        let poi = cart0.add(dir.scale(d4));
        this.planet.camera.flyDistance(poi, this.planet.camera.eye.distance(poi));
      };
      this._onElevationProfileMouseEnter = () => {
        if (this._elevationProfileView.model.pointsReady) {
          this._elevationProfileScene.setPointerVisibility(true);
        }
      };
      this._onElevationProfileMouseLeave = () => {
      };
      this._elevationProfileScene = new ElevationProfileScene();
      this._elevationProfileView = new ElevationProfileView();
      this._elevationProfileLegend = new ElevationProfileLegend();
      this._elevationProfileButtonsView = new ElevationProfileButtonsView({
        model: this._elevationProfileView.model
      });
      this._elevationProfileView.events.on("pointer", this._onElevationProfilePointer);
      this._elevationProfileView.events.on("dblclick", this._onElevationProfileDblClick);
      this._elevationProfileView.events.on("mouseenter", this._onElevationProfileMouseEnter);
      this._elevationProfileView.events.on("mouseleave", this._onElevationProfileMouseLeave);
      this._dialog = new Dialog({
        title: "Elevation Profile",
        visible: false,
        resizable: true,
        useHide: true,
        top: 175,
        left: 65,
        width: 400,
        height: 200,
        minHeight: 100,
        minWidth: 100
      });
      this._graphView = new View({
        template: TEMPLATE12
      });
      this._poiListDialog = new PointListDialog({
        model: this._elevationProfileScene
      });
      this._toggleBtn = new ToggleButton({
        classList: ["og-map-button", "og-elevationprofile_button"],
        icon: ICON_BUTTON_SVG9
      });
      this._collectProfileThrottled = throttle(() => {
        let points = this._elevationProfileScene.getPointsLonLat();
        this._elevationProfileView.model.collectProfile(points);
      }, 250);
    }
    oninit() {
      this._dialog.appendTo(this.planet.renderer.div);
      this._graphView.appendTo(this._dialog.container);
      this._toggleBtn.appendTo(this.renderer.div);
      this._dialog.events.on("visibility", (v4) => {
        this._toggleBtn.setActive(v4);
        if (v4) {
          this.activate();
          this._elevationProfileView.resize();
        } else {
          this.deactivate();
        }
      });
      this._toggleBtn.events.on("change", (isActive) => {
        this._dialog.setVisibility(isActive);
      });
      this._elevationProfileView.appendTo(this._graphView.select(".og-elevationprofile__graph"));
      this._elevationProfileView.model.bindPlanet(this.planet);
      this._elevationProfileView.model.events.on("clear", () => {
        this._elevationProfileScene.clear();
        this._elevationProfileLegend.clear();
      });
      this._elevationProfileView.model.events.on("startcollecting", () => {
        this._elevationProfileScene.setPointerVisibility(false);
      });
      this._elevationProfileView.events.on("tracklength", (length) => {
        this._elevationProfileLegend.setTrackLength(length);
      });
      this._elevationProfileView.events.on("groundlength", (length) => {
        this._elevationProfileLegend.setGroundLength(length);
      });
      this._elevationProfileView.events.on("warninglength", (length) => {
        this._elevationProfileLegend.setWarningLength(length);
      });
      this._elevationProfileView.events.on("collisionlength", (length) => {
        this._elevationProfileLegend.setCollisionLength(length);
      });
      this._poiListDialog.appendTo(this.planet.renderer.div);
      this._poiListDialog.events.on("visibility", (isVisible) => {
        this._elevationProfileButtonsView.pointListBtn.setActive(isVisible, true);
      });
      this._elevationProfileLegend.appendTo(this._graphView.select(".og-elevationprofile__menu"));
      this._elevationProfileButtonsView.appendTo(this._graphView.select(".og-elevationprofile__menu"));
      this._elevationProfileButtonsView.events.on("list", (isActive) => {
        this._poiListDialog.setVisibility(isActive);
      });
      this._elevationProfileButtonsView.events.on("location", (isActive) => {
        this._elevationProfileScene.flyExtent();
      });
      this._elevationProfileButtonsView.events.on("reset", (isActive) => {
        this._elevationProfileScene.setPointerVisibility(false);
      });
      this._elevationProfileScene.events.on("change", this._onSceneChange);
    }
    onactivate() {
      this.renderer.controls.mouseNavigation.deactivateDoubleClickZoom();
      this.planet && this._elevationProfileScene.bindPlanet(this.planet);
      this.renderer && this.renderer.addNode(this._elevationProfileScene);
    }
    ondeactivate() {
      this._poiListDialog.setVisibility(false);
      this._elevationProfileView.model.clear();
      this.renderer.controls.mouseNavigation.activateDoubleClickZoom();
      this.renderer && this.renderer.removeNode(this._elevationProfileScene);
      this._dialog.hide();
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/AtmosphereConfig.js
  var TEMPLATE13 = `<div class="og-atmosphere og-options-container">
         
         <div class="og-option og-atmosphere-maxOpacity"></div> 
         <div class="og-option og-atmosphere-minOpacity"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-rayleight"></div>
         <div class="og-option og-atmosphere-mie"></div>
         
       <div class="og-emptyline-2"></div>
                  
         <div class="og-option og-atmosphere-height"></div> 
         <div class="og-option og-atmosphere-bottomRadius"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-mieScatteringCoefficient"></div>  
         <div class="og-option og-atmosphere-mieExtinctionCoefficient"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-rayleighScatteringCoefficientA"></div>    
         <div class="og-option og-atmosphere-rayleighScatteringCoefficientB"></div>    
         <div class="og-option og-atmosphere-rayleighScatteringCoefficientC"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-ozoneAbsorptionCoefficientA"></div>    
         <div class="og-option og-atmosphere-ozoneAbsorptionCoefficientB"></div>    
         <div class="og-option og-atmosphere-ozoneAbsorptionCoefficientC"></div>
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-ozoneDensityHeight"></div>    
         <div class="og-option og-atmosphere-ozoneDensityWide"></div>    
         
       <div class="og-emptyline-2"></div>
         
         <div class="og-option og-atmosphere-sunAngularRadius"></div> 
         <div class="og-option og-atmosphere-sunIntensity"></div> 
         <div class="og-option og-atmosphere-earthAlbedo"></div>
       
    </div>`;
  var ICON_BUTTON_SVG10 = `<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path fill="#000000" d="M135.688 18.5c-6.798 74.842-23.842 85.39-107.907 59.656 84.85 52.022 73.57 64.954-6.843 96.938 87.743-10.27 103.29 4.89 70.75 87.594 17.805-27.56 32.5-44.498 46.282-54.47-11.813 28.26-18.345 59.274-18.345 91.813 0 84.184 43.71 157.96 109.656 200.376-41.624-43.834-67.686-102.7-67.686-167.875 0-134.923 109.45-244.405 244.375-244.405 30.92 0 60.76 5.762 88 16.25-38.584-26.87-85.517-42.625-136.064-42.625-55.257 0-106.14 18.802-146.562 50.375 4.627-18.783 17.39-38.073 41.03-60.906C190.18 90.942 153.53 95.634 135.69 18.5zm10.03 77.188c5.67.002 11.428 1.247 16.876 3.874 14.506 6.998 22.72 21.81 22 36.938-10.26 10.87-19.507 22.696-27.594 35.344-9.035 2.753-19.075 2.27-28.25-2.156-19.37-9.343-27.5-32.6-18.156-51.97 6.715-13.92 20.638-22.036 35.125-22.03z"/></svg>`;
  var AtmosphereConfig = class extends Control {
    constructor(options2 = {}) {
      super(options2);
      this.$maxOpacity = null;
      this.$minOpacity = null;
      this.$rayleight = null;
      this.$mie = null;
      this.$height = null;
      this.$bottomRadius = null;
      this.$mieScatteringCoefficient = null;
      this.$mieExtinctionCoefficient = null;
      this.$rayleighScatteringCoefficientA = null;
      this.$rayleighScatteringCoefficientB = null;
      this.$rayleighScatteringCoefficientC = null;
      this.$ozoneAbsorptionCoefficientA = null;
      this.$ozoneAbsorptionCoefficientB = null;
      this.$ozoneAbsorptionCoefficientC = null;
      this.$sunAngularRadius = null;
      this.$sunIntensity = null;
      this.$groundAlbedo = null;
      this.$ozoneDensityHeight = null;
      this.$ozoneDensityWide = null;
      this._toggleBtn = new ToggleButton({
        classList: ["og-map-button", "og-atmosphere_button"],
        icon: ICON_BUTTON_SVG10
      });
      this._dialog = new Dialog({
        title: "Atmosphere Parameters",
        visible: false,
        useHide: true,
        top: 60,
        left: 60,
        width: 720
      });
      this._dialog.events.on("visibility", (v4) => {
        this._toggleBtn.setActive(v4);
      });
      this._panel = new View({
        template: TEMPLATE13
      });
      this._maxOpacity = new Slider({
        label: "Max.opacity",
        max: 5
      });
      this._minOpacity = new Slider({
        label: "Min.opacity",
        max: 5
      });
      this._rayleight = new Slider({
        label: "Rayleight Scale",
        min: -10,
        max: 10
      });
      this._mie = new Slider({
        label: "Mie Scale",
        min: -10,
        max: 10
      });
      this._height = new Slider({
        label: "Height",
        max: 1e6
      });
      this._bottomRadius = new Slider({
        label: "Planet Radius",
        max: 5 * 6356752314245179e-9
      });
      this._mieScatteringCoefficient = new Slider({
        label: "Mie Scattering Coefficient e-6",
        min: -10 * 3.996,
        max: 10 * 3.996
      });
      this._mieExtinctionCoefficient = new Slider({
        label: "Mie Extinction Coef.e-6",
        min: -10 * 4.44,
        max: 10 * 4.44
      });
      this._rayleighScatteringCoefficientA = new Slider({
        label: "Rayleight Scattering Coef A.e-6",
        min: -10 * 5.802,
        max: 10 * 5.802
      });
      this._rayleighScatteringCoefficientB = new Slider({
        label: "Rayleight Scattering Coef B.e-6",
        min: -10 * 13.558,
        max: 10 * 13.558
      });
      this._rayleighScatteringCoefficientC = new Slider({
        label: "Rayleight Scattering Coef C.e-6",
        min: -10 * 33.1,
        max: 10 * 33.1
      });
      this._ozoneAbsorptionCoefficientA = new Slider({
        label: "Ozone absorbtion Coef A.e-6",
        min: -10 * 0.65,
        max: 10 * 0.65
      });
      this._ozoneAbsorptionCoefficientB = new Slider({
        label: "Ozone absorbtion Coef B.e-6",
        min: -10 * 0.65,
        max: 10 * 1.881
      });
      this._ozoneAbsorptionCoefficientC = new Slider({
        label: "Ozone absorbtion Coef C.e-6",
        min: -10 * 0.085,
        max: 10 * 0.085
      });
      this._ozoneDensityHeight = new Slider({
        label: "Ozone Density Height",
        max: 100 * 25e3
      });
      this._ozoneDensityWide = new Slider({
        label: "Ozone Density Wide",
        max: 100 * 25e3
      });
      this._sunAngularRadius = new Slider({
        label: "Sun Angular Radius",
        max: 1e3 * 4685e-6
      });
      this._sunIntensity = new Slider({
        label: "Sun Intensity",
        max: 10 * 1
      });
      this._groundAlbedo = new Slider({
        label: "Earth Albedo",
        max: 10 * 0.05
      });
      this._parameters = {
        ATMOS_HEIGHT: 0,
        RAYLEIGH_SCALE: 0,
        MIE_SCALE: 0,
        GROUND_ALBEDO: 0,
        BOTTOM_RADIUS: 0,
        rayleighScatteringCoefficient: [0, 0, 0],
        mieScatteringCoefficient: 0,
        mieExtinctionCoefficient: 0,
        ozoneAbsorptionCoefficient: [0, 0, 0],
        SUN_ANGULAR_RADIUS: 0,
        SUN_INTENSITY: 0,
        ozoneDensityHeight: 0,
        ozoneDensityWide: 0
      };
    }
    oninit() {
      this._toggleBtn.appendTo(this.renderer.div);
      this._dialog.appendTo(this.renderer.div);
      this._panel.appendTo(this._dialog.container);
      if (this._panel.el) {
        this.$height = this._panel.el.querySelector(".og-option.og-atmosphere-height");
        this.$maxOpacity = this._panel.el.querySelector(".og-option.og-atmosphere-maxOpacity");
        this.$minOpacity = this._panel.el.querySelector(".og-option.og-atmosphere-minOpacity");
        this.$rayleight = this._panel.el.querySelector(".og-option.og-atmosphere-rayleight");
        this.$mie = this._panel.el.querySelector(".og-option.og-atmosphere-mie");
        this.$bottomRadius = this._panel.el.querySelector(".og-option.og-atmosphere-bottomRadius");
        this.$mieScatteringCoefficient = this._panel.el.querySelector(".og-option.og-atmosphere-mieScatteringCoefficient");
        this.$mieExtinctionCoefficient = this._panel.el.querySelector(".og-option.og-atmosphere-mieExtinctionCoefficient");
        this.$rayleighScatteringCoefficientA = this._panel.el.querySelector(".og-option.og-atmosphere-rayleighScatteringCoefficientA");
        this.$rayleighScatteringCoefficientB = this._panel.el.querySelector(".og-option.og-atmosphere-rayleighScatteringCoefficientB");
        this.$rayleighScatteringCoefficientC = this._panel.el.querySelector(".og-option.og-atmosphere-rayleighScatteringCoefficientC");
        this.$ozoneAbsorptionCoefficientA = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneAbsorptionCoefficientA");
        this.$ozoneAbsorptionCoefficientB = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneAbsorptionCoefficientB");
        this.$ozoneAbsorptionCoefficientC = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneAbsorptionCoefficientC");
        this.$sunAngularRadius = this._panel.el.querySelector(".og-option.og-atmosphere-sunAngularRadius");
        this.$sunIntensity = this._panel.el.querySelector(".og-option.og-atmosphere-sunIntensity");
        this.$groundAlbedo = this._panel.el.querySelector(".og-option.og-atmosphere-earthAlbedo");
        this.$ozoneDensityHeight = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneDensityHeight");
        this.$ozoneDensityWide = this._panel.el.querySelector(".og-option.og-atmosphere-ozoneDensityWide");
      }
      this._toggleBtn.events.on("change", (isActive) => {
        this._dialog.setVisibility(isActive);
      });
      this._maxOpacity.appendTo(this.$maxOpacity);
      this._minOpacity.appendTo(this.$minOpacity);
      this._height.appendTo(this.$height);
      this._rayleight.appendTo(this.$rayleight);
      this._mie.appendTo(this.$mie);
      this._bottomRadius.appendTo(this.$bottomRadius);
      this._mieScatteringCoefficient.appendTo(this.$mieScatteringCoefficient);
      this._mieExtinctionCoefficient.appendTo(this.$mieExtinctionCoefficient);
      this._rayleighScatteringCoefficientA.appendTo(this.$rayleighScatteringCoefficientA);
      this._rayleighScatteringCoefficientB.appendTo(this.$rayleighScatteringCoefficientB);
      this._rayleighScatteringCoefficientC.appendTo(this.$rayleighScatteringCoefficientC);
      this._ozoneAbsorptionCoefficientA.appendTo(this.$ozoneAbsorptionCoefficientA);
      this._ozoneAbsorptionCoefficientB.appendTo(this.$ozoneAbsorptionCoefficientB);
      this._ozoneAbsorptionCoefficientC.appendTo(this.$ozoneAbsorptionCoefficientC);
      this._sunAngularRadius.appendTo(this.$sunAngularRadius);
      this._sunIntensity.appendTo(this.$sunIntensity);
      this._groundAlbedo.appendTo(this.$groundAlbedo);
      this._ozoneDensityHeight.appendTo(this.$ozoneDensityHeight);
      this._ozoneDensityWide.appendTo(this.$ozoneDensityWide);
      if (this.planet) {
        this._parameters = this.planet.atmosphereControl.parameters;
        this._height.value = this._parameters.ATMOS_HEIGHT;
        this._rayleight.value = this._parameters.RAYLEIGH_SCALE;
        this._mie.value = this._parameters.MIE_SCALE;
        this._bottomRadius.value = this._parameters.BOTTOM_RADIUS;
        this._mieScatteringCoefficient.value = this._parameters.mieScatteringCoefficient;
        this._mieExtinctionCoefficient.value = this._parameters.mieExtinctionCoefficient;
        this._rayleighScatteringCoefficientA.value = this._parameters.rayleighScatteringCoefficient[0];
        this._rayleighScatteringCoefficientB.value = this._parameters.rayleighScatteringCoefficient[1];
        this._rayleighScatteringCoefficientC.value = this._parameters.rayleighScatteringCoefficient[2];
        this._ozoneAbsorptionCoefficientA.value = this._parameters.ozoneAbsorptionCoefficient[0];
        this._ozoneAbsorptionCoefficientB.value = this._parameters.ozoneAbsorptionCoefficient[1];
        this._ozoneAbsorptionCoefficientC.value = this._parameters.ozoneAbsorptionCoefficient[2];
        this._sunAngularRadius.value = this._parameters.SUN_ANGULAR_RADIUS;
        this._sunIntensity.value = this._parameters.SUN_INTENSITY;
        this._groundAlbedo.value = this._parameters.GROUND_ALBEDO;
        this._ozoneDensityHeight.value = this._parameters.ozoneDensityHeight;
        this._ozoneDensityWide.value = this._parameters.ozoneDensityWide;
      }
      this._minOpacity.value = this.planet.atmosphereMinOpacity;
      this._minOpacity.events.on("change", (val) => {
        this.planet.atmosphereMinOpacity = val;
      });
      this._maxOpacity.value = this.planet.atmosphereMaxOpacity;
      this._maxOpacity.events.on("change", (val) => {
        this.planet.atmosphereMaxOpacity = val;
      });
      this._rayleight.events.on("change", (val) => {
        this._parameters.RAYLEIGH_SCALE = val;
        this._update();
      });
      this._mie.events.on("change", (val) => {
        this._parameters.MIE_SCALE = val;
        this._update();
      });
      this._height.events.on("change", (val) => {
        this._parameters.ATMOS_HEIGHT = val;
        this._update();
      });
      this._bottomRadius.events.on("change", (val) => {
        this._parameters.BOTTOM_RADIUS = val;
        this._update();
      });
      this._mieScatteringCoefficient.events.on("change", (val) => {
        this._parameters.mieScatteringCoefficient = val;
        this._update();
      });
      this._mieExtinctionCoefficient.events.on("change", (val) => {
        this._parameters.mieExtinctionCoefficient = val;
        this._update();
      });
      this._rayleighScatteringCoefficientA.events.on("change", (val) => {
        this._parameters.rayleighScatteringCoefficient[0] = val;
        this._update();
      });
      this._rayleighScatteringCoefficientB.events.on("change", (val) => {
        this._parameters.rayleighScatteringCoefficient[1] = val;
        this._update();
      });
      this._rayleighScatteringCoefficientC.events.on("change", (val) => {
        this._parameters.rayleighScatteringCoefficient[2] = val;
        this._update();
      });
      this._ozoneAbsorptionCoefficientA.events.on("change", (val) => {
        this._parameters.ozoneAbsorptionCoefficient[0] = val;
        this._update();
      });
      this._ozoneAbsorptionCoefficientB.events.on("change", (val) => {
        this._parameters.ozoneAbsorptionCoefficient[1] = val;
        this._update();
      });
      this._ozoneAbsorptionCoefficientC.events.on("change", (val) => {
        this._parameters.ozoneAbsorptionCoefficient[2] = val;
        this._update();
      });
      this._sunAngularRadius.events.on("change", (val) => {
        this._parameters.SUN_ANGULAR_RADIUS = val;
        this._update();
      });
      this._sunIntensity.events.on("change", (val) => {
        this._parameters.SUN_INTENSITY = val;
        this._update();
      });
      this._groundAlbedo.events.on("change", (val) => {
        this._parameters.GROUND_ALBEDO = val;
        this._update();
      });
      this._ozoneDensityHeight.events.on("change", (val) => {
        this._parameters.ozoneDensityHeight = val;
        this._update();
      });
      this._ozoneDensityWide.events.on("change", (val) => {
        this._parameters.ozoneDensityWide = val;
        this._update();
      });
    }
    _update() {
      if (this.planet) {
        this.planet.atmosphereControl.setParameters(this._parameters);
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/segment/segmentHelper.js
  function NewIndexesTypedArray(arr) {
    return new Uint32Array(arr);
  }
  function NewIndexesTypedArrayEmpty(size) {
    return new Uint32Array(size);
  }
  function createCenterBodyIndexes(size) {
    let indexes = [];
    let i0 = 1, j0 = 1;
    let i1 = 1, j1 = 1;
    let ind1 = 0, ind2 = 0, nr = 0;
    for (let i9 = i0; i9 < size - 1 - i1; i9++) {
      for (let j2 = j0; j2 < size - j1; j2++) {
        ind1 = i9 * size + j2;
        nr = (i9 + 1) * size;
        ind2 = nr + j2;
        indexes.push(ind1, ind2);
      }
      indexes.push(ind2, nr + j0);
    }
    indexes.push(indexes[indexes.length - 1], size * size - size);
    return NewIndexesTypedArray(indexes);
  }
  function createWestNeighborSkirt(size, deltaGr) {
    let indexes = [];
    const grCount = (size - 1) / deltaGr;
    const b4 = size * size - size;
    let k3 = 0;
    for (let i9 = 0; i9 < size - 2; i9++) {
      if (i9 % grCount === 0) {
        k3 = i9;
      }
      let rind = b4 - size * i9 - size + 1, lind = b4 - size * k3;
      indexes.push(lind, rind);
    }
    if (deltaGr === size - 1) {
      indexes.push(size);
      indexes.push(0);
    }
    return NewIndexesTypedArray(indexes);
  }
  function createNorthNeighborSkirt(size, deltaGr) {
    let indexes = [];
    const grCount = (size - 1) / deltaGr;
    let k3 = 0;
    for (let i9 = 0; i9 < size - 2; i9++) {
      if (i9 % grCount === 0) {
        k3 = i9;
      }
      let rind = size + i9 + 1, lind = k3;
      indexes.push(lind, rind);
    }
    if (deltaGr === size - 1) {
      indexes.push(size - 2);
      indexes.push(size - 1);
    }
    return NewIndexesTypedArray(indexes);
  }
  function createEastNeighborSkirt(size, deltaGr) {
    let indexes = [];
    const grCount = (size - 1) / deltaGr;
    let k3 = 0;
    for (let i9 = 0; i9 < size - 2; i9++) {
      if (i9 % grCount === 0) {
        k3 = i9;
      }
      let rind = size * (i9 + 1) + size - 2, lind = size + size * k3 - 1;
      indexes.push(lind, rind);
    }
    if (deltaGr === size - 1) {
      indexes.push(size * (size - 1) - 1);
      indexes.push(size * size - 1);
    }
    return NewIndexesTypedArray(indexes);
  }
  function createSouthNeighborSkirt(size, deltaGr) {
    let indexes = [];
    const grCount = (size - 1) / deltaGr;
    let k3 = 0;
    const rb = size * (size - 1) - 2;
    const lb = size * size - 1;
    for (let i9 = 0; i9 < size - 2; i9++) {
      if (i9 % grCount === 0) {
        k3 = i9;
      }
      let rind = rb - i9, lind = lb - k3;
      indexes.push(lind, rind);
    }
    if (deltaGr === size - 1) {
      indexes.push(size * size - size + 1);
    }
    indexes.push(size * size - size);
    return NewIndexesTypedArray(indexes);
  }
  function initIndexesBodySkirts(pow) {
    let table = [[], [], [], []];
    for (let i9 = 0; i9 <= pow; i9++) {
      let d4 = Math.pow(2, i9), d1 = d4 + 1;
      table[N][i9] = [];
      table[W2][i9] = [];
      table[S][i9] = [];
      table[E][i9] = [];
      for (let j2 = 0; j2 <= pow; j2++) {
        let dd = Math.pow(2, j2);
        table[W2][i9][j2] = createWestNeighborSkirt(d1, dd);
        table[N][i9][j2] = createNorthNeighborSkirt(d1, dd);
        table[E][i9][j2] = createEastNeighborSkirt(d1, dd);
        table[S][i9][j2] = createSouthNeighborSkirt(d1, dd);
      }
    }
    return table;
  }
  function initIndexBodiesTable(pow) {
    let table = [];
    for (let i9 = 0; i9 <= pow; i9++) {
      const d4 = Math.pow(2, i9);
      table[i9] = createCenterBodyIndexes(d4 + 1);
    }
    return table;
  }
  function createTextureCoords(size) {
    let texCoords = new Uint16Array((size + 1) * (size + 1) * 2);
    let k3 = 0;
    for (let i9 = 0; i9 <= size; i9++) {
      for (let j2 = 0; j2 <= size; j2++) {
        texCoords[k3++] = j2 / size * 65535;
        texCoords[k3++] = i9 / size * 65535;
      }
    }
    return texCoords;
  }
  var SegmentHelper = class {
    constructor(maxGridSize = 0) {
      this._maxGridSize = maxGridSize;
      this.centerIndexesTable = initIndexBodiesTable(this._maxGridSize);
      this.skirtsIndexesTable = initIndexesBodySkirts(this._maxGridSize);
    }
    get maxGridSize() {
      return this._maxGridSize;
    }
    init() {
      this.centerIndexesTable = initIndexBodiesTable(this._maxGridSize);
      this.skirtsIndexesTable = initIndexesBodySkirts(this._maxGridSize);
    }
    setMaxGridSize(gridSize) {
      this._maxGridSize = gridSize;
      this.init();
    }
    createSegmentIndexes(size, sidesSizes) {
      if (size) {
        let c7 = this.centerIndexesTable[size], w3 = this.skirtsIndexesTable[W2][size][sidesSizes[W2]], n7 = this.skirtsIndexesTable[N][size][sidesSizes[N]], e9 = this.skirtsIndexesTable[E][size][sidesSizes[E]], s7 = this.skirtsIndexesTable[S][size][sidesSizes[S]];
        let indexes = NewIndexesTypedArrayEmpty(c7.length + w3.length + n7.length + e9.length + s7.length);
        indexes.set(c7, 0);
        indexes.set(w3, c7.length);
        indexes.set(n7, c7.length + w3.length);
        indexes.set(e9, c7.length + w3.length + n7.length);
        indexes.set(s7, c7.length + w3.length + n7.length + e9.length);
        return indexes;
      } else {
        return NewIndexesTypedArray([0, 2, 1, 3]);
      }
    }
    initTextureCoordsTable(pow) {
      let table = [];
      for (let i9 = 0; i9 <= pow; i9++) {
        const d4 = Math.pow(2, i9);
        table[i9] = createTextureCoords(d4);
      }
      return table;
    }
  };
  var instance = new SegmentHelper();
  function getInstance() {
    return instance;
  }

  // frontend/node_modules/@openglobus/og/lib/js/shaders/utils.js
  var UTILS = `
    float getLerpValue(in float min, in float max, in float between)
    {
        return (clamp(between, min, max) - min) / (max - min);
    }
    
    vec3 aces(vec3 color) 
    {
        float a = 2.51;
        float b = 0.03;
        float c = 2.43;
        float d = 0.59;
        float e = 0.14;
        return clamp((color * (a * color + b)) / (color * (c * color + d ) + e), 0.0, 1.0);
    }
     
    bool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t1, inout float t2) 
    {
        float b = dot(rayDirection, rayOrigin);
        float c = dot(rayOrigin, rayOrigin) - radius * radius;
        float d = b * b - c;
        if (d < 0.0) {
            return false;
        }
        t1 = -b - sqrt(d);
        t2 = -b + sqrt(d);
        return true;
    }
    
    bool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t) 
    {
        float b = dot(rayDirection, rayOrigin);
        float c = dot(rayOrigin, rayOrigin) - radius * radius;
        float d = b * b - c;
        if (d < 0.0) {
            return false;
        }
        t = -b - sqrt(d);
        return true;
    }
    
    bool intersectEllipsoid( in vec3 ro, in vec3 rd, in vec3 ra, inout float t )
    {
        vec3 ocn = ro/ra;
        vec3 rdn = rd/ra;
        float a = dot( rdn, rdn );
        float b = dot( ocn, rdn );
        float c = dot( ocn, ocn );
        float h = b*b - a*(c-1.0);
                       
        if (h < 0.0) 
        { 
            return false; 
        }
        
        t = (-b-sqrt(h))/a;
        
        return true;
    }
    
    bool intersectEllipsoid( in vec3 ro, in vec3 rd, in vec3 ra, inout float t1, inout float t2)
    {
        vec3 ocn = ro/ra;
        vec3 rdn = rd/ra;
        float a = dot( rdn, rdn );
        float b = dot( ocn, rdn );
        float c = dot( ocn, ocn );
        float h = b*b - a*(c-1.0);
                
        if (h < 0.0) 
        { 
            return false; 
        }
        
        h = sqrt(h);
        t1 = (-b-h)/a;
        t2 = (-b+h)/a;
        
        return true;
    }
    
    vec3 normalEllipsoid( in vec3 pos, in vec3 ra )
    {
        return normalize( pos/(ra*ra) );
    }
`;

  // frontend/node_modules/@openglobus/og/lib/js/shaders/atmos.js
  var DEFAULT_PARAMS = {
    ATMOS_HEIGHT: 1e5,
    RAYLEIGH_SCALE: 0.08,
    MIE_SCALE: 0.012,
    GROUND_ALBEDO: 0.05,
    BOTTOM_RADIUS: 6356752314245179e-9,
    rayleighScatteringCoefficient: [5.802, 13.558, 33.1],
    mieScatteringCoefficient: 3.996,
    mieExtinctionCoefficient: 4.44,
    ozoneAbsorptionCoefficient: [0.65, 1.881, 0.085],
    SUN_ANGULAR_RADIUS: 4685e-6,
    SUN_INTENSITY: 1,
    ozoneDensityHeight: 25e3,
    ozoneDensityWide: 15e3
  };
  var COMMON = (atmosParams = DEFAULT_PARAMS) => `    
    ${UTILS}
    
    #define PI 3.1415926538
    #define ATMOS_HEIGHT ${atmosParams.ATMOS_HEIGHT.toFixed(2)}
    #define RAYLEIGH_SCALE ${atmosParams.RAYLEIGH_SCALE.toFixed(5)}
    #define MIE_SCALE ${atmosParams.MIE_SCALE.toFixed(5)}
    
    #define SAMPLE_COUNT 16
    #define SQRT_SAMPLE_COUNT 4
            
    const float GROUND_ALBEDO = ${atmosParams.GROUND_ALBEDO.toFixed(2)} / PI;

    // Sphere
    const float BOTTOM_RADIUS = ${atmosParams.BOTTOM_RADIUS.toFixed(10)};
    const float TOP_RADIUS = BOTTOM_RADIUS + ATMOS_HEIGHT;   
    const float EQUATORIAL_RADIUS = 6378137.0;
    
    // Ellipsoid
    const vec3 bottomRadii = vec3(EQUATORIAL_RADIUS, EQUATORIAL_RADIUS, BOTTOM_RADIUS);           
    const vec3 topRadii = bottomRadii + ATMOS_HEIGHT;
    
    const vec3 SPHERE_TO_ELLIPSOID_SCALE = vec3(BOTTOM_RADIUS) / bottomRadii;           
    
    const vec2 rayleighMieHeights = vec2(RAYLEIGH_SCALE, MIE_SCALE) * ATMOS_HEIGHT;
     
    const vec3 rayleighScatteringCoefficient = vec3(${atmosParams.rayleighScatteringCoefficient[0].toFixed(5)}, ${atmosParams.rayleighScatteringCoefficient[1].toFixed(5)}, ${atmosParams.rayleighScatteringCoefficient[2].toFixed(5)}) * 1e-6;
    
    const float mieScatteringCoefficient = ${atmosParams.mieScatteringCoefficient.toFixed(3)} * 1e-6;
    const float mieExtinctionCoefficient = ${atmosParams.mieExtinctionCoefficient.toFixed(3)} * 1e-6;
    const vec3 ozoneAbsorptionCoefficient = vec3(${atmosParams.ozoneAbsorptionCoefficient[0].toFixed(5)}, ${atmosParams.ozoneAbsorptionCoefficient[1].toFixed(5)}, ${atmosParams.ozoneAbsorptionCoefficient[2].toFixed(5)}) * 1e-6;
    
    const float SUN_ANGULAR_RADIUS = ${atmosParams.SUN_ANGULAR_RADIUS.toFixed(10)};
    const float SUN_INTENSITY = ${atmosParams.SUN_INTENSITY.toFixed(2)};        
    
    const float ozoneDensityHeight = ${atmosParams.ozoneDensityHeight.toFixed(1)};//25e3;
    const float ozoneDensityWide = ${atmosParams.ozoneDensityWide.toFixed(1)};//15e3;
    
    vec3 sunWithBloom(vec3 rayDir, vec3 sunDir) 
    {
        float minSunCosTheta = cos(SUN_ANGULAR_RADIUS);            
        float cosTheta = dot(rayDir, sunDir);
        if (cosTheta >= minSunCosTheta) return vec3(1.0);                
        float offset = minSunCosTheta - cosTheta;
        float gaussianBloom = exp(-offset*15000.0)*0.7;
        float invBloom = 1.0/(0.09 + offset*200.0)*0.01;
        return vec3(gaussianBloom + invBloom);
    }
    
    float rayleighPhase(float angle) 
    {
        return 3.0 / (16.0 * PI) * (1.0 + (angle * angle));
    }
    
    float miePhase(float angle) 
    {
        float g = 0.8;
        return 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + angle * angle)) / ((2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * angle, 1.5));
    }
        
    vec3 opticalDepth(float height, float angle) 
    {
        vec3 rayOrigin = vec3(0.0, BOTTOM_RADIUS + height, 0.0);
        vec3 rayDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);
        float t1, t2;
        intersectSphere(rayOrigin, rayDirection, TOP_RADIUS, t1, t2);
        float segmentLength = t2 / float(SAMPLE_COUNT);
        
        float t = segmentLength * 0.5;
        vec3 opticalDepth = vec3(0.0);
        
        for (int i = 0; i < SAMPLE_COUNT; i++) 
        {
            vec3 position = rayOrigin + t * rayDirection;
            float height = length(position) - BOTTOM_RADIUS;
            opticalDepth.xy += exp(-height / rayleighMieHeights) * segmentLength;
            opticalDepth.z += (1.0 - min(abs(height - ozoneDensityHeight) / ozoneDensityWide, 1.0)) * segmentLength;  
            t += segmentLength;
        }
        
        return opticalDepth;
    }
    
    vec3 transmittance(float height, float angle) 
    {
        vec3 opticalDepth = opticalDepth(height, angle);
        return exp(-(rayleighScatteringCoefficient * opticalDepth.x + mieExtinctionCoefficient * opticalDepth.y + ozoneAbsorptionCoefficient * opticalDepth.z));
    }`;
  function transmittance(atmosParams) {
    return new Program("transmittance", {
      uniforms: {
        iResolution: "vec2"
      },
      attributes: {
        a_position: "vec2"
      },
      vertexShader: `
            attribute vec2 a_position;
            
            void main(void) 
            {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }`,
      fragmentShader: `
            precision highp float;
            
            ${COMMON(atmosParams)}
                       
            uniform vec2 iResolution;
                        
            void main(void) 
            {
                vec2 uv = gl_FragCoord.xy / iResolution.xy;
                float height = uv.y * ATMOS_HEIGHT;
                float angle = uv.x * 2.0 - 1.0;
                gl_FragColor = vec4(transmittance(height, angle), 1.0);
            }`
    });
  }
  function scattering(atmosParams) {
    return new Program("scattering", {
      uniforms: {
        iResolution: "vec2",
        transmittanceTexture: "sampler2d"
      },
      attributes: {
        a_position: "vec2"
      },
      vertexShader: `            
            attribute vec2 a_position;  
                      
            void main(void) 
            {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }`,
      fragmentShader: `            
            precision highp float;
            
            uniform sampler2D transmittanceTexture;
            uniform vec2 iResolution;
            
            ${COMMON(atmosParams)}
            
            vec3 transmittanceFromTexture(float height, float angle) 
            {
                float u = (angle + 1.0) * 0.5;
                float v = height / ATMOS_HEIGHT;
                return texture2D(transmittanceTexture, vec2(u, v)).xyz;
            }
                                   
            void main(void) 
            {
                vec2 uv = gl_FragCoord.xy / iResolution.xy;
                
                float height = uv.y * ATMOS_HEIGHT;
                float angle = uv.x * 2.0 - 1.0;
                
                vec3 rayOrigin = vec3(0.0, BOTTOM_RADIUS + height, 0.0);
                vec3 up = rayOrigin / length(rayOrigin);
                vec3 lightDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);
                                
                const float isotropicPhase = 1.0 / (4.0 * PI);
                
                vec3 light = vec3(0.0);
                vec3 lightTransferFactor = vec3(0.0);
                
                for (int i = 0; i < SQRT_SAMPLE_COUNT; i++)
                {
                    for (int j = 0; j < SQRT_SAMPLE_COUNT; j++)
                    {
                        float u = ((0.5 + float(i)) / float(SQRT_SAMPLE_COUNT)) * 2.0 - 1.0;
                        float v = (0.5 + float(j)) / float(SQRT_SAMPLE_COUNT);
                        float r = sqrt(1.0 - u * u);
                        float theta = 2.0 * PI * v;
                        vec3 rayDirection = vec3(cos(theta) * r, sin(theta) * r, u);
                                                
                        float rayAngle = dot(up, rayDirection);
                        bool cameraBelow = rayAngle < 0.0;
                        
                        vec3 transmittanceFromCameraToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                        
                        float offset = 0.0;
                        float distanceToSpace = 0.0;
                        
                        intersectSphere(rayOrigin, rayDirection, TOP_RADIUS, offset, distanceToSpace);
                        
                        float distanceToGround = 0.0;
                        bool hitGround = intersectSphere(rayOrigin, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;                        
                        float segmentLength = (hitGround ? distanceToGround : distanceToSpace) / float(SAMPLE_COUNT);
                        float t = segmentLength * 0.5;
                        
                        vec3 transmittanceCamera;
                        vec3 transmittanceLight;
                         
                        for (int k = 0; k < SAMPLE_COUNT; k++) 
                        {
                            vec3 position = rayOrigin + t * rayDirection;
                            float height = length(position) - BOTTOM_RADIUS;
                            vec3 up = position / length(position);
                            float rayAngle = dot(up, rayDirection);
                            float lightAngle = dot(up, lightDirection);
                            
                            float distanceToGround;
                            float shadow = intersectSphere(position, lightDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround >= 0.0 ? 0.0 : 1.0;
                            vec3 transmittanceToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                            
                            transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);
                            transmittanceLight = transmittanceFromTexture(height, lightAngle);
                            
                            vec2 opticalDensity = exp(-height / rayleighMieHeights);        
                            vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y) * isotropicPhase;
                            
                            light += shadow * transmittanceCamera * scatteredLight * segmentLength;
                            lightTransferFactor += transmittanceCamera * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y) * segmentLength;
                            
                            t += segmentLength;
                        }
                    
                        if (hitGround) 
                        {
                            vec3 hitPoint = rayOrigin + rayDirection * distanceToGround;
                            vec3 normal = normalize(hitPoint);
                            float diffuseAngle = max(dot(normal, lightDirection), 0.0); 
                            light += transmittanceCamera * transmittanceLight * GROUND_ALBEDO * diffuseAngle;
                        }
                    }
                }
                
                light /= float(SAMPLE_COUNT);
                lightTransferFactor /= float(SAMPLE_COUNT);
                vec3 color = light / (1.0 - lightTransferFactor);                 
                gl_FragColor = vec4(color, 1.0);
            }`
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/shaders/drawnode.js
  var NIGHT = `const vec3 nightStep = 10.0 * vec3(0.58, 0.48, 0.25);`;
  var DEF_BLEND = `#define blend(DEST, SAMPLER, OFFSET, OPACITY)                     src = texture( SAMPLER, OFFSET.xy + vTextureCoord.xy * OFFSET.zw );                    DEST = DEST * (1.0 - src.a * OPACITY) + src * OPACITY;`;
  var DEF_BLEND_WEBGL1 = `#define blend(DEST, SAMPLER, OFFSET, OPACITY)                             src = texture2D( SAMPLER, OFFSET.xy + vTextureCoord.xy * OFFSET.zw );                             DEST = DEST * (1.0 - src.a * OPACITY) + src * OPACITY;`;
  var DEF_BLEND_PICKING = `#define blendPicking(DEST, OFFSET, SAMPLER, MASK, COLOR, OPACITY)     tc = OFFSET.xy + vTextureCoord.xy * OFFSET.zw;     t = texture2D(SAMPLER, tc);     p = texture2D(MASK, tc);     DEST = mix(DEST, vec4(max(COLOR.rgb, p.rgb), OPACITY), (t.a == 0.0 ? 0.0 : 1.0) * COLOR.a);`;
  var SLICE_SIZE = 4;
  function drawnode_screen_nl() {
    return new Program("drawnode_screen_nl", {
      uniforms: {
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        samplerCount: "int",
        tileOffsetArr: "vec4",
        layerOpacityArr: "float",
        samplerArr: "sampler2darray",
        defaultTexture: "sampler2d",
        height: "float"
      },
      attributes: {
        aVertexPositionHigh: "vec3",
        aVertexPositionLow: "vec3",
        aTextureCoord: "vec2"
      },
      vertexShader: `precision highp float;
            
            attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;
            attribute vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            varying vec2 vTextureCoord;

            void main(void) {

                vTextureCoord = aTextureCoord;
                vec3 nh = height * normalize(aVertexPositionHigh + aVertexPositionLow);

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);
                mat4 m = projectionMatrix * viewMatrixRTE;
        
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;
                
                // This is works for Mac Chrome, prevent some weird optimization I suppose
                gl_Position =  m * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
            }`,
      fragmentShader: `precision highp float;
            #define SLICE_SIZE ${SLICE_SIZE + 1}
            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform float layerOpacityArr[SLICE_SIZE];
            uniform sampler2D defaultTexture;
            uniform sampler2D samplerArr[SLICE_SIZE];
            uniform int samplerCount;
            varying vec2 vTextureCoord;

            ${DEF_BLEND_WEBGL1}

            void main(void) {
                gl_FragColor = texture2D( defaultTexture, vTextureCoord );
                if( samplerCount == 0 ) return;

                vec4 src;

                blend(gl_FragColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);
                if( samplerCount == 1 ) return;

                blend(gl_FragColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);
                if( samplerCount == 2 ) return;

                blend(gl_FragColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);
                if( samplerCount == 3 ) return;

                blend(gl_FragColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);
                if( samplerCount == 4 ) return;

                blend(gl_FragColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);
            }`
    });
  }
  function drawnode_screen_wl_webgl1NoAtmos() {
    return new Program("drawnode_screen_wl", {
      uniforms: {
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        height: "float",
        uGlobalTextureCoord: "vec4",
        uNormalMapBias: "vec3",
        samplerCount: "int",
        tileOffsetArr: "vec4",
        layerOpacityArr: "float",
        samplerArr: "sampler2darray",
        defaultTexture: "sampler2d",
        uNormalMap: "sampler2d",
        nightTexture: "sampler2d",
        specularTexture: "sampler2d",
        lightsPositions: "vec3",
        diffuse: "vec3",
        ambient: "vec3",
        specular: "vec4",
        camHeight: "float",
        nightTextureCoefficient: "float"
      },
      attributes: {
        aVertexPositionHigh: "vec3",
        aVertexPositionLow: "vec3",
        aTextureCoord: "vec2"
      },
      vertexShader: `
            attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;
            attribute vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec4 uGlobalTextureCoord;
            uniform vec3 uNormalMapBias;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            varying vec4 vTextureCoord;
            varying vec3 v_vertex;
            varying vec3 cameraPosition;
            varying vec2 vGlobalTextureCoord;
            varying float v_height;

            void main(void) {

                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;                
                vec3 nh = height * normalize(aVertexPosition);

                vTextureCoord.xy = aTextureCoord;
                vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;
                vTextureCoord.zw = uNormalMapBias.z * ( aTextureCoord + uNormalMapBias.xy );

                cameraPosition = eyePositionHigh + eyePositionLow;
                
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                v_height = height;
                v_vertex = aVertexPosition + nh;
                            
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
            }`,
      fragmentShader: `
            precision highp float;
            
            #define MAX_POINT_LIGHTS 1
            #define SLICE_SIZE ${SLICE_SIZE + 1}

            uniform vec4 specular;
            uniform vec3 diffuse;
            uniform vec3 ambient;

            uniform sampler2D uNormalMap;
            uniform sampler2D nightTexture;
            uniform sampler2D specularTexture;
            uniform sampler2D defaultTexture;
            uniform sampler2D samplerArr[SLICE_SIZE];

            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform vec3 lightsPositions[MAX_POINT_LIGHTS];
            uniform float layerOpacityArr[SLICE_SIZE];

            uniform int samplerCount;
            uniform float nightTextureCoefficient;              
            uniform float camHeight;

            varying vec4 vTextureCoord;
            varying vec3 v_vertex;
            varying vec3 cameraPosition;
            varying vec2 vGlobalTextureCoord;
            varying float v_height;

            vec3 sunPos;

            ${NIGHT}

            ${DEF_BLEND_WEBGL1}
            
            ${UTILS}
                                               
            void main(void) {
            
                sunPos = lightsPositions[0];
                                
                vec3 texNormal = texture2D(uNormalMap, vTextureCoord.zw).rgb;
                vec3 normal = normalize((texNormal - 0.5) * 2.0);
                
                float minH = 1200000.0;
                float maxH = minH * 3.0;
                float nightCoef = getLerpValue(minH, maxH, camHeight) * nightTextureCoefficient;
                                
                // if(camHeight > 6000000.0)
                // {
                //     normal = normalize(v_vertex);
                // }
                                            
                vec3 lightDir = normalize(sunPos);
                vec3 viewDir = normalize(cameraPosition - v_vertex);
                                                
                float overGround = 1.0 - step(0.1, v_height);

                float shininess = texture2D( specularTexture, vGlobalTextureCoord.st ).r * 255.0 * overGround;
                vec3 reflectionDirection = reflect(-lightDir, normal);
                float reflection = max( dot(reflectionDirection, viewDir), 0.0);
                vec3 spec = specular.rgb * pow( reflection, specular.w) * shininess;                
                float diffuseLightWeighting = max(dot(normal, lightDir), 0.0);                
                vec4 nightImageColor = texture2D( nightTexture, vGlobalTextureCoord.st );
                vec3 night = nightStep * (.18 - diffuseLightWeighting * 3.0) * nightImageColor.rgb * nightCoef;
                night *= overGround * step(0.0, night);                
                vec4 lightWeighting = vec4(ambient + diffuse * diffuseLightWeighting + night, 1.0);
                
                gl_FragColor = texture2D( defaultTexture, vTextureCoord.xy );
                if( samplerCount == 0 ) {
                    gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
                    return;
                }

                vec4 src;

                blend(gl_FragColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);
                if( samplerCount == 1 ) {                
                    gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
                    return;
                }

                blend(gl_FragColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);
                if( samplerCount == 2 ) {
                    gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
                    return;
                }

                blend(gl_FragColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);
                if( samplerCount == 3 ) {
                    gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
                    return;
                }

                blend(gl_FragColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);
                if( samplerCount == 4 ) {
                    gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
                    return;
                }

                blend(gl_FragColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);
                gl_FragColor = gl_FragColor * lightWeighting + vec4(spec, 0.0);
            }`
    });
  }
  function drawnode_screen_wl_webgl2NoAtmos() {
    return new Program("drawnode_screen_wl", {
      uniforms: {
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        height: "float",
        uGlobalTextureCoord: "vec4",
        uNormalMapBias: "vec3",
        samplerCount: "int",
        tileOffsetArr: "vec4",
        layerOpacityArr: "float",
        samplerArr: "sampler2darray",
        defaultTexture: "sampler2d",
        uNormalMap: "sampler2d",
        nightTexture: "sampler2d",
        specularTexture: "sampler2d",
        lightsPositions: "vec3",
        diffuse: "vec3",
        ambient: "vec3",
        specular: "vec4",
        camHeight: "float",
        nightTextureCoefficient: "float",
        transitionOpacity: "float"
      },
      attributes: {
        aVertexPositionHigh: "vec3",
        aVertexPositionLow: "vec3",
        aTextureCoord: "vec2"
      },
      vertexShader: `#version 300 es

            precision highp float;

            in vec3 aVertexPositionHigh;
            in vec3 aVertexPositionLow;
            in vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec4 uGlobalTextureCoord;
            uniform vec3 uNormalMapBias;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            out vec4 vTextureCoord;
            out vec3 v_vertex;
            out vec3 cameraPosition;
            out vec2 vGlobalTextureCoord;
            out float v_height;

            void main(void) {

                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;                
                vec3 nh = height * normalize(aVertexPosition);
                
                vTextureCoord.xy = aTextureCoord;
                vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;
                vTextureCoord.zw = uNormalMapBias.z * ( aTextureCoord + uNormalMapBias.xy );

                cameraPosition = eyePositionHigh + eyePositionLow;
                
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                v_height = height;
                v_vertex = aVertexPosition + nh;
                            
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
            }`,
      fragmentShader: `#version 300 es

            precision highp float;
            
            #define MAX_POINT_LIGHTS 1
            #define SLICE_SIZE ${SLICE_SIZE + 1}

            uniform vec4 specular;
            uniform vec3 diffuse;
            uniform vec3 ambient;  

            uniform sampler2D uNormalMap;
            uniform sampler2D nightTexture;
            uniform sampler2D specularTexture;
            uniform sampler2D defaultTexture;
            uniform sampler2D samplerArr[SLICE_SIZE];

            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform vec3 lightsPositions[MAX_POINT_LIGHTS];
            uniform float layerOpacityArr[SLICE_SIZE];

            uniform int samplerCount;
            uniform float nightTextureCoefficient;
            
            uniform float transitionOpacity;
                
            uniform float camHeight;

            in vec4 vTextureCoord;
            in vec3 v_vertex;
            in vec3 cameraPosition;
            in vec2 vGlobalTextureCoord;
            in float v_height;

            vec3 sunPos;

            layout(location = 0) out vec4 diffuseColor;

            ${NIGHT}

            ${DEF_BLEND}
            
            ${UTILS}
                                               
            void main(void) {
            
                sunPos = lightsPositions[0];
                                
                vec3 texNormal = texture(uNormalMap, vTextureCoord.zw).rgb;
                vec3 normal = normalize((texNormal - 0.5) * 2.0);
                
                float minH = 1200000.0;
                float maxH = minH * 3.0;
                float nightCoef = getLerpValue(minH, maxH, camHeight) * nightTextureCoefficient;
                                
                // if(camHeight > 6000000.0)
                // {
                //     normal = normalize(v_vertex);
                // }
                                            
                vec3 lightDir = normalize(sunPos);
                vec3 viewDir = normalize(cameraPosition - v_vertex);
                                                
                float overGround = 1.0 - step(0.1, v_height);

                float shininess = texture( specularTexture, vGlobalTextureCoord.st ).r * 255.0 * overGround;
                vec3 reflectionDirection = reflect(-lightDir, normal);
                float reflection = max( dot(reflectionDirection, viewDir), 0.0);
                vec3 spec = specular.rgb * pow( reflection, specular.w) * shininess;                
                float diffuseLightWeighting = max(dot(normal, lightDir), 0.0);                
                vec4 nightImageColor = texture( nightTexture, vGlobalTextureCoord.st );
                vec3 night = nightStep * (.18 - diffuseLightWeighting * 3.0) * nightImageColor.rgb * nightCoef;
                night *= overGround * step(0.0, night);                
                vec4 lightWeighting = vec4(ambient + diffuse * diffuseLightWeighting + night, 1.0);
                
                diffuseColor = texture( defaultTexture, vTextureCoord.xy );
                
                if( samplerCount == 0 ) {
                    diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                vec4 src;

                blend(diffuseColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);
                if( samplerCount == 1 ) {                
                    diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);
                if( samplerCount == 2 ) {
                    diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);
                if( samplerCount == 3 ) {
                    diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);
                if( samplerCount == 4 ) {
                    diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);
                diffuseColor = diffuseColor * lightWeighting + vec4(spec, 0.0);
                diffuseColor *= transitionOpacity;
            }`
    });
  }
  function drawnode_screen_wl_webgl2Atmos(atmosParams) {
    return new Program("drawnode_screen_wl", {
      uniforms: {
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        height: "float",
        uGlobalTextureCoord: "vec4",
        uNormalMapBias: "vec3",
        samplerCount: "int",
        tileOffsetArr: "vec4",
        layerOpacityArr: "float",
        samplerArr: "sampler2darray",
        defaultTexture: "sampler2d",
        uNormalMap: "sampler2d",
        nightTexture: "sampler2d",
        specularTexture: "sampler2d",
        lightsPositions: "vec3",
        diffuse: "vec3",
        ambient: "vec3",
        specular: "vec4",
        transmittanceTexture: "sampler2D",
        scatteringTexture: "sampler2D",
        camHeight: "float",
        nightTextureCoefficient: "float",
        maxMinOpacity: "vec2",
        transitionOpacity: "float"
      },
      attributes: {
        aVertexPositionHigh: "vec3",
        aVertexPositionLow: "vec3",
        aTextureCoord: "vec2"
      },
      vertexShader: `#version 300 es

            precision highp float;

            in vec3 aVertexPositionHigh;
            in vec3 aVertexPositionLow;
            in vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec4 uGlobalTextureCoord;
            uniform vec3 uNormalMapBias;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            out vec4 vTextureCoord;
            out vec3 v_vertex;
            out vec3 cameraPosition;
            out vec2 vGlobalTextureCoord;
            out float v_height;

            void main(void) {

                vec3 aVertexPosition = aVertexPositionHigh + aVertexPositionLow;                
                vec3 nh = height * normalize(aVertexPosition);

                vTextureCoord.xy = aTextureCoord;
                vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;
                vTextureCoord.zw = uNormalMapBias.z * ( aTextureCoord + uNormalMapBias.xy );

                cameraPosition = eyePositionHigh + eyePositionLow;
                
                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                v_height = height;
                v_vertex = aVertexPosition + nh;
                            
                gl_Position = projectionMatrix * viewMatrixRTE * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
            }`,
      fragmentShader: `#version 300 es

            precision highp float;
            
            #define MAX_POINT_LIGHTS 1
            #define SLICE_SIZE ${SLICE_SIZE + 1}

            uniform vec4 specular;
            uniform vec3 diffuse;
            uniform vec3 ambient;

            uniform vec3 lightsPositions[MAX_POINT_LIGHTS];

            uniform sampler2D uNormalMap;
            uniform sampler2D nightTexture;
            uniform sampler2D specularTexture;
            uniform sampler2D transmittanceTexture;
            uniform sampler2D scatteringTexture;
            uniform sampler2D defaultTexture;
            uniform sampler2D samplerArr[SLICE_SIZE];

            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform float layerOpacityArr[SLICE_SIZE];

            uniform int samplerCount;
            uniform float nightTextureCoefficient;
            
            uniform vec2 maxMinOpacity;                
            uniform float camHeight;
            
            uniform float transitionOpacity;

            in vec4 vTextureCoord;
            in vec3 v_vertex;
            in vec3 cameraPosition;
            in vec2 vGlobalTextureCoord;
            in float v_height;

            vec3 sunPos;

            layout(location = 0) out vec4 diffuseColor;

            ${NIGHT}

            ${DEF_BLEND}
            
            ${COMMON(atmosParams)}            
            
            vec3 transmittanceFromTexture(float height, float angle) 
            {
                float u = (angle + 1.0) * 0.5;
                float v = height / ATMOS_HEIGHT;
                return texture(transmittanceTexture, vec2(u, v)).xyz;
            }

            vec3 multipleScatteringContributionFromTexture(float height, float angle) 
            {
                float u = (angle + 1.0) * 0.5;
                float v = height / ATMOS_HEIGHT;
                return texture(scatteringTexture, vec2(u, v)).xyz;
            }
            
            void getSunIlluminance(in vec3 point, in vec3 lightDir, out vec3 sunIlluminance)
            {
                //     float r = length(point);
                //     float mu_s = dot(point, sun_direction) / r;
                //     float height = r - BOTTOM_RADIUS;
                
                float mu_s = dot(normalize(point), lightDir);
                float height = length(point) - BOTTOM_RADIUS;
                sunIlluminance = SUN_INTENSITY * transmittanceFromTexture(height, mu_s);
            }
           
            void atmosGroundColor(out vec4 fragColor, in vec3 normal)
            {      
                vec3 cameraPosition = cameraPosition;           
                
                if(length(cameraPosition * SPHERE_TO_ELLIPSOID_SCALE) < BOTTOM_RADIUS + 1.0){
                    cameraPosition = normalize(cameraPosition * SPHERE_TO_ELLIPSOID_SCALE) * (BOTTOM_RADIUS + 1.0) / SPHERE_TO_ELLIPSOID_SCALE;
                }             
                                                                                
                vec3 rayDirection = normalize(v_vertex - cameraPosition);
                vec3 lightDir = normalize(sunPos);
                
                rayDirection = normalize(rayDirection * SPHERE_TO_ELLIPSOID_SCALE);
                vec3 camPos = cameraPosition * SPHERE_TO_ELLIPSOID_SCALE;
                lightDir = normalize(lightDir * SPHERE_TO_ELLIPSOID_SCALE);
               

                vec3 light = vec3(0.0);
                vec3 transmittanceFromCameraToSpace = vec3(1.0);
                float offset = 0.0;
                float distanceToSpace = 0.0;
                
                intersectSphere(camPos, rayDirection, TOP_RADIUS, offset, distanceToSpace);
            
                vec3 rayOrigin = camPos;
                
                // above atmosphere
                if (offset > 0.0) 
                {
                    // intersection of camera ray with atmosphere
                    rayOrigin += rayDirection * offset;
                }
                
                float height = length(rayOrigin) - BOTTOM_RADIUS;
                float rayAngle = dot(rayOrigin, rayDirection) / length(rayOrigin);
                bool cameraBelow = rayAngle < 0.0;
                
                transmittanceFromCameraToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                
                float phaseAngle = dot(lightDir, rayDirection);
                float rayleighPhase = rayleighPhase(phaseAngle);
                float miePhase = miePhase(phaseAngle);
                
                float distanceToGround = 0.0;
                
                bool hitGround = intersectSphere(camPos, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;                
                //intersectSphere(camPos, rayDirection, BOTTOM_RADIUS, distanceToGround);
               

                if(length(v_vertex * SPHERE_TO_ELLIPSOID_SCALE) > BOTTOM_RADIUS){
                    distanceToGround = distance(camPos, v_vertex * SPHERE_TO_ELLIPSOID_SCALE);
                }
                                                                
                float segmentLength = (distanceToGround - max(offset, 0.0)) / float(SAMPLE_COUNT);
                
                float t = segmentLength * 0.5;
                
                vec3 transmittanceCamera; 
                vec3 transmittanceLight; 
                
                for (int i = 0; i < SAMPLE_COUNT; i++) 
                {
                    vec3 position = rayOrigin + t * rayDirection;
                    float height = length(position) - BOTTOM_RADIUS;
                    vec3 up = position / length(position);
                    float rayAngle = dot(up, rayDirection);
                    float lightAngle = dot(up, lightDir);                                                 
                    vec3 transmittanceToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                    transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);
                    transmittanceLight = transmittanceFromTexture(height, lightAngle);
                    vec2 opticalDensity = exp(-height / rayleighMieHeights);
                    vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x * rayleighPhase + mieScatteringCoefficient * opticalDensity.y * miePhase);
                    scatteredLight += multipleScatteringContributionFromTexture(height, lightAngle) * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y);  
                    light += transmittanceCamera * scatteredLight * segmentLength;
                    t += segmentLength;
                }
                
                light *= SUN_INTENSITY;
        
                vec3 hitPoint = camPos + rayDirection * distanceToGround;
                vec3 up = normalize(hitPoint);
                float diffuseAngle = max(dot(up, lightDir), 0.0);                
                                
                float lightAngle = dot(normal, lightDir);
                vec3 tA = transmittanceCamera * GROUND_ALBEDO * SUN_INTENSITY;                                               
                vec3 scatteringLight = multipleScatteringContributionFromTexture(height, lightAngle);
                vec3 diffuseTransmittanceLight = transmittanceLight * diffuseAngle;                
                light += tA * (scatteringLight + diffuseTransmittanceLight);
                                                                
                fragColor = vec4(pow(light * 8.0, vec3(1.0 / 2.2)), 1.0);
            }

            void getAtmosFadingOpacity(out float opacity)
            {            
                float c = length(cameraPosition);
                float maxDist = sqrt(c * c - BOTTOM_RADIUS * BOTTOM_RADIUS);
                float minDist = c - BOTTOM_RADIUS;
                float vertDist = distance(cameraPosition, v_vertex);                    
                opacity = clamp(maxMinOpacity.y + ( maxMinOpacity.x -  maxMinOpacity.y) * getLerpValue(minDist, maxDist, vertDist), 0.0, 1.0);
            }

            void main(void) {
            
                sunPos = lightsPositions[0];
                                
                vec3 texNormal = texture(uNormalMap, vTextureCoord.zw).rgb;
                vec3 normal = normalize((texNormal - 0.5) * 2.0);
                
                float minH = 1200000.0;
                float maxH = minH * 3.0;
                float nightCoef = getLerpValue(minH, maxH, camHeight) * nightTextureCoefficient;
                                
                // if(camHeight > 6000000.0)
                // {
                //    normal = normalize(v_vertex);
                // }
                                            
                vec3 lightDir = normalize(sunPos);
                vec3 viewDir = normalize(cameraPosition - v_vertex);
                
                vec4 atmosColor;
                atmosGroundColor(atmosColor, normal);
                
                vec3 sunIlluminance;                
                getSunIlluminance(v_vertex * SPHERE_TO_ELLIPSOID_SCALE, lightDir * SPHERE_TO_ELLIPSOID_SCALE, sunIlluminance);
                
                float overGround = 1.0 - step(0.1, v_height);

                float shininess = texture( specularTexture, vGlobalTextureCoord.st ).r * 255.0 * overGround;
                vec3 reflectionDirection = reflect(-lightDir, normal);
                float reflection = max( dot(reflectionDirection, viewDir), 0.0);
                vec3 spec = sunIlluminance * specular.rgb * pow( reflection, specular.w) * shininess;                
                float diffuseLightWeighting = max(dot(normal, lightDir), 0.0);
                              
                vec4 nightImageColor = texture( nightTexture, vGlobalTextureCoord.st );
                vec3 night = nightStep * (.18 - diffuseLightWeighting * 3.0) * nightImageColor.rgb * nightCoef;
                night *= overGround * step(0.0, night);                
                vec4 lightWeighting = vec4(ambient + sunIlluminance * diffuse * diffuseLightWeighting + night, 1.0);
                
                float fadingOpacity;
                getAtmosFadingOpacity(fadingOpacity);
                
                getSunIlluminance(cameraPosition, viewDir * SPHERE_TO_ELLIPSOID_SCALE, sunIlluminance);
                
                spec *= sunIlluminance;

                diffuseColor = texture( defaultTexture, vTextureCoord.xy );
                if( samplerCount == 0 ) {
                    diffuseColor = mix(diffuseColor * lightWeighting, atmosColor, fadingOpacity) + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                vec4 src;

                blend(diffuseColor, samplerArr[0], tileOffsetArr[0], layerOpacityArr[0]);
                if( samplerCount == 1 ) {                
                    diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[1], tileOffsetArr[1], layerOpacityArr[1]);
                if( samplerCount == 2 ) {
                    diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[2], tileOffsetArr[2], layerOpacityArr[2]);
                if( samplerCount == 3 ) {
                    diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[3], tileOffsetArr[3], layerOpacityArr[3]);
                if( samplerCount == 4 ) {
                    diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);
                    diffuseColor *= transitionOpacity;
                    return;
                }

                blend(diffuseColor, samplerArr[4], tileOffsetArr[4], layerOpacityArr[4]);
                diffuseColor = mix(diffuseColor * lightWeighting, atmosColor * diffuseColor.a, fadingOpacity) + vec4(spec, 0.0);
                diffuseColor *= transitionOpacity;
            }`
    });
  }
  function drawnode_colorPicking() {
    return new Program("drawnode_colorPicking", {
      uniforms: {
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        samplerCount: "int",
        tileOffsetArr: "vec4",
        samplerArr: "sampler2darray",
        pickingMaskArr: "sampler2darray",
        pickingColorArr: "vec4",
        height: "float"
      },
      attributes: {
        aVertexPositionHigh: "vec3",
        aVertexPositionLow: "vec3",
        aTextureCoord: "vec2"
      },
      vertexShader: `precision highp float;
            
            attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;
            attribute vec2 aTextureCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            varying vec2 vTextureCoord;

            void main(void) {

                vTextureCoord = aTextureCoord;

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                mat4 m = projectionMatrix * viewMatrixRTE;

                vec3 nh = height * normalize(aVertexPositionHigh + aVertexPositionLow);

                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;

                gl_Position = m * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);
            }`,
      fragmentShader: `precision highp float;
            #define SLICE_SIZE ${SLICE_SIZE + 1}
            uniform vec4 tileOffsetArr[SLICE_SIZE];
            uniform vec4 pickingColorArr[SLICE_SIZE];
            uniform sampler2D samplerArr[SLICE_SIZE];
            uniform sampler2D pickingMaskArr[SLICE_SIZE];
            uniform int samplerCount;
            varying vec2 vTextureCoord;

            ${DEF_BLEND_PICKING}

            void main(void) {
                gl_FragColor = vec4(0.0);
                if( samplerCount == 0 ) return;

                vec2 tc;
                vec4 t;
                vec4 p;

                blendPicking(gl_FragColor, tileOffsetArr[0], samplerArr[0], pickingMaskArr[0], pickingColorArr[0], 1.0);
                if( samplerCount == 1 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[1], samplerArr[1], pickingMaskArr[1], pickingColorArr[1], 1.0);
                if( samplerCount == 2 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[2], samplerArr[2], pickingMaskArr[2], pickingColorArr[2], 1.0);
                if( samplerCount == 3 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[3], samplerArr[3], pickingMaskArr[3], pickingColorArr[3], 1.0);
                if( samplerCount == 4 ) return;

                blendPicking(gl_FragColor, tileOffsetArr[4], samplerArr[4], pickingMaskArr[4], pickingColorArr[4], 1.0);
            }`
    });
  }
  function drawnode_heightPicking() {
    return new Program("drawnode_heightPicking", {
      uniforms: {
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        height: "float",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3"
      },
      attributes: {
        aVertexPositionHigh: "vec3",
        aVertexPositionLow: "vec3"
      },
      vertexShader: `precision highp float;

            attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            varying vec3 eyePosition;
            varying vec3 vertexPosition;

            void main(void) {

                // This code is works for Mac Chrome and Safari
                // any other code probably will produce jittering

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                mat4 m = projectionMatrix * viewMatrixRTE;

                vec3 nh = height * normalize(aVertexPositionHigh + aVertexPositionLow);

                eyePosition = eyePositionHigh + eyePositionLow;
                vertexPosition = aVertexPositionHigh + aVertexPositionLow;

                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;
                
                gl_Position =  m * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);         
            }`,
      fragmentShader: `precision highp float;

            varying vec3 eyePosition;
            varying vec3 vertexPosition;

            vec3 encode24(highp float f) {
                float F = abs(f);
                float s = step( 0.0, -f );
                float e = floor( log2(F) );
                float m = exp2(- e) * F;
                e = floor( log2(F) + 127.0 ) + floor( log2(m) );
                return vec3(
                    ( 128.0 * s + floor( e * exp2(-1.0) ) ) / 255.0,
                    ( 128.0 * mod( e, 2.0 ) + mod( floor( m * 128.0 ), 128.0 ) ) / 255.0,
                    floor( mod( floor( m * exp2( 23.0 - 8.0) ), exp2(8.0) ) ) / 255.0);
            }

            void main(void) {
                float range = distance(eyePosition, vertexPosition);
                gl_FragColor = vec4(encode24(range), 1.0);
            }`
    });
  }
  function drawnode_depth() {
    return new Program("drawnode_depth", {
      uniforms: {
        projectionMatrix: "mat4",
        viewMatrix: "mat4",
        height: "float",
        eyePositionHigh: "vec3",
        eyePositionLow: "vec3",
        frustumPickingColor: "vec3"
      },
      attributes: {
        aVertexPositionHigh: "vec3",
        aVertexPositionLow: "vec3"
      },
      vertexShader: `precision highp float;

            attribute vec3 aVertexPositionHigh;
            attribute vec3 aVertexPositionLow;

            uniform mat4 projectionMatrix;
            uniform mat4 viewMatrix;
            uniform vec3 eyePositionHigh;
            uniform vec3 eyePositionLow;
            uniform float height;

            void main(void) {

                // @hack
                // This code is works for Mac Chrome and Safari
                // any other code probably will produce jittering

                mat4 viewMatrixRTE = viewMatrix;
                viewMatrixRTE[3] = vec4(0.0, 0.0, 0.0, 1.0);

                mat4 m = projectionMatrix * viewMatrixRTE;

                vec3 nh = height * normalize(aVertexPositionHigh + aVertexPositionLow);

                vec3 eyePosition = eyePositionHigh + eyePositionLow;
                vec3 vertexPosition = aVertexPositionHigh + aVertexPositionLow;

                vec3 highDiff = aVertexPositionHigh - eyePositionHigh;
                vec3 lowDiff = aVertexPositionLow - eyePositionLow + nh;
                
                gl_Position =  m * vec4(highDiff * step(1.0, length(highDiff)) + lowDiff, 1.0);    
            }`,
      fragmentShader: `precision highp float;
            uniform vec3 frustumPickingColor;

            void main(void) {
                gl_FragColor = vec4(frustumPickingColor, 1.0);
            } `
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/webgl/BaseFramebuffer.js
  var BaseFramebuffer = class {
    constructor(handler, options2 = {}) {
      this.handler = handler;
      this._fbo = null;
      this._width = options2.width || handler.canvas.width;
      this._height = options2.height || handler.canvas.height;
      this._depthComponent = options2.depthComponent != void 0 ? options2.depthComponent : "DEPTH_COMPONENT16";
      this._useDepth = options2.useDepth != void 0 ? options2.useDepth : true;
      this._active = false;
      this._size = options2.size || 1;
      this._depthRenderbuffer = null;
      this._filter = options2.filter || "NEAREST";
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    /**
     * Sets framebuffer viewport size.
     * @public
     * @param {number} width - Framebuffer width.
     * @param {number} height - Framebuffer height.
     * @param {boolean} [forceDestroy] -
     */
    setSize(width, height, forceDestroy = false) {
      this._width = width;
      this._height = height;
      if (this._active) {
        this.handler.gl.viewport(0, 0, this._width, this._height);
      }
      if (this._useDepth || forceDestroy) {
        this.destroy();
        this.init();
      }
    }
    init() {
    }
    destroy() {
    }
    /**
     * Returns framebuffer completed.
     * @public
     * @returns {boolean} -
     */
    isComplete() {
      let gl = this.handler.gl;
      return gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    }
    checkStatus() {
      let gl = this.handler.gl;
      return gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    }
    /**
     * Activate framebuffer frame to draw.
     * @public
     * @returns {Framebuffer} Returns Current framebuffer.
     */
    activate() {
      let gl = this.handler.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
      gl.viewport(0, 0, this._width, this._height);
      this._active = true;
      let c7 = this.handler.framebufferStack.current().data;
      c7 && (c7._active = false);
      this.handler.framebufferStack.push(this);
      return this;
    }
    /**
     * Deactivate framebuffer frame.
     * @public
     */
    deactivate() {
      let h8 = this.handler, gl = h8.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      this._active = false;
      let f8 = this.handler.framebufferStack.popPrev();
      if (f8) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, f8._fbo);
        gl.viewport(0, 0, f8._width, f8._height);
      } else {
        gl.viewport(0, 0, h8.canvas.width, h8.canvas.height);
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/ImageCanvas.js
  var ImageCanvas = class {
    constructor(width = 256, height = 256) {
      this._canvas = document.createElement("canvas");
      this._canvas.width = width;
      this._canvas.height = height;
      this._context = this._canvas.getContext("2d", {
        willReadFrequently: true
      });
    }
    /**
     * Returns canvas object.
     * @public
     * @returns {HTMLCanvasElement}
     */
    getCanvas() {
      return this._canvas;
    }
    /**
     * Returns canvas context pointer.
     * @public
     * @returns {CanvasRenderingContext2D}
     */
    getContext() {
      return this._context;
    }
    /**
     * Fills canvas RGBA with zeroes.
     * @public
     */
    fillEmpty() {
      let imgd = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
      let pixels = imgd.data;
      for (let i9 = 0, n7 = pixels.length; i9 < n7; i9 += 4) {
        pixels[i9] = pixels[i9 + 1] = pixels[i9 + 2] = pixels[i9 + 3] = 0;
      }
      this._context.putImageData(imgd, 0, 0);
    }
    /**
     * Fills canvas RGBA with color.
     * @public
     * @param {string} color - CSS string color.
     */
    fill(color) {
      this._context.fillStyle = color;
      this._context.fill();
    }
    /**
     * Gets canvas pixels RGBA data.
     * @public
     * @returns {Uint8ClampedArray}
     */
    getData() {
      let imgd = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
      return imgd.data;
    }
    /**
     * Fill the canvas by color.
     * @public
     * @param {string} color - CSS string color.
     */
    fillColor(color) {
      this._context.fillStyle = color;
      this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
    }
    /**
     * Sets RGBA pixel data.
     * @public
     * @param {Array.<number>} data - Array RGBA data.
     */
    setData(data) {
      let imageData = this._context.createImageData(this._canvas.width, this._canvas.height);
      imageData.data.set(data);
      this._context.putImageData(imageData, 0, 0);
    }
    /**
     * Resize canvas.
     * @public
     * @param {number} width - Width.
     * @param {number} height - Height.
     */
    resize(width, height) {
      this._canvas.width = width;
      this._canvas.height = height;
      this._context = this._canvas.getContext("2d");
    }
    /**
     * Draw an image on the canvas.
     * @public
     * @param {Image} img - Draw image.
     * @param {number} [x] - Left top image corner X coordinate on the canvas.
     * @param {number} [y] - Left top image corner Y coordinate on the canvas.
     * @param {number} [width] - Image width slice. Image width is default.
     * @param {number} [height] - Image height slice. Image height is default.
     */
    drawImage(img, x3, y4, width, height) {
      this._context.drawImage(img, x3 || 0, y4 || 0, width || img.width, height || img.height);
    }
    /**
     * Converts canvas to JS image object.
     * @public
     * @returns {Image}
     */
    getImage() {
      let img = new Image();
      img.width = this.getWidth();
      img.height = this.getHeight();
      img.src = this._canvas.toDataURL("image/png");
      return img;
    }
    /**
     * Get measured text width.
     * @public
     * @param {string} text - Measured text.
     * @returns {number}
     */
    getTextWidth(text) {
      let metrics = this._context.measureText(text);
      return Math.round(metrics.width);
    }
    /**
     * Draw a text on the canvas.
     * @public
     * @param {string} text - Text.
     * @param {number} [x] - Canvas X - coordinate. 0 - default.
     * @param {number} [y] - Canvas Y - coordinate. 0 - default.
     * @param {string} [font] - Font style. 'normal 14px Verdana' - is default.
     * @param {string} [color] - Css font color.
     */
    drawText(text, x3 = 0, y4 = 14, font = "normal 14px Verdana", color = "black") {
      this._context.fillStyle = color;
      this._context.font = font;
      this._context.fillText(text, x3, y4);
    }
    /**
     * Gets canvas width.
     * @public
     * @returns {number}
     */
    getWidth() {
      return this._canvas.width;
    }
    /**
     * Gets canvas height.
     * @public
     * @returns {number}
     */
    getHeight() {
      return this._canvas.height;
    }
    /**
     * Load image to canvas.
     * @public
     * @param {string} url - Image url.
     * @param {Function} [callback] - Image onload callback.
     */
    load(url, callback) {
      let img = new Image();
      let that = this;
      img.onload = function() {
        that.resize(img.width, img.height);
        that._context.drawImage(img, 0, 0, img.width, img.height);
        callback && callback(img);
      };
      img.src = url;
    }
    /**
     * Open canvas image in the new window.
     * @public
     */
    openImage() {
      let img = this.getImage();
      let dataUrl = img.src;
      let windowContent = "<!DOCTYPE html>";
      windowContent += "<html>";
      windowContent += "<head><title>Print</title></head>";
      windowContent += "<body>";
      windowContent += '<img src="' + dataUrl + '">';
      windowContent += "</body>";
      windowContent += "</html>";
      let printWin = window.open("", "", "width=" + img.width + "px ,height=" + img.height + "px");
      if (printWin) {
        printWin.document.open();
        printWin.document.write(windowContent);
        printWin.document.close();
        printWin.focus();
      }
    }
    destroy() {
      this._canvas.width = 1;
      this._canvas.height = 1;
      this._canvas = null;
      this._context = null;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/webgl/Framebuffer.js
  var Framebuffer = class extends BaseFramebuffer {
    constructor(handler, options2 = {}) {
      super(handler, options2);
      this._isBare = options2.isBare || false;
      this._internalFormatArr = options2.internalFormat instanceof Array ? options2.internalFormat : [options2.internalFormat || "RGBA"];
      this._formatArr = options2.format instanceof Array ? options2.format : [options2.format || "RGBA"];
      this._typeArr = options2.type instanceof Array ? options2.type : [options2.type || "UNSIGNED_BYTE"];
      if (options2.attachment instanceof Array) {
        this._attachmentArr = options2.attachment.map((a6, i9) => {
          let res = a6.toUpperCase();
          if (res === "COLOR_ATTACHMENT") {
            return `${res}${i9.toString()}`;
          }
          return res;
        });
      } else {
        this._attachmentArr = [options2.attachment || "COLOR_ATTACHMENT0"];
      }
      this._renderbufferTarget = options2.renderbufferTarget != void 0 ? options2.renderbufferTarget : "DEPTH_ATTACHMENT";
      this.textures = options2.textures || new Array(this._size);
    }
    // static blit(sourceFramebuffer: Framebuffer, destFramebuffer: Framebuffer, glAttachment: number, glMask: number, glFilter: number) {
    //     let gl = sourceFramebuffer.handler.gl!;
    //
    //     gl.bindFramebuffer(gl.READ_FRAMEBUFFER, sourceFramebuffer._fbo);
    //     gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, destFramebuffer._fbo);
    //     gl.readBuffer(glAttachment);
    //
    //     gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
    //
    //     gl.blitFramebuffer(0, 0, sourceFramebuffer._width, sourceFramebuffer._height, 0, 0, destFramebuffer._width, destFramebuffer._height, glMask, glFilter);
    //
    //     gl.bindFramebuffer(gl.FRAMEBUFFER, null!);
    //     gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null!);
    //     gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null!);
    // }
    destroy() {
      let gl = this.handler.gl;
      if (!gl)
        return;
      for (let i9 = 0; i9 < this.textures.length; i9++) {
        gl.deleteTexture(this.textures[i9]);
      }
      this.textures = new Array(this._size);
      gl.deleteFramebuffer(this._fbo);
      gl.deleteRenderbuffer(this._depthRenderbuffer);
      this._depthRenderbuffer = null;
      this._fbo = null;
      this._active = false;
    }
    /**
     * Framebuffer initialization.
     * @public
     * @override
     */
    init() {
      let gl = this.handler.gl;
      if (!gl)
        return;
      this._fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
      if (!this._isBare) {
        let attachmentArr = [];
        for (let i9 = 0; i9 < this.textures.length; i9++) {
          let ti = this.textures[i9] || this.handler.createEmptyTexture2DExt(this._width, this._height, this._filter, this._internalFormatArr[i9], this._formatArr[i9], this._typeArr[i9]);
          let att_i = gl[this._attachmentArr[i9]];
          if (ti) {
            this.bindOutputTexture(ti, att_i);
            this.textures[i9] = ti;
          }
          if (this._attachmentArr[i9] != "DEPTH_ATTACHMENT") {
            attachmentArr.push(att_i);
          }
        }
        gl.drawBuffers && gl.drawBuffers(attachmentArr);
      }
      if (this._useDepth) {
        this._depthRenderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderbuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl[this._depthComponent], this._width, this._height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl[this._renderbufferTarget], gl.RENDERBUFFER, this._depthRenderbuffer);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Bind buffer texture.
     * @public
     * @param {WebGLTexture} texture - Output texture.
     * @param {number} [glAttachment=0] - color attachment index.
     */
    bindOutputTexture(texture, glAttachment) {
      let gl = this.handler.gl;
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment || gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Gets pixel RGBA color from framebuffer by coordinates.
     * @public
     * @param {Uint8Array} res - Normalized x - coordinate.
     * @param {number} nx - Normalized x - coordinate.
     * @param {number} ny - Normalized y - coordinate.
     * @param {number} [w=1] - Normalized width.
     * @param {number} [h=1] - Normalized height.
     * @param {number} [index=0] - color attachment index.
     */
    readPixels(res, nx, ny, index = 0, w3 = 1, h8 = 1) {
      let gl = this.handler.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
      gl.readBuffer && gl.readBuffer(gl.COLOR_ATTACHMENT0 + index || 0);
      gl.readPixels(nx * this._width, ny * this._height, w3, h8, gl.RGBA, gl[this._typeArr[index]], res);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Reads all pixels(RGBA colors) from framebuffer.
     * @public
     * @param {Uint8Array} res - Result array.
     * @param {number} [attachmentIndex=0] - color attachment index.
     */
    readAllPixels(res, attachmentIndex = 0) {
      let gl = this.handler.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
      gl.readBuffer && gl.readBuffer(gl.COLOR_ATTACHMENT0 + attachmentIndex);
      gl.readPixels(0, 0, this._width, this._height, gl.RGBA, gl[this._typeArr[attachmentIndex]], res);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Gets JavaScript image that in the framebuffer.
     * @public
     * @returns {HTMLImageElement} -
     */
    getImage() {
      let data = new Uint8Array(4 * this._width * this._height);
      this.readAllPixels(data);
      let imageCanvas = new ImageCanvas(this._width, this._height);
      imageCanvas.setData(data);
      return imageCanvas.getImage();
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/control/Atmosphere.js
  var Atmosphere = class extends Control {
    constructor(options2 = {}) {
      super({
        name: "Atmosphere",
        ...options2
      });
      this._transmittanceBuffer = null;
      this._scatteringBuffer = null;
      this.opacity = 1;
      this._parameters = {
        ATMOS_HEIGHT: options2.height || 1e5,
        RAYLEIGH_SCALE: options2.rayleighScale || 0.08,
        MIE_SCALE: options2.mieScale || 0.012,
        GROUND_ALBEDO: options2.groundAlbedo || 0.05,
        BOTTOM_RADIUS: options2.bottomRadius || 6356752314245179e-9,
        rayleighScatteringCoefficient: options2.rayleighScatteringCoefficient || [5.802, 13.558, 33.1],
        mieScatteringCoefficient: options2.mieScatteringCoefficient || 3.996,
        mieExtinctionCoefficient: options2.mieExtinctionCoefficient || 4.44,
        ozoneAbsorptionCoefficient: options2.ozoneAbsorptionCoefficient || [0.65, 1.881, 0.085],
        SUN_ANGULAR_RADIUS: options2.sunAngularRadius || 4685e-6,
        SUN_INTENSITY: options2.sunIntensity || 1,
        ozoneDensityHeight: options2.ozoneDensityHeight || 25e3,
        ozoneDensityWide: options2.ozoneDensityWide || 15e3
      };
    }
    setParameters(parameters) {
      this._parameters = JSON.parse(JSON.stringify(parameters));
      this.initLookupTexturesShaders();
      this.drawLookupTextures();
      this.removeLookupTexturesShaders();
      this.initPlanetAtmosphereShader();
    }
    get parameters() {
      return JSON.parse(JSON.stringify(this._parameters));
    }
    initPlanetAtmosphereShader() {
      this.planet?.initAtmosphereShader(this._parameters);
    }
    oninit() {
      if (this.renderer) {
        this._initLookupTextures();
        this.initLookupTexturesShaders();
        this.drawLookupTextures();
        this.removeLookupTexturesShaders();
        this.initBackgroundShader();
        this.activate();
      }
    }
    initLookupTexturesShaders() {
      if (this.renderer) {
        this.renderer.handler.addProgram(transmittance(this._parameters), true);
        this.renderer.handler.addProgram(scattering(this._parameters), true);
      }
    }
    initBackgroundShader() {
      if (this.renderer) {
        this.renderer.handler.addProgram(atmosphereBackgroundShader(this._parameters), true);
      }
    }
    removeBackgroundShader() {
      if (this.renderer) {
        this.renderer.handler.removeProgram("atmosphereBackground");
      }
    }
    removeLookupTexturesShaders() {
      if (this.renderer) {
        let h8 = this.renderer.handler;
        if (this._scatteringBuffer?.isComplete()) {
          h8.removeProgram("scattering");
        }
        if (this._transmittanceBuffer?.isComplete()) {
          h8.removeProgram("transmittance");
        }
      }
    }
    onactivate() {
      super.onactivate();
      this.planet && this.planet.events.on("draw", this._drawBackground, this);
    }
    ondeactivate() {
      super.ondeactivate();
      this.planet && this.planet.events.off("draw", this._drawBackground);
    }
    _initLookupTextures() {
      let width = 1024, height = 1024;
      this._transmittanceBuffer = new Framebuffer(this.renderer.handler, {
        width,
        height,
        useDepth: false,
        filter: "LINEAR",
        type: "FLOAT",
        internalFormat: "RGBA16F"
      });
      this._transmittanceBuffer.init();
      this._scatteringBuffer = new Framebuffer(this.renderer.handler, {
        width,
        height,
        useDepth: false,
        filter: "LINEAR",
        type: "FLOAT",
        internalFormat: "RGBA16F"
      });
      this._scatteringBuffer.init();
    }
    _renderLookupTextures() {
      if (!this.renderer)
        return;
      let positionBuffer = this.renderer.screenFramePositionBuffer;
      let h8 = this.renderer.handler;
      let gl = h8.gl;
      if (this._transmittanceBuffer) {
        this._transmittanceBuffer.activate();
        let p4 = h8.programs.transmittance;
        let sha = p4._program.attributes;
        let shu = p4._program.uniforms;
        p4.activate();
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.uniform2fv(shu.iResolution, [this._transmittanceBuffer.width, this._transmittanceBuffer.height]);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(sha.a_position, positionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, positionBuffer.numItems);
        this._transmittanceBuffer.deactivate();
      }
      if (this._scatteringBuffer && this._transmittanceBuffer) {
        this._scatteringBuffer.activate();
        let p4 = h8.programs.scattering;
        let sha = p4._program.attributes;
        let shu = p4._program.uniforms;
        p4.activate();
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.uniform2fv(shu.iResolution, [this._scatteringBuffer.width, this._scatteringBuffer.height]);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._transmittanceBuffer.textures[0]);
        gl.uniform1i(shu.transmittanceTexture, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(sha.a_position, positionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, positionBuffer.numItems);
        this._scatteringBuffer.deactivate();
      }
    }
    drawLookupTextures() {
      this._renderLookupTextures();
    }
    _drawBackground() {
      let h8 = this.renderer.handler;
      let sh = h8.programs.atmosphereBackground, p4 = sh._program, shu = p4.uniforms, gl = h8.gl;
      let r8 = this.renderer;
      let cam = this.planet.camera;
      gl.disable(gl.DEPTH_TEST);
      sh.activate();
      gl.bindBuffer(gl.ARRAY_BUFFER, r8.screenFramePositionBuffer);
      gl.vertexAttribPointer(p4.attributes.corners, 2, gl.FLOAT, false, 0, 0);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this._transmittanceBuffer.textures[0]);
      gl.uniform1i(shu.transmittanceTexture, 0);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, this._scatteringBuffer.textures[0]);
      gl.uniform1i(shu.scatteringTexture, 1);
      gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
      let sunPos = this.planet.sunPos;
      gl.uniform3fv(shu.sunPos, [sunPos.x, sunPos.y, sunPos.z]);
      gl.uniform3fv(shu.camPos, [cam.eye.x, cam.eye.y, cam.eye.z]);
      gl.uniform2fv(shu.iResolution, [r8.sceneFramebuffer.width, r8.sceneFramebuffer.height]);
      gl.uniform1f(shu.fov, cam.getViewAngle());
      gl.uniform1f(shu.opacity, this.opacity);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.enable(gl.DEPTH_TEST);
    }
  };
  function atmosphereBackgroundShader(atmosParams) {
    return new Program("atmosphereBackground", {
      uniforms: {
        iResolution: "vec2",
        fov: "float",
        camPos: "vec3",
        viewMatrix: "mat4",
        transmittanceTexture: "sampler2D",
        scatteringTexture: "sampler2D",
        sunPos: "vec3",
        opacity: "float"
      },
      attributes: {
        corners: "vec3"
      },
      vertexShader: `            
            attribute vec2 corners;
            
            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
            }`,
      fragmentShader: `                                   
            precision lowp float;
            
            ${COMMON(atmosParams)}
            
            uniform mat4 viewMatrix;
            uniform vec3 sunPos;
            uniform vec3 camPos;     
            uniform vec2 iResolution;
            uniform float fov;
            uniform float opacity;
                       
            uniform sampler2D transmittanceTexture;
            uniform sampler2D scatteringTexture;
                                                           
            vec3 transmittanceFromTexture(float height, float angle) 
            {
                float u = (angle + 1.0) * 0.5;
                float v = height / ATMOS_HEIGHT;
                return texture2D(transmittanceTexture, vec2(u, v)).xyz;
            }
            
            vec3 multipleScatteringContributionFromTexture(float height, float angle) 
            {
                float u = (angle + 1.0) * 0.5;
                float v = height / ATMOS_HEIGHT;
                return texture2D(scatteringTexture, vec2(u, v)).xyz; 
            }

            bool intersectEllipsoidToSphere(in vec3 ro, in vec3 rd, in vec3 ellRadii, in float sphereRadius, out float t1, out float t2) 
            {
                float offset = 0.0,
                      distanceToSpace = 0.0;
                                                        
                if(intersectEllipsoid(ro, rd, ellRadii, offset, distanceToSpace)){
                    vec3 hitEll = ro + rd * offset;
                    vec3 nEll = normalEllipsoid(hitEll, ellRadii);
                    float t = 0.0;
                    bool intersectsSphere = intersectSphere(hitEll, nEll, sphereRadius, t);
                    vec3 hitSphere = hitEll + nEll * t;
                    t1 = length(hitSphere - ro);
                    
                    hitEll = ro + rd * distanceToSpace;
                    nEll = normalEllipsoid(hitEll, ellRadii);
                    t = 0.0;
                    intersectsSphere = intersectSphere(hitEll, nEll, sphereRadius, t);
                    hitSphere = hitEll + nEll * t;
                    t2 = length(hitSphere - ro);
                    
                    return true; 
                }
                return false; 
            }
            
            mat4 transpose(in mat4 m) 
            {
                vec4 i0 = m[0];
                vec4 i1 = m[1];
                vec4 i2 = m[2];
                vec4 i3 = m[3];
            
                mat4 outMatrix = mat4(
                     vec4(i0.x, i1.x, i2.x, i3.x),
                     vec4(i0.y, i1.y, i2.y, i3.y),
                     vec4(i0.z, i1.z, i2.z, i3.z),
                     vec4(i0.w, i1.w, i2.w, i3.w)
                     );
                                 
                return outMatrix;
            }
                                                                     
            void mainImage(out vec4 fragColor) 
            {            
                vec3 cameraPosition = camPos;
                
                vec3 lightDirection = normalize(sunPos);               
                             
                vec2 uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;
                float fieldOfView = fov;
                float z = 1.0 / tan(fieldOfView * 0.5 * PI / 180.0);
                vec3 rayDirection = normalize(vec3(uv, -z));
                vec4 rd = transpose(viewMatrix) * vec4(rayDirection, 1.0);
                rayDirection = rd.xyz;               
                                          
                vec3 light = vec3(0.0);
                vec3 transmittanceFromCameraToSpace = vec3(1.0);
                float offset = 0.0;
                float distanceToSpace = 0.0;
                                                
                rayDirection = normalize(rayDirection * SPHERE_TO_ELLIPSOID_SCALE);
                cameraPosition *= SPHERE_TO_ELLIPSOID_SCALE;
                lightDirection = normalize(lightDirection * SPHERE_TO_ELLIPSOID_SCALE);
                
                if(length(cameraPosition) < BOTTOM_RADIUS + 100.0){
                    cameraPosition = normalize(cameraPosition) * (BOTTOM_RADIUS + 100.0); 
                }
                                                
                if (intersectSphere(cameraPosition, rayDirection, TOP_RADIUS, offset, distanceToSpace)) 
                {    
                    vec3 rayOrigin = cameraPosition;
                    
                    // above atmosphere                    
                    if (offset > 0.0) {
                        // intersection of camera ray with atmosphere
                        rayOrigin = cameraPosition + rayDirection * offset;
                    }                   
                    
                    float height = length(rayOrigin) - BOTTOM_RADIUS;
                    float rayAngle = dot(rayOrigin, rayDirection) / length(rayOrigin);
                    bool cameraBelow = rayAngle < 0.0;
                    
                    transmittanceFromCameraToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                    
                    float phaseAngle = dot(lightDirection, rayDirection);
                    float rayleighPhase = rayleighPhase(phaseAngle);
                    float miePhase = miePhase(phaseAngle);
                    
                    float distanceToGround = 0.0;
                    
                    bool hitGround = intersectSphere(cameraPosition, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;
                    
                    if(intersectSphere(cameraPosition, rayDirection, BOTTOM_RADIUS - 100000.0, distanceToGround) && hitGround)
                    {
                        discard;
                    }
                    
                    float segmentLength = ((hitGround ? distanceToGround : distanceToSpace) - max(offset, 0.0)) / float(SAMPLE_COUNT);
                                                                    
                    float t = segmentLength * 0.5;
                    
                    vec3 transmittanceCamera; 
                    vec3 transmittanceLight; 
            
                    for (int i = 0; i < SAMPLE_COUNT; i++) 
                    {
                        vec3 position = rayOrigin + t * rayDirection;
                        float height = length(position) - BOTTOM_RADIUS; 
                        vec3 up = position / length(position);
                        float rayAngle = dot(up, rayDirection);
                        float lightAngle = dot(up, lightDirection);
                        vec3 transmittanceToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);
                        transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);
                        transmittanceLight = transmittanceFromTexture(height, lightAngle);
                        vec2 opticalDensity = exp(-height / rayleighMieHeights);
                        vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x * rayleighPhase + mieScatteringCoefficient * opticalDensity.y * miePhase);
                        scatteredLight += multipleScatteringContributionFromTexture(height, lightAngle) * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y);  
                        light += transmittanceCamera * scatteredLight * segmentLength;
                        t += segmentLength;
                    }
                    
                    light *= SUN_INTENSITY;
            
                    if (hitGround) 
                    {
                        vec3 hitPoint = cameraPosition + rayDirection * distanceToGround;
                        vec3 up = hitPoint / length(hitPoint);
                        float diffuseAngle = max(dot(up, lightDirection), 0.0);
                        float lightAngle = dot(up, lightDirection);
                        light += transmittanceCamera * GROUND_ALBEDO * multipleScatteringContributionFromTexture(height, lightAngle) * SUN_INTENSITY;
                        light += transmittanceCamera * transmittanceLight * GROUND_ALBEDO * diffuseAngle * SUN_INTENSITY;
                    }
                }
                                     
                // sun disk
                // float distanceToGround;
                // bool hitGround = intersectSphere(cameraPosition, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;
                // if (!hitGround) {
                //    float angle = dot(rayDirection, lightDirection);
                //    if (angle > cos(SUN_ANGULAR_RADIUS)) {
                //       light = SUN_INTENSITY * transmittanceFromCameraToSpace;
                //    }
                // }
                
                float distanceToGround = 0.0;
                bool hitGround = intersectSphere(cameraPosition, rayDirection, BOTTOM_RADIUS, distanceToGround) && distanceToGround > 0.0;
                if(!hitGround)
                {
                    vec3 sunLum = sunWithBloom(rayDirection, lightDirection) * vec3(1.0,1.0,0.8);
                    // limit the bloom effect
                    sunLum = smoothstep(0.002, 1.0, sunLum);
                    light += sunLum * SUN_INTENSITY * transmittanceFromCameraToSpace;
                }
                            
                fragColor = vec4(pow(light * 8.0, vec3(1.0 / 2.2)), clamp(opacity, 0.0, 1.0));           
            }
                                    
            void main(void) 
            {                            
                mainImage(gl_FragColor);            
            }`
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/proj/Proj.js
  var Units = {
    DEGREES: "degrees",
    FEET: "ft",
    METERS: "m",
    KILOMETERS: "km"
  };
  var METERS_PER_UNIT = {};
  METERS_PER_UNIT[Units.FEET] = 0.3048;
  METERS_PER_UNIT[Units.METERS] = 1;
  METERS_PER_UNIT[Units.KILOMETERS] = 1e3;
  var _counter = 0;
  var Proj = class {
    constructor(options2) {
      this.id = _counter++;
      this.code = options2.code;
      this.units = options2.units;
    }
    /**
     * Compare projections.
     * @public
     * @param {Proj} proj - Projection object.
     * @returns {boolean}
     */
    equal(proj) {
      return proj.id === this.id;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/proj/EPSG3857.js
  var EPSG3857 = new Proj({ code: "epsg:3857", units: Units.METERS });

  // frontend/node_modules/@openglobus/og/lib/js/proj/EPSG4326.js
  var EPSG4326 = new Proj({ code: "epsg:4326", units: Units.DEGREES });

  // frontend/node_modules/@openglobus/og/lib/js/segment/Slice.js
  var Slice = class {
    constructor(segment) {
      this.segment = segment;
      this.layers = [];
      this.tileOffsetArr = new Float32Array(segment.planet.SLICE_SIZE_4);
      this.layerOpacityArr = new Float32Array(segment.planet.SLICE_SIZE);
    }
    clear() {
      this.layers = null;
      this.tileOffsetArr = null;
      this.layerOpacityArr = null;
    }
    append(layer, material) {
      let n7 = this.layers.length;
      this.layers.push(layer);
      this.layerOpacityArr[n7] = layer.screenOpacity;
      let n42 = n7 * 4;
      let arr = layer.applyMaterial(material);
      this.tileOffsetArr[n42] = arr[0];
      this.tileOffsetArr[n42 + 1] = arr[1];
      this.tileOffsetArr[n42 + 2] = arr[2];
      this.tileOffsetArr[n42 + 3] = arr[3];
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/segment/Segment.js
  function getTileCellIndex(coordinate, tileSize, worldEdge) {
    return Math.floor(Math.abs(worldEdge - coordinate) / tileSize);
  }
  function getTileCellExtent(x3, y4, z3, worldExtent) {
    let pz = 1 / (1 << z3);
    let worldWidth = worldExtent.getWidth(), worldHeight = worldExtent.getHeight();
    let w3 = worldWidth * pz, h8 = worldHeight * pz;
    let sw_lon = worldExtent.southWest.lon + x3 * w3, ne_lat = worldExtent.northEast.lat - y4 * h8;
    return new Extent(new LonLat(sw_lon, ne_lat - h8), new LonLat(sw_lon + w3, ne_lat));
  }
  var TILEGROUP_COMMON = 0;
  var TILEGROUP_NORTH = 20;
  var TILEGROUP_SOUTH = 300;
  function getTileGroupByLat(lat, maxLat = MAX_LAT) {
    if (lat > maxLat) {
      return TILEGROUP_NORTH;
    } else if (lat < -maxLat) {
      return TILEGROUP_SOUTH;
    }
    return TILEGROUP_COMMON;
  }
  var _tempHigh2 = new Vec3();
  var _tempLow2 = new Vec3();
  var _v0 = new Vec3();
  var _v1 = new Vec3();
  var _v2 = new Vec3();
  var _v3 = new Vec3();
  var _ray = new Ray();
  var _rayEx = new Ray();
  var _S = new Array(4);
  _S[N] = 0;
  _S[E] = 1;
  _S[S] = 1;
  _S[W2] = 0;
  var _V = new Array(4);
  _V[N] = false;
  _V[E] = true;
  _V[S] = false;
  _V[W2] = true;
  var Segment = class {
    constructor(node, planet, tileZoom, extent) {
      this.isPole = false;
      this._tileGroup = TILEGROUP_COMMON;
      this._projection = EPSG3857;
      this.node = node;
      this.planet = planet;
      this.handler = planet.renderer.handler;
      this.bsphere = new Sphere();
      this._plainRadius = 0;
      this.bbox = new Box();
      this._sw = new Vec3();
      this._nw = new Vec3();
      this._se = new Vec3();
      this._ne = new Vec3();
      this.centerNormal = new Vec3();
      this._extent = this._extentMerc = extent;
      this._extentLonLat = new Extent();
      this.gridSize = planet.terrain.gridSizeByZoom[tileZoom];
      this.fileGridSize = 0;
      this.tileZoom = tileZoom;
      this.powTileZoom = 1 << tileZoom;
      this.tileX = 0;
      this.tileXE = 0;
      this.tileXW = 0;
      this.tileYN = 0;
      this.tileYS = 0;
      this.tileY = 0;
      this.tileIndex = "";
      this.elevationData = null;
      this._assignTileIndexes();
      this.materials = [];
      this.plainReady = false;
      this.initialized = false;
      this.normalMapReady = false;
      this.terrainReady = false;
      this.terrainIsLoading = false;
      this.terrainExists = false;
      this.passReady = false;
      this.plainVertices = null;
      this.plainVerticesHigh = null;
      this.plainVerticesLow = null;
      this.plainNormals = null;
      this.terrainVertices = null;
      this.terrainVerticesHigh = null;
      this.terrainVerticesLow = null;
      this.noDataVertices = null;
      this.tempVertices = null;
      this.tempVerticesHigh = null;
      this.tempVerticesLow = null;
      this.normalMapTexture = null;
      this.normalMapTextureBias = new Float32Array(3);
      this.normalMapVertices = null;
      this.normalMapVerticesHigh = null;
      this.normalMapVerticesLow = null;
      this.normalMapNormals = null;
      this.vertexNormalBuffer = null;
      this.vertexPositionBuffer = null;
      this.vertexPositionBufferHigh = null;
      this.vertexPositionBufferLow = null;
      this.vertexTextureCoordBuffer = null;
      this._globalTextureCoordinates = new Float32Array(4);
      this._inTheQueue = false;
      this._appliedNeighborsZoom = [0, 0, 0, 0];
      this._slices = [];
      this._indexBuffer = null;
      this.readyToEngage = false;
      this.plainProcessing = false;
      this.normalMapTexturePtr = null;
      this._transitionOpacity = 1;
      this._transitionTimestamp = 0;
    }
    checkZoom() {
      return this.tileZoom < this.planet.terrain._maxNodeZoom;
    }
    /**
     * Returns entity terrain point.
     * @public
     * @param {Entity} entity - Entity.
     * @param {Vec3} res - Point coordinates.
     * @returns {Vec3} -
     */
    getEntityTerrainPoint(entity, res) {
      return this.getTerrainPoint(entity._cartesian, this.getInsideLonLat(entity), res);
    }
    getInsideLonLat(obj) {
      return obj._lonLatMerc;
    }
    isEntityInside(entity) {
      return this._extentLonLat.isInside(entity._lonLat);
    }
    /**
     * Returns distance from object to terrain coordinates and terrain point that calculates out in the res parameter.
     * @public
     * @param {Vec3} xyz - Cartesian object position.
     * @param {LonLat} insideSegmentPosition - Geodetic object position.
     * @param {Vec3} [res] - Result cartesian coordinates on the terrain.
     * @returns {number} -
     */
    getTerrainPoint(xyz, insideSegmentPosition, res) {
      let verts = this.tempVertices;
      if (verts && verts.length) {
        let norm = this.planet.ellipsoid.getSurfaceNormal3v(xyz);
        _ray.set(xyz, norm.negateTo());
        let ne = this._extent.northEast, sw = this._extent.southWest, size = Math.sqrt(verts.length / 3) - 1;
        let xmax = ne.lon, ymax = ne.lat, xmin = sw.lon, ymin = sw.lat, x3 = insideSegmentPosition.lon, y4 = insideSegmentPosition.lat;
        let sxn = xmax - xmin, syn = ymax - ymin;
        let qx = sxn / size, qy = syn / size;
        let xn = x3 - xmin, yn = y4 - ymin;
        let indX = Math.floor(xn / qx), indY = Math.floor(size - yn / qy);
        let ind_v0 = ((size + 1) * indY + indX) * 3;
        let ind_v2 = ((size + 1) * (indY + 1) + indX) * 3;
        _v0.set(verts[ind_v0], verts[ind_v0 + 1], verts[ind_v0 + 2]);
        _v1.set(verts[ind_v0 + 3], verts[ind_v0 + 4], verts[ind_v0 + 5]);
        _v2.set(verts[ind_v2], verts[ind_v2 + 1], verts[ind_v2 + 2]);
        let d4 = _ray.hitTriangle(_v0, _v1, _v2, res);
        if (d4 === Ray.INSIDE) {
          return xyz.distance(res);
        } else if (d4 === Ray.AWAY) {
          _rayEx.set(xyz, norm);
          let d5 = _rayEx.hitTriangle(_v0, _v1, _v2, res);
          if (d5 === Ray.INSIDE) {
            return -xyz.distance(res);
          }
        }
        _v3.set(verts[ind_v2 + 3], verts[ind_v2 + 4], verts[ind_v2 + 5]);
        d4 = _ray.hitTriangle(_v1, _v3, _v2, res);
        if (d4 === Ray.INSIDE) {
          return xyz.distance(res);
        } else if (d4 === Ray.AWAY) {
          _rayEx.set(xyz, norm);
          let d5 = _rayEx.hitTriangle(_v1, _v3, _v2, res);
          if (d5 === Ray.INSIDE) {
            return -xyz.distance(res);
          }
        }
        if (d4 === Ray.AWAY) {
          return -xyz.distance(res);
        }
        return xyz.distance(res);
      } else {
        return xyz.distance(this.planet.ellipsoid.hitRay(_ray.origin, _ray.direction));
      }
    }
    /**
     * Project wgs86 to segment native projection.
     * @public
     * @param {LonLat} lonlat - Coordinates to project.
     * @returns {LonLat} -
     */
    projectNative(lonlat) {
      return lonlat.forwardMercator();
    }
    loadTerrain(forceLoading = false) {
      if (this.tileZoom < this.planet.terrain.minZoom || this.planet.terrain.isEmpty) {
        this.terrainIsLoading = true;
        this.elevationsNotExists();
        if (!this._inTheQueue) {
          this.planet._normalMapCreator.queue(this);
        }
      } else {
        if (this.tileZoom > this.planet.terrain.maxZoom) {
          this.elevationsNotExists();
        } else if (!this.terrainIsLoading && !this.terrainReady) {
          this.planet.terrain.loadTerrain(this, forceLoading);
        }
      }
    }
    /**
     * Terrain obtained from server.
     * @param {Float32Array} elevations - Elevation data.
     */
    elevationsExists(elevations) {
      if (this.plainReady && this.terrainIsLoading) {
        let _elevations = new Float32Array(elevations.length);
        _elevations.set(elevations);
        this.elevationData = new Float32Array(elevations.length);
        this.elevationData.set(elevations);
        this.planet._terrainWorker.make({ segment: this, elevations: _elevations });
        this.plainVerticesHigh = null;
        this.plainVerticesLow = null;
        this.normalMapVerticesHigh = null;
        this.normalMapVerticesLow = null;
        if (!this.planet.terrain.equalizeVertices) {
          this.tempVerticesHigh = null;
          this.tempVerticesLow = null;
        }
      }
    }
    /**
     * Keep plain elevation segment for rendering
     *
     * 'this.tileZoom <= this.planet.terrain.maxZoom' it means, that the segment is plain
     *
     */
    elevationsNotExists() {
      if (this.planet && this.tileZoom <= this.planet.terrain.maxNativeZoom) {
        if (this.plainReady && this.terrainIsLoading) {
          this.terrainIsLoading = false;
          let n7 = this.node;
          n7.appliedTerrainNodeId = this.node.nodeId;
          n7.equalizedSideWithNodeId[N] = n7.equalizedSideWithNodeId[E] = n7.equalizedSideWithNodeId[S] = n7.equalizedSideWithNodeId[W2] = n7.appliedTerrainNodeId;
          if (this.planet.lightEnabled && !this._inTheQueue) {
            this.planet._normalMapCreator.queue(this);
          }
          this.readyToEngage = true;
        }
        this.terrainVertices = this.plainVertices;
        this.terrainVerticesHigh = this.plainVerticesHigh;
        this.terrainVerticesLow = this.plainVerticesLow;
        this.tempVertices = this.terrainVertices;
        this.tempVerticesHigh = this.terrainVerticesHigh;
        this.tempVerticesLow = this.terrainVerticesLow;
        this.noDataVertices = null;
        this.fileGridSize = Math.sqrt(this.terrainVertices.length / 3) - 1;
        this.gridSize = this.fileGridSize;
        this.terrainReady = true;
        this.terrainExists = false;
      } else {
        if (this.plainReady && this.terrainIsLoading) {
          this.terrainIsLoading = false;
          let n7 = this.node;
          n7.appliedTerrainNodeId = this.node.nodeId;
          n7.equalizedSideWithNodeId[N] = n7.equalizedSideWithNodeId[E] = n7.equalizedSideWithNodeId[S] = n7.equalizedSideWithNodeId[W2] = n7.appliedTerrainNodeId;
          this.readyToEngage = true;
          this.terrainReady = true;
          this.passReady = true;
          this.terrainExists = false;
        }
      }
    }
    _checkEqualization(neighborSide, neigborNode) {
      return neigborNode && neigborNode.segment && this.tileZoom >= neigborNode.segment.tileZoom && this.node.equalizedSideWithNodeId[neighborSide] !== neigborNode.equalizedSideWithNodeId[OPSIDE[neighborSide]];
    }
    equalize() {
      if (this.tileZoom < 2 || this.gridSize < 2) {
        return;
      }
      this.readyToEngage = true;
      let nn = this.node.neighbors;
      let v4 = this.tempVertices, vHigh = this.tempVerticesHigh, vLow = this.tempVerticesLow;
      let gs = this.gridSize, gsOne = gs + 1;
      let n7 = nn[N][0];
      if (this._checkEqualization(N, n7)) {
        this.node.equalizedSideWithNodeId[N] = n7.equalizedSideWithNodeId[S];
        this.readyToEngage = true;
        let offset = this.node.getOffsetOppositeNeighbourSide(n7, N);
        let nv = n7.segment.tempVertices, nvHigh = n7.segment.tempVerticesHigh, nvLow = n7.segment.tempVerticesLow;
        let n_gs = n7.segment.gridSize, n_gsOne = n_gs + 1;
        let dz = 1 / (1 << this.tileZoom - n7.segment.tileZoom);
        let inc = Math.max(gs / (n_gs * dz), 1), n_inc = Math.max(n_gs * dz / gs, 1), n_offset = offset * n_gs;
        for (let k3 = 0, nk = n_offset; k3 < gsOne; k3 += inc, nk += n_inc) {
          const index = k3 * 3;
          const n_index = (n_gsOne * n_gs + nk) * 3;
          v4[index] = nv[n_index];
          v4[index + 1] = nv[n_index + 1];
          v4[index + 2] = nv[n_index + 2];
          vHigh[index] = nvHigh[n_index];
          vHigh[index + 1] = nvHigh[n_index + 1];
          vHigh[index + 2] = nvHigh[n_index + 2];
          vLow[index] = nvLow[n_index];
          vLow[index + 1] = nvLow[n_index + 1];
          vLow[index + 2] = nvLow[n_index + 2];
        }
      }
      n7 = nn[E][0];
      if (this._checkEqualization(E, n7)) {
        this.node.equalizedSideWithNodeId[E] = n7.equalizedSideWithNodeId[W2];
        this.readyToEngage = true;
        let offset = this.node.getOffsetOppositeNeighbourSide(n7, E);
        let nv = n7.segment.tempVertices, nvHigh = n7.segment.tempVerticesHigh, nvLow = n7.segment.tempVerticesLow;
        let n_gs = n7.segment.gridSize, n_gsOne = n_gs + 1;
        let dz = 1 / (1 << this.tileZoom - n7.segment.tileZoom);
        let inc = Math.max(gs / (n_gs * dz), 1), n_inc = Math.max(n_gs * dz / gs, 1), n_offset = offset * n_gs;
        for (let k3 = 0, nk = n_offset; k3 < gsOne; k3 += inc, nk += n_inc) {
          const index = (gsOne * k3 + gs) * 3;
          const n_index = n_gsOne * nk * 3;
          v4[index] = nv[n_index];
          v4[index + 1] = nv[n_index + 1];
          v4[index + 2] = nv[n_index + 2];
          vHigh[index] = nvHigh[n_index];
          vHigh[index + 1] = nvHigh[n_index + 1];
          vHigh[index + 2] = nvHigh[n_index + 2];
          vLow[index] = nvLow[n_index];
          vLow[index + 1] = nvLow[n_index + 1];
          vLow[index + 2] = nvLow[n_index + 2];
        }
      }
      n7 = nn[S][0];
      if (this._checkEqualization(S, n7)) {
        this.node.equalizedSideWithNodeId[S] = n7.equalizedSideWithNodeId[N];
        this.readyToEngage = true;
        let offset = this.node.getOffsetOppositeNeighbourSide(n7, S);
        let nv = n7.segment.tempVertices, nvHigh = n7.segment.tempVerticesHigh, nvLow = n7.segment.tempVerticesLow;
        let n_gs = n7.segment.gridSize;
        let dz = 1 / (1 << this.tileZoom - n7.segment.tileZoom);
        let inc = Math.max(gs / (n_gs * dz), 1), n_inc = Math.max(n_gs * dz / gs, 1), n_offset = offset * n_gs;
        for (let k3 = 0, nk = n_offset; k3 < gsOne; k3 += inc, nk += n_inc) {
          const index = (gsOne * gs + k3) * 3;
          const n_index = nk * 3;
          v4[index] = nv[n_index];
          v4[index + 1] = nv[n_index + 1];
          v4[index + 2] = nv[n_index + 2];
          vHigh[index] = nvHigh[n_index];
          vHigh[index + 1] = nvHigh[n_index + 1];
          vHigh[index + 2] = nvHigh[n_index + 2];
          vLow[index] = nvLow[n_index];
          vLow[index + 1] = nvLow[n_index + 1];
          vLow[index + 2] = nvLow[n_index + 2];
        }
      }
      n7 = nn[W2][0];
      if (this._checkEqualization(W2, n7)) {
        this.node.equalizedSideWithNodeId[W2] = n7.equalizedSideWithNodeId[E];
        this.readyToEngage = true;
        let offset = this.node.getOffsetOppositeNeighbourSide(n7, W2);
        let nv = n7.segment.tempVertices, nvHigh = n7.segment.tempVerticesHigh, nvLow = n7.segment.tempVerticesLow;
        let n_gs = n7.segment.gridSize, n_gsOne = n_gs + 1;
        let dz = 1 / (1 << this.tileZoom - n7.segment.tileZoom);
        let inc = Math.max(gs / (n_gs * dz), 1), n_inc = Math.max(n_gs * dz / gs, 1), n_offset = offset * n_gs;
        for (let k3 = 0, nk = n_offset; k3 < gsOne; k3 += inc, nk += n_inc) {
          const index = gsOne * k3 * 3;
          const n_index = (n_gsOne * nk + n_gs) * 3;
          v4[index] = nv[n_index];
          v4[index + 1] = nv[n_index + 1];
          v4[index + 2] = nv[n_index + 2];
          vHigh[index] = nvHigh[n_index];
          vHigh[index + 1] = nvHigh[n_index + 1];
          vHigh[index + 2] = nvHigh[n_index + 2];
          vLow[index] = nvLow[n_index];
          vLow[index + 1] = nvLow[n_index + 1];
          vLow[index + 2] = nvLow[n_index + 2];
        }
      }
    }
    engage() {
      this.readyToEngage = false;
      this.createCoordsBuffers(this.tempVerticesHigh, this.tempVerticesLow, this.gridSize);
    }
    _terrainWorkerCallback(data) {
      if (this.plainReady) {
        this.readyToEngage = true;
        this.normalMapNormals = null;
        this.normalMapVertices = null;
        this.normalMapVerticesHigh = null;
        this.normalMapVerticesLow = null;
        this.terrainVertices = null;
        this.terrainVerticesHigh = null;
        this.terrainVerticesLow = null;
        this.noDataVertices = null;
        this.tempVertices = null;
        this.tempVerticesHigh = null;
        this.tempVerticesLow = null;
        this.normalMapNormals = data.normalMapNormals;
        this.normalMapVertices = data.normalMapVertices;
        this.normalMapVerticesHigh = data.normalMapVerticesHigh;
        this.normalMapVerticesLow = data.normalMapVerticesLow;
        this.terrainVertices = data.terrainVertices;
        this.terrainVerticesHigh = data.terrainVerticesHigh;
        this.terrainVerticesLow = data.terrainVerticesLow;
        this.noDataVertices = data.noDataVertices;
        this.tempVertices = this.terrainVertices;
        this.tempVerticesHigh = this.terrainVerticesHigh;
        this.tempVerticesLow = this.terrainVerticesLow;
        this.setBoundingVolumeArr(data.bounds);
        this.gridSize = Math.sqrt(this.terrainVertices.length / 3) - 1;
        let n7 = this.node;
        n7.appliedTerrainNodeId = n7.nodeId;
        n7.equalizedSideWithNodeId[N] = n7.equalizedSideWithNodeId[E] = n7.equalizedSideWithNodeId[S] = n7.equalizedSideWithNodeId[W2] = n7.appliedTerrainNodeId;
        this.terrainReady = true;
        this.terrainIsLoading = false;
        this.terrainExists = true;
        if (!this.normalMapTexturePtr) {
          const nmc = this.planet._normalMapCreator;
          this.normalMapTexturePtr = this.planet.renderer.handler.createEmptyTexture_l(nmc.width, nmc.height);
        }
        if (this.planet.lightEnabled) {
          this.planet._normalMapCreator.queue(this);
        }
      }
    }
    _normalMapEdgeEqualize(side) {
      let nn = this.node.neighbors;
      let nns = nn[side];
      let n7 = nns && nns[0];
      let maxZ = this.planet.terrain.maxZoom;
      if (this.tileZoom === maxZ) {
        if (nns && !(nn[0].length || nn[1].length || nn[2].length || nn[3].length)) {
          n7 = this.node.getEqualNeighbor(side);
        }
      }
      let b4 = n7 && n7.segment, s7 = this;
      if (n7 && b4 && b4.terrainReady && b4.terrainExists && b4.tileZoom <= maxZ && s7._appliedNeighborsZoom[side] !== b4.tileZoom) {
        s7._appliedNeighborsZoom[side] = b4.tileZoom;
        let seg_a = s7.normalMapNormals, seg_b = b4.normalMapNormals;
        if (!(seg_a && seg_b))
          return;
        let seg_a_raw = s7.normalMapNormals, seg_b_raw = b4.normalMapNormals;
        let s_gs = Math.sqrt(seg_a.length / 3), s_gs1 = s_gs - 1;
        const i_a = s_gs1 * _S[side];
        let nx, ny, nz, q2;
        if (s7.tileZoom === b4.tileZoom) {
          const i_b = s_gs1 - i_a;
          if (_V[side]) {
            for (let k3 = 0; k3 < s_gs; k3++) {
              let vInd_a = (k3 * s_gs + i_a) * 3, vInd_b = (k3 * s_gs + i_b) * 3;
              nx = seg_a_raw[vInd_a] + seg_b_raw[vInd_b];
              ny = seg_a_raw[vInd_a + 1] + seg_b_raw[vInd_b + 1];
              nz = seg_a_raw[vInd_a + 2] + seg_b_raw[vInd_b + 2];
              q2 = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
              seg_b[vInd_b] = seg_a[vInd_a] = nx * q2;
              seg_b[vInd_b + 1] = seg_a[vInd_a + 1] = ny * q2;
              seg_b[vInd_b + 2] = seg_a[vInd_a + 2] = nz * q2;
            }
          } else {
            for (let k3 = 0; k3 < s_gs; k3++) {
              let vInd_a = (i_a * s_gs + k3) * 3, vInd_b = (i_b * s_gs + k3) * 3;
              nx = seg_a_raw[vInd_a] + seg_b_raw[vInd_b];
              ny = seg_a_raw[vInd_a + 1] + seg_b_raw[vInd_b + 1];
              nz = seg_a_raw[vInd_a + 2] + seg_b_raw[vInd_b + 2];
              q2 = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
              seg_b[vInd_b] = seg_a[vInd_a] = nx * q2;
              seg_b[vInd_b + 1] = seg_a[vInd_a + 1] = ny * q2;
              seg_b[vInd_b + 2] = seg_a[vInd_a + 2] = nz * q2;
            }
          }
          if (!b4._inTheQueue && b4._appliedNeighborsZoom[OPSIDE[side]] !== s7.tileZoom) {
            b4._appliedNeighborsZoom[OPSIDE[side]] = s7.tileZoom;
            s7.planet._normalMapCreator.queue(b4);
          }
        }
      }
    }
    applyTerrain(elevations) {
      if (elevations) {
        this.elevationsExists(elevations);
      } else {
        this.elevationsNotExists();
      }
    }
    deleteBuffers() {
      const gl = this.handler.gl;
      gl.deleteBuffer(this.vertexNormalBuffer);
      gl.deleteBuffer(this.vertexPositionBuffer);
      gl.deleteBuffer(this.vertexPositionBufferHigh);
      gl.deleteBuffer(this.vertexPositionBufferLow);
      this.vertexNormalBuffer = null;
      this.vertexPositionBuffer = null;
      this.vertexPositionBufferHigh = null;
      this.vertexPositionBufferLow = null;
      this.vertexTextureCoordBuffer = null;
    }
    deleteMaterials() {
      let m5 = this.materials;
      for (let i9 = 0; i9 < m5.length; i9++) {
        let mi = m5[i9];
        if (mi) {
          mi.clear();
        }
      }
      this.materials.length = 0;
    }
    deleteElevations() {
      this.terrainExists = false;
      this.terrainReady = false;
      this.terrainIsLoading = false;
      this.normalMapVertices = null;
      this.normalMapVerticesHigh = null;
      this.normalMapVerticesLow = null;
      this.normalMapNormals = null;
      this.tempVertices = null;
      this.tempVerticesHigh = null;
      this.tempVerticesLow = null;
      this.terrainVertices = null;
      this.terrainVerticesHigh = null;
      this.terrainVerticesLow = null;
      this.noDataVertices = null;
      this.plainVertices = null;
      this.plainVerticesHigh = null;
      this.plainVerticesLow = null;
      this.plainNormals = null;
      if (this.normalMapReady) {
        this.handler.gl.deleteTexture(this.normalMapTexture);
        this.normalMapReady = false;
      }
      this._appliedNeighborsZoom = [0, 0, 0, 0];
      this.normalMapTextureBias[0] = 0;
      this.normalMapTextureBias[1] = 0;
      this.normalMapTextureBias[2] = 1;
      this._inTheQueue = false;
    }
    clearSegment() {
      this.plainReady = false;
      this.initialized = false;
      this.deleteBuffers();
      this.deleteMaterials();
      this.deleteElevations();
    }
    childrenInitialized() {
      let n7 = this.node.nodes;
      return n7.length === 4 && n7[0].segment.initialized && n7[1].segment.initialized && n7[2].segment.initialized && n7[3].segment.initialized;
    }
    destroySegment() {
      this.clearSegment();
      let i9 = this._slices.length;
      while (i9--) {
        this._slices[i9].clear();
      }
      this._slices = null;
      this.node = null;
      this.planet = null;
      this.handler = null;
      this.bbox = null;
      this.bsphere = null;
      this._extent = null;
      this.materials = null;
      this.plainVertices = null;
      this.plainVerticesHigh = null;
      this.plainVerticesLow = null;
      this.plainNormals = null;
      this.terrainVertices = null;
      this.terrainVerticesHigh = null;
      this.terrainVerticesLow = null;
      this.noDataVertices = null;
      this.tempVertices = null;
      this.tempVerticesHigh = null;
      this.tempVerticesLow = null;
      this.normalMapTextureBias = null;
      this.normalMapTexture = null;
      this.normalMapVertices = null;
      this.normalMapVerticesHigh = null;
      this.normalMapVerticesLow = null;
      this.normalMapNormals = null;
      this.vertexNormalBuffer = null;
      this.vertexPositionBuffer = null;
      this.vertexPositionBufferHigh = null;
      this.vertexPositionBufferLow = null;
      this.vertexTextureCoordBuffer = null;
      this._projection = null;
      this._appliedNeighborsZoom = null;
      this._globalTextureCoordinates = null;
    }
    /**
     * @todo: looks like it could be simplified in Segment contructor
     */
    _setExtentLonLat() {
      this._extentLonLat = this._extent.inverseMercator();
    }
    _createExtentNormals() {
      const ellipsoid = this.planet.ellipsoid;
      const extent = this._extentLonLat;
      const coord_sw = ellipsoid.geodeticToCartesian(extent.southWest.lon, extent.southWest.lat);
      const coord_ne = ellipsoid.geodeticToCartesian(extent.northEast.lon, extent.northEast.lat);
      const coord_nw = ellipsoid.geodeticToCartesian(extent.southWest.lon, extent.northEast.lat);
      const coord_se = ellipsoid.geodeticToCartesian(extent.northEast.lon, extent.southWest.lat);
      this._sw.copy(coord_sw);
      this._nw.copy(coord_nw);
      this._ne.copy(coord_ne);
      this._se.copy(coord_se);
    }
    createBoundsByExtent() {
      this._createExtentNormals();
      this.setBoundingVolume3v(this._sw, this._ne);
    }
    createBoundsByParent() {
      let pn = this.node;
      while (pn.parentNode && !pn.segment.terrainReady) {
        pn = pn.parentNode;
      }
      let dZ2 = 1 << this.tileZoom - pn.segment.tileZoom;
      let offsetX = this.tileX - pn.segment.tileX * dZ2, offsetY = this.tileY - pn.segment.tileY * dZ2;
      if (pn.segment.terrainReady && pn.segment.tileZoom >= this.planet.terrain.minZoom) {
        let gridSize = pn.segment.gridSize / dZ2;
        if (gridSize >= 1) {
          this.bsphere.center.x = pn.segment.bsphere.center.x;
          this.bsphere.center.y = pn.segment.bsphere.center.y;
          this.bsphere.center.z = pn.segment.bsphere.center.z;
          this.bsphere.radius = pn.segment.bsphere.radius;
          let i0 = gridSize * offsetY;
          let j0 = gridSize * offsetX;
          let pnGsOne = pn.segment.gridSize + 1;
          let ind_sw = 3 * ((i0 + gridSize) * pnGsOne + j0), ind_nw = 3 * (i0 * pnGsOne + j0), ind_ne = 3 * (i0 * pnGsOne + j0 + gridSize), ind_se = 3 * ((i0 + gridSize) * pnGsOne + j0 + gridSize);
          let pVerts = pn.segment.tempVertices;
          let v_sw = new Vec3(pVerts[ind_sw], pVerts[ind_sw + 1], pVerts[ind_sw + 2]), v_ne = new Vec3(pVerts[ind_ne], pVerts[ind_ne + 1], pVerts[ind_ne + 2]);
          let v_nw = new Vec3(pVerts[ind_nw], pVerts[ind_nw + 1], pVerts[ind_nw + 2]), v_se = new Vec3(pVerts[ind_se], pVerts[ind_se + 1], pVerts[ind_se + 2]);
          this._sw.copy(v_sw);
          this._nw.copy(v_nw);
          this._ne.copy(v_ne);
          this._se.copy(v_se);
        } else {
          let pseg = pn.segment;
          let i0 = Math.floor(gridSize * offsetY), j0 = Math.floor(gridSize * offsetX);
          let insideSize = 1 / gridSize;
          let t_i0 = offsetY - insideSize * i0, t_j0 = offsetX - insideSize * j0;
          let bigOne;
          if (pseg.gridSize === 1) {
            bigOne = pseg.tempVertices;
          } else {
            bigOne = getMatrixSubArray64(pseg.tempVertices, pseg.gridSize, i0, j0, 1);
          }
          let v_lt = new Vec3(bigOne[0], bigOne[1], bigOne[2]), v_rb = new Vec3(bigOne[9], bigOne[10], bigOne[11]);
          let vn = new Vec3(bigOne[3] - bigOne[0], bigOne[4] - bigOne[1], bigOne[5] - bigOne[2]), vw = new Vec3(bigOne[6] - bigOne[0], bigOne[7] - bigOne[1], bigOne[8] - bigOne[2]), ve = new Vec3(bigOne[3] - bigOne[9], bigOne[4] - bigOne[10], bigOne[5] - bigOne[11]), vs = new Vec3(bigOne[6] - bigOne[9], bigOne[7] - bigOne[10], bigOne[8] - bigOne[11]);
          let vi_y = t_i0, vi_x = t_j0;
          let coords_lt, coords_rb;
          if (vi_y + vi_x < insideSize) {
            coords_lt = Vec3.add(vn.scaleTo(vi_x / insideSize), vw.scaleTo(vi_y / insideSize)).addA(v_lt);
          } else {
            coords_lt = Vec3.add(vs.scaleTo(1 - vi_x / insideSize), ve.scaleTo(1 - vi_y / insideSize)).addA(v_rb);
          }
          vi_y = t_i0 + 1;
          vi_x = t_j0 + 1;
          if (vi_y + vi_x < insideSize) {
            coords_rb = Vec3.add(vn.scaleTo(vi_x / insideSize), vw.scaleTo(vi_y / insideSize)).addA(v_lt);
          } else {
            coords_rb = Vec3.add(vs.scaleTo(1 - vi_x / insideSize), ve.scaleTo(1 - vi_y / insideSize)).addA(v_rb);
          }
          this._createExtentNormals();
          this.setBoundingVolume3v(coords_lt, coords_rb);
        }
      } else {
        this.createBoundsByExtent();
      }
    }
    setBoundingSphere(x3, y4, z3, v4) {
      this.bsphere.center.x = x3;
      this.bsphere.center.y = y4;
      this.bsphere.center.z = z3;
      this.bsphere.radius = this.bsphere.center.distance(v4);
    }
    setBoundingVolume(xmin, ymin, zmin, xmax, ymax, zmax) {
      this.bbox.setFromBoundsArr([xmin, ymin, zmin, xmax, ymax, zmax]);
      let x3 = xmin + (xmax - xmin) * 0.5, y4 = ymin + (ymax - ymin) * 0.5, z3 = zmin + (zmax - zmin) * 0.5;
      this.bsphere.center.set(x3, y4, z3);
      this.bsphere.radius = this.bsphere.center.distance(new Vec3(xmin, ymin, zmin));
    }
    setBoundingVolume3v(vmin, vmax) {
      this.bbox.setFromBoundsArr([vmin.x, vmin.y, vmin.z, vmax.x, vmax.y, vmax.z]);
      let x3 = vmin.x + (vmax.x - vmin.x) * 0.5, y4 = vmin.y + (vmax.y - vmin.y) * 0.5, z3 = vmin.z + (vmax.z - vmin.z) * 0.5;
      this.bsphere.center.set(x3, y4, z3);
      this.bsphere.radius = this.bsphere.center.distance(new Vec3(vmin.x, vmin.y, vmin.z));
    }
    setBoundingVolumeArr(bounds) {
      this.bbox.setFromBoundsArr(bounds);
      let x3 = bounds[0] + (bounds[3] - bounds[0]) * 0.5, y4 = bounds[1] + (bounds[4] - bounds[1]) * 0.5, z3 = bounds[2] + (bounds[5] - bounds[2]) * 0.5;
      this.bsphere.center.set(x3, y4, z3);
      this.bsphere.radius = this.bsphere.center.distance(new Vec3(bounds[0], bounds[1], bounds[2]));
    }
    createCoordsBuffers(verticesHigh, verticesLow, gridSize) {
      const gsgs = (gridSize + 1) * (gridSize + 1);
      const h8 = this.handler;
      if (this.vertexPositionBufferHigh && this.vertexPositionBufferHigh.numItems === gsgs) {
        h8.setStreamArrayBuffer(this.vertexPositionBufferHigh, verticesHigh);
        h8.setStreamArrayBuffer(this.vertexPositionBufferLow, verticesLow);
      } else {
        h8.gl.deleteBuffer(this.vertexPositionBufferHigh);
        h8.gl.deleteBuffer(this.vertexPositionBufferLow);
        this.vertexTextureCoordBuffer = this.planet._textureCoordsBufferCache[Math.log2(gridSize)];
        this.vertexPositionBufferHigh = h8.createArrayBuffer(verticesHigh, 3, gsgs);
        this.vertexPositionBufferLow = h8.createArrayBuffer(verticesLow, 3, gsgs);
      }
    }
    _addViewExtent() {
      const ext = this._extentLonLat;
      let viewExt = this.planet._viewExtent;
      if (ext.southWest.lon < viewExt.southWest.lon) {
        viewExt.southWest.lon = ext.southWest.lon;
      }
      if (ext.northEast.lon > viewExt.northEast.lon) {
        viewExt.northEast.lon = ext.northEast.lon;
      }
      if (ext.southWest.lat < viewExt.southWest.lat) {
        viewExt.southWest.lat = ext.southWest.lat;
      }
      if (ext.northEast.lat > viewExt.northEast.lat) {
        viewExt.northEast.lat = ext.northEast.lat;
      }
    }
    _assignTileIndexes() {
      this._tileGroup = TILEGROUP_COMMON;
      const tileZoom = this.tileZoom;
      const extent = this._extent;
      const pole = POLE;
      this.tileX = getTileCellIndex(extent.getCenter().lon, extent.getWidth(), -pole);
      this.tileY = getTileCellIndex(extent.getCenter().lat, extent.getHeight(), pole);
      const p22 = this.powTileZoom;
      this.tileXE = (this.tileX + 1) % p22;
      this.tileXW = (p22 + this.tileX - 1) % p22;
      this.tileYN = this.tileY - 1;
      this.tileYS = this.tileY + 1;
      this.tileIndex = Layer.getTileIndex(this.tileX, this.tileY, tileZoom, this._tileGroup);
    }
    initialize() {
      const p4 = this.planet;
      const n7 = this.node;
      this.gridSize = p4.terrain.gridSizeByZoom[this.tileZoom] || p4.terrain.plainGridSize;
      n7.sideSizeLog2[0] = n7.sideSizeLog2[1] = n7.sideSizeLog2[2] = n7.sideSizeLog2[3] = Math.log2(this.gridSize);
      if (this.tileZoom <= p4.terrain.maxZoom) {
        const nmc = this.planet._normalMapCreator;
        this.normalMapTexturePtr = p4.renderer.handler.createEmptyTexture_l(nmc.width, nmc.height);
      }
      this.normalMapTexture = this.planet.transparentTexture;
      this._assignGlobalTextureCoordinates();
      this.initialized = true;
    }
    _assignGlobalTextureCoordinates() {
      const e9 = this._extent;
      this._globalTextureCoordinates[0] = (e9.southWest.lon + POLE) * ONE_BY_POLE_DOUBLE;
      this._globalTextureCoordinates[1] = (POLE - e9.northEast.lat) * ONE_BY_POLE_DOUBLE;
      this._globalTextureCoordinates[2] = (e9.northEast.lon + POLE) * ONE_BY_POLE_DOUBLE;
      this._globalTextureCoordinates[3] = (POLE - e9.southWest.lat) * ONE_BY_POLE_DOUBLE;
    }
    createPlainSegmentAsync() {
      let p4 = this.planet, t9 = p4.terrain;
      if (t9.isReady() && !this.plainReady && this.tileZoom <= t9.maxZoom) {
        this.plainProcessing = true;
        p4._plainSegmentWorker.make(this);
      }
    }
    _plainSegmentWorkerCallback(data) {
      this.plainProcessing = false;
      if (this.initialized && !this.terrainReady) {
        this.plainReady = true;
        this.plainVertices = data.plainVertices;
        this.plainVerticesHigh = data.plainVerticesHigh;
        this.plainVerticesLow = data.plainVerticesLow;
        this.plainNormals = data.plainNormals;
        this._plainRadius = data.plainRadius;
        this.normalMapNormals = data.normalMapNormals;
        this.normalMapVertices = data.normalMapVertices;
        this.normalMapVerticesHigh = data.normalMapVerticesHigh;
        this.normalMapVerticesLow = data.normalMapVerticesLow;
        this.fileGridSize = Math.sqrt(data.normalMapVertices.length / 3) - 1;
      }
    }
    createPlainSegment() {
      this.initialize();
      this._createPlainVertices();
      this.readyToEngage = true;
    }
    _projToDeg(lon, lat) {
      return LonLat.inverseMercator(lon, lat);
    }
    _createPlainVertices() {
      const gridSize = this.planet.terrain.gridSizeByZoom[this.tileZoom];
      const fgs = this.planet.terrain.plainGridSize;
      const currGridSize = Math.max(fgs, gridSize);
      const e9 = this._extent;
      const lonSize = e9.getWidth();
      const latSize = e9.getHeight();
      const llStep = lonSize / currGridSize;
      const ltStep = latSize / currGridSize;
      const esw_lon = e9.southWest.lon;
      const ene_lat = e9.northEast.lat;
      const dg = Math.max(fgs / gridSize, 1);
      const gs = currGridSize + 1;
      const r22 = this.planet.ellipsoid._invRadii2;
      const gsgs = gs * gs;
      const gridSize3 = (gridSize + 1) * (gridSize + 1) * 3;
      let ind = 0, nmInd = 0;
      this.plainNormals = new Float32Array(gridSize3);
      this.plainVertices = new Float64Array(gridSize3);
      this.plainVerticesHigh = new Float32Array(gridSize3);
      this.plainVerticesLow = new Float32Array(gridSize3);
      this.normalMapNormals = new Float32Array(gsgs * 3);
      this.normalMapVertices = new Float64Array(gsgs * 3);
      this.normalMapVerticesHigh = new Float32Array(gsgs * 3);
      this.normalMapVerticesLow = new Float32Array(gsgs * 3);
      let verts = this.plainVertices, vertsHigh = this.plainVerticesHigh, vertsLow = this.plainVerticesLow, norms = this.plainNormals, nmVerts = this.normalMapVertices, nmVertsHigh = this.normalMapVerticesHigh, nmVertsLow = this.normalMapVerticesLow, nmNorms = this.normalMapNormals;
      for (let k3 = 0; k3 < gsgs; k3++) {
        let j2 = k3 % gs, i9 = ~~(k3 / gs);
        let v4 = this.planet.ellipsoid.lonLatToCartesian(this._projToDeg(esw_lon + j2 * llStep, ene_lat - i9 * ltStep));
        let nx = v4.x * r22.x, ny = v4.y * r22.y, nz = v4.z * r22.z;
        let l4 = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
        let nxl = nx * l4, nyl = ny * l4, nzl = nz * l4;
        Vec3.doubleToTwoFloats(v4, _tempHigh2, _tempLow2);
        nmVerts[nmInd] = v4.x;
        nmVertsHigh[nmInd] = _tempHigh2.x;
        nmVertsLow[nmInd] = _tempLow2.x;
        nmNorms[nmInd++] = nxl;
        nmVerts[nmInd] = v4.y;
        nmVertsHigh[nmInd] = _tempHigh2.y;
        nmVertsLow[nmInd] = _tempLow2.y;
        nmNorms[nmInd++] = nyl;
        nmVerts[nmInd] = v4.z;
        nmVertsHigh[nmInd] = _tempHigh2.z;
        nmVertsLow[nmInd] = _tempLow2.z;
        nmNorms[nmInd++] = nzl;
        if (i9 % dg === 0 && j2 % dg === 0) {
          verts[ind] = v4.x;
          vertsHigh[ind] = _tempHigh2.x;
          vertsLow[ind] = _tempLow2.x;
          norms[ind++] = nxl;
          verts[ind] = v4.y;
          vertsHigh[ind] = _tempHigh2.y;
          vertsLow[ind] = _tempLow2.y;
          norms[ind++] = nyl;
          verts[ind] = v4.z;
          vertsHigh[ind] = _tempHigh2.z;
          vertsLow[ind] = _tempLow2.z;
          norms[ind++] = nzl;
        }
      }
      this.terrainVertices = verts;
      this.terrainVerticesHigh = vertsHigh;
      this.terrainVerticesLow = vertsLow;
      this.plainReady = true;
    }
    /**
     * Gets specific layer material.
     * @public
     * @param {Layer} layer - Layer object.
     * @returns {Material | undefined} - Segment material.
     */
    getMaterialByLayer(layer) {
      return this.materials[layer.__id];
    }
    /**
     * @param layer
     * @protected
     *
     * @todo siplify layer._extentMerc in this.getLayerExtent(layer)
     *
     */
    _getLayerExtentOffset(layer) {
      const v0s = layer._extentMerc;
      const v0t = this._extent;
      const sSize_x = v0s.northEast.lon - v0s.southWest.lon;
      const sSize_y = v0s.northEast.lat - v0s.southWest.lat;
      const dV0s_x = (v0t.southWest.lon - v0s.southWest.lon) / sSize_x;
      const dV0s_y = (v0s.northEast.lat - v0t.northEast.lat) / sSize_y;
      const dSize_x = (v0t.northEast.lon - v0t.southWest.lon) / sSize_x;
      const dSize_y = (v0t.northEast.lat - v0t.southWest.lat) / sSize_y;
      return [dV0s_x, dV0s_y, dSize_x, dSize_y];
    }
    initSlice(sliceIndex) {
      let slice2 = this._slices[sliceIndex];
      if (!slice2) {
        slice2 = this._slices[sliceIndex] = new Slice(this);
      } else {
        slice2.layers = [];
      }
      return slice2;
    }
    screenRendering(sh, layerSlice, sliceIndex, defaultTexture, isOverlay = false, forcedOpacity) {
      const gl = this.handler.gl;
      const sha = sh.attributes;
      const shu = sh.uniforms;
      const pm = this.materials;
      const p4 = this.planet;
      let currHeight, li;
      if (layerSlice && layerSlice.length) {
        li = layerSlice[0];
        currHeight = li._height;
      } else {
        currHeight = 0;
      }
      gl.activeTexture(gl.TEXTURE0 + p4.SLICE_SIZE + 2);
      gl.bindTexture(gl.TEXTURE_2D, defaultTexture || this.getDefaultTexture());
      gl.uniform1i(shu.defaultTexture, p4.SLICE_SIZE + 2);
      let n7 = 0, i9 = 0;
      let notEmpty = false;
      let slice2 = this.initSlice(sliceIndex);
      this._indexBuffer = this._getIndexBuffer();
      while (li) {
        if (this.layerOverlap(li) && (li._fading && li._fadingOpacity > 0 || (li.minZoom >= p4.minCurrZoom || li.maxZoom >= p4.minCurrZoom) && (li.minZoom <= p4.maxCurrZoom || li.maxZoom <= p4.maxCurrZoom))) {
          notEmpty = true;
          let m5 = pm[li.__id];
          if (!m5) {
            m5 = pm[li.__id] = li.createMaterial(this);
          }
          if (!m5.isReady) {
            this.planet._renderCompleted = false;
          }
          slice2.append(li, m5);
          p4._samplerArr[n7] = n7;
          gl.activeTexture(gl.TEXTURE0 + n7);
          gl.bindTexture(gl.TEXTURE_2D, m5.texture || p4.transparentTexture);
          n7++;
        }
        i9++;
        li = layerSlice[i9];
      }
      if (notEmpty || !isOverlay) {
        gl.uniform1f(shu.transitionOpacity, forcedOpacity || this._transitionOpacity > 1 ? 1 : this._transitionOpacity);
        gl.uniform1i(shu.samplerCount, n7);
        gl.uniform1f(shu.height, currHeight);
        gl.uniform1iv(shu.samplerArr, p4._samplerArr);
        gl.uniform4fv(shu.tileOffsetArr, slice2.tileOffsetArr);
        gl.uniform1fv(shu.layerOpacityArr, slice2.layerOpacityArr);
        if (p4.lightEnabled) {
          gl.activeTexture(gl.TEXTURE0 + p4.SLICE_SIZE + 3);
          gl.bindTexture(gl.TEXTURE_2D, this.normalMapTexture || p4.transparentTexture);
          gl.uniform1i(shu.uNormalMap, p4.SLICE_SIZE + 3);
          gl.uniform3fv(shu.uNormalMapBias, this.normalMapTextureBias);
          gl.uniform4fv(shu.uGlobalTextureCoord, this._globalTextureCoordinates);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
        gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
        gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
        gl.vertexAttribPointer(sha.aTextureCoord, 2, gl.UNSIGNED_SHORT, true, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.drawElements(p4.drawMode, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
      }
    }
    heightPickingRendering(sh, layerSlice) {
      const gl = this.handler.gl;
      const sha = sh.attributes;
      const shu = sh.uniforms;
      let currHeight;
      if (layerSlice && layerSlice.length) {
        currHeight = layerSlice[0]._height;
      } else {
        currHeight = 0;
      }
      gl.uniform1f(shu.height, currHeight);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
      gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
      gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      gl.drawElements(gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
    }
    increaseTransitionOpacity() {
      this._transitionOpacity += (window.performance.now() - this._transitionTimestamp) / this.planet.transitionTime;
      this._transitionTimestamp = window.performance.now();
      if (this._transitionOpacity > 2) {
        this._transitionOpacity = 2;
      }
      let i9 = this.node._fadingNodes.length;
      while (i9--) {
        let n7 = this.node._fadingNodes[i9];
        if (n7.segment) {
          if (n7.segment._transitionOpacity > 0 && !this.planet._fadingNodes.has(n7.__id)) {
            this.planet._fadingNodes.set(n7.__id, n7);
            n7.segment._transitionOpacity = 2 - this._transitionOpacity;
            if (n7.segment._transitionOpacity === 0) {
              this.node._fadingNodes.splice(i9, 1);
            }
          }
        } else {
          this._transitionOpacity = 1;
          break;
        }
      }
    }
    fadingTransitionOpacity() {
      this._transitionOpacity -= 0.01;
      this._transitionTimestamp = window.performance.now();
      if (this._transitionOpacity < 0) {
        this._transitionOpacity = 0;
      }
    }
    colorPickingRendering(sh, layerSlice, sliceIndex, defaultTexture, isOverlay = false) {
      const gl = this.handler.gl;
      const sha = sh.attributes;
      const shu = sh.uniforms;
      let pm = this.materials, p4 = this.planet;
      let currHeight;
      if (layerSlice && layerSlice.length) {
        currHeight = layerSlice[0]._height;
      } else {
        currHeight = 0;
      }
      let notEmpty = false;
      let slice2 = this._slices[sliceIndex];
      let len = slice2.layers.length;
      for (let n7 = 0; n7 < len; n7++) {
        notEmpty = true;
        let li = slice2.layers[n7];
        let n42 = n7 * 4;
        p4._pickingColorArr[n42] = li._pickingColor.x / 255;
        p4._pickingColorArr[n42 + 1] = li._pickingColor.y / 255;
        p4._pickingColorArr[n42 + 2] = li._pickingColor.z / 255;
        p4._pickingColorArr[n42 + 3] = Number(li._pickingEnabled);
        p4._samplerArr[n7] = n7;
        gl.activeTexture(gl.TEXTURE0 + n7);
        gl.bindTexture(gl.TEXTURE_2D, pm[li.__id].texture || this.planet.transparentTexture);
        p4._pickingMaskArr[n7] = n7 + p4.SLICE_SIZE;
        gl.activeTexture(gl.TEXTURE0 + n7 + p4.SLICE_SIZE);
        gl.bindTexture(gl.TEXTURE_2D, pm[li.__id].pickingMask || this.planet.transparentTexture);
      }
      if (notEmpty || !isOverlay) {
        gl.uniform1i(shu.samplerCount, len);
        gl.uniform1f(shu.height, currHeight);
        gl.uniform1iv(shu.samplerArr, p4._samplerArr);
        gl.uniform1iv(shu.pickingMaskArr, p4._pickingMaskArr);
        gl.uniform4fv(shu.pickingColorArr, p4._pickingColorArr);
        gl.uniform4fv(shu.tileOffsetArr, slice2.tileOffsetArr);
        gl.uniform1fv(shu.layerOpacityArr, slice2.layerOpacityArr);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
        gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
        gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
        gl.vertexAttribPointer(sha.aTextureCoord, 2, gl.UNSIGNED_SHORT, true, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.drawElements(gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
      }
    }
    depthRendering(sh, layerSlice) {
      const gl = this.handler.gl;
      const sha = sh.attributes;
      const shu = sh.uniforms;
      var currHeight;
      if (layerSlice && layerSlice.length) {
        currHeight = layerSlice[0]._height;
      } else {
        currHeight = 0;
      }
      gl.uniform1f(shu.height, currHeight);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferHigh);
      gl.vertexAttribPointer(sha.aVertexPositionHigh, this.vertexPositionBufferHigh.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBufferLow);
      gl.vertexAttribPointer(sha.aVertexPositionLow, this.vertexPositionBufferLow.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      gl.drawElements(gl.TRIANGLE_STRIP, this._indexBuffer.numItems, gl.UNSIGNED_INT, 0);
    }
    _getIndexBuffer() {
      const s7 = this.node.sideSizeLog2;
      let cache = this.planet._indexesCache[Math.log2(this.gridSize)][s7[0]][s7[1]][s7[2]][s7[3]];
      if (!cache.buffer) {
        let indexes = getInstance().createSegmentIndexes(Math.log2(this.gridSize), [s7[0], s7[1], s7[2], s7[3]]);
        cache.buffer = this.planet.renderer.handler.createElementArrayBuffer(indexes, 1);
        this.planet._indexesCacheToRemoveCounter++;
      }
      return cache.buffer;
    }
    _collectVisibleNodes() {
      this.planet._visibleNodes[this.node.nodeId] = this.node;
    }
    layerOverlap(layer) {
      return this._extent.overlaps(layer._extentMerc);
    }
    getDefaultTexture() {
      return this.planet.solidTextureOne;
    }
    getExtentLonLat() {
      return this._extentLonLat;
    }
    getExtentMerc() {
      return this._extentMerc;
    }
    getExtent() {
      return this._extent;
    }
    getNeighborSide(b4) {
      if (this.tileY === b4.tileY) {
        if (this.tileX === b4.tileXE) {
          return W2;
        } else if (this.tileX === b4.tileXW) {
          return E;
        }
      } else if (this.tileX === b4.tileX) {
        if (this.tileY === b4.tileYS) {
          return N;
        } else if (this.tileY === b4.tileYN) {
          return S;
        }
      }
      return -1;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/quadTree/Node.js
  var _tempHigh3 = new Vec3();
  var _tempLow3 = new Vec3();
  var _vertOrder = [
    new Vec2(0, 0),
    new Vec2(1, 0),
    new Vec2(0, 1),
    new Vec2(1, 1)
  ];
  var _neGridSize = Math.sqrt(_vertOrder.length) - 1;
  var BOUNDS = {
    xmin: 0,
    ymin: 0,
    zmin: 0,
    xmax: 0,
    ymax: 0,
    zmax: 0
  };
  var __staticCounter = 0;
  var Node2 = class _Node {
    constructor(SegmentPrototype, planet, partId, parent, tileZoom, extent) {
      planet._createdNodesCount++;
      this.__id = __staticCounter++;
      this.SegmentPrototype = SegmentPrototype;
      this.planet = planet;
      this.parentNode = parent;
      this.partId = partId;
      this.nodeId = partId + (parent ? parent.nodeId * 4 + 1 : 0);
      this.state = null;
      this.prevState = null;
      this.appliedTerrainNodeId = -1;
      this.sideSizeLog2 = [0, 0, 0, 0];
      this.ready = false;
      this.neighbors = [[], [], [], []];
      this.equalizedSideWithNodeId = [this.nodeId, this.nodeId, this.nodeId, this.nodeId];
      this.nodes = [];
      this.segment = new SegmentPrototype(this, planet, tileZoom, extent);
      this._cameraInside = false;
      this.inFrustum = 0;
      this._fadingNodes = [];
      this.createBounds();
    }
    createChildrenNodes() {
      this.ready = true;
      const p4 = this.planet;
      const ps = this.segment;
      const ext = ps._extent;
      const z3 = ps.tileZoom + 1;
      const size_x = ext.getWidth() * 0.5;
      const size_y = ext.getHeight() * 0.5;
      const ne = ext.northEast;
      const sw = ext.southWest;
      const c7 = new LonLat(sw.lon + size_x, sw.lat + size_y);
      const nd = this.nodes;
      nd[NW] = new _Node(this.SegmentPrototype, p4, NW, this, z3, new Extent(new LonLat(sw.lon, sw.lat + size_y), new LonLat(sw.lon + size_x, ne.lat)));
      nd[NE] = new _Node(this.SegmentPrototype, p4, NE, this, z3, new Extent(c7, new LonLat(ne.lon, ne.lat)));
      nd[SW] = new _Node(this.SegmentPrototype, p4, SW, this, z3, new Extent(new LonLat(sw.lon, sw.lat), c7));
      nd[SE] = new _Node(this.SegmentPrototype, p4, SE, this, z3, new Extent(new LonLat(sw.lon + size_x, sw.lat), new LonLat(ne.lon, sw.lat + size_y)));
    }
    createBounds() {
      let seg = this.segment;
      seg._setExtentLonLat();
      if (seg.tileZoom === 0) {
        seg.setBoundingSphere(0, 0, 0, new Vec3(0, 0, seg.planet.ellipsoid.equatorialSize));
      } else if (seg.tileZoom < seg.planet.terrain.minZoom) {
        seg.createBoundsByExtent();
      } else {
        seg.createBoundsByParent();
      }
      let x3 = seg.bsphere.center.x, y4 = seg.bsphere.center.y, z3 = seg.bsphere.center.z;
      let length = 1 / Math.sqrt(x3 * x3 + y4 * y4 + z3 * z3);
      seg.centerNormal.x = x3 * length;
      seg.centerNormal.y = y4 * length;
      seg.centerNormal.z = z3 * length;
    }
    getState() {
      if (this.state === -1) {
        return this.state;
      }
      let pn = this.parentNode;
      while (pn) {
        if (pn.state !== WALKTHROUGH) {
          return NOTRENDERING;
        }
        pn = pn.parentNode;
      }
      return this.state;
    }
    /**
     * Returns the same deep existent neighbour node.
     * @public
     * @param {number} side - Neighbour side index e.g. og.quadTree.N, og.quadTree.W etc.
     * @returns {Node} -
     */
    getEqualNeighbor(side) {
      let pn = this;
      let part = NEIGHBOUR[side][pn.partId];
      if (part !== -1) {
        return pn.parentNode.nodes[part];
      } else {
        let pathId = [];
        while (pn.parentNode) {
          pathId.push(pn.partId);
          part = NEIGHBOUR[side][pn.partId];
          pn = pn.parentNode;
          if (part !== -1) {
            let i9 = pathId.length;
            side = OPSIDE[side];
            while (pn && i9--) {
              part = OPPART[side][pathId[i9]];
              pn = pn.nodes[part];
            }
            return pn;
          }
        }
      }
    }
    // public isBrother(node: Node): boolean {
    //     return !(this.parentNode || node.parentNode) || (this.parentNode!.nodeId === node.parentNode!.nodeId);
    // }
    traverseNodes(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode) {
      if (!this.ready) {
        this.createChildrenNodes();
      }
      let n7 = this.nodes;
      n7[0].renderTree(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode);
      n7[1].renderTree(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode);
      n7[2].renderTree(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode);
      n7[3].renderTree(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode);
    }
    renderTree(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode) {
      if (this.planet._renderedNodes.length >= MAX_RENDERED_NODES) {
        return;
      }
      if (!maxZoom || zoomPassNode && this.segment.tileZoom > zoomPassNode.segment.tileZoom) {
        this.prevState = this.state;
      }
      this.state = WALKTHROUGH;
      this.clearNeighbors();
      let seg = this.segment, planet = this.planet;
      this._cameraInside = false;
      if (!this.parentNode || this.parentNode._cameraInside) {
        let inside;
        if (Math.abs(cam._lonLat.lat) <= MAX_LAT && seg._projection.id === EPSG3857.id) {
          inside = seg._extent.isInside(cam._lonLatMerc);
        } else if (seg._projection.id === EPSG4326.id) {
          inside = seg._extent.isInside(cam._lonLat);
        }
        if (inside) {
          cam._insideSegment = seg;
          this._cameraInside = true;
        }
      }
      this.inFrustum = 0;
      let frustums = cam.frustums, numFrustums = frustums.length;
      if (seg.tileZoom < 6) {
        for (let i9 = 0; i9 < numFrustums; i9++) {
          if (frustums[i9].containsSphere(seg.bsphere)) {
            this.inFrustum |= 1 << i9;
          }
        }
      } else {
        let commonFrustumFlag = 1 << numFrustums - 1 - 1;
        for (let i9 = 0; commonFrustumFlag && i9 < numFrustums; i9++) {
          if (seg.terrainReady) {
            if (frustums[i9].containsBox(seg.bbox)) {
              commonFrustumFlag >>= 1;
              this.inFrustum |= 1 << i9;
            }
          } else {
            if (frustums[i9].containsSphere(seg.bsphere)) {
              commonFrustumFlag >>= 1;
              this.inFrustum |= 1 << i9;
            }
          }
        }
      }
      if (this.inFrustum || this._cameraInside || seg.tileZoom < 3) {
        let h8 = Math.abs(cam._lonLat.height);
        let horizonDist = cam.eye.length2() - this.planet.ellipsoid.polarSizeSqr;
        horizonDist = horizonDist < 10687647287563281e-5 * planet._heightFactor ? 10687647287563281e-5 * planet._heightFactor : horizonDist;
        let altVis = seg.tileZoom < 2 || seg.tileZoom > 19 || /* Could be replaced with camera frustum always looking down check,
        and not to go througn nodes from the oppositeside of the globe*/
        seg.tileZoom < 6 && !seg.terrainReady;
        altVis = altVis || cam.eye.distance2(seg._sw) < horizonDist || cam.eye.distance2(seg._nw) < horizonDist || cam.eye.distance2(seg._ne) < horizonDist || cam.eye.distance2(seg._se) < horizonDist;
        if (this.inFrustum && (altVis || h8 > 1e4) || this._cameraInside) {
          seg._collectVisibleNodes();
        }
        if (seg.tileZoom < 2) {
          this.traverseNodes(cam, maxZoom, terrainReadySegment, stopLoading, zoomPassNode);
        } else if (seg.terrainReady && (!maxZoom && cam.projectedSize(seg.bsphere.center, seg._plainRadius) < planet.lodSize || maxZoom && (seg.tileZoom === maxZoom || !altVis))) {
          if (altVis) {
            seg.passReady = true;
            this.renderNode(this.inFrustum, !this.inFrustum, terrainReadySegment, stopLoading);
          } else {
            this.state = NOTRENDERING;
          }
        } else if (seg.terrainReady && seg.checkZoom() && (!maxZoom || cam.projectedSize(seg.bsphere.center, seg.bsphere.radius) > this.planet._maxLodSize)) {
          this.traverseNodes(cam, maxZoom, seg, stopLoading, zoomPassNode);
        } else if (altVis) {
          seg.passReady = maxZoom ? seg.terrainReady : false;
          this.renderNode(this.inFrustum, !this.inFrustum, terrainReadySegment, stopLoading);
        } else {
          this.state = NOTRENDERING;
        }
      } else {
        this.state = NOTRENDERING;
      }
    }
    renderNode(inFrustum, onlyTerrain, terrainReadySegment, stopLoading) {
      let seg = this.segment;
      if (!seg.terrainReady) {
        if (!seg.initialized) {
          seg.initialize();
        }
        this.whileTerrainLoading(terrainReadySegment);
        if (!seg.plainProcessing) {
          seg.createPlainSegmentAsync();
        }
        if (seg.plainReady && !stopLoading) {
          seg.loadTerrain();
        }
      }
      if (seg.planet.lightEnabled && !seg.normalMapReady) {
        this.whileNormalMapCreating();
      }
      if (onlyTerrain) {
        this.state = -1;
        return;
      }
      if (!this._cameraInside && seg.tileZoom > this.planet.maxCurrZoom) {
        this.planet.maxCurrZoom = seg.tileZoom;
      }
      if (seg.tileZoom < this.planet.minCurrZoom) {
        this.planet.minCurrZoom = seg.tileZoom;
      }
      seg._addViewExtent();
      this.addToRender(inFrustum);
    }
    childrenPrevStateEquals(state) {
      let n7 = this.nodes;
      return n7.length === 4 && n7[0].prevState === state && n7[1].prevState === state && n7[2].prevState === state && n7[3].prevState === state;
    }
    isFading() {
      let n7 = this.nodes;
      return this.state === WALKTHROUGH && this.segment._transitionOpacity > 0 && n7.length === 4 && (n7[0].state === RENDERING && n7[1].state === RENDERING && n7[2].state === RENDERING && n7[3].state === RENDERING);
    }
    _collectFadingNodes() {
      if (this.segment.tileZoom < 3) {
        this.segment._transitionOpacity = 1;
        return;
      }
      if (this.prevState !== RENDERING) {
        this.segment._transitionOpacity = 0;
        this._fadingNodes = [];
        let timestamp = window.performance.now();
        this.segment._transitionTimestamp = timestamp;
        if (this.parentNode) {
          if (this.parentNode.prevState === RENDERING) {
            let pn = this.parentNode.parentNode;
            while (pn) {
              if (pn.isFading()) {
                for (let i9 = 0; i9 < pn.nodes.length; i9++) {
                  pn.nodes[i9].segment._transitionOpacity = 1;
                  pn.nodes[i9]._fadingNodes = [];
                }
                pn.segment._transitionOpacity = 0;
                break;
              }
              pn = pn.parentNode;
            }
            this.parentNode.whileTerrainLoading();
            this._fadingNodes.push(this.parentNode);
            this.parentNode.segment._transitionOpacity = 2;
            this.parentNode.segment._transitionTimestamp = timestamp;
          } else {
            if (this.segment.childrenInitialized() && this.childrenPrevStateEquals(RENDERING)) {
              for (let i9 = 0; i9 < this.nodes.length; i9++) {
                let ni = this.nodes[i9];
                ni.whileTerrainLoading();
                this._fadingNodes.push(ni);
                ni.segment._transitionOpacity = 2;
                ni.segment._transitionTimestamp = timestamp;
                ni.prevState = ni.state;
                ni.state = NOTRENDERING;
              }
            }
          }
        }
      }
    }
    clearNeighbors() {
      if (this.neighbors) {
        this.neighbors[0] = this.neighbors[1] = this.neighbors[2] = this.neighbors[3] = null;
        this.neighbors[0] = [];
        this.neighbors[1] = [];
        this.neighbors[2] = [];
        this.neighbors[3] = [];
      }
    }
    _refreshTransitionOpacity() {
      if (this._fadingNodes.length === 0) {
        this.segment._transitionOpacity = 1;
      } else {
        if (this._fadingNodes.length === 4 && !this.childrenPrevStateEquals(RENDERING)) {
          this.segment._transitionOpacity = 1;
          this._fadingNodes = [];
        } else {
          for (let i9 = 0; i9 < this._fadingNodes.length; i9++) {
            if (this.segment._transitionOpacity < 1 && this._fadingNodes[i9].segment._transitionOpacity === 0) {
              this._fadingNodes[i9].segment._transitionOpacity = 0;
              this.segment._transitionOpacity = 1;
            }
          }
          this.segment.increaseTransitionOpacity();
        }
      }
    }
    /**
     * Picking up current node to render processing.
     * @public
     */
    addToRender(inFrustum) {
      this.state = RENDERING;
      let nodes = this.planet._renderedNodes;
      if (!this.planet._transitionOpacityEnabled) {
        this.getRenderedNodesNeighbors(nodes);
        nodes.push(this);
      } else {
        binaryInsert(nodes, this, (a6, b4) => {
          return a6.segment.tileZoom - b4.segment.tileZoom;
        });
      }
      if (!this.segment.terrainReady) {
        this.planet._renderCompleted = false;
        this.planet._terrainCompleted = false;
      }
      let k3 = 0, rf = this.planet._renderedNodesInFrustum;
      while (inFrustum) {
        if (inFrustum & 1) {
          rf[k3].push(this);
        }
        k3++;
        inFrustum >>= 1;
      }
    }
    applyNeighbor(node, side) {
      const opcs = OPSIDE[side];
      if (this.neighbors[side].length === 0 || node.neighbors[opcs].length === 0) {
        const ap = this.segment;
        const bp = node.segment;
        const ld = ap.gridSize / (bp.gridSize * Math.pow(2, bp.tileZoom - ap.tileZoom));
        let cs_size = ap.gridSize, opcs_size = bp.gridSize;
        if (ld > 1) {
          cs_size = Math.ceil(ap.gridSize / ld);
          opcs_size = bp.gridSize;
        } else if (ld < 1) {
          cs_size = ap.gridSize;
          opcs_size = Math.ceil(bp.gridSize * ld);
        }
        this.sideSizeLog2[side] = Math.log2(cs_size);
        node.sideSizeLog2[opcs] = Math.log2(opcs_size);
      }
      this.neighbors[side].push(node);
      node.neighbors[opcs].push(this);
    }
    /**
     * Searching current node for its neighbours.
     * @public
     */
    getRenderedNodesNeighbors(nodes) {
      for (let i9 = nodes.length - 1; i9 >= 0; --i9) {
        let ni = nodes[i9];
        let cs = this.getCommonSide(ni);
        if (cs !== -1) {
          this.applyNeighbor(ni, cs);
        }
      }
    }
    /**
     * Checking if current node has a common side with input node and return side index N, E, S or W. Otherwise returns -1.
     * @param {Node} node - Input node
     * @returns {number} - Node side index
     */
    getCommonSide(node) {
      const as = this.segment;
      const bs = node.segment;
      if (as.tileZoom === bs.tileZoom && as._tileGroup === bs._tileGroup) {
        return as.getNeighborSide(bs);
      } else {
        const a6 = as._extentLonLat;
        const b4 = bs._extentLonLat;
        let a_ne = a6.northEast, a_sw = a6.southWest, b_ne = b4.northEast, b_sw = b4.southWest;
        let a_ne_lon = a_ne.lon, a_ne_lat = a_ne.lat, a_sw_lon = a_sw.lon, a_sw_lat = a_sw.lat, b_ne_lon = b_ne.lon, b_ne_lat = b_ne.lat, b_sw_lon = b_sw.lon, b_sw_lat = b_sw.lat;
        if (as._tileGroup === bs._tileGroup) {
          if (a_ne_lon === b_sw_lon && (a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat || a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat)) {
            return E;
          } else if (a_sw_lon === b_ne_lon && (a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat || a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat)) {
            return W2;
          } else if (a_ne_lat === b_sw_lat && (a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon || a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon)) {
            return N;
          } else if (a_sw_lat === b_ne_lat && (a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon || a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon)) {
            return S;
          } else if (bs.tileX === 0 && b_sw_lon === -a_ne_lon && (a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat || a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat)) {
            return E;
          } else if (as.tileX === 0 && a_sw_lon === -b_ne_lon && (a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat || a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat)) {
            return W2;
          }
        }
        if (as._tileGroup === TILEGROUP_COMMON && bs._tileGroup === TILEGROUP_NORTH && as.tileY === 0 && bs.tileY === bs.powTileZoom - 1 && (a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon || a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon)) {
          return N;
        } else if (as._tileGroup === TILEGROUP_COMMON && bs._tileGroup === TILEGROUP_SOUTH && as.tileY === as.powTileZoom - 1 && bs.tileY === 0 && (a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon || a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon)) {
          return S;
        } else if (as._tileGroup === TILEGROUP_SOUTH && bs._tileGroup === TILEGROUP_COMMON && as.tileY === 0 && bs.tileY === bs.powTileZoom - 1 && (a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon || a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon)) {
          return N;
        } else if (as._tileGroup === TILEGROUP_NORTH && bs._tileGroup === TILEGROUP_COMMON && as.tileY === as.powTileZoom - 1 && bs.tileY === 0 && (a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon || a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon)) {
          return S;
        }
      }
      return -1;
    }
    whileNormalMapCreating() {
      const seg = this.segment;
      if (!seg.terrainIsLoading && seg.terrainExists && !seg._inTheQueue) {
        seg.planet._normalMapCreator.queue(seg);
      }
      let pn = this;
      while (pn.parentNode && !pn.segment.normalMapReady) {
        pn = pn.parentNode;
      }
      const dZ2 = 2 << seg.tileZoom - pn.segment.tileZoom - 1;
      seg.normalMapTexture = pn.segment.normalMapTexture;
      seg.normalMapTextureBias[0] = seg.tileX - pn.segment.tileX * dZ2;
      seg.normalMapTextureBias[1] = seg.tileY - pn.segment.tileY * dZ2;
      seg.normalMapTextureBias[2] = 1 / dZ2;
    }
    whileTerrainLoading(terrainReadySegment) {
      const seg = this.segment;
      let pn = this;
      if (terrainReadySegment && terrainReadySegment.terrainReady) {
        pn = terrainReadySegment.node;
      } else {
        while (pn.parentNode && !pn.segment.terrainReady) {
          pn = pn.parentNode;
        }
      }
      if (pn.segment.terrainReady && this.appliedTerrainNodeId !== pn.nodeId) {
        let dZ2 = 2 << seg.tileZoom - pn.segment.tileZoom - 1, offsetX = seg.tileX - pn.segment.tileX * dZ2, offsetY = seg.tileY - pn.segment.tileY * dZ2;
        const pseg = pn.segment;
        let tempVertices, tempVerticesHigh, tempVerticesLow, noDataVertices;
        this.appliedTerrainNodeId = pn.nodeId;
        this.equalizedSideWithNodeId[N] = this.equalizedSideWithNodeId[E] = this.equalizedSideWithNodeId[S] = this.equalizedSideWithNodeId[W2] = this.appliedTerrainNodeId;
        let gridSize = pn.segment.gridSize / dZ2, gridSizeExt = pn.segment.fileGridSize / dZ2;
        BOUNDS.xmin = MAX;
        BOUNDS.xmax = MIN;
        BOUNDS.ymin = MAX;
        BOUNDS.ymax = MIN;
        BOUNDS.zmin = MAX;
        BOUNDS.zmax = MIN;
        if (gridSize >= 1) {
          seg.gridSize = gridSize;
          let len = (gridSize + 1) * (gridSize + 1) * 3;
          tempVertices = new Float64Array(len);
          tempVerticesHigh = new Float32Array(len);
          tempVerticesLow = new Float32Array(len);
          if (pseg.noDataVertices) {
            noDataVertices = new Uint8Array(len / 3);
          }
          getMatrixSubArrayBoundsExt(pseg.terrainVertices, pseg.terrainVerticesHigh, pseg.terrainVerticesLow, pseg.noDataVertices, pseg.gridSize, gridSize * offsetY, gridSize * offsetX, gridSize, tempVertices, tempVerticesHigh, tempVerticesLow, BOUNDS, noDataVertices);
        } else if (gridSizeExt >= 1 && pn.segment.terrainExists) {
          seg.gridSize = gridSizeExt;
          let len = (gridSizeExt + 1) * (gridSizeExt + 1) * 3;
          tempVertices = new Float64Array(len);
          tempVerticesHigh = new Float32Array(len);
          tempVerticesLow = new Float32Array(len);
          if (pseg.noDataVertices) {
            noDataVertices = new Uint8Array(len / 3);
          }
          getMatrixSubArrayBoundsExt(pseg.normalMapVertices, pseg.normalMapVerticesHigh, pseg.normalMapVerticesLow, pseg.noDataVertices, pn.segment.fileGridSize, gridSizeExt * offsetY, gridSizeExt * offsetX, gridSizeExt, tempVertices, tempVerticesHigh, tempVerticesLow, BOUNDS, noDataVertices);
        } else {
          seg.gridSize = _neGridSize;
          let i0 = Math.floor(gridSize * offsetY), j0 = Math.floor(gridSize * offsetX);
          let bigOne;
          if (pseg.gridSize === 1) {
            bigOne = pseg.terrainVertices;
          } else {
            bigOne = getMatrixSubArray64(pseg.terrainVertices, pseg.gridSize, i0, j0, 1);
          }
          let insideSize = 1 / gridSize;
          let t_i0 = offsetY - insideSize * i0, t_j0 = offsetX - insideSize * j0;
          let v_lt = new Vec3(bigOne[0], bigOne[1], bigOne[2]), v_rb = new Vec3(bigOne[9], bigOne[10], bigOne[11]);
          let vn = new Vec3(bigOne[3] - bigOne[0], bigOne[4] - bigOne[1], bigOne[5] - bigOne[2]), vw = new Vec3(bigOne[6] - bigOne[0], bigOne[7] - bigOne[1], bigOne[8] - bigOne[2]), ve = new Vec3(bigOne[3] - bigOne[9], bigOne[4] - bigOne[10], bigOne[5] - bigOne[11]), vs = new Vec3(bigOne[6] - bigOne[9], bigOne[7] - bigOne[10], bigOne[8] - bigOne[11]);
          let coords = new Vec3();
          tempVertices = new Float64Array(3 * _vertOrder.length);
          tempVerticesHigh = new Float32Array(3 * _vertOrder.length);
          tempVerticesLow = new Float32Array(3 * _vertOrder.length);
          for (let i9 = 0; i9 < _vertOrder.length; i9++) {
            let vi_y = _vertOrder[i9].y + t_i0, vi_x = _vertOrder[i9].x + t_j0;
            let vi_x_is = vi_x * gridSize, vi_y_is = vi_y * gridSize;
            if (vi_y + vi_x < insideSize) {
              coords = vn.scaleTo(vi_x_is).addA(vw.scaleTo(vi_y_is)).addA(v_lt);
            } else {
              coords = vs.scaleTo(1 - vi_x_is).addA(ve.scaleTo(1 - vi_y_is)).addA(v_rb);
            }
            Vec3.doubleToTwoFloats(coords, _tempHigh3, _tempLow3);
            let i32 = i9 * 3;
            tempVertices[i32] = coords.x;
            tempVertices[i32 + 1] = coords.y;
            tempVertices[i32 + 2] = coords.z;
            tempVerticesHigh[i32] = _tempHigh3.x;
            tempVerticesHigh[i32 + 1] = _tempHigh3.y;
            tempVerticesHigh[i32 + 2] = _tempHigh3.z;
            tempVerticesLow[i32] = _tempLow3.x;
            tempVerticesLow[i32 + 1] = _tempLow3.y;
            tempVerticesLow[i32 + 2] = _tempLow3.z;
            if (coords.x < BOUNDS.xmin)
              BOUNDS.xmin = coords.x;
            if (coords.x > BOUNDS.xmax)
              BOUNDS.xmax = coords.x;
            if (coords.y < BOUNDS.ymin)
              BOUNDS.ymin = coords.y;
            if (coords.y > BOUNDS.ymax)
              BOUNDS.ymax = coords.y;
            if (coords.z < BOUNDS.zmin)
              BOUNDS.zmin = coords.z;
            if (coords.z > BOUNDS.zmax)
              BOUNDS.zmax = coords.z;
          }
        }
        seg.readyToEngage = true;
        seg.terrainVertices = tempVertices;
        seg.terrainVerticesHigh = tempVerticesHigh;
        seg.terrainVerticesLow = tempVerticesLow;
        seg.tempVertices = tempVertices;
        seg.tempVerticesHigh = tempVerticesHigh;
        seg.tempVerticesLow = tempVerticesLow;
        seg.noDataVertices = noDataVertices;
        seg.setBoundingVolume(BOUNDS.xmin, BOUNDS.ymin, BOUNDS.zmin, BOUNDS.xmax, BOUNDS.ymax, BOUNDS.zmax);
        if (seg.tileZoom > seg.planet.terrain.maxZoom) {
          if (pn.segment.tileZoom >= seg.planet.terrain.maxZoom) {
            seg._plainRadius = pn.segment._plainRadius / dZ2;
            seg.terrainReady = true;
            seg.terrainIsLoading = false;
            seg.terrainVertices = tempVertices;
            seg.terrainVerticesHigh = tempVerticesHigh;
            seg.terrainVerticesLow = tempVerticesLow;
            seg.passReady = true;
            this.appliedTerrainNodeId = this.nodeId;
            this.equalizedSideWithNodeId[N] = this.equalizedSideWithNodeId[E] = this.equalizedSideWithNodeId[S] = this.equalizedSideWithNodeId[W2] = this.appliedTerrainNodeId;
            if (pn.segment.terrainExists) {
              seg.normalMapVertices = tempVertices;
              seg.fileGridSize = Math.sqrt(tempVertices.length / 3) - 1;
              let fgs = Math.sqrt(pseg.normalMapNormals.length / 3) - 1, fgsZ = fgs / dZ2;
              if (fgs > 1) {
                seg.normalMapNormals = getMatrixSubArray32(pseg.normalMapNormals, fgs, fgsZ * offsetY, fgsZ * offsetX, fgsZ);
              } else {
                seg.normalMapNormals = pseg.normalMapNormals;
              }
            }
          }
        }
      }
    }
    destroy() {
      this.prevState = this.state = NOTRENDERING;
      this.segment.destroySegment();
      let n7 = this.neighbors;
      for (let i9 = 0, len = n7.length; i9 < len; i9++) {
        let ni = n7[i9];
        if (ni) {
          for (let j2 = 0; j2 < ni.length; j2++) {
            let nij = ni[j2];
            if (nij && nij.neighbors) {
              nij.clearNeighbors();
            }
          }
        }
      }
      this.neighbors = null;
      this.parentNode = null;
      this.sideSizeLog2 = null;
      this.segment = null;
    }
    clearTree() {
      const state = this.getState();
      if (state === NOTRENDERING || state === RENDERING) {
        this.destroyBranches();
      } else {
        for (let i9 = 0; i9 < this.nodes.length; i9++) {
          this.nodes[i9] && this.nodes[i9].clearTree();
        }
      }
    }
    clearBranches() {
      for (let i9 = 0; i9 < this.nodes.length; i9++) {
        this.nodes[i9].clearBranches();
        this.nodes[i9].segment.deleteMaterials();
      }
    }
    destroyBranches() {
      if (this.ready) {
        let nodesToRemove = [], i9;
        for (i9 = 0; i9 < this.nodes.length; i9++) {
          nodesToRemove[i9] = this.nodes[i9];
        }
        this.ready = false;
        this.nodes = [];
        for (i9 = 0; i9 < nodesToRemove.length; i9++) {
          nodesToRemove[i9].destroyBranches();
          nodesToRemove[i9].destroy();
          nodesToRemove[i9] = null;
        }
        nodesToRemove.length = 0;
        nodesToRemove = null;
      }
    }
    traverseTree(callback) {
      callback(this);
      if (this.ready) {
        for (let i9 = 0; i9 < this.nodes.length; i9++) {
          this.nodes[i9].traverseTree(callback);
        }
      }
    }
    getOffsetOppositeNeighbourSide(neighbourNode, side) {
      let pNode = this, neighbourZoom = neighbourNode.segment.tileZoom, offset = 0;
      while (pNode.segment.tileZoom > neighbourZoom) {
        offset += PARTOFFSET[pNode.partId][side] / (1 << pNode.segment.tileZoom - neighbourZoom);
        pNode = pNode.parentNode;
      }
      return offset;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/quadTree/QuadTreeStrategy.js
  var QuadTreeStrategy = class {
    constructor(planet, name = "", proj = EPSG3857) {
      this.name = name;
      this.projection = proj;
      this._planet = planet;
      this._quadTreeList = [];
    }
    destroyBranches() {
      for (let i9 = 0, len = this._quadTreeList.length; i9 < len; i9++) {
        this._quadTreeList[i9].destroyBranches();
      }
    }
    clearLayerMaterial(layer) {
      let lid = layer.__id;
      for (let i9 = 0, len = this._quadTreeList.length; i9 < len; i9++) {
        this._quadTreeList[i9].traverseTree(function(node) {
          let mats = node.segment.materials;
          if (mats[lid]) {
            mats[lid].clear();
            mats[lid] = null;
          }
        });
      }
    }
    get planet() {
      return this._planet;
    }
    init() {
    }
    preRender() {
      for (let i9 = 0; i9 < this._quadTreeList.length; i9++) {
        let quadTree = this._quadTreeList[i9];
        quadTree.createChildrenNodes();
        quadTree.segment.createPlainSegment();
        for (let j2 = 0; j2 < quadTree.nodes.length; j2++) {
          quadTree.nodes[j2].segment.createPlainSegment();
        }
      }
    }
    preLoad() {
      for (let i9 = 0; i9 < this._quadTreeList.length; i9++) {
        let quadTree = this._quadTreeList[i9];
        quadTree.segment.passReady = true;
        quadTree.renderNode(1);
        this._planet.normalMapCreator.drawSingle(quadTree.segment);
        for (let j2 = 0; j2 < quadTree.nodes.length; j2++) {
          quadTree.nodes[j2].segment.passReady = true;
          quadTree.nodes[j2].renderNode(1);
          this._planet._normalMapCreator.drawSingle(quadTree.nodes[j2].segment);
        }
      }
    }
    collectRenderNodes() {
      for (let i9 = 0; i9 < this._quadTreeList.length; i9++) {
        this._quadTreeList[i9].renderTree(this._planet.camera, 0, null);
      }
    }
    clear() {
      for (let i9 = 0; i9 < this._quadTreeList.length; i9++) {
        this._quadTreeList[i9].clearTree();
      }
    }
    get quadTreeList() {
      return this._quadTreeList;
    }
    getTileXY(lonLat, zoom) {
      let z3 = zoom, x3 = -1, y4 = -1, pz = 1 << z3;
      x3 = getTileCellIndex(lonLat.lon, 360 / pz, -180);
      y4 = getTileCellIndex(lonLat.lat, 180 / pz, 90);
      return [x3, y4, z3, TILEGROUP_COMMON];
    }
    getLonLatTileOffset(lonLat, x3, y4, z3, gridSize) {
      let coords = lonLat;
      let extent = new Extent();
      let worldExtent = Extent.createFromArray([-180, -90, 180, 90]);
      extent = getTileCellExtent(x3, y4, z3, worldExtent);
      let sizeImgW = extent.getWidth() / (gridSize - 1), sizeImgH = extent.getHeight() / (gridSize - 1);
      let i9 = gridSize - Math.ceil((coords.lat - extent.southWest.lat) / sizeImgH) - 1, j2 = Math.floor((coords.lon - extent.southWest.lon) / sizeImgW);
      return [i9, j2];
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/segment/SegmentLonLat.js
  var MAX_POLE_ZOOM = 7;
  var POLE_PIECE_SIZE = (90 - MAX_LAT) / Math.pow(2, MAX_POLE_ZOOM);
  var SegmentLonLat = class extends Segment {
    constructor(node, planet, tileZoom, extent) {
      super(node, planet, tileZoom, extent);
      this._projection = EPSG4326;
      this._extentLonLat = this._extent;
      this._extentMerc = new Extent(extent.southWest.forwardMercatorEPS01(), extent.northEast.forwardMercatorEPS01());
      this._isNorth = this._extent.northEast.lat > 0;
      this.isPole = true;
    }
    _setExtentLonLat() {
      this._extentLonLat = this._extent;
    }
    projectNative(coords) {
      return coords;
    }
    getInsideLonLat(obj) {
      return obj._lonLat;
    }
    _getMaxZoom() {
      let maxPoleZoom = 0;
      if (this._isNorth) {
        let Yz = Math.floor((90 - this._extent.northEast.lat) / POLE_PIECE_SIZE);
        maxPoleZoom = Math.floor(Yz / 16) + 7;
      } else {
        let Yz = Math.floor((MIN_LAT - this._extent.northEast.lat) / POLE_PIECE_SIZE);
        maxPoleZoom = 12 - Math.floor(Yz / 16);
      }
      return maxPoleZoom;
    }
    checkZoom() {
      return super.checkZoom() && this.tileZoom <= this._getMaxZoom();
    }
    _assignTileIndexes() {
      this._assignTileXIndexes(this._extent);
      this._assignTileYIndexes(this._extent);
      this.tileIndex = Layer.getTileIndex(this.tileX, this.tileY, this.tileZoom, this._tileGroup);
    }
    _assignTileXIndexes(extent) {
      this.tileX = getTileCellIndex(extent.getCenter().lon, extent.getWidth(), -180);
      let p22 = 1 << this.tileZoom;
      this.tileXE = (this.tileX + 1) % p22;
      this.tileXW = (p22 + this.tileX - 1) % p22;
    }
    _assignTileYIndexes(extent) {
      const lat = extent.getCenter().lat;
      if (lat > 0) {
        this._tileGroup = TILEGROUP_NORTH;
        this.tileY = getTileCellIndex(lat, extent.getHeight(), 90);
      } else {
        this._tileGroup = TILEGROUP_SOUTH;
        this.tileY = getTileCellIndex(lat, extent.getHeight(), MIN_LAT);
      }
      this.tileYN = this.tileY - 1;
      this.tileYS = this.tileY + 1;
    }
    _projToDeg(lon, lat) {
      return new LonLat(lon, lat);
    }
    _assignGlobalTextureCoordinates() {
      const e9 = this._extent;
      this._globalTextureCoordinates[0] = (e9.southWest.lon + 180) / 360;
      this._globalTextureCoordinates[1] = (90 - e9.northEast.lat) / 180;
      this._globalTextureCoordinates[2] = (e9.northEast.lon + 180) / 360;
      this._globalTextureCoordinates[3] = (90 - e9.southWest.lat) / 180;
    }
    /**
     * @todo: replace to the strategy
     */
    _collectVisibleNodes() {
      if (this._isNorth) {
        this.planet._visibleNodesNorth[this.node.nodeId] = this.node;
      } else {
        this.planet._visibleNodesSouth[this.node.nodeId] = this.node;
      }
    }
    /**
     * @param layer
     * @protected
     *
     * @todo simplify layer._extentMerc in layer.getNativeExtent(this)
     *
     */
    _getLayerExtentOffset(layer) {
      const v0s = layer._extent;
      const v0t = this._extent;
      const sSize_x = v0s.northEast.lon - v0s.southWest.lon;
      const sSize_y = v0s.northEast.lat - v0s.southWest.lat;
      const dV0s_x = (v0t.southWest.lon - v0s.southWest.lon) / sSize_x;
      const dV0s_y = (v0s.northEast.lat - v0t.northEast.lat) / sSize_y;
      const dSize_x = (v0t.northEast.lon - v0t.southWest.lon) / sSize_x;
      const dSize_y = (v0t.northEast.lat - v0t.southWest.lat) / sSize_y;
      return [dV0s_x, dV0s_y, dSize_x, dSize_y];
    }
    layerOverlap(layer) {
      return this._extent.overlaps(layer._extent);
    }
    getDefaultTexture() {
      return this._isNorth ? this.planet.solidTextureOne : this.planet.solidTextureTwo;
    }
    getExtentLonLat() {
      return this._extent;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/quadTree/EarthQuadTreeStrategy.js
  var EarthQuadTreeStrategy = class extends QuadTreeStrategy {
    constructor(planet) {
      super(planet, "Earth");
    }
    init() {
      this._quadTreeList = [
        new Node2(Segment, this.planet, 0, null, 0, Extent.createFromArray([-2003750834e-2, -2003750834e-2, 2003750834e-2, 2003750834e-2])),
        new Node2(SegmentLonLat, this.planet, 0, null, 0, Extent.createFromArray([-180, MAX_LAT, 180, 90])),
        new Node2(SegmentLonLat, this.planet, 0, null, 0, Extent.createFromArray([-180, -90, 180, MIN_LAT]))
      ];
    }
    getTileXY(lonLat, zoom) {
      let tileGroup = getTileGroupByLat(lonLat.lat, MAX_LAT), z3 = zoom, x3 = -1, y4 = -1, pz = 1 << z3;
      if (tileGroup === TILEGROUP_NORTH) {
        x3 = getTileCellIndex(lonLat.lon, 360 / pz, -180);
        y4 = getTileCellIndex(lonLat.lat, (90 - MAX_LAT) / pz, 90);
      } else if (tileGroup === TILEGROUP_SOUTH) {
        x3 = getTileCellIndex(lonLat.lon, 360 / pz, -180);
        y4 = getTileCellIndex(lonLat.lat, (90 - MAX_LAT) / pz, MIN_LAT);
      } else {
        let merc = forward(lonLat);
        x3 = getTileCellIndex(merc.lon, POLE2 / pz, -POLE);
        y4 = getTileCellIndex(merc.lat, POLE2 / pz, POLE);
      }
      return [x3, y4, z3, tileGroup];
    }
    getLonLatTileOffset(lonLat, x3, y4, z3, gridSize) {
      let coords = lonLat;
      let extent = new Extent();
      if (lonLat.lat > MAX_LAT) {
        let worldExtent = Extent.createFromArray([-180, MAX_LAT, 180, 90]);
        extent = getTileCellExtent(x3, y4, z3, worldExtent);
      } else if (lonLat.lat < MIN_LAT) {
        let worldExtent = Extent.createFromArray([-180, -90, 180, MIN_LAT]);
        extent = getTileCellExtent(x3, y4, z3, worldExtent);
      } else {
        coords = forward(lonLat);
        extent = getTileExtent(x3, y4, z3);
      }
      let sizeImgW = extent.getWidth() / (gridSize - 1), sizeImgH = extent.getHeight() / (gridSize - 1);
      let i9 = gridSize - Math.ceil((coords.lat - extent.southWest.lat) / sizeImgH) - 1, j2 = Math.floor((coords.lon - extent.southWest.lon) / sizeImgW);
      return [i9, j2];
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/terrain/Geoid.js
  var Geoid = class {
    constructor(options2 = {}) {
      this.model = options2.model || null;
      this.src = options2.src || null;
      this._cached_ix = 0;
      this._cached_iy = 0;
      this._v00 = 0;
      this._v01 = 0;
      this._v10 = 0;
      this._v11 = 0;
      this._t = 0;
    }
    static loadModel(url) {
      if (!url) {
        return new Promise((resolve) => {
          resolve(null);
        });
      } else
        return fetch(url, {}).then((r8) => {
          if (!r8.ok) {
            throw Error("Geoid model file: HTTP error " + r8.status);
          }
          return r8.arrayBuffer();
        }).then((r8) => {
          if (r8) {
            return new Uint8Array(r8);
          } else {
            throw Error("Geoid model file: no data from " + url);
          }
        }).then(function(rawfile) {
          if (!(rawfile[0] === 80 && rawfile[1] === 53 && (rawfile[2] === 13 && rawfile[3] === 10 || rawfile[2] === 10))) {
            throw new Error("Geoid model file: no PGM header");
          }
          var i9 = rawfile[2] === 13 ? 4 : 3;
          var offset = null;
          var scale2 = null;
          function getline() {
            let start = i9;
            for (var j2 = i9; ; j2++) {
              if (j2 >= rawfile.length) {
                throw new Error("Geoid model file: missing newline in header");
              }
              if (rawfile[j2] === 10) {
                i9 = j2 + 1;
                break;
              }
            }
            if (j2 > start && rawfile[j2 - 1] === 13)
              j2--;
            return String.fromCharCode.apply(null, rawfile.slice(start, j2));
          }
          var m5, s7;
          for (; ; ) {
            s7 = getline();
            if (s7[0] !== "#")
              break;
            m5 = s7.match(/^# Offset (.*)$/);
            if (m5) {
              offset = parseInt(m5[1], 10);
              if (!isFinite(offset)) {
                throw new Error("Geoid model file: bad offset " + m5[1]);
              }
            } else {
              m5 = s7.match(/^# Scale (.*)$/);
              if (m5) {
                scale2 = parseFloat(m5[1]);
                if (!isFinite(scale2)) {
                  throw new Error("Geoid model file: bad scale " + m5[1]);
                }
              }
            }
          }
          m5 = s7.match(/^\s*(\d+)\s+(\d+)\s*$/);
          let width = 0;
          let height = 0;
          if (m5) {
            width = parseInt(m5[1], 10);
            height = parseInt(m5[2], 10);
          }
          if (!(m5 && width >= 0 && height >= 0)) {
            throw new Error("Geoid model file: bad PGM width&height line");
          }
          let levels = parseInt(getline());
          if (levels != 65535) {
            throw new Error("Geoid model file: PGM file must have 65535 gray levels");
          }
          if (offset === null) {
            throw new Error("Geoid model file: PGM file does not contain offset");
          }
          if (scale2 === null) {
            throw new Error("Geoid model file: PGM file does not contain scale");
          }
          if (width < 2 || height < 2) {
            throw new Error("Geoid model file: Raster size too small");
          }
          let payload_len = rawfile.length - i9;
          if (payload_len !== width * height * 2) {
            throw new Error("Geoid model file: File has the wrong length");
          }
          return {
            scale: scale2,
            offset,
            width,
            height,
            rlonres: width / 360,
            rlatres: (height - 1) / 180,
            i: i9,
            rawfile
          };
        });
    }
    setModel(model) {
      this.model = model;
    }
    _rawval(ix, iy) {
      let model = this.model;
      if (iy < 0) {
        iy = -iy;
        ix += model.width / 2;
      } else if (iy >= model.height) {
        iy = 2 * (model.height - 1) - iy;
        ix += model.width / 2;
      }
      if (ix < 0) {
        ix += model.width;
      } else if (ix >= model.width) {
        ix -= model.width;
      }
      let k3 = (iy * model.width + ix) * 2 + model.i;
      return model.rawfile[k3] << 8 | model.rawfile[k3 + 1];
    }
    getHeightLonLat(lonlat) {
      return this.getHeight(lonlat.lon, lonlat.lat);
    }
    getHeight(lon, lat) {
      if (!this.model)
        return 0;
      let model = this.model;
      if (lon < 0)
        lon += 360;
      let fy = (90 - lat) * model.rlatres;
      let fx = lon * model.rlonres;
      let iy = Math.floor(fy);
      let ix = Math.floor(fx);
      fx -= ix;
      fy -= iy;
      if (iy === model.height - 1) {
        iy--;
      }
      if (this._cached_ix !== ix || this._cached_iy !== iy) {
        this._cached_ix = ix;
        this._cached_iy = iy;
        this._v00 = this._rawval(ix, iy);
        this._v01 = this._rawval(ix + 1, iy);
        this._v10 = this._rawval(ix, iy + 1);
        this._v11 = this._rawval(ix + 1, iy + 1);
      }
      let a6 = (1 - fx) * this._v00 + fx * this._v01;
      let b4 = (1 - fx) * this._v10 + fx * this._v11;
      let h8 = (1 - fy) * a6 + fy * b4;
      return model.offset + model.scale * h8;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/GeoImageCreator.js
  var GeoImageCreator = class {
    constructor(planet, maxFrames = 5) {
      this.MAX_FRAMES = maxFrames;
      this._gridSize = 64;
      this._planet = planet;
      this._framebuffer = null;
      this._framebufferMercProj = null;
      this._texCoordsBuffer = null;
      this._indexBuffer = null;
      this._currentFrame = 0;
      this._queue = [];
      this._animate = [];
      this._quadTexCoordsBuffer = null;
      this._quadVertexBuffer = null;
    }
    init() {
      this._initShaders();
      this._initBuffers();
    }
    /**
     * Creates geoImage corners coordinates grid buffer.
     * @public
     * @param{Array.<LonLat>} c - GeoImage corners coordinates.
     * @param{boolean} [toMerc=false] - Transform to web mercator.
     * @return{WebGLBuffer} Grid coordinates buffer.
     */
    createGridBuffer(c7, toMerc = false) {
      let gs = this._gridSize;
      let v03 = new LonLat((c7[3].lon - c7[0].lon) / gs, (c7[3].lat - c7[0].lat) / gs), v12 = new LonLat((c7[2].lon - c7[1].lon) / gs, (c7[2].lat - c7[1].lat) / gs), v01 = new LonLat((c7[1].lon - c7[0].lon) / gs, (c7[1].lat - c7[0].lat) / gs), v32 = new LonLat((c7[2].lon - c7[3].lon) / gs, (c7[2].lat - c7[3].lat) / gs);
      const size = (gs + 1) * (gs + 1) * 2, halfSize = size / 2;
      let gridHigh = new Float32Array(size), gridLow = new Float32Array(size);
      let lonLatArr = new Array(halfSize);
      let kh = 0, kl = 0, k3 = 0;
      let tempArr2 = new Float32Array(2);
      for (let i9 = 0; i9 <= gs; i9++) {
        let P03i = new LonLat(c7[0].lon + i9 * v03.lon, c7[0].lat + i9 * v03.lat), P12i = new LonLat(c7[1].lon + i9 * v12.lon, c7[1].lat + i9 * v12.lat);
        for (let j2 = 0; j2 <= gs; j2++) {
          let P01j = new LonLat(c7[0].lon + j2 * v01.lon, c7[0].lat + j2 * v01.lat), P32j = new LonLat(c7[3].lon + j2 * v32.lon, c7[3].lat + j2 * v32.lat);
          let xx = getLinesIntersectionLonLat(P03i, P12i, P01j, P32j);
          doubleToTwoFloats2(xx.lon, tempArr2);
          gridHigh[kh++] = tempArr2[0];
          gridLow[kl++] = tempArr2[1];
          doubleToTwoFloats2(xx.lat, tempArr2);
          gridHigh[kh++] = tempArr2[0];
          gridLow[kl++] = tempArr2[1];
          lonLatArr[k3++] = xx;
        }
      }
      if (toMerc) {
        for (let i9 = 0; i9 < halfSize; i9++) {
          let c8 = lonLatArr[i9].forwardMercator();
          doubleToTwoFloats2(c8.lon, tempArr2);
          gridHigh[i9 * 2] = tempArr2[0];
          gridLow[i9 * 2] = tempArr2[1];
          doubleToTwoFloats2(c8.lat, tempArr2);
          gridHigh[i9 * 2 + 1] = tempArr2[0];
          gridLow[i9 * 2 + 1] = tempArr2[1];
        }
      }
      return [
        this._planet.renderer.handler.createArrayBuffer(gridHigh, 2, halfSize),
        this._planet.renderer.handler.createArrayBuffer(gridLow, 2, halfSize)
      ];
    }
    frame() {
      let i9 = this.MAX_FRAMES;
      while (i9-- && this._queue.length) {
        const q2 = this._queue.shift();
        q2._isRendering = false;
        q2.rendering();
        q2.events.dispatch(q2.events.loadend);
      }
      i9 = this._animate.length;
      while (i9--) {
        this._animate[i9].rendering();
      }
    }
    add(geoImage) {
      if (!geoImage._isRendering) {
        geoImage._isRendering = true;
        if (geoImage._animate) {
          this._animate.push(geoImage);
        } else {
          this._queue.push(geoImage);
        }
      }
    }
    remove(geoImage) {
      if (geoImage._isRendering) {
        geoImage._creationProceeding = false;
        geoImage._isRendering = false;
        let arr;
        if (geoImage._animate) {
          arr = this._animate;
        } else {
          arr = this._queue;
        }
        for (let i9 = 0; i9 < arr.length; i9++) {
          if (arr[i9].isEqual(geoImage)) {
            arr.splice(i9, 1);
            return;
          }
        }
      }
    }
    _initBuffers() {
      let h8 = this._planet.renderer.handler;
      this._framebuffer = new Framebuffer(h8, { width: 2, height: 2, useDepth: false });
      this._framebuffer.init();
      this._framebufferMercProj = new Framebuffer(h8, { width: 2, height: 2, useDepth: false });
      this._framebufferMercProj.init();
      let gs = Math.log2(this._gridSize);
      this._texCoordsBuffer = this._planet._textureCoordsBufferCache[gs];
      this._indexBuffer = this._planet._indexesCache[gs][gs][gs][gs][gs].buffer;
      this._quadTexCoordsBuffer = h8.createArrayBuffer(new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]), 2, 4);
      this._quadVertexBuffer = h8.createArrayBuffer(new Float32Array([-1, 1, 1, 1, -1, -1, 1, -1]), 2, 4);
    }
    _initShaders() {
      this._planet.renderer.handler.addProgram(new Program("geoImageTransform", {
        uniforms: {
          sourceTexture: "sampler2d",
          extentParamsHigh: "vec4",
          extentParamsLow: "vec4",
          isFullExtent: "bool"
        },
        attributes: {
          cornersHigh: "vec2",
          cornersLow: "vec2",
          texCoords: "vec2"
        },
        vertexShader: `attribute vec2 cornersHigh; 
                     attribute vec2 cornersLow;
                      attribute vec2 texCoords; 
                      uniform vec4 extentParamsHigh; 
                      uniform vec4 extentParamsLow; 
                      varying vec2 v_texCoords;
                      void main() {                                                             
                          v_texCoords = texCoords; 
                          vec2 highDiff = cornersHigh - extentParamsHigh.xy;
                          vec2 lowDiff = cornersLow - extentParamsLow.xy;                                        
                          gl_Position = vec4((-1.0 + (highDiff * step(1.0, length(highDiff)) + lowDiff) * extentParamsHigh.zw) * vec2(1.0, -1.0), 0.0, 1.0); 
                      }`,
        fragmentShader: `precision highp float;
                        uniform sampler2D sourceTexture;
                        uniform bool isFullExtent;
                        varying vec2 v_texCoords;
                        void main () {
                            if(!isFullExtent && (v_texCoords.x <= 0.001 || v_texCoords.x >= 0.999 ||
                                v_texCoords.y <= 0.001 || v_texCoords.y >= 0.999)) {
                                discard;
                            }
                            gl_FragColor = texture2D(sourceTexture, v_texCoords);
                        }`
      }));
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/Loader.js
  var LOADER_EVENTS = ["loadend", "layerloadend"];
  var Loader = class {
    constructor(maxRequests = 24) {
      this.MAX_REQUESTS = maxRequests;
      this.events = createEvents(LOADER_EVENTS);
      this._loading = 0;
      this._queue = [];
      this._senderRequestCounter = [];
      this._promises = {
        "json": (r8) => r8.json(),
        "blob": (r8) => r8.blob(),
        "arrayBuffer": (r8) => r8.arrayBuffer(),
        "imageBitmap": (r8) => r8.blob().then((r9) => createImageBitmap(r9, {
          premultiplyAlpha: "premultiply"
        })),
        "text": (r8) => r8.text()
      };
    }
    load(params, callback) {
      if (params.sender) {
        if (!this._senderRequestCounter[params.sender.__id]) {
          this._senderRequestCounter[params.sender.__id] = {
            sender: params.sender,
            counter: 0,
            __requestCounterFrame__: 0
          };
        }
        this._senderRequestCounter[params.sender.__id].counter++;
      }
      this._queue.push({ params, callback });
      this._exec();
    }
    fetch(params) {
      return fetch(params.src, params.options || {}).then((response) => {
        if (!response.ok) {
          throw Error(`Unable to load '${params.src}'`);
        }
        return this._promises[params.type || "blob"](response);
      }).then((data) => {
        return { status: "ready", data };
      }).catch((err) => {
        return { status: "error", msg: err.toString() };
      });
    }
    getRequestCounter(sender) {
      if (sender) {
        let r8 = this._senderRequestCounter[sender.__id];
        if (r8) {
          return r8.counter;
        }
      }
      return 0;
    }
    isIdle(sender) {
      return sender.isIdle;
    }
    _checkLoadend(request, sender) {
      if (request.counter === 0 && (!sender._planet || sender._planet._terrainCompletedActivated)) {
        sender.events.dispatch(sender.events.loadend, sender);
        this.events.dispatch(this.events.layerloadend, sender);
        request.__requestCounterFrame__ = 0;
      } else {
        request.__requestCounterFrame__ = requestAnimationFrame(() => {
          this._checkLoadend(request, sender);
        });
      }
    }
    _handleResponse(q2, response) {
      q2.callback(response);
      let sender = q2.params.sender;
      if (sender && (sender.events.loadend.handlers.length || this.events.layerloadend.handlers.length)) {
        let request = this._senderRequestCounter[sender.__id];
        if (request && request.counter > 0) {
          request.counter--;
          cancelAnimationFrame(request.__requestCounterFrame__);
          request.__requestCounterFrame__ = requestAnimationFrame(() => {
            this._checkLoadend(request, sender);
          });
        }
      }
      this._exec();
    }
    _exec() {
      if (this._queue.length > 0 && this._loading < this.MAX_REQUESTS) {
        let q2 = this._queue.pop();
        if (!q2)
          return;
        let p4 = q2.params;
        if (!p4.filter || p4.filter(p4)) {
          this._loading++;
          return fetch(p4.src, p4.options || {}).then((response) => {
            if (!response.ok) {
              throw Error(`Unable to load '${p4.src}'`);
            }
            return this._promises[p4.type || "blob"](response);
          }).then((data) => {
            this._loading--;
            this._handleResponse(q2, { status: "ready", data });
          }).catch((err) => {
            this._loading--;
            this._handleResponse(q2, { status: "error", msg: err.toString() });
          });
        } else {
          this._handleResponse(q2, { status: "abort" });
        }
      } else if (this._loading === 0) {
        this.events.dispatch(this.events.loadend);
      }
    }
    abort(sender) {
      if (this._senderRequestCounter[sender.__id]) {
        this._senderRequestCounter[sender.__id].counter = 0;
        cancelAnimationFrame(this._senderRequestCounter[sender.__id].__requestCounterFrame__);
        this._senderRequestCounter[sender.__id].__requestCounterFrame__ = 0;
      }
      for (let i9 = 0, len = this._queue.length; i9 < len; i9++) {
        let qi = this._queue[i9];
        if (qi && qi.params.sender && sender.isEqual(qi.params.sender)) {
          qi.callback({ "status": "abort" });
          this._queue[i9] = null;
        }
      }
    }
    abortAll() {
      for (let i9 = 0, len = this._queue.length; i9 < len; i9++) {
        let qi = this._queue[i9];
        if (qi) {
          let sender = qi.params.sender;
          if (sender && this._senderRequestCounter[sender.__id]) {
            this._senderRequestCounter[sender.__id].counter = 0;
            cancelAnimationFrame(this._senderRequestCounter[sender.__id].__requestCounterFrame__);
            this._senderRequestCounter[sender.__id].__requestCounterFrame__ = 0;
          }
          qi.callback({ "status": "abort" });
          this._queue[i9] = null;
        }
      }
      this._queue = [];
    }
    get loading() {
      return this._loading;
    }
    get queue() {
      return this._queue;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/NormalMapCreator.js
  var NormalMapCreator = class {
    constructor(planet, options2 = {}) {
      this._minTabelSize = options2.minTableSize || 1;
      this._maxTableSize = options2.maxTableSize || 8;
      this._planet = planet;
      this._handler = null;
      this._verticesBufferArray = [];
      this._indexBufferArray = [];
      this._positionBuffer = null;
      this._framebuffer = null;
      this._normalMapVerticesTexture = null;
      this._width = options2.width || 128;
      this._height = options2.height || 128;
      this._queue = new QueueArray(1024);
      this._lock = new Lock();
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    init() {
      this._maxTableSize = this._planet.maxGridSize || 8;
      this._handler = this._planet.renderer.handler;
      let isWebkit = false;
      const normalMapBlur = new Program("normalMapBlur", {
        attributes: {
          a_position: "vec2"
        },
        uniforms: {
          s_texture: "sampler2d"
        },
        vertexShader: `attribute vec2 a_position;
                       attribute vec2 a_texCoord;

                      varying vec2 blurCoordinates[5];

                      void main() {
                          vec2 vt = a_position * 0.5 + 0.5; 
                          ${isWebkit ? "vt.y = 1.0 - vt.y; " : " "}
                          gl_Position = vec4(a_position, 0.0, 1.0);
                          blurCoordinates[0] = vt;
                          blurCoordinates[1] = vt + ${1 / this._width * 1.407333};
                          blurCoordinates[2] = vt - ${1 / this._height * 1.407333};
                          blurCoordinates[3] = vt + ${1 / this._width * 3.294215};
                          blurCoordinates[4] = vt - ${1 / this._height * 3.294215};
                }`,
        fragmentShader: `precision lowp float;
                        uniform sampler2D s_texture;                        
                        varying vec2 blurCoordinates[5];                        

                        void main() {
                            lowp vec4 sum = vec4(0.0);
                            //if(blurCoordinates[0].x <= 0.01 || blurCoordinates[0].x >= 0.99 ||
                            //    blurCoordinates[0].y <= 0.01 || blurCoordinates[0].y >= 0.99){
                            //    sum = texture2D(s_texture, blurCoordinates[0]);
                            //} else {
                                sum += texture2D(s_texture, blurCoordinates[0]) * 0.204164;
                                sum += texture2D(s_texture, blurCoordinates[1]) * 0.304005;
                                sum += texture2D(s_texture, blurCoordinates[2]) * 0.304005;
                                sum += texture2D(s_texture, blurCoordinates[3]) * 0.093913;
                                sum += texture2D(s_texture, blurCoordinates[4]) * 0.093913;
                            //}
                            gl_FragColor = sum;
                        }`
      });
      const normalMap = new Program("normalMap", {
        attributes: {
          a_position: "vec2",
          a_normal: "vec3"
        },
        uniforms: {},
        vertexShader: `attribute vec2 a_position;
                      attribute vec3 a_normal;
                      
                      varying vec3 v_color;
                      
                      void main() {
                          gl_Position = vec4(a_position, 0, 1);
                          v_color = normalize(a_normal) * 0.5 + 0.5;
                      }`,
        fragmentShader: `precision highp float;
                        
                        varying vec3 v_color;
                        
                        void main () {
                            gl_FragColor = vec4(v_color, 1.0);
                        }`
      });
      this._handler.addProgram(normalMapBlur);
      this._handler.addProgram(normalMap);
      this._framebuffer = new Framebuffer(this._handler, {
        width: this._width,
        height: this._height,
        useDepth: false
      });
      this._framebuffer.init();
      this._normalMapVerticesTexture = this._handler.createEmptyTexture_l(this._width, this._height);
      for (let p4 = this._minTabelSize; p4 <= this._maxTableSize; p4++) {
        const gs = 1 << p4;
        const gs2 = gs / 2;
        let vertices = new Float32Array((gs + 1) * (gs + 1) * 2);
        for (let i9 = 0; i9 <= gs; i9++) {
          for (let j2 = 0; j2 <= gs; j2++) {
            let ind = (i9 * (gs + 1) + j2) * 2;
            vertices[ind] = -1 + j2 / gs2;
            vertices[ind + 1] = -1 + i9 / gs2;
          }
        }
        this._verticesBufferArray[gs] = this._handler.createArrayBuffer(vertices, 2, vertices.length / 2);
        this._indexBufferArray[gs] = this._planet._indexesCache[Math.log2(gs)][Math.log2(gs)][Math.log2(gs)][Math.log2(gs)][Math.log2(gs)].buffer;
      }
      const positions2 = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
      this._positionBuffer = this._handler.createArrayBuffer(positions2, 2, positions2.length / 2);
    }
    _drawNormalMapBlur(segment) {
      let normals = segment.normalMapNormals;
      if (segment.node && segment.node.getState() !== NOTRENDERING && normals && normals.length) {
        const size = normals.length / 3;
        const gridSize = Math.sqrt(size) - 1;
        let indBuf = this._verticesBufferArray[gridSize];
        if (indBuf) {
          if (segment.planet.terrain.equalizeNormals) {
            segment._normalMapEdgeEqualize(N);
            segment._normalMapEdgeEqualize(S);
            segment._normalMapEdgeEqualize(W2);
            segment._normalMapEdgeEqualize(E);
          }
          let outTexture = segment.normalMapTexturePtr;
          const h8 = this._handler;
          const gl = h8.gl;
          let _normalsBuffer = h8.createArrayBuffer(normals, 3, size, gl.DYNAMIC_DRAW);
          const f8 = this._framebuffer;
          let p4 = h8.programs.normalMap;
          let sha = p4._program.attributes;
          f8.bindOutputTexture(this._normalMapVerticesTexture);
          p4.activate();
          gl.bindBuffer(gl.ARRAY_BUFFER, indBuf);
          gl.vertexAttribPointer(sha.a_position, indBuf.itemSize, gl.FLOAT, false, 0, 0);
          gl.bindBuffer(gl.ARRAY_BUFFER, _normalsBuffer);
          gl.vertexAttribPointer(sha.a_normal, _normalsBuffer.itemSize, gl.FLOAT, false, 0, 0);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBufferArray[gridSize]);
          gl.drawElements(gl.TRIANGLE_STRIP, this._indexBufferArray[gridSize].numItems, gl.UNSIGNED_INT, 0);
          gl.deleteBuffer(_normalsBuffer);
          f8.bindOutputTexture(outTexture);
          p4 = h8.programs.normalMapBlur;
          p4.activate();
          gl.bindBuffer(gl.ARRAY_BUFFER, this._positionBuffer);
          gl.vertexAttribPointer(p4._program.attributes.a_position, this._positionBuffer.itemSize, gl.FLOAT, false, 0, 0);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, this._normalMapVerticesTexture);
          gl.uniform1i(p4._program.uniforms.s_texture, 0);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, this._positionBuffer.numItems);
          return true;
        } else {
          return true;
        }
      }
      return false;
    }
    _drawNormalMapNoBlur(segment) {
      let normals = segment.normalMapNormals;
      if (segment.node && segment.node.getState() !== NOTRENDERING && normals && normals.length) {
        const size = normals.length / 3;
        const gridSize = Math.sqrt(size) - 1;
        let indBuf = this._verticesBufferArray[gridSize];
        if (indBuf) {
          if (segment.planet.terrain.equalizeNormals) {
            segment._normalMapEdgeEqualize(N);
            segment._normalMapEdgeEqualize(S);
            segment._normalMapEdgeEqualize(W2);
            segment._normalMapEdgeEqualize(E);
          }
          let outTexture = segment.normalMapTexturePtr;
          const h8 = this._handler;
          const gl = h8.gl;
          let _normalsBuffer = h8.createArrayBuffer(normals, 3, size, gl.DYNAMIC_DRAW);
          const f8 = this._framebuffer;
          const p4 = h8.programs.normalMap;
          const sha = p4._program.attributes;
          f8.bindOutputTexture(outTexture);
          p4.activate();
          gl.bindBuffer(gl.ARRAY_BUFFER, indBuf);
          gl.vertexAttribPointer(sha.a_position, indBuf.itemSize, gl.FLOAT, false, 0, 0);
          gl.bindBuffer(gl.ARRAY_BUFFER, _normalsBuffer);
          gl.vertexAttribPointer(sha.a_normal, _normalsBuffer.itemSize, gl.FLOAT, false, 0, 0);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBufferArray[gridSize]);
          gl.drawElements(gl.TRIANGLE_STRIP, this._indexBufferArray[gridSize].numItems, gl.UNSIGNED_INT, 0);
          gl.deleteBuffer(_normalsBuffer);
          return true;
        } else {
          return true;
        }
      }
      return false;
    }
    _drawNormalMap(segment) {
      if (segment.planet.terrain.isBlur(segment)) {
        return this._drawNormalMapBlur(segment);
      } else {
        return this._drawNormalMapNoBlur(segment);
      }
    }
    drawSingle(segment) {
      const h8 = this._handler;
      const gl = h8.gl;
      this._framebuffer.activate();
      gl.disable(gl.CULL_FACE);
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.BLEND);
      if (segment.terrainReady && this._drawNormalMap(segment)) {
        segment.normalMapReady = true;
        segment.normalMapTexture = segment.normalMapTexturePtr;
        segment.normalMapTextureBias[0] = 0;
        segment.normalMapTextureBias[1] = 0;
        segment.normalMapTextureBias[2] = 1;
      }
      segment._inTheQueue = false;
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.CULL_FACE);
      gl.enable(gl.BLEND);
      this._framebuffer.deactivate();
    }
    frame() {
      if (this._queue.length) {
        const h8 = this._handler;
        const gl = h8.gl;
        this._framebuffer.activate();
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
        let deltaTime = 0, startTime = window.performance.now();
        while (this._lock.isFree() && this._queue.length && deltaTime < 0.25) {
          const segment = this._queue.shift();
          if (segment.terrainReady && this._drawNormalMap(segment)) {
            segment.normalMapReady = true;
            segment.normalMapTexture = segment.normalMapTexturePtr;
            segment.normalMapTextureBias[0] = 0;
            segment.normalMapTextureBias[1] = 0;
            segment.normalMapTextureBias[2] = 1;
          }
          segment._inTheQueue = false;
          deltaTime = window.performance.now() - startTime;
        }
        gl.enable(gl.BLEND);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);
        this._framebuffer.deactivate();
      }
    }
    get queueSize() {
      return this._queue.length;
    }
    queue(segment) {
      segment._inTheQueue = true;
      this._queue.push(segment);
    }
    unshift(segment) {
      segment._inTheQueue = true;
      this._queue.unshift(segment);
    }
    remove(segment) {
    }
    clear() {
      while (this._queue.length) {
        let s7 = this._queue.pop();
        s7._inTheQueue = false;
      }
    }
    /**
     * Set activity off
     * @public
     */
    lock(key) {
      this._lock.lock(key);
    }
    /**
     * Set activity on
     * @public
     */
    free(key) {
      this._lock.free(key);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/PlainSegmentWorker.js
  var PlainSegmentWorker = class extends BaseWorker {
    constructor(numWorkers = 2) {
      super(numWorkers, PLAIN_SEGMENT_PROGRAM);
    }
    _onMessage(e9) {
      this._source.get(e9.data.id)._plainSegmentWorkerCallback(e9.data);
      e9.data.plainVertices = null;
      e9.data.plainVerticesHigh = null;
      e9.data.plainVerticesLow = null;
      e9.data.plainNormals = null;
      e9.data.normalMapNormals = null;
      e9.data.normalMapVertices = null;
      e9.data.normalMapVerticesHigh = null;
      e9.data.normalMapVerticesLow = null;
      this._source.delete(e9.data.id);
    }
    setGeoid(geoid) {
      if (geoid.model) {
        let m5 = geoid.model;
        let model = {
          scale: m5.scale,
          offset: m5.offset,
          width: m5.width,
          height: m5.height,
          rlonres: m5.rlonres,
          rlatres: m5.rlatres,
          i: m5.i
        };
        this._workerQueue.forEach((w3) => {
          let rawfile = new Uint8Array(m5.rawfile.length);
          rawfile.set(m5.rawfile);
          w3.postMessage({
            model,
            rawfile
          }, [
            rawfile.buffer
          ]);
        });
      } else {
        this._workerQueue.forEach((w3) => {
          w3.postMessage({
            model: null
          });
        });
      }
    }
    make(segment) {
      if (segment.initialized) {
        if (this._workerQueue.length) {
          let w3 = this._workerQueue.pop();
          this._source.set(this._sourceId, segment);
          let params = new Float64Array([
            this._sourceId,
            segment._projection.id === EPSG4326.id ? 1 : 0,
            segment.planet.terrain.gridSizeByZoom[segment.tileZoom],
            segment.planet.terrain.plainGridSize,
            segment._extent.southWest.lon,
            segment._extent.southWest.lat,
            segment._extent.northEast.lon,
            segment._extent.northEast.lat,
            // @ts-ignore
            segment.planet.ellipsoid._e2,
            segment.planet.ellipsoid.equatorialSize,
            segment.planet.ellipsoid._invRadii2.x,
            segment.planet.ellipsoid._invRadii2.y,
            segment.planet.ellipsoid._invRadii2.z,
            segment.planet._heightFactor
          ]);
          this._sourceId++;
          w3.postMessage({
            params
          }, [
            params.buffer
          ]);
        } else {
          this._pendingQueue.push(segment);
        }
      } else {
        this.check();
      }
    }
  };
  var PLAIN_SEGMENT_PROGRAM = `
    'use strict';
    
    let model = null;

    let cached_ix = null;
    let cached_iy = null;
    let v00 = null;
    let v01 = null;
    let v10 = null;
    let v11 = null;
    let t = null;

    function rawval(ix, iy) {

        if (iy < 0) {
            iy = -iy;
            ix += model.width / 2;
        } else if (iy >= model.height) {
            iy = 2 * (model.height - 1) - iy;
            ix += model.width / 2;
        }

        if (ix < 0) {
            ix += model.width;
        } else if (ix >= model.width) {
            ix -= model.width;
        }

        var k = (iy * model.width + ix) * 2 + model.i;

        return (model.rawfile[k] << 8) | model.rawfile[k + 1];
    };

    function getHeightMSL(lon, lat) {

        if (!model) return 0;

        if (lon < 0) lon += 360.0;

        var fy = (90 - lat) * model.rlatres;
        var fx = lon * model.rlonres;
        var iy = Math.floor(fy);
        var ix = Math.floor(fx);

        fx -= ix;
        fy -= iy;

        if (iy === (model.height - 1)) {
            iy--;
        }

        if ((cached_ix !== ix) || (cached_iy !== iy)) {

            cached_ix = ix;
            cached_iy = iy;

            v00 = rawval(ix, iy);
            v01 = rawval(ix + 1, iy);
            v10 = rawval(ix, iy + 1);
            v11 = rawval(ix + 1, iy + 1);
        }

        let h = null;

        var a = (1 - fx) * v00 + fx * v01;
        var b = (1 - fx) * v10 + fx * v11;

        h = (1 - fy) * a + fy * b;

        return model.offset + model.scale * h;
    };

    const HALF_PI = Math.PI * 0.5;
    const POLE = 20037508.34;
    const PI_BY_POLE = Math.PI / POLE;
    const INV_POLE_BY_180 = 180.0 / POLE;
    const INV_PI_BY_180 = 180.0 / Math.PI;
    const INV_PI_BY_180_HALF_PI = INV_PI_BY_180 * HALF_PI;
    const RADIANS = Math.PI / 180.0;
    const INV_PI_BY_360 = INV_PI_BY_180 * 2.0;

    let E2 = 0.0,
        A = 0.0;

    let _projFunc = null;

    const Vec3 = function (x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    };

    var geodeticToCartesian = function (lon, lat, heightFactor, res) {

        let h = getHeightMSL(lon, lat) * heightFactor;

        let latrad = RADIANS * lat,
            lonrad = RADIANS * lon;

        let slt = Math.sin(latrad);

        let N = A / Math.sqrt(1.0 - E2 * slt * slt);
        let nc = (N + h) * Math.cos(latrad);       
           
        res.x = nc * Math.cos(lonrad);
        res.y = nc * Math.sin(lonrad);
        res.z = (N * (1 - E2) + h) * slt;
    };

    var geodeticToCartesianInverse = function (lon, lat, heightFactor, res){
        geodeticToCartesian(
            lon * INV_POLE_BY_180,
            INV_PI_BY_360 * Math.atan(Math.exp(lat * PI_BY_POLE)) - INV_PI_BY_180_HALF_PI,
            heightFactor,
            res);
    };

    var v = new Vec3(0.0, 0.0, 0.0);
    var _tempHigh = new Vec3(0.0, 0.0, 0.0);
    var _tempLow = new Vec3(0.0, 0.0, 0.0);

    var doubleToTwoFloats = function(v, high, low) {

        let x = v.x, y = v.y, z = v.z;
    
        if (x >= 0.0) {
            var doubleHigh = Math.floor(x / 65536.0) * 65536.0;
            high.x = Math.fround(doubleHigh);
            low.x = Math.fround(x - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
            high.x = Math.fround(-doubleHigh);
            low.x = Math.fround(x + doubleHigh);
        }

        if (y >= 0.0) {
            var doubleHigh = Math.floor(y / 65536.0) * 65536.0;
            high.y = Math.fround(doubleHigh);
            low.y = Math.fround(y - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
            high.y = Math.fround(-doubleHigh);
            low.y = Math.fround(y + doubleHigh);
        }

        if (z >= 0.0) {
            var doubleHigh = Math.floor(z / 65536.0) * 65536.0;
            high.z = Math.fround(doubleHigh);
            low.z = Math.fround(z - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-z / 65536.0) * 65536.0;
            high.z = Math.fround(-doubleHigh);
            low.z = Math.fround(z + doubleHigh);
        }
    };

    self.onmessage = function (msg) {
        if(msg.data.model) {
            model = msg.data.model;
            model.rawfile = msg.data.rawfile;
        } else if(msg.data.params) {

            let xmin = 549755748352.0, xmax = -549755748352.0, 
                ymin = 549755748352.0, ymax = -549755748352.0, 
                zmin = 549755748352.0, zmax = -549755748352.0;

            E2 = msg.data.params[8];
            A = msg.data.params[9];

            let gridSize = msg.data.params[2],
                fgs = msg.data.params[3],
                r2_x = msg.data.params[10],
                r2_y = msg.data.params[11],
                r2_z = msg.data.params[12];

            let heightFactor =  msg.data.params[13];
        
            if(msg.data.params[1] === 0.0){
                _projFunc = geodeticToCartesianInverse;
            }else{
                _projFunc = geodeticToCartesian;
            }

            let maxFgs = Math.max(fgs, gridSize);
            let llStep = (msg.data.params[6] - msg.data.params[4]) / maxFgs;
            let ltStep = (msg.data.params[7] - msg.data.params[5]) / maxFgs;

            let esw_lon = msg.data.params[4],
                ene_lat = msg.data.params[7];

            let dg = Math.max(fgs / gridSize, 1.0),
                gs = maxFgs + 1;
            
            const gsgs = gs * gs;

            const gridSize3 = (gridSize + 1) * (gridSize + 1) * 3;

            let plainNormals = new Float32Array(gridSize3);

            let plainVertices = new Float64Array(gridSize3);
            let plainVerticesHigh = new Float32Array(gridSize3);
            let plainVerticesLow = new Float32Array(gridSize3);

            let normalMapNormals = new Float32Array(gsgs * 3);

            let normalMapVertices = new Float64Array(gsgs * 3);
            let normalMapVerticesHigh = new Float32Array(gsgs * 3);
            let normalMapVerticesLow = new Float32Array(gsgs * 3);

            let ind = 0,
                nmInd = 0;

            for (let k = 0; k < gsgs; k++) {

                let j = k % gs,
                    i = ~~(k / gs);

                _projFunc(esw_lon + j * llStep, ene_lat - i * ltStep, heightFactor, v);

                let nx = v.x * r2_x, ny = v.y * r2_y, nz = v.z * r2_z;
                let l = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);            
                let nxl = nx * l,
                    nyl = ny * l,
                    nzl = nz * l;

                doubleToTwoFloats(v, _tempHigh, _tempLow);

                normalMapVertices[nmInd] = v.x;
                normalMapVerticesHigh[nmInd] = _tempHigh.x;
                normalMapVerticesLow[nmInd] = _tempLow.x;
                normalMapNormals[nmInd++] = nxl;

                normalMapVertices[nmInd] = v.y;
                normalMapVerticesHigh[nmInd] = _tempHigh.y;
                normalMapVerticesLow[nmInd] = _tempLow.y;
                normalMapNormals[nmInd++] = nyl;

                normalMapVertices[nmInd] = v.z;
                normalMapVerticesHigh[nmInd] = _tempHigh.z;
                normalMapVerticesLow[nmInd] = _tempLow.z;
                normalMapNormals[nmInd++] = nzl;

                if (i % dg === 0 && j % dg === 0) {
                    plainVertices[ind] = v.x;
                    plainVerticesHigh[ind] = _tempHigh.x;
                    plainVerticesLow[ind] = _tempLow.x;
                    plainNormals[ind++] = nxl;

                    plainVertices[ind] = v.y;
                    plainVerticesHigh[ind] = _tempHigh.y;
                    plainVerticesLow[ind] = _tempLow.y;
                    plainNormals[ind++] = nyl;

                    plainVertices[ind] = v.z;
                    plainVerticesHigh[ind] = _tempHigh.z;
                    plainVerticesLow[ind] = _tempLow.z;
                    plainNormals[ind++] = nzl;

                    if (v.x < xmin) xmin = v.x; if (v.x > xmax) xmax = v.x;
                    if (v.y < ymin) ymin = v.y; if (v.y > ymax) ymax = v.y;
                    if (v.z < zmin) zmin = v.z; if (v.z > zmax) zmax = v.z;
                }
            }

            let x = (xmax - xmin) * 0.5,
                y = (ymax - ymin) * 0.5,
                z = (zmax - zmin) * 0.5;

            let plainRadius = Math.sqrt(x * x + y * y + z * z);

            self.postMessage({
                id: msg.data.params[0],
                plainVertices: plainVertices,
                plainVerticesHigh: plainVerticesHigh,
                plainVerticesLow: plainVerticesLow,
                plainNormals: plainNormals,
                normalMapNormals: normalMapNormals,
                normalMapVertices: normalMapVertices,
                normalMapVerticesHigh: normalMapVerticesHigh,
                normalMapVerticesLow: normalMapVerticesLow,
                plainRadius: plainRadius
             }, [
                plainVertices.buffer,
                plainVerticesHigh.buffer,
                plainVerticesLow.buffer,
                plainNormals.buffer,
                normalMapNormals.buffer,
                normalMapVertices.buffer,
                normalMapVerticesHigh.buffer,
                normalMapVerticesLow.buffer
            ]);
        }
    }`;

  // frontend/node_modules/@openglobus/og/lib/js/camera/Frustum.js
  function planeNormalize(plane) {
    let t9 = 1 / Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
    plane[0] *= t9;
    plane[1] *= t9;
    plane[2] *= t9;
    plane[3] *= t9;
  }
  var Frustum = class {
    constructor(options2 = {}) {
      this._pickingColorU = new Float32Array([0, 0, 0]);
      this._f = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
      this.projectionMatrix = new Mat4();
      this.inverseProjectionMatrix = new Mat4();
      this.projectionViewMatrix = new Mat4();
      this.inverseProjectionViewMatrix = new Mat4();
      this.left = 0;
      this.right = 0;
      this.bottom = 0;
      this.top = 0;
      this.near = 0;
      this.far = 0;
      this.cameraFrustumIndex = options2.cameraFrustumIndex != void 0 ? options2.cameraFrustumIndex : -1;
      this.setProjectionMatrix(options2.fov || 30, options2.aspect || 1, options2.near || 1, options2.far || 1e3);
    }
    getRightPlane() {
      return this._f[0];
    }
    getLeftPlane() {
      return this._f[1];
    }
    getBottomPlane() {
      return this._f[2];
    }
    getTopPlane() {
      return this._f[3];
    }
    getBackwardPlane() {
      return this._f[4];
    }
    getForwardPlane() {
      return this._f[5];
    }
    getProjectionViewMatrix() {
      return this.projectionViewMatrix._m;
    }
    getProjectionMatrix() {
      return this.projectionMatrix._m;
    }
    getInverseProjectionMatrix() {
      return this.inverseProjectionMatrix._m;
    }
    /**
     * Sets up camera projection matrix.
     * @public
     * @param {number} angle - Camera's view angle.
     * @param {number} aspect - Screen aspect ratio.
     * @param {number} near - Near camera distance.
     * @param {number} far - Far camera distance.
     */
    setProjectionMatrix(angle, aspect, near, far) {
      this.top = near * Math.tan(angle * RADIANS_HALF);
      this.bottom = -this.top;
      this.right = this.top * aspect;
      this.left = -this.right;
      this.near = near;
      this.far = far;
      this.projectionMatrix.setPerspective(this.left, this.right, this.bottom, this.top, near, far);
      this.projectionMatrix.inverseTo(this.inverseProjectionMatrix);
    }
    /**
     * Camera's projection matrix values.
     * @public
     * @param {Mat4} viewMatrix - View matrix.
     */
    setViewMatrix(viewMatrix) {
      this.projectionViewMatrix = this.projectionMatrix.mul(viewMatrix);
      this.projectionViewMatrix.inverseTo(this.inverseProjectionViewMatrix);
      let m5 = this.projectionViewMatrix._m;
      this._f[0][0] = m5[3] - m5[0];
      this._f[0][1] = m5[7] - m5[4];
      this._f[0][2] = m5[11] - m5[8];
      this._f[0][3] = m5[15] - m5[12];
      planeNormalize(this._f[0]);
      this._f[1][0] = m5[3] + m5[0];
      this._f[1][1] = m5[7] + m5[4];
      this._f[1][2] = m5[11] + m5[8];
      this._f[1][3] = m5[15] + m5[12];
      planeNormalize(this._f[1]);
      this._f[2][0] = m5[3] + m5[1];
      this._f[2][1] = m5[7] + m5[5];
      this._f[2][2] = m5[11] + m5[9];
      this._f[2][3] = m5[15] + m5[13];
      planeNormalize(this._f[2]);
      this._f[3][0] = m5[3] - m5[1];
      this._f[3][1] = m5[7] - m5[5];
      this._f[3][2] = m5[11] - m5[9];
      this._f[3][3] = m5[15] - m5[13];
      planeNormalize(this._f[3]);
      this._f[4][0] = m5[3] - m5[2];
      this._f[4][1] = m5[7] - m5[6];
      this._f[4][2] = m5[11] - m5[10];
      this._f[4][3] = m5[15] - m5[14];
      planeNormalize(this._f[4]);
      this._f[5][0] = m5[3] + m5[2];
      this._f[5][1] = m5[7] + m5[6];
      this._f[5][2] = m5[11] + m5[10];
      this._f[5][3] = m5[15] + m5[14];
      planeNormalize(this._f[5]);
    }
    /**
     * Returns true if a point in the frustum.
     * @public
     * @param {Vec3} point - Cartesian point.
     * @returns {boolean} -
     */
    containsPoint(point) {
      for (let p4 = 0; p4 < 6; p4++) {
        let d4 = point.dotArr(this._f[p4]) + this._f[p4][3];
        if (d4 <= 0) {
          return false;
        }
      }
      return true;
    }
    /**
     * Returns true if the frustum contains a bonding sphere, but bottom plane exclude.
     * @public
     * @param {Sphere} sphere - Bounding sphere.
     * @returns {boolean} -
     */
    containsSphereBottomExc(sphere) {
      let r8 = -sphere.radius, f8 = this._f;
      if (sphere.center.dotArr(f8[0]) + f8[0][3] <= r8)
        return false;
      if (sphere.center.dotArr(f8[1]) + f8[1][3] <= r8)
        return false;
      if (sphere.center.dotArr(f8[3]) + f8[3][3] <= r8)
        return false;
      if (sphere.center.dotArr(f8[4]) + f8[4][3] <= r8)
        return false;
      if (sphere.center.dotArr(f8[5]) + f8[5][3] <= r8)
        return false;
      return true;
    }
    containsSphereButtom(sphere) {
      let r8 = -sphere.radius, f8 = this._f;
      if (sphere.center.dotArr(f8[2]) + f8[2][3] <= r8)
        return false;
      return true;
    }
    /**
     * Returns true if the frustum contains a bonding sphere.
     * @public
     * @param {Sphere} sphere - Bounding sphere.
     * @returns {boolean} -
     */
    containsSphere(sphere) {
      let r8 = -sphere.radius, f8 = this._f;
      if (sphere.center.dotArr(f8[0]) + f8[0][3] <= r8)
        return false;
      if (sphere.center.dotArr(f8[1]) + f8[1][3] <= r8)
        return false;
      if (sphere.center.dotArr(f8[2]) + f8[2][3] <= r8)
        return false;
      if (sphere.center.dotArr(f8[3]) + f8[3][3] <= r8)
        return false;
      if (sphere.center.dotArr(f8[4]) + f8[4][3] <= r8)
        return false;
      if (sphere.center.dotArr(f8[5]) + f8[5][3] <= r8)
        return false;
      return true;
    }
    /**
     * Returns true if the frustum contains a bonding sphere.
     * @public
     * @param {Vec3} center - Sphere center.
     * @param {number} radius - Sphere radius.
     * @returns {boolean} -
     */
    containsSphere2(center, radius) {
      let r8 = -radius;
      if (center.dotArr(this._f[0]) + this._f[0][3] <= r8)
        return false;
      if (center.dotArr(this._f[1]) + this._f[1][3] <= r8)
        return false;
      if (center.dotArr(this._f[2]) + this._f[2][3] <= r8)
        return false;
      if (center.dotArr(this._f[3]) + this._f[3][3] <= r8)
        return false;
      if (center.dotArr(this._f[4]) + this._f[4][3] <= r8)
        return false;
      if (center.dotArr(this._f[5]) + this._f[5][3] <= r8)
        return false;
      return true;
    }
    /**
     * Returns true if the frustum contains a bounding box.
     * @public
     * @param {Box} box - Bounding box.
     * @returns {boolean} -
     */
    containsBox(box) {
      let result = true, cout, cin;
      for (let i9 = 0; i9 < 6; i9++) {
        cout = 0;
        cin = 0;
        for (let k3 = 0; k3 < 8 && (cin === 0 || cout === 0); k3++) {
          let d4 = box.vertices[k3].dotArr(this._f[i9]) + this._f[i9][3];
          if (d4 < 0) {
            cout++;
          } else {
            cin++;
          }
        }
        if (cin === 0) {
          return false;
        } else if (cout > 0) {
          result = true;
        }
      }
      return result;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/camera/Camera.js
  var EVENT_NAMES2 = [
    /**
     * When camera has been updated.
     * @event og.Camera#viewchange
     */
    "viewchange",
    /**
     * Camera is stopped.
     * @event og.Camera#moveend
     */
    "moveend"
  ];
  var Camera = class {
    constructor(renderer, options2 = {}) {
      this.renderer = renderer;
      this.events = createEvents(EVENT_NAMES2, this);
      this.eye = options2.eye || new Vec3();
      this.eyeHigh = new Float32Array(3);
      this.eyeLow = new Float32Array(3);
      this._aspect = options2.aspect || 1;
      this._viewAngle = options2.viewAngle || 47;
      this._viewMatrix = new Mat4();
      this._normalMatrix = new Mat3();
      this._r = new Vec3(1, 0, 0);
      this._u = new Vec3(0, 1, 0);
      this._b = new Vec3(0, 0, 1);
      this._pr = this._r.clone();
      this._pu = this._u.clone();
      this._pb = this._b.clone();
      this._peye = this.eye.clone();
      this.isMoving = false;
      this._tanViewAngle_hrad = 0;
      this._tanViewAngle_hradOneByHeight = 0;
      this.frustums = [];
      this.frustumColors = [];
      if (options2.frustums) {
        for (let i9 = 0, len = options2.frustums.length; i9 < len; i9++) {
          let fi = options2.frustums[i9];
          let fr = new Frustum({
            fov: this._viewAngle,
            aspect: this._aspect,
            near: fi[0],
            far: fi[1]
          });
          fr.cameraFrustumIndex = this.frustums.length;
          this.frustums.push(fr);
          this.frustumColors.push(fr._pickingColorU[0], fr._pickingColorU[1], fr._pickingColorU[2]);
        }
      } else {
        let near = 1, far = 1e4;
        let fr = new Frustum({
          fov: this._viewAngle,
          aspect: this._aspect,
          near,
          far
        });
        fr.cameraFrustumIndex = this.frustums.length;
        this.frustums.push(fr);
        this.frustumColors.push(fr._pickingColorU[0], fr._pickingColorU[1], fr._pickingColorU[2]);
      }
      this.FARTHEST_FRUSTUM_INDEX = this.frustums.length - 1;
      this.currentFrustumIndex = 0;
      this.isFirstPass = false;
      this._projSizeConst = 0;
      this.set(options2.eye || new Vec3(0, 0, 1), options2.look || new Vec3(), options2.up || new Vec3(0, 1, 0));
    }
    checkMoveEnd() {
      let r8 = this._r, u4 = this._u, b4 = this._b, eye = this.eye;
      if (this._peye.equal(eye) && this._pr.equal(r8) && this._pu.equal(u4) && this._pb.equal(b4)) {
        if (this.isMoving) {
          this.events.dispatch(this.events.moveend, this);
        }
        this.isMoving = false;
      } else {
        this.isMoving = true;
      }
      this._pr.copy(r8);
      this._pu.copy(u4);
      this._pb.copy(b4);
      this._peye.copy(eye);
    }
    bindRenderer(renderer) {
      this.renderer = renderer;
      for (let i9 = 0; i9 < this.frustums.length; i9++) {
        this.renderer.assignPickingColor(this.frustums[i9]);
      }
      this._aspect = this.renderer.handler.getClientAspect();
      this._setProj(this._viewAngle, this._aspect);
    }
    /**
     * Camera initialization.
     * @public
     * @param {Object} [options] - Camera options:
     * @param {number} [options.viewAngle] - Camera angle of view.
     * @param {number} [options.near] - Camera near plane distance. Default is 1.0
     * @param {number} [options.far] - Camera far plane distance. Default is math.MAX
     * @param {Vec3} [options.eye] - Camera eye position. Default (0,0,0)
     * @param {Vec3} [options.look] - Camera look position. Default (0,0,0)
     * @param {Vec3} [options.up] - Camera eye position. Default (0,1,0)
     */
    _init(options2) {
      this._setProj(this._viewAngle, this._aspect);
      this.set(options2.eye || new Vec3(0, 0, 1), options2.look || new Vec3(), options2.up || new Vec3(0, 1, 0));
    }
    getUp() {
      return this._u.clone();
    }
    getDown() {
      return this._u.negateTo();
    }
    getRight() {
      return this._r.clone();
    }
    getLeft() {
      return this._r.negateTo();
    }
    getForward() {
      return this._b.negateTo();
    }
    getBackward() {
      return this._b.clone();
    }
    /**
     * Updates camera view space
     * @public
     * @virtual
     */
    update() {
      let u4 = this._r, v4 = this._u, n7 = this._b, eye = this.eye;
      Vec3.doubleToTwoFloat32Array(eye, this.eyeHigh, this.eyeLow);
      this._viewMatrix.set([
        u4.x,
        v4.x,
        n7.x,
        0,
        u4.y,
        v4.y,
        n7.y,
        0,
        u4.z,
        v4.z,
        n7.z,
        0,
        -eye.dot(u4),
        -eye.dot(v4),
        -eye.dot(n7),
        1
      ]);
      for (let i9 = 0, len = this.frustums.length; i9 < len; i9++) {
        this.frustums[i9].setViewMatrix(this._viewMatrix);
      }
      this.events.dispatch(this.events.viewchange, this);
    }
    /**
     * Refresh camera matrices
     * @public
     */
    refresh() {
      this._setProj(this._viewAngle, this._aspect);
      this.update();
    }
    /**
     * Sets aspect ratio
     * @public
     * @param {Number} aspect - Camera aspect ratio
     */
    setAspectRatio(aspect) {
      this._aspect = aspect;
      this.refresh();
    }
    /**
     * Returns aspect ratio
     * @public
     * @returns {number} - Aspect ratio
     */
    getAspectRatio() {
      return this._aspect;
    }
    /**
     * Sets up camera projection
     * @public
     * @param {number} angle - Camera view angle
     * @param {number} aspect - Screen aspect ratio
     */
    _setProj(angle, aspect) {
      this._viewAngle = angle;
      this._aspect = aspect;
      this._tanViewAngle_hrad = Math.tan(angle * RADIANS_HALF);
      this._tanViewAngle_hradOneByHeight = this._tanViewAngle_hrad * this.renderer.handler._oneByHeight;
      let c7 = this.renderer.handler.canvas;
      this._projSizeConst = Math.min(c7.clientWidth < 512 ? 512 : c7.clientWidth, c7.clientHeight < 512 ? 512 : c7.clientHeight) / (angle * RADIANS);
      for (let i9 = 0, len = this.frustums.length; i9 < len; i9++) {
        this.frustums[i9].setProjectionMatrix(angle, aspect, this.frustums[i9].near, this.frustums[i9].far);
      }
    }
    /**
     * Sets camera view angle in degrees
     * @public
     * @param {number} angle - View angle
     */
    setViewAngle(angle) {
      this._viewAngle = angle;
      this.refresh();
    }
    /**
     * Gets camera view angle in degrees
     * @public
     * @returns {number} angle -
     */
    getViewAngle() {
      return this._viewAngle;
    }
    get viewAngle() {
      return this._viewAngle;
    }
    /**
     * Sets camera to eye position
     * @public
     * @param {Vec3} eye - Camera position
     * @param {Vec3} look - Look point
     * @param {Vec3} up - Camera up vector
     * @returns {Camera} - This camera
     */
    set(eye, look, up) {
      this.eye.x = eye.x;
      this.eye.y = eye.y;
      this.eye.z = eye.z;
      look = look || this._b;
      up = up || this._u;
      this._b.x = eye.x - look.x;
      this._b.y = eye.y - look.y;
      this._b.z = eye.z - look.z;
      this._r.copy(up.cross(this._b));
      this._b.normalize();
      this._r.normalize();
      this._u.copy(this._b.cross(this._r));
      return this;
    }
    /**
     * Sets camera look point
     * @public
     * @param {Vec3} look - Look point
     * @param {Vec3} [up] - Camera up vector otherwise camera current up vector(this._u)
     */
    look(look, up) {
      this._b.set(this.eye.x - look.x, this.eye.y - look.y, this.eye.z - look.z);
      this._r.copy((up || this._u).cross(this._b));
      this._b.normalize();
      this._r.normalize();
      this._u.copy(this._b.cross(this._r));
    }
    /**
     * Slides camera to vector d - (du, dv, dn)
     * @public
     * @param {number} du - delta X
     * @param {number} dv - delta Y
     * @param {number} dn - delta Z
     */
    slide(du, dv, dn) {
      this.eye.x += du * this._r.x + dv * this._u.x + dn * this._b.x;
      this.eye.y += du * this._r.y + dv * this._u.y + dn * this._b.y;
      this.eye.z += du * this._r.z + dv * this._u.z + dn * this._b.z;
    }
    /**
     * Roll the camera to the angle in degrees
     * @public
     * @param {number} angle - Delta roll angle in degrees
     */
    roll(angle) {
      let cs = Math.cos(RADIANS * angle);
      let sn = Math.sin(RADIANS * angle);
      let t9 = this._r.clone();
      this._r.set(cs * t9.x - sn * this._u.x, cs * t9.y - sn * this._u.y, cs * t9.z - sn * this._u.z);
      this._u.set(sn * t9.x + cs * this._u.x, sn * t9.y + cs * this._u.y, sn * t9.z + cs * this._u.z);
    }
    /**
     * Pitch the camera to the angle in degrees
     * @public
     * @param {number} angle - Delta pitch angle in degrees
     */
    pitch(angle) {
      let cs = Math.cos(RADIANS * angle);
      let sn = Math.sin(RADIANS * angle);
      let t9 = this._b.clone();
      this._b.set(cs * t9.x - sn * this._u.x, cs * t9.y - sn * this._u.y, cs * t9.z - sn * this._u.z);
      this._u.set(sn * t9.x + cs * this._u.x, sn * t9.y + cs * this._u.y, sn * t9.z + cs * this._u.z);
    }
    /**
     * Yaw the camera to the angle in degrees
     * @public
     * @param {number} angle - Delta yaw angle in degrees
     */
    yaw(angle) {
      let cs = Math.cos(RADIANS * angle);
      let sn = Math.sin(RADIANS * angle);
      let t9 = this._r.clone();
      this._r.set(cs * t9.x - sn * this._b.x, cs * t9.y - sn * this._b.y, cs * t9.z - sn * this._b.z);
      this._b.set(sn * t9.x + cs * this._b.x, sn * t9.y + cs * this._b.y, sn * t9.z + cs * this._b.z);
    }
    /**
     * Returns normal vector direction to the unprojected screen point from camera eye
     * @public
     * @param {number} x - Screen X coordinate
     * @param {number} y - Screen Y coordinate
     * @returns {Vec3} - Direction vector
     */
    unproject(x3, y4) {
      let c7 = this.renderer.handler.canvas, w3 = c7.width * 0.5, h8 = c7.height * 0.5;
      let px = (x3 - w3) / w3, py = -(y4 - h8) / h8;
      let world1 = this.frustums[0].inverseProjectionViewMatrix.mulVec4(new Vec4(px, py, -1, 1)).affinity(), world2 = this.frustums[0].inverseProjectionViewMatrix.mulVec4(new Vec4(px, py, 0, 1)).affinity();
      return world2.subA(world1).toVec3().normalize();
    }
    /**
     * Gets projected 3d point to the 2d screen coordinates
     * @public
     * @param {Vec3} v - Cartesian 3d coordinates
     * @returns {Vec2} - Screen point coordinates
     */
    project(v4) {
      let r8 = this.frustums[0].projectionViewMatrix.mulVec4(v4.toVec4()), c7 = this.renderer.handler.canvas;
      return new Vec2((1 + r8.x / r8.w) * c7.width * 0.5, (1 - r8.y / r8.w) * c7.height * 0.5);
    }
    /**
     * Rotates camera around center point
     * @public
     * @param {number} angle - Rotation angle in radians
     * @param {boolean} [isArc] - If true camera up vector gets from current up vector every frame,
     * otherwise up is always input parameter.
     * @param {Vec3} [center] - Point that the camera rotates around
     * @param {Vec3} [up] - Camera up vector
     */
    rotateAround(angle, isArc, center, up) {
      center = center || Vec3.ZERO;
      up = up || Vec3.UP;
      let rot = new Mat4().setRotation(isArc ? this._u : up, angle);
      let tr = new Mat4().setIdentity().translate(center);
      let ntr = new Mat4().setIdentity().translate(center.negateTo());
      let trm = tr.mul(rot).mul(ntr);
      this.eye = trm.mulVec3(this.eye);
      this._u = rot.mulVec3(this._u).normalize();
      this._r = rot.mulVec3(this._r).normalize();
      this._b = rot.mulVec3(this._b).normalize();
    }
    /**
     * Rotates camera around center point by horizontal.
     * @public
     * @param {number} angle - Rotation angle in radians.
     * @param {boolean} [isArc] - If true camera up vector gets from current up vector every frame,
     * otherwise up is always input parameter.
     * @param {Vec3} [center] - Point that the camera rotates around.
     * @param {Vec3} [up] - Camera up vector.
     */
    rotateHorizontal(angle, isArc, center, up) {
      this.rotateAround(angle, isArc, center, up);
    }
    /**
     * Rotates camera around center point by vertical.
     * @param {number} angle - Rotation angle in radians.
     * @param {Vec3} [center] - Point that the camera rotates around.
     */
    rotateVertical(angle, center) {
      this.rotateAround(angle, false, center, this._r);
    }
    /**
     * Gets 3d size factor. Uses in LOD distance calculation.
     * @public
     * @param {Vec3} p - Far point.
     * @param {Vec3} r - Far point.
     * @returns {number} - Size factor.
     */
    projectedSize(p4, r8) {
      return Math.atan(r8 / this.eye.distance(p4)) * this._projSizeConst;
    }
    /**
     * Returns model matrix.
     * @public
     * @returns {NumberArray16} - View matrix.
     */
    getViewMatrix() {
      return this._viewMatrix._m;
    }
    /**
     * Returns normal matrix.
     * @public
     * @returns {NumberArray9} - Normal matrix.
     */
    getNormalMatrix() {
      return this._normalMatrix._m;
    }
    setCurrentFrustum(k3) {
      this.currentFrustumIndex = k3;
      this.isFirstPass = k3 === this.FARTHEST_FRUSTUM_INDEX;
    }
    getCurrentFrustum() {
      return this.currentFrustumIndex;
    }
    get frustum() {
      return this.frustums[this.currentFrustumIndex];
    }
    /**
     * Returns projection matrix.
     * @public
     * @returns {Mat4} - Projection matrix.
     */
    getProjectionMatrix() {
      return this.frustum.projectionMatrix._m;
    }
    /**
     * Returns projection and model matrix product.
     * @public
     * @return {Mat4} - Projection-view matrix.
     */
    getProjectionViewMatrix() {
      return this.frustum.projectionViewMatrix._m;
    }
    /**
     * Returns inverse projection and model matrix product.
     * @public
     * @returns {Mat4} - Inverse projection-view matrix.
     */
    getInverseProjectionViewMatrix() {
      return this.frustum.inverseProjectionViewMatrix._m;
    }
    /**
     * Returns inverse projection matrix.
     * @public
     * @returns {Mat4} - Inverse projection-view matrix.
     */
    getInverseProjectionMatrix() {
      return this.frustum.inverseProjectionMatrix._m;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/camera/PlanetCamera.js
  var PlanetCamera = class extends Camera {
    constructor(planet, options2 = {}) {
      super(planet.renderer, {
        ...options2,
        frustums: options2.frustums || [[1, 100 + 0.075], [100, 1e3 + 0.075], [1e3, 1e6 + 1e4], [1e6, 1e9]]
      });
      this.planet = planet;
      this.minAltitude = options2.minAltitude || 1;
      this.maxAltitude = options2.maxAltitude || 2e7;
      this._lonLat = this.planet.ellipsoid.cartesianToLonLat(this.eye);
      this._lonLatMerc = this._lonLat.forwardMercator();
      this._terrainAltitude = this._lonLat.height;
      this._terrainPoint = new Vec3();
      this._insideSegment = null;
      this.slope = 0;
      this._keyLock = new Key();
      this._framesArr = [];
      this._framesCounter = 0;
      this._numFrames = 50;
      this._completeCallback = null;
      this._frameCallback = null;
      this._flying = false;
      this._checkTerrainCollision = true;
      this.eyeNorm = this.eye.getNormal();
    }
    setTerrainCollisionActivity(isActive) {
      this._checkTerrainCollision = isActive;
    }
    /**
     * Updates camera view space.
     * @public
     * @virtual
     */
    update() {
      this.events.stopPropagation();
      let maxAlt = this.maxAltitude + this.planet.ellipsoid.getEquatorialSize();
      if (this.eye.length() > maxAlt) {
        this.eye.copy(this.eye.getNormal().scale(maxAlt));
      }
      super.update();
      this.updateGeodeticPosition();
      this.eyeNorm = this.eye.getNormal();
      this.slope = this._b.dot(this.eyeNorm);
      this.events.dispatch(this.events.viewchange, this);
    }
    updateGeodeticPosition() {
      this.planet.ellipsoid.cartesianToLonLatRes(this.eye, this._lonLat);
      if (Math.abs(this._lonLat.lat) <= MAX_LAT) {
        LonLat.forwardMercatorRes(this._lonLat, this._lonLatMerc);
      }
    }
    /**
     * Sets altitude over the terrain.
     * @public
     * @param {number} alt - Altitude over the terrain.
     */
    setAltitude(alt) {
      let t9 = this._terrainPoint;
      let n7 = this.planet.ellipsoid.getSurfaceNormal3v(this.eye);
      this.eye.x = n7.x * alt + t9.x;
      this.eye.y = n7.y * alt + t9.y;
      this.eye.z = n7.z * alt + t9.z;
      this._terrainAltitude = alt;
    }
    /**
     * Gets altitude over the terrain.
     * @public
     */
    getAltitude() {
      return this._terrainAltitude;
    }
    /**
     * Places camera to view to the geographical point.
     * @public
     * @param {LonLat} lonlat - New camera and camera view position.
     * @param {LonLat} [lookLonLat] - Look up coordinates.
     * @param {Vec3} [up] - Camera UP vector. Default (0,1,0)
     */
    setLonLat(lonlat, lookLonLat, up) {
      this.stopFlying();
      this._lonLat.set(lonlat.lon, lonlat.lat, lonlat.height || this._lonLat.height);
      let el = this.planet.ellipsoid;
      let newEye = el.lonLatToCartesian(this._lonLat);
      let newLook = lookLonLat ? el.lonLatToCartesian(lookLonLat) : Vec3.ZERO;
      this.set(newEye, newLook, up || Vec3.NORTH);
      this.update();
    }
    /**
     * Returns camera geographical position.
     * @public
     * @returns {LonLat}
     */
    getLonLat() {
      return this._lonLat;
    }
    /**
     * Returns camera height.
     * @public
     * @returns {number}
     */
    getHeight() {
      return this._lonLat.height;
    }
    /**
     * Gets position by viewable extent.
     * @public
     * @param {Extent} extent - Viewable extent.
     * @param {Number} height - Camera height
     * @returns {Vec3}
     */
    getExtentPosition(extent, height) {
      height = height || 0;
      let north = extent.getNorth();
      let south = extent.getSouth();
      let east = extent.getEast();
      let west = extent.getWest();
      if (west > east) {
        east += 360;
      }
      let e9 = this.planet.ellipsoid;
      let cart = new LonLat(east, north);
      let northEast = e9.lonLatToCartesian(cart);
      cart.lat = south;
      let southEast = e9.lonLatToCartesian(cart);
      cart.lon = west;
      let southWest = e9.lonLatToCartesian(cart);
      cart.lat = north;
      let northWest = e9.lonLatToCartesian(cart);
      let center = Vec3.sub(northEast, southWest).scale(0.5).addA(southWest);
      let mag = center.length();
      if (mag < 1e-6) {
        cart.lon = (east + west) * 0.5;
        cart.lat = (north + south) * 0.5;
        center = e9.lonLatToCartesian(cart);
      }
      northWest.subA(center);
      southEast.subA(center);
      northEast.subA(center);
      southWest.subA(center);
      let direction = center.getNormal();
      let right = direction.cross(Vec3.NORTH).normalize();
      let up = right.cross(direction).normalize();
      let _h = Math.max(Math.abs(up.dot(northWest)), Math.abs(up.dot(southEast)), Math.abs(up.dot(northEast)), Math.abs(up.dot(southWest)));
      let _w = Math.max(Math.abs(right.dot(northWest)), Math.abs(right.dot(southEast)), Math.abs(right.dot(northEast)), Math.abs(right.dot(southWest)));
      let tanPhi = Math.tan(this._viewAngle * RADIANS * 0.5);
      let tanTheta = this._aspect * tanPhi;
      let d4 = Math.max(_w / tanTheta, _h / tanPhi);
      center.normalize();
      center.scale(mag + d4 + height);
      return center;
    }
    /**
     * View current extent.
     * @public
     * @param {Extent} extent - Current extent.
     * @param {number} [height]
     */
    viewExtent(extent, height) {
      this.stopFlying();
      this.set(this.getExtentPosition(extent, height), Vec3.ZERO, Vec3.NORTH);
      this.update();
    }
    /**
     * Flies to the current extent.
     * @public
     * @param {Extent} extent - Current extent.
     * @param {number} [height] - Destination height.
     * @param {Vec3} [up] - Camera UP in the end of flying. Default - (0,1,0)
     * @param {Number} [ampl] - Altitude amplitude factor.
     * @param {Function} [completeCallback] - Callback that calls after flying when flying is finished.
     * @param {Function} [startCallback] - Callback that calls before the flying begins.
     * @param {Function} [frameCallback] - Each frame callback
     */
    flyExtent(extent, height, up, ampl, completeCallback, startCallback, frameCallback) {
      this.flyCartesian(this.getExtentPosition(extent, height), Vec3.ZERO, up, ampl == null ? 1 : ampl, completeCallback, startCallback, frameCallback);
    }
    viewDistance(cartesian, distance = 1e4) {
      let p0 = this.eye.add(this.getForward().scaleTo(distance));
      let _rot = Quat.getRotationBetweenVectors(p0.getNormal(), cartesian.getNormal());
      if (_rot.isZero()) {
        let newPos = cartesian.add(this.getBackward().scaleTo(distance));
        this.set(newPos, cartesian);
      } else {
        let newPos = cartesian.add(_rot.mulVec3(this.getBackward()).scale(distance)), newUp = _rot.mulVec3(this.getUp());
        this.set(newPos, cartesian, newUp);
      }
      this.update();
    }
    flyDistance(cartesian, distance = 1e4, ampl = 0, completeCallback, startCallback, frameCallback) {
      let p0 = this.eye.add(this.getForward().scaleTo(distance));
      let _rot = Quat.getRotationBetweenVectors(p0.getNormal(), cartesian.getNormal());
      if (_rot.isZero()) {
        let newPos = cartesian.add(this.getBackward().scaleTo(distance));
        this.set(newPos, cartesian);
      } else {
        let newPos = cartesian.add(_rot.mulVec3(this.getBackward()).scale(distance)), newUp = _rot.mulVec3(this.getUp());
        this.flyCartesian(newPos, cartesian, newUp, ampl, completeCallback, startCallback, frameCallback);
      }
    }
    /**
     * Flies to the cartesian coordinates.
     * @public
     * @param {Vec3} cartesian - Finish cartesian coordinates.
     * @param {Vec3} [look] - Camera LOOK in the end of flying. Default - (0,0,0)
     * @param {Vec3} [up] - Camera UP vector in the end of flying. Default - (0,1,0)
     * @param {Number} [ampl=1.0] - Altitude amplitude factor.
     * @param {Function} [completeCallback] - Callback that calls after flying when flying is finished.
     * @param {Function} [startCallback] - Callback that calls before the flying begins.
     * @param {Function} [frameCallback] - Each frame callback
     */
    flyCartesian(cartesian, look = Vec3.ZERO, up = Vec3.NORTH, ampl = 1, completeCallback = () => {
    }, startCallback = () => {
    }, frameCallback = () => {
    }) {
      this.stopFlying();
      look = look || Vec3.ZERO;
      up = up || Vec3.NORTH;
      this._completeCallback = completeCallback;
      this._frameCallback = frameCallback;
      if (startCallback) {
        startCallback.call(this);
      }
      if (look instanceof LonLat) {
        look = this.planet.ellipsoid.lonLatToCartesian(look);
      }
      let ground_a = this.planet.ellipsoid.lonLatToCartesian(new LonLat(this._lonLat.lon, this._lonLat.lat));
      let v_a = this._u, n_a = this._b;
      let lonlat_b = this.planet.ellipsoid.cartesianToLonLat(cartesian);
      let up_b = up;
      let ground_b = this.planet.ellipsoid.lonLatToCartesian(new LonLat(lonlat_b.lon, lonlat_b.lat, 0));
      let n_b = Vec3.sub(cartesian, look);
      let u_b = up_b.cross(n_b);
      n_b.normalize();
      u_b.normalize();
      let v_b = n_b.cross(u_b);
      let an = ground_a.getNormal();
      let bn = ground_b.getNormal();
      let anbn = 1 - an.dot(bn);
      let hM_a = ampl * SQRT_HALF * Math.sqrt(anbn > 0 ? anbn : 0);
      let maxHeight = 6639613;
      let currMaxHeight = Math.max(this._lonLat.height, lonlat_b.height);
      if (currMaxHeight > maxHeight) {
        maxHeight = currMaxHeight;
      }
      let max_h = currMaxHeight + 2.5 * hM_a * (maxHeight - currMaxHeight);
      let zero = Vec3.ZERO;
      for (let i9 = 0; i9 <= this._numFrames; i9++) {
        let d4 = 1 - i9 / this._numFrames;
        d4 = d4 * d4 * (3 - 2 * d4);
        d4 *= d4;
        let g_i = ground_a.smerp(ground_b, d4).normalize();
        let ground_i = this.planet.getRayIntersectionEllipsoid(new Ray(zero, g_i));
        let t9 = 1 - d4;
        let height_i = this._lonLat.height * d4 * d4 * d4 + max_h * 3 * d4 * d4 * t9 + max_h * 3 * d4 * t9 * t9 + lonlat_b.height * t9 * t9 * t9;
        let eye_i = ground_i.addA(g_i.scale(height_i));
        let up_i = v_a.smerp(v_b, d4);
        let look_i = Vec3.add(eye_i, n_a.smerp(n_b, d4).negateTo());
        let n7 = new Vec3(eye_i.x - look_i.x, eye_i.y - look_i.y, eye_i.z - look_i.z);
        let u4 = up_i.cross(n7);
        n7.normalize();
        u4.normalize();
        let v4 = n7.cross(u4);
        this._framesArr[i9] = {
          eye: eye_i,
          n: n7,
          u: u4,
          v: v4
        };
      }
      this._framesCounter = this._numFrames;
      this._flying = true;
    }
    /**
     * Flies to the geo coordinates.
     * @public
     * @param {LonLat} lonlat - Finish coordinates.
     * @param {Vec3 | LonLat} [look] - Camera LOOK in the end of flying. Default - (0,0,0)
     * @param {Vec3} [up] - Camera UP vector in the end of flying. Default - (0,1,0)
     * @param {number} [ampl] - Altitude amplitude factor.
     * @param {Function} [completeCallback] - Callback that calls after flying when flying is finished.
     * @param {Function} [startCallback] - Callback that calls befor the flying begins.
     * @param {Function} [frameCallback] - each frame callback
     */
    flyLonLat(lonlat, look, up, ampl, completeCallback, startCallback, frameCallbak) {
      let _lonLat = new LonLat(lonlat.lon, lonlat.lat, lonlat.height || this._lonLat.height);
      this.flyCartesian(this.planet.ellipsoid.lonLatToCartesian(_lonLat), look, up, ampl, completeCallback, startCallback, frameCallbak);
    }
    /**
     * Breaks the flight.
     * @public
     */
    stopFlying() {
      this.planet.layerLock.free(this._keyLock);
      this.planet.terrainLock.free(this._keyLock);
      this.planet.normalMapCreator.free(this._keyLock);
      this._flying = false;
      this._framesArr.length = 0;
      this._framesArr = [];
      this._framesCounter = -1;
      this._frameCallback = null;
    }
    /**
     * Returns camera is flying.
     * @public
     * @returns {boolean}
     */
    isFlying() {
      return this._flying;
    }
    /**
     * Rotates around planet to the left.
     * @public
     * @param {number} angle - Rotation angle.
     * @param {boolean} [spin] - If its true rotates around globe spin.
     */
    rotateLeft(angle, spin) {
      this.rotateHorizontal(angle * RADIANS, spin !== true, Vec3.ZERO);
      this.update();
    }
    /**
     * Rotates around planet to the right.
     * @public
     * @param {number} angle - Rotation angle.
     * @param {boolean} [spin] - If its true rotates around globe spin.
     */
    rotateRight(angle, spin) {
      this.rotateHorizontal(-angle * RADIANS, spin !== true, Vec3.ZERO);
      this.update();
    }
    /**
     * Rotates around planet to the North Pole.
     * @public
     * @param {number} angle - Rotation angle.
     */
    rotateUp(angle) {
      this.rotateVertical(angle * RADIANS, Vec3.ZERO);
      this.update();
    }
    /**
     * Rotates around planet to the South Pole.
     * @public
     * @param {number} angle - Rotation angle.
     */
    rotateDown(angle) {
      this.rotateVertical(-angle * RADIANS, Vec3.ZERO);
      this.update();
    }
    rotateVertical(angle, center, minSlope = 0) {
      let rot = new Mat4().setRotation(this._r, angle);
      let tr = new Mat4().setIdentity().translate(center);
      let ntr = new Mat4().setIdentity().translate(center.negateTo());
      let trm = tr.mul(rot).mul(ntr);
      let eye = trm.mulVec3(this.eye);
      let u4 = rot.mulVec3(this._u).normalize();
      let r8 = rot.mulVec3(this._r).normalize();
      let b4 = rot.mulVec3(this._b).normalize();
      let eyeNorm = eye.getNormal();
      let slope = b4.dot(eyeNorm);
      if (minSlope) {
        let dSlope = slope - this.slope;
        if (slope < minSlope && dSlope < 0)
          return;
        if (slope > 0.1 && u4.dot(eyeNorm) > 0 || this.slope <= 0.1 || this._u.dot(this.eye.getNormal()) <= 0) {
          this.eye = eye;
          this._u = u4;
          this._r = r8;
          this._b = b4;
        }
      } else {
        this.eye = eye;
        this._u = u4;
        this._r = r8;
        this._b = b4;
      }
    }
    /**
     * Prepare camera to the frame. Used in render node frame function.
     * @public
     */
    checkFly() {
      if (this._flying) {
        let c7 = this._numFrames - this._framesCounter;
        this.planet.layerLock.lock(this._keyLock);
        this.planet.terrainLock.lock(this._keyLock);
        this.planet.normalMapCreator.lock(this._keyLock);
        this.eye = this._framesArr[c7].eye;
        this._r = this._framesArr[c7].u;
        this._u = this._framesArr[c7].v;
        this._b = this._framesArr[c7].n;
        if (this._frameCallback) {
          this._frameCallback();
        }
        this.update();
        this._framesCounter--;
        if (this._framesCounter < 0) {
          this.stopFlying();
          if (this._completeCallback) {
            this._completeCallback();
            this._completeCallback = null;
          }
        }
      }
    }
    checkTerrainCollision() {
      this._terrainAltitude = this._lonLat.height;
      if (this._insideSegment && this._insideSegment.planet) {
        this._terrainAltitude = this._insideSegment.getTerrainPoint(this.eye, this._insideSegment.getInsideLonLat(this), this._terrainPoint);
        if (this._terrainAltitude < this.minAltitude && this._checkTerrainCollision) {
          this.setAltitude(this.minAltitude);
        }
        return this._terrainPoint;
      }
    }
    getSurfaceVisibleDistance(d4) {
      let R4 = this.planet.ellipsoid.equatorialSize;
      return R4 * Math.acos(R4 / (R4 + this._lonLat.height + d4));
    }
    getHeading() {
      let u4 = this.eye.getNormal();
      let f8 = Vec3.proj_b_to_plane(this.slope >= 0.97 ? this.getUp() : this.getForward(), u4).normalize(), n7 = Vec3.proj_b_to_plane(Vec3.NORTH, u4).normalize();
      let res = Math.sign(u4.dot(f8.cross(n7))) * Math.acos(f8.dot(n7)) * DEGREES;
      if (res < 0) {
        return 360 + res;
      }
      return res;
    }
    isVisible(poi) {
      let e9 = this.eye.length();
      return this.eye.distance(poi) < Math.sqrt(e9 * e9 - this.planet.ellipsoid.equatorialSizeSqr);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/TerrainWorker.js
  var TerrainWorker = class extends BaseWorker {
    constructor(numWorkers = 2) {
      super(numWorkers, TERRAIN_PROGRAM);
    }
    _onMessage(e9) {
      this._source.get(e9.data.id).segment._terrainWorkerCallback(e9.data);
      this._source.delete(e9.data.id);
      e9.data.normalMapNormals = null;
      e9.data.normalMapVertices = null;
      e9.data.normalMapVerticesHigh = null;
      e9.data.normalMapVerticesLow = null;
      e9.data.terrainVertices = null;
      e9.data.terrainVerticesHigh = null;
      e9.data.terrainVerticesLow = null;
    }
    make(info) {
      if (info.segment.plainReady && info.segment.terrainIsLoading) {
        if (this._workerQueue.length) {
          const w3 = this._workerQueue.pop();
          this._source.set(this._sourceId, info);
          let segment = info.segment;
          w3.postMessage({
            "elevations": info.elevations,
            "this_plainVertices": segment.plainVertices,
            "this_plainNormals": segment.plainNormals,
            "this_normalMapVertices": segment.normalMapVertices,
            "this_normalMapNormals": segment.normalMapNormals,
            "heightFactor": segment.planet._heightFactor,
            "gridSize": segment.planet.terrain.gridSizeByZoom[segment.tileZoom],
            "noDataValues": segment.planet.terrain.noDataValues,
            "id": this._sourceId
          }, [
            info.elevations.buffer,
            segment.plainVertices.buffer,
            segment.plainNormals.buffer,
            segment.normalMapVertices.buffer,
            segment.normalMapNormals.buffer
          ]);
          this._sourceId++;
        } else {
          this._pendingQueue.push(info);
        }
      } else {
        this.check();
      }
    }
  };
  var TERRAIN_PROGRAM = `'use strict';
    //
    //Terrain worker
    //

    function binarySearchFast(arr, x) {
        let start = 0,
            end = arr.length - 1;
        while (start <= end) {
            let k = Math.floor((start + end) * 0.5); 
            if (Math.abs(arr[k] - x) < 1e-3)
                return k;
            else if (arr[k] < x)
                start = k + 1;
            else
                end = k - 1;
        }
        return -1;
    };

    function checkNoDataValue(noDataValues, value) {
        return binarySearchFast(noDataValues, value) !== -1;
    };


    var Vec3 = function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    };

    var doubleToTwoFloats = function(v, high, low) {

        let x = v.x, y = v.y, z = v.z;
    
        if (x >= 0.0) {
            var doubleHigh = Math.floor(x / 65536.0) * 65536.0;
            high.x = Math.fround(doubleHigh);
            low.x = Math.fround(x - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-x / 65536.0) * 65536.0;
            high.x = Math.fround(-doubleHigh);
            low.x = Math.fround(x + doubleHigh);
        }

        if (y >= 0.0) {
            var doubleHigh = Math.floor(y / 65536.0) * 65536.0;
            high.y = Math.fround(doubleHigh);
            low.y = Math.fround(y - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-y / 65536.0) * 65536.0;
            high.y = Math.fround(-doubleHigh);
            low.y = Math.fround(y + doubleHigh);
        }

        if (z >= 0.0) {
            var doubleHigh = Math.floor(z / 65536.0) * 65536.0;
            high.z = Math.fround(doubleHigh);
            low.z = Math.fround(z - doubleHigh);
        } else {
            var doubleHigh = Math.floor(-z / 65536.0) * 65536.0;
            high.z = Math.fround(-doubleHigh);
            low.z = Math.fround(z + doubleHigh);
        }
    };

    Vec3.prototype.sub = function(v) {
        return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
    };

    Vec3.prototype.add = function(v) {
        return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
    };

    Vec3.prototype.cross = function(v) {
        return new Vec3(
            this.y * v.z - this.z * v.y,
            this.z * v.x - this.x * v.z,
            this.x * v.y - this.y * v.x
        );
    };

    Vec3.prototype.normalize = function(v) {
        var x = this.x, y = this.y, z = this.z;
        var length = 1.0 / Math.sqrt(x * x + y * y + z * z);
        this.x = x * length;
        this.y = y * length;
        this.z = z * length;
        return this;
    };

    Vec3.prototype.distance = function(v) {
        return this.sub(v).length();
    };

    Vec3.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };

    var blerp = function(x, y, fQ11, fQ21, fQ12, fQ22) {
        return (fQ11 * (1.0 - x) * (1.0 - y) + fQ21 * x * (1.0 - y) + fQ12 * (1.0 - x) * y + fQ22 * x * y);
    };
    
    var slice = function (t, h1, h0) {
      return t * (h1 - h0);
    };

    var _tempVec = new Vec3(0.0, 0.0, 0.0);

    var _tempHigh = new Vec3(0.0, 0.0, 0.0),
        _tempLow = new Vec3(0.0, 0.0, 0.0);

    self.onmessage = function (e) {
        var elevations = e.data.elevations,
            this_plainVertices = e.data.this_plainVertices,
            this_plainNormals = e.data.this_plainNormals,
            this_normalMapVertices = e.data.this_normalMapVertices,
            this_normalMapNormals = e.data.this_normalMapNormals,
            heightFactor =  e.data.heightFactor,
            gridSize = e.data.gridSize,
            noDataValues = e.data.noDataValues,
            id = e.data.id;
        
        var xmin = 549755748352.0, xmax = -549755748352.0, 
            ymin = 549755748352.0, ymax = -549755748352.0, 
            zmin = 549755748352.0, zmax = -549755748352.0;

        const fileGridSize = Math.sqrt(elevations.length) - 1;

        const fileGridSize_one = fileGridSize + 1;
        const fileGridSize_one_x2 = fileGridSize_one * fileGridSize_one;
        const tgs = gridSize;
        const dg = fileGridSize / tgs;
        const gs = tgs + 1;
        const hf = heightFactor;

        var nmvInd = 0,
            vInd = 0,
            noDataInd = 0;

        var gsgs3 = gs * gs * 3;

        var terrainVertices = new Float64Array(gsgs3),
            terrainVerticesHigh = new Float32Array(gsgs3),
            terrainVerticesLow = new Float32Array(gsgs3),
            noDataVertices = new Uint8Array(gs * gs);

        var normalMapNormals,
            normalMapVertices,
            normalMapVerticesHigh,
            normalMapVerticesLow;

        var nv = this_normalMapVertices,
            nn = this_normalMapNormals;

        if (fileGridSize >= tgs) {

            normalMapNormals = new Float32Array(fileGridSize_one_x2 * 3);
            normalMapVertices = new Float64Array(fileGridSize_one_x2 * 3);
            normalMapVerticesHigh = new Float32Array(fileGridSize_one_x2 * 3);
            normalMapVerticesLow = new Float32Array(fileGridSize_one_x2 * 3);

            for (let k = 0; k < fileGridSize_one_x2; k++) {

                var j = k % fileGridSize_one,
                    i = ~~(k / fileGridSize_one);

                //
                // V0
                //
                var hInd0 = k;
                var vInd0 = hInd0 * 3;
                var currElv = elevations[hInd0];
                if(checkNoDataValue(noDataValues, currElv)) {
                    currElv = 0.0;
                }
                var h0 = hf * currElv;
                var v0 = new Vec3(nv[vInd0] + h0 * nn[vInd0], nv[vInd0 + 1] + h0 * nn[vInd0 + 1], nv[vInd0 + 2] + h0 * nn[vInd0 + 2]);
                                
                doubleToTwoFloats(v0, _tempHigh, _tempLow);

                normalMapVertices[vInd0] = v0.x;
                normalMapVertices[vInd0 + 1] = v0.y;
                normalMapVertices[vInd0 + 2] = v0.z;

                normalMapVerticesHigh[vInd0] = _tempHigh.x;
                normalMapVerticesHigh[vInd0 + 1] = _tempHigh.y;
                normalMapVerticesHigh[vInd0 + 2] = _tempHigh.z;

                normalMapVerticesLow[vInd0] = _tempLow.x;
                normalMapVerticesLow[vInd0 + 1] = _tempLow.y;
                normalMapVerticesLow[vInd0 + 2] = _tempLow.z;

                //
                // The vertex goes into screen buffer
                if (i % dg === 0 && j % dg === 0) {

                    let currVert = new Vec3(nv[vInd0], nv[vInd0 + 1], nv[vInd0 + 2]);
                    let nextVert = new Vec3(nv[vInd0 + 3], nv[vInd0 + 4], nv[vInd0 + 5]);

                    let nextElv =  elevations[hInd0 + 1];
                    if(checkNoDataValue(noDataValues, nextElv)) {
                        nextElv = 0.0;
                    }
                    
                    let eps = false;
                    if(noDataValues.length === 0){
                        let step = currVert.distance(nextVert);
                        let deltaElv = Math.abs(currElv - nextElv);
                        eps = ((deltaElv / step) > 10.0) || (currElv < -5000);
                    }

                    if(eps){
                        noDataVertices[noDataInd] = 1;
                    } else {
                        noDataVertices[noDataInd] = 0;
                        if (v0.x < xmin) xmin = v0.x; if (v0.x > xmax) xmax = v0.x;
                        if (v0.y < ymin) ymin = v0.y; if (v0.y > ymax) ymax = v0.y;
                        if (v0.z < zmin) zmin = v0.z; if (v0.z > zmax) zmax = v0.z;
                    }

                    terrainVerticesHigh[vInd] = _tempHigh.x;
                    terrainVerticesLow[vInd] = _tempLow.x;
                    terrainVertices[vInd++] = v0.x;

                    terrainVerticesHigh[vInd] = _tempHigh.y;
                    terrainVerticesLow[vInd] = _tempLow.y;
                    terrainVertices[vInd++] = v0.y;

                    terrainVerticesHigh[vInd] = _tempHigh.z;
                    terrainVerticesLow[vInd] = _tempLow.z;
                    terrainVertices[vInd++] = v0.z;

                    noDataInd++;
                }

                if (i !== fileGridSize && j !== fileGridSize) {

                    //
                    //  V1
                    //
                    var hInd1 = k + 1;
                    var vInd1 = hInd1 * 3;
                    var elv = elevations[hInd1];
                    if(checkNoDataValue(noDataValues, elv)) {
                        elv = 0.0;
                    }
                    var h1 = hf * elv;
                    var v1 = new Vec3(nv[vInd1] + h1 * nn[vInd1], nv[vInd1 + 1] + h1 * nn[vInd1 + 1], nv[vInd1 + 2] + h1 * nn[vInd1 + 2]);

                    doubleToTwoFloats(v1, _tempHigh, _tempLow);

                    normalMapVertices[vInd1] = v1.x;
                    normalMapVertices[vInd1 + 1] = v1.y;
                    normalMapVertices[vInd1 + 2] = v1.z;

                    normalMapVerticesHigh[vInd1] = _tempHigh.x;
                    normalMapVerticesHigh[vInd1 + 1] = _tempHigh.y;
                    normalMapVerticesHigh[vInd1 + 2] = _tempHigh.z;

                    normalMapVerticesLow[vInd1] = _tempLow.x;
                    normalMapVerticesLow[vInd1 + 1] = _tempLow.y;
                    normalMapVerticesLow[vInd1 + 2] = _tempLow.z;

                    //
                    //  V2
                    //
                    var hInd2 = k + fileGridSize_one;
                    var vInd2 = hInd2 * 3;
                    var elv = elevations[hInd2];
                    if(checkNoDataValue(noDataValues, elv)) {
                        elv = 0.0;
                    }
                    var h2 = hf * elv;
                    var v2 = new Vec3(nv[vInd2] + h2 * nn[vInd2], nv[vInd2 + 1] + h2 * nn[vInd2 + 1], nv[vInd2 + 2] + h2 * nn[vInd2 + 2]);

                    doubleToTwoFloats(v2, _tempHigh, _tempLow);

                    normalMapVertices[vInd2] = v2.x;
                    normalMapVertices[vInd2 + 1] = v2.y;
                    normalMapVertices[vInd2 + 2] = v2.z;

                    normalMapVerticesHigh[vInd2] = _tempHigh.x;
                    normalMapVerticesHigh[vInd2 + 1] = _tempHigh.y;
                    normalMapVerticesHigh[vInd2 + 2] = _tempHigh.z;

                    normalMapVerticesLow[vInd2] = _tempLow.x;
                    normalMapVerticesLow[vInd2 + 1] = _tempLow.y;
                    normalMapVerticesLow[vInd2 + 2] = _tempLow.z;

                    //
                    //  V3
                    //
                    var hInd3 = k + fileGridSize_one + 1;
                    var vInd3 = hInd3 * 3;
                    var elv = elevations[hInd3];
                    if(checkNoDataValue(noDataValues, elv)) {
                        elv = 0.0;
                    }
                    var h3 = hf * elv;
                    var v3 = new Vec3(nv[vInd3] + h3 * nn[vInd3], nv[vInd3 + 1] + h3 * nn[vInd3 + 1], nv[vInd3 + 2] + h3 * nn[vInd3 + 2]);

                    doubleToTwoFloats(v3, _tempHigh, _tempLow);

                    normalMapVertices[vInd3] = v3.x;
                    normalMapVertices[vInd3 + 1] = v3.y;
                    normalMapVertices[vInd3 + 2] = v3.z;

                    normalMapVerticesHigh[vInd3] = _tempHigh.x;
                    normalMapVerticesHigh[vInd3 + 1] = _tempHigh.y;
                    normalMapVerticesHigh[vInd3 + 2] = _tempHigh.z;

                    normalMapVerticesLow[vInd3] = _tempLow.x;
                    normalMapVerticesLow[vInd3 + 1] = _tempLow.y;
                    normalMapVerticesLow[vInd3 + 2] = _tempLow.z;

                    //
                    // Normal
                    //
                    var e10 = v1.sub(v0),
                        e20 = v2.sub(v0),
                        e30 = v3.sub(v0);
                    var sw = e20.cross(e30).normalize();
                    var ne = e30.cross(e10).normalize();
                    var n0 = ne.add(sw).normalize();

                    normalMapNormals[vInd0] += n0.x;
                    normalMapNormals[vInd0 + 1] += n0.y;
                    normalMapNormals[vInd0 + 2] += n0.z;

                    normalMapNormals[vInd1] += ne.x;
                    normalMapNormals[vInd1 + 1] += ne.y;
                    normalMapNormals[vInd1 + 2] += ne.z;

                    normalMapNormals[vInd2] += sw.x;
                    normalMapNormals[vInd2 + 1] += sw.y;
                    normalMapNormals[vInd2 + 2] += sw.z;

                    normalMapNormals[vInd3] += n0.x;
                    normalMapNormals[vInd3 + 1] += n0.y;
                    normalMapNormals[vInd3 + 2] += n0.z;
                }
            }

        } else {

            normalMapNormals = new Float32Array(gsgs3);
            normalMapVertices = new Float64Array(gsgs3);
            normalMapVerticesHigh = new Float32Array(gsgs3);
            normalMapVerticesLow = new Float32Array(gsgs3);
            normalMapNormals = new Float32Array(gsgs3);

            var oneSize = tgs / fileGridSize;
            var h, inside_i, inside_j, v_i, v_j;
            var gsgs = gsgs3 / 3;
            var fgsOne = fileGridSize + 1;

            for(let i = 0; i < gsgs; i++) {
                let ii = Math.floor(i / gs),
                    ij = i % gs;
              
                let qii = ii % oneSize,
                    qij = ij % oneSize;

                let hlt_ind = Math.floor(ii / oneSize) * fgsOne + Math.floor(ij / oneSize);

                if (ij === tgs) {
                    hlt_ind -= 1;
                    qij = oneSize;
                }

                if (ii === tgs) {
                    hlt_ind -= fgsOne;
                    qii = oneSize;
                }

                let hrt_ind = hlt_ind + 1,
                    hlb_ind = hlt_ind + fgsOne,
                    hrb_ind = hlb_ind + 1;

                let h_lt = elevations[hlt_ind],
                    h_rt = elevations[hrt_ind],
                    h_lb = elevations[hlb_ind],
                    h_rb = elevations[hrb_ind];

                if(checkNoDataValue(noDataValues, h_lt)) {
                    h_lt = 0.0;
                }

                if(checkNoDataValue(noDataValues, h_rt)) {
                    h_rt = 0.0;
                }

                if(checkNoDataValue(noDataValues, h_lb)) {
                    h_lb = 0.0;
                }

                if(checkNoDataValue(noDataValues, h_rb)) {
                    h_rb = 0.0;
                }

                let hi = blerp(qij / oneSize, qii / oneSize, h_lt, h_rt, h_lb, h_rb);

                let i3 = i * 3;

                _tempVec.x = this_plainVertices[i3] + hi * this_plainNormals[i3],
                _tempVec.y = this_plainVertices[i3 + 1] + hi * this_plainNormals[i3 + 1],
                _tempVec.z = this_plainVertices[i3 + 2] + hi * this_plainNormals[i3 + 2];

                doubleToTwoFloats(_tempVec, _tempHigh, _tempLow);

                terrainVertices[i3] = _tempVec.x;
                terrainVertices[i3 + 1] = _tempVec.y;
                terrainVertices[i3 + 2] = _tempVec.z;

                terrainVerticesHigh[i3] = _tempHigh.x;
                terrainVerticesHigh[i3 + 1] = _tempHigh.y;
                terrainVerticesHigh[i3 + 2] = _tempHigh.z;

                terrainVerticesLow[i3] = _tempLow.x;
                terrainVerticesLow[i3 + 1] = _tempLow.y;
                terrainVerticesLow[i3 + 2] = _tempLow.z;

                if (_tempVec.x < xmin) xmin = _tempVec.x; if (_tempVec.x > xmax) xmax = _tempVec.x;
                if (_tempVec.y < ymin) ymin = _tempVec.y; if (_tempVec.y > ymax) ymax = _tempVec.y;
                if (_tempVec.z < zmin) zmin = _tempVec.z; if (_tempVec.z > zmax) zmax = _tempVec.z;
            }

            normalMapVertices.set(terrainVertices);
            normalMapVerticesHigh.set(terrainVerticesHigh);
            normalMapVerticesLow.set(terrainVerticesLow);

            for (let k = 0; k < gsgs; k++) {

                var j = k % gs,
                    i = ~~(k / gs);

                if (i !== tgs && j !== tgs) {
                    var v0ind = k * 3,
                        v1ind = v0ind + 3,
                        v2ind = v0ind + gs * 3,
                        v3ind = v2ind + 3;


                    var v0 = new Vec3(terrainVertices[v0ind], terrainVertices[v0ind + 1], terrainVertices[v0ind + 2]),
                        v1 = new Vec3(terrainVertices[v1ind], terrainVertices[v1ind + 1], terrainVertices[v1ind + 2]),
                        v2 = new Vec3(terrainVertices[v2ind], terrainVertices[v2ind + 1], terrainVertices[v2ind + 2]),
                        v3 = new Vec3(terrainVertices[v3ind], terrainVertices[v3ind + 1], terrainVertices[v3ind + 2]);

                    var e10 = v1.sub(v0).normalize(),
                        e20 = v2.sub(v0).normalize(),
                        e30 = v3.sub(v0).normalize();

                    var sw = e20.cross(e30).normalize();
                    var ne = e30.cross(e10).normalize();
                    var n0 = ne.add(sw).normalize();

                    normalMapNormals[v0ind] += n0.x;
                    normalMapNormals[v0ind + 1] += n0.y;
                    normalMapNormals[v0ind + 2] += n0.z;

                    normalMapNormals[v1ind] += ne.x;
                    normalMapNormals[v1ind + 1] += ne.y;
                    normalMapNormals[v1ind + 2] += ne.z;

                    normalMapNormals[v2ind] += sw.x;
                    normalMapNormals[v2ind + 1] += sw.y;
                    normalMapNormals[v2ind + 2] += sw.z;

                    normalMapNormals[v3ind] += n0.x;
                    normalMapNormals[v3ind + 1] += n0.y;
                    normalMapNormals[v3ind + 2] += n0.z;
                }
            }
        }

        self.postMessage({
                id: id,
                normalMapNormals: normalMapNormals,
                normalMapVertices: normalMapVertices,
                normalMapVerticesHigh: normalMapVerticesHigh,
                normalMapVerticesLow: normalMapVerticesLow,
                terrainVertices: terrainVertices,
                terrainVerticesHigh: terrainVerticesHigh,
                terrainVerticesLow: terrainVerticesLow,
                noDataVertices: noDataVertices,
                //bounds: [xmin, xmax, ymin, ymax, zmin, zmax]
                bounds: [xmin, ymin, zmin, xmax, ymax, zmax]
             }, [
                    normalMapNormals.buffer, 
                    normalMapVertices.buffer, 
                    normalMapVerticesHigh.buffer, 
                    normalMapVerticesLow.buffer, 
                    terrainVertices.buffer,
                    terrainVerticesHigh.buffer,
                    terrainVerticesLow.buffer,
                    noDataVertices.buffer
            ]);
    }`;

  // frontend/node_modules/@openglobus/og/lib/js/utils/VectorTileCreator.js
  var tempArr = new Float32Array(2);
  var MAX_FRAME_TIME = 25;
  var VectorTileCreator = class {
    constructor(planet, width = 512, height = 512) {
      this._width = width;
      this._height = height;
      this._planet = planet;
      this._framebuffer = null;
      this._queue = [];
      this._handler = null;
    }
    init() {
      this._handler = this._planet.renderer.handler;
      if (!this._handler.programs.vectorTileLineRasterization) {
        this._handler.addProgram(new Program("vectorTileLineRasterization", {
          uniforms: {
            "viewport": "vec2",
            "thicknessOutline": "float",
            "alpha": "float",
            "extentParamsHigh": "vec4",
            "extentParamsLow": "vec4"
          },
          attributes: {
            "prevHigh": "vec2",
            "currentHigh": "vec2",
            "nextHigh": "vec2",
            "prevLow": "vec2",
            "currentLow": "vec2",
            "nextLow": "vec2",
            "order": "float",
            "color": "vec4",
            "thickness": "float"
          },
          vertexShader: `attribute vec2 prevHigh;
                attribute vec2 currentHigh;
                attribute vec2 nextHigh;

                attribute vec2 prevLow;
                attribute vec2 currentLow;
                attribute vec2 nextLow;

                attribute float order;
                attribute float thickness;
                attribute vec4 color;
                uniform float thicknessOutline;
                uniform vec2 viewport;
                uniform vec4 extentParamsHigh;
                uniform vec4 extentParamsLow;
                varying vec4 vColor;
                
                vec2 proj(vec2 coordHigh, vec2 coordLow) {
                    vec2 highDiff = coordHigh - extentParamsHigh.xy;
                    vec2 lowDiff = coordLow - extentParamsLow.xy;                    
                    return vec2(-1.0 + (highDiff * step(1.0, length(highDiff)) + lowDiff) * extentParamsHigh.zw) * vec2(1.0, -1.0);
                }
                
                void main(){
                    vColor = color;

                    vec2 vNext = proj(nextHigh, nextLow),
                         vCurrent = proj(currentHigh, currentLow),
                         vPrev = proj(prevHigh, prevLow);

                    vec2 _next = vNext;
                    vec2 _prev = vPrev;
                    vec2 _current = vCurrent;

                    if(_prev == _current){
                        if(_next == _current){
                            _next = _current + vec2(1.0, 0.0);
                            _prev = _current - _next;
                        }else{
                            _prev = _current + normalize(_current - _next);
                        }
                    }

                    if(_next == _current){
                        _next = _current + normalize(_current - _prev);
                    }

                    vec2 sNext = _next;
                    vec2 sCurrent = _current;
                    vec2 sPrev = _prev;
                    
                    vec2 dirNext = normalize(sNext - sCurrent);
                    vec2 dirPrev = normalize(sPrev - sCurrent);
                    float dotNP = dot(dirNext, dirPrev);
                    
                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));
                    vec2 d = (thickness + thicknessOutline) * 0.5 * sign(order) / viewport;
                    
                    vec2 m;
                    if(dotNP >= 0.99991){
                        m = sCurrent - normalPrev * d;
                    }else{
                        vec2 dir = normalPrev + normalNext;
                        m = sCurrent + dir * d / (dirNext.x * dir.y - dirNext.y * dir.x);
                        
                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);
                            if(occw == -1.0){
                                m = sCurrent + normalPrev * d;
                            }else if(occw == 1.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == -2.0){
                                m = sCurrent + normalNext * d;
                            }else if(occw == 2.0){
                                m = sCurrent + normalPrev * d;
                            }
                        }else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){
                            m = sCurrent + normalNext * d;
                        }
                    }
                    gl_Position = vec4(m.x, m.y, 0.0, 1.0);
                }`,
          fragmentShader: `precision highp float;
                uniform float alpha;
                varying vec4 vColor;
                void main() {
                    gl_FragColor = vec4(vColor.rgb, alpha * vColor.a);
                }`
        }));
      }
      if (!this._handler.programs.vectorTilePolygonRasterization) {
        this._handler.addProgram(new Program("vectorTilePolygonRasterization", {
          uniforms: {
            "extentParamsHigh": "vec4",
            "extentParamsLow": "vec4"
          },
          attributes: {
            "coordinatesHigh": "vec2",
            "coordinatesLow": "vec2",
            "colors": "vec4"
          },
          vertexShader: `attribute vec2 coordinatesHigh;
                attribute vec2 coordinatesLow; 
                attribute vec4 colors; 
                uniform vec4 extentParamsHigh; 
                uniform vec4 extentParamsLow; 
                varying vec4 color;

                vec2 proj(vec2 coordHigh, vec2 coordLow) {
                    vec2 highDiff = coordHigh - extentParamsHigh.xy;
                    vec2 lowDiff = coordLow - extentParamsLow.xy;
                    return vec2(-1.0 + (highDiff * step(1.0, length(highDiff)) + lowDiff) * extentParamsHigh.zw) * vec2(1.0, -1.0);
                }

                void main() { 
                    color = colors;
                    gl_Position = vec4(proj(coordinatesHigh, coordinatesLow), 0.0, 1.0); 
                }`,
          fragmentShader: `precision highp float;
                varying vec4 color;
                void main () {  
                    gl_FragColor = color; 
                }`
        }));
      }
      this._framebuffer = new Framebuffer(this._handler, {
        width: this._width,
        height: this._height,
        useDepth: false
      });
      this._framebuffer.init();
    }
    frame() {
      if (this._planet.layerLock.isFree() && this._queue.length) {
        let h8 = this._handler, gl = h8.gl;
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.DEPTH_TEST);
        let hLine = h8.programs.vectorTileLineRasterization, hPoly = h8.programs.vectorTilePolygonRasterization;
        let _w = this._width, _h = this._height, width = _w, height = _h, _w2 = width << 1, _h2 = height << 1;
        let extentParamsHigh = new Float32Array(4);
        let extentParamsLow = new Float32Array(4);
        let f8 = this._framebuffer.activate();
        let deltaTime = 0, startTime = window.performance.now();
        while (this._queue.length && deltaTime < MAX_FRAME_TIME) {
          let material = this._queue.shift();
          if (material.isLoading && material.segment.node.getState() === RENDERING) {
            let pickingEnabled = material.layer._pickingEnabled;
            if (material.segment.tileZoom < 4) {
              width = _w2;
              height = _h2;
            } else {
              width = _w;
              height = _h;
            }
            let texture = material._updateTexture || h8.createEmptyTexture_l(width, height);
            let pickingMask = pickingEnabled ? material._updatePickingMask || h8.createEmptyTexture_n(width, height) : null;
            material.applyTexture(texture, pickingMask);
            f8.setSize(width, height);
            f8.bindOutputTexture(texture);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            let extent = material.segment.getExtentMerc();
            doubleToTwoFloats2(extent.southWest.lon, tempArr);
            extentParamsHigh[0] = tempArr[0];
            extentParamsLow[0] = tempArr[1];
            doubleToTwoFloats2(extent.southWest.lat, tempArr);
            extentParamsHigh[1] = tempArr[0];
            extentParamsLow[1] = tempArr[1];
            extentParamsHigh[2] = 2 / extent.getWidth();
            extentParamsHigh[3] = 2 / extent.getHeight();
            hPoly.activate();
            let sh = hPoly._program;
            let sha = sh.attributes, shu = sh.uniforms;
            let geomHandler = material.layer._geometryHandler;
            gl.uniform4fv(shu.extentParamsHigh, extentParamsHigh);
            gl.uniform4fv(shu.extentParamsLow, extentParamsLow);
            gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyVerticesHighBufferMerc);
            gl.vertexAttribPointer(sha.coordinatesHigh, geomHandler._polyVerticesHighBufferMerc.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyVerticesLowBufferMerc);
            gl.vertexAttribPointer(sha.coordinatesLow, geomHandler._polyVerticesLowBufferMerc.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyColorsBuffer);
            gl.vertexAttribPointer(sha.colors, geomHandler._polyColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geomHandler._polyIndexesBuffer);
            gl.drawElements(gl.TRIANGLES, geomHandler._polyIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
            if (pickingEnabled) {
              f8.bindOutputTexture(pickingMask);
              gl.clearColor(0, 0, 0, 0);
              gl.clear(gl.COLOR_BUFFER_BIT);
              gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyPickingColorsBuffer);
              gl.vertexAttribPointer(sha.colors, geomHandler._polyPickingColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
              gl.drawElements(gl.TRIANGLES, geomHandler._polyIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
            }
            f8.bindOutputTexture(texture);
            hLine.activate();
            sh = hLine._program;
            sha = sh.attributes;
            shu = sh.uniforms;
            gl.uniform2fv(shu.viewport, [width, height]);
            gl.uniform4fv(shu.extentParamsHigh, extentParamsHigh);
            gl.uniform4fv(shu.extentParamsLow, extentParamsLow);
            let mb = geomHandler._lineVerticesHighBufferMerc;
            gl.bindBuffer(gl.ARRAY_BUFFER, mb);
            gl.vertexAttribPointer(sha.prevHigh, mb.itemSize, gl.FLOAT, false, 8, 0);
            gl.vertexAttribPointer(sha.currentHigh, mb.itemSize, gl.FLOAT, false, 8, 32);
            gl.vertexAttribPointer(sha.nextHigh, mb.itemSize, gl.FLOAT, false, 8, 64);
            mb = geomHandler._lineVerticesLowBufferMerc;
            gl.bindBuffer(gl.ARRAY_BUFFER, mb);
            gl.vertexAttribPointer(sha.prevLow, mb.itemSize, gl.FLOAT, false, 8, 0);
            gl.vertexAttribPointer(sha.currentLow, mb.itemSize, gl.FLOAT, false, 8, 32);
            gl.vertexAttribPointer(sha.nextLow, mb.itemSize, gl.FLOAT, false, 8, 64);
            gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineOrdersBuffer);
            gl.vertexAttribPointer(sha.order, geomHandler._lineOrdersBuffer.itemSize, gl.FLOAT, false, 4, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geomHandler._lineIndexesBuffer);
            gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineStrokesBuffer);
            gl.vertexAttribPointer(sha.thickness, geomHandler._lineStrokesBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineStrokeColorsBuffer);
            gl.vertexAttribPointer(sha.color, geomHandler._lineStrokeColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.uniform1f(shu.thicknessOutline, 2);
            gl.uniform1f(shu.alpha, 0.54);
            gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
            gl.uniform1f(shu.thicknessOutline, 1);
            gl.uniform1f(shu.alpha, 1);
            gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineThicknessBuffer);
            gl.vertexAttribPointer(sha.thickness, geomHandler._lineThicknessBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineColorsBuffer);
            gl.vertexAttribPointer(sha.color, geomHandler._lineColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.uniform1f(shu.thicknessOutline, 2);
            gl.uniform1f(shu.alpha, 0.54);
            gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
            gl.uniform1f(shu.thicknessOutline, 1);
            gl.uniform1f(shu.alpha, 1);
            gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
            if (pickingEnabled) {
              f8.bindOutputTexture(pickingMask);
              gl.uniform1f(shu.thicknessOutline, 8);
              gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._linePickingColorsBuffer);
              gl.vertexAttribPointer(sha.color, geomHandler._linePickingColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
              gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
            }
          } else {
            material.isLoading = false;
          }
          deltaTime = window.performance.now() - startTime;
        }
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);
        f8.deactivate();
      }
    }
    add(material) {
      this._queue.push(material);
    }
    remove(material) {
    }
    get queueSize() {
      return this._queue.length;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/ellipsoid/Ellipsoid.js
  var Ellipsoid = class {
    constructor(equatorialSize = 1, polarSize = 1) {
      this._a = equatorialSize;
      this._b = polarSize;
      this._flattening = (equatorialSize - polarSize) / equatorialSize;
      this._f = 1 / this._flattening;
      this._a2 = equatorialSize * equatorialSize;
      this._b2 = polarSize * polarSize;
      const qa2b2 = Math.sqrt(this._a2 - this._b2);
      this._e = qa2b2 / equatorialSize;
      this._e2 = this._e * this._e;
      this._e22 = this._e2 * this._e2;
      this._k = qa2b2 / polarSize;
      this._k2 = this._k * this._k;
      this._radii = new Vec3(equatorialSize, equatorialSize, polarSize);
      this._radii2 = new Vec3(this._a2, this._a2, this._b2);
      this._invRadii = new Vec3(1 / equatorialSize, 1 / equatorialSize, 1 / polarSize);
      this._invRadii2 = new Vec3(1 / this._a2, 1 / this._a2, 1 / this._b2);
    }
    /**
     * Returns the distance travelling from ‘this’ point to destination point along a rhumb line.
     * @param   {LonLat} startLonLat coordinates.
     * @param   {LonLat} endLonLat coordinates
     * @returns {number} Distance in m between this point and destination point (same units as radius).
     */
    rhumbDistanceTo(startLonLat, endLonLat) {
      const f1 = startLonLat.lat * RADIANS;
      const f22 = endLonLat.lat * RADIANS;
      const df = f22 - f1;
      let d4 = Math.abs(endLonLat.lon - startLonLat.lon) * RADIANS;
      if (Math.abs(d4) > Math.PI)
        d4 = d4 > 0 ? -(2 * Math.PI - d4) : 2 * Math.PI + d4;
      const dd = Math.log(Math.tan(f22 / 2 + Math.PI / 4) / Math.tan(f1 / 2 + Math.PI / 4));
      const q2 = Math.abs(dd) > 1e-11 ? df / dd : Math.cos(f1);
      const t9 = Math.sqrt(df * df + q2 * q2 * d4 * d4);
      return t9 * this._a;
    }
    /**
     * Returns the point at given fraction between two points on the great circle.
     * @param   {LonLat} lonLat1 - Longitude/Latitude of source point.
     * @param   {LonLat} lonLat2 - Longitude/Latitude of destination point.
     * @param   {number} fraction - Fraction between the two points (0 = source point, 1 = destination point).
     * @returns {LonLat} Intermediate point between points.
     */
    getIntermediatePointOnGreatCircle(lonLat1, lonLat2, fraction) {
      if (fraction == 0)
        return lonLat1.clone();
      if (fraction == 1)
        return lonLat2.clone();
      const inverse = this.inverse(lonLat1, lonLat2);
      const dist = inverse.distance;
      const azimuth = inverse.initialAzimuth;
      return isNaN(azimuth) ? lonLat1 : this.getGreatCircleDestination(lonLat1, azimuth, dist * fraction);
    }
    /**
     * REMOVE ASAP after
     * @param lonLat1
     * @param lonLat2
     * @returns {number}
     */
    static getBearing(lonLat1, lonLat2) {
      let f1 = lonLat1.lat * RADIANS, l1 = lonLat1.lon * RADIANS;
      let f22 = lonLat2.lat * RADIANS, l22 = lonLat2.lon * RADIANS;
      let y4 = Math.sin(l22 - l1) * Math.cos(f22);
      let x3 = Math.cos(f1) * Math.sin(f22) - Math.sin(f1) * Math.cos(f22) * Math.cos(l22 - l1);
      return Math.atan2(y4, x3) * DEGREES;
    }
    getFlattening() {
      return this._flattening;
    }
    /**
     * Gets ellipsoid equatorial size.
     * @public
     * @returns {number} -
     */
    getEquatorialSize() {
      return this._a;
    }
    get equatorialSize() {
      return this._a;
    }
    get equatorialSizeSqr() {
      return this._a2;
    }
    /**
     * Gets ellipsoid polar size.
     * @public
     * @returns {number} -
     */
    getPolarSize() {
      return this._b;
    }
    get polarSize() {
      return this._b;
    }
    get polarSizeSqr() {
      return this._b2;
    }
    /**
     * Calculate cartesian coordinates by its ECEF geodetic coordinates.
     * @public
     * @param {LonLat} lonlat - Geodetic coordinates.
     * @returns {Vec3} -
     */
    lonLatToCartesian(lonlat) {
      return this.geodeticToCartesian(lonlat.lon, lonlat.lat, lonlat.height);
    }
    /**
     * Calculate cartesian coordinates by its ECEF geodetic coordinates.
     * @public
     * @param {LonLat} lonlat - Geodetic coordinates.
     * @param {Vec3} res - Output variable reference.
     * @returns {Vec3} -
     */
    lonLatToCartesianRes(lonlat, res) {
      return this.geodeticToCartesian(lonlat.lon, lonlat.lat, lonlat.height, res);
    }
    /**
     * Gets cartesian ECEF from Wgs84 geodetic coordinates.
     * @public
     * @param {Number} lon - Longitude.
     * @param {Number} lat - Latitude.
     * @param {Number} height - Height.
     * @param {Vec3} res - Output result variable.
     * @returns {Vec3} -
     */
    geodeticToCartesian(lon, lat, height = 0, res = new Vec3()) {
      let latrad = RADIANS * lat, lonrad = RADIANS * lon;
      let slt = Math.sin(latrad);
      let N4 = this._a / Math.sqrt(1 - this._e2 * slt * slt);
      let nc = (N4 + height) * Math.cos(latrad);
      res.x = nc * Math.cos(lonrad);
      res.y = nc * Math.sin(lonrad);
      res.z = (N4 * (1 - this._e2) + height) * slt;
      return res;
    }
    /**
     * Gets Wgs84 geodetic coordinates from cartesian ECEF.
     * @public
     * @param {Vec3} p - Cartesian coordinates.
     * @returns {LonLat} -
     */
    projToSurface(p4) {
      let pX = p4.x || 0, pY = p4.y || 0, pZ = p4.z || 0;
      let length = Math.sqrt(pX * pX + pY * pY + pZ * pZ);
      if (length === 0) {
        return this.lonLatToCartesian(new LonLat());
      }
      let invRadii2X = this._invRadii2.x, invRadii2Y = this._invRadii2.y, invRadii2Z = this._invRadii2.z;
      let x22 = pX * pX * invRadii2X, y22 = pY * pY * invRadii2Y, z22 = pZ * pZ * invRadii2Z;
      let norm = x22 + y22 + z22;
      let ratio = Math.sqrt(1 / norm);
      let first = p4.scaleTo(ratio);
      if (norm < EPS1) {
        return !Number.isFinite(ratio) ? new Vec3() : first;
      }
      let lambda = (1 - ratio) * length / first.mulA(this._invRadii2).length();
      let m_X = 0, m_Y = 0, m_Z = 0;
      do {
        m_X = 1 / (1 + lambda * invRadii2X);
        m_Y = 1 / (1 + lambda * invRadii2Y);
        m_Z = 1 / (1 + lambda * invRadii2Z);
        let m_X2 = m_X * m_X, m_Y2 = m_Y * m_Y, m_Z2 = m_Z * m_Z;
        let func = x22 * m_X2 + y22 * m_Y2 + z22 * m_Z2 - 1;
        if (Math.abs(func) < EPS12) {
          break;
        }
        let m_X3 = m_X2 * m_X, m_Y3 = m_Y2 * m_Y, m_Z3 = m_Z2 * m_Z;
        lambda += 0.5 * func / (x22 * m_X3 * invRadii2X + y22 * m_Y3 * invRadii2Y + z22 * m_Z3 * invRadii2Z);
      } while (true);
      return new Vec3(pX * m_X, pY * m_Y, pZ * m_Z);
    }
    /**
     * Converts 3d cartesian coordinates to geodetic
     * @param {Vec3} cart - Cartesian coordinates
     * @returns {LonLat} - Geodetic coordinates
     */
    cartesianToLonLat(cart) {
      return this.cartesianToLonLatRes(cart);
    }
    /**
     * Converts 3d cartesian coordinates to geodetic
     * @param {Vec3} cart - Cartesian coordinates
     * @param {LonLat} res - Link geodetic coordinates variable
     * @returns {LonLat} - Geodetic coordinates
     */
    cartesianToLonLatRes(cart, res = new LonLat()) {
      let p4 = this.projToSurface(cart);
      let n7 = this.getSurfaceNormal3v(p4), h8 = cart.sub(p4);
      res.lon = Math.atan2(n7.y, n7.x) * DEGREES;
      res.lat = Math.asin(n7.z) * DEGREES;
      res.height = Math.sign(h8.dot(cart)) * h8.length();
      return res;
    }
    /**
     * Gets ellipsoid surface normal.
     * @public
     * @param {Vec3} coord - Spatial coordinates.
     * @return {Vec3} -
     */
    getSurfaceNormal3v(coord) {
      let r22 = this._invRadii2;
      let nx = coord.x * r22.x, ny = coord.y * r22.y, nz = coord.z * r22.z;
      let l4 = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
      return new Vec3(nx * l4, ny * l4, nz * l4);
    }
    getGreatCircleDistance(lonLat1, lonLat2) {
      return this.inverse(lonLat1, lonLat2).distance;
    }
    /**
     * Calculates the destination point given start point lat / lon, azimuth(deg) and distance (m).
     * Source: http://movable-type.co.uk/scripts/latlong-vincenty-direct.html and optimized / cleaned up by Mathias Bynens <http://mathiasbynens.be/>
     * Based on the Vincenty direct formula by T. Vincenty, “Direct and Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations”, Survey Review, vol XXII no 176, 1975 <http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf>
     * @param {LonLat} lonLat - Origin coordinates
     * @param {number} azimuth - View azimuth in degrees
     * @param {number} dist - Distance to the destination point coordinates in meters
     * @returns {LonLat} - Destination point coordinates
     */
    getGreatCircleDestination(lonLat, azimuth, dist) {
      return this.direct(lonLat, azimuth, dist).destination;
    }
    /**
     * Returns inverse Geodesic solution for two points
     * @param {LonLat} lonLat1 - start coordinates point
     * @param {LonLat} lonLat2 - end coordinates point
     * @returns {IInverseResult} - Contains distance, initialAzimuth, and finalAzimuth values
     */
    inverse(lonLat1, lonLat2) {
      let a6 = this._a, b4 = this._b, f8 = this._flattening;
      const fi1 = lonLat1.lat * RADIANS, lambda1 = lonLat1.lon * RADIANS;
      const fi2 = lonLat2.lat * RADIANS, lambda2 = lonLat2.lon * RADIANS;
      const L2 = lambda2 - lambda1;
      const tanU1 = (1 - f8) * Math.tan(fi1), cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1), sinU1 = tanU1 * cosU1;
      const tanU2 = (1 - f8) * Math.tan(fi2), cosU2 = 1 / Math.sqrt(1 + tanU2 * tanU2), sinU2 = tanU2 * cosU2;
      const antipodal = Math.abs(L2) > Math.PI / 2 || Math.abs(fi2 - fi1) > Math.PI / 2;
      let lmb = L2, sinLmb = null, cosLmb = null;
      let s7 = antipodal ? Math.PI : 0, sin_s = 0, cos_s = antipodal ? -1 : 1, sinSqs = null;
      let cos2sm = 1;
      let cosSqa = 1;
      let lmb_ = null, iterations = 0;
      do {
        sinLmb = Math.sin(lmb);
        cosLmb = Math.cos(lmb);
        sinSqs = (cosU2 * sinLmb) ** 2 + (cosU1 * sinU2 - sinU1 * cosU2 * cosLmb) ** 2;
        if (Math.abs(sinSqs) < 1e-24)
          break;
        sin_s = Math.sqrt(sinSqs);
        cos_s = sinU1 * sinU2 + cosU1 * cosU2 * cosLmb;
        s7 = Math.atan2(sin_s, cos_s);
        const sin_a = cosU1 * cosU2 * sinLmb / sin_s;
        cosSqa = 1 - sin_a * sin_a;
        cos2sm = cosSqa != 0 ? cos_s - 2 * sinU1 * sinU2 / cosSqa : 0;
        const C2 = f8 / 16 * cosSqa * (4 + f8 * (4 - 3 * cosSqa));
        lmb_ = lmb;
        lmb = L2 + (1 - C2) * f8 * sin_a * (s7 + C2 * sin_s * (cos2sm + C2 * cos_s * (-1 + 2 * cos2sm * cos2sm)));
      } while (Math.abs(lmb - lmb_) > EPS12 && ++iterations < 1e3);
      const uSq = cosSqa * (a6 * a6 - b4 * b4) / (b4 * b4);
      const A3 = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
      const B3 = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
      const ds = B3 * sin_s * (cos2sm + B3 / 4 * (cos_s * (-1 + 2 * cos2sm * cos2sm) - B3 / 6 * cos2sm * (-3 + 4 * sin_s * sin_s) * (-3 + 4 * cos2sm * cos2sm)));
      const dist = b4 * A3 * (s7 - ds);
      const a1 = Math.abs(sinSqs) < Number.EPSILON ? 0 : Math.atan2(cosU2 * sinLmb, cosU1 * sinU2 - sinU1 * cosU2 * cosLmb);
      const a22 = Math.abs(sinSqs) < Number.EPSILON ? Math.PI : Math.atan2(cosU1 * sinLmb, -sinU1 * cosU2 + cosU1 * sinU2 * cosLmb);
      return {
        distance: dist,
        initialAzimuth: Math.abs(dist) < Number.EPSILON ? NaN : zeroTwoPI(a1) * DEGREES,
        finalAzimuth: Math.abs(dist) < Number.EPSILON ? NaN : zeroTwoPI(a22) * DEGREES
      };
    }
    /**
     * Calculates the destination point given start point lat / lon, azimuth(deg) and distance (m).
     * Source: http://movable-type.co.uk/scripts/latlong-vincenty-direct.html and optimized / cleaned up by Mathias Bynens <http://mathiasbynens.be/>
     * Based on the Vincenty direct formula by T. Vincenty, “Direct and Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations”, Survey Review, vol XXII no 176, 1975 <http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf>
     * @param {LonLat} lonLat - Origin coordinates
     * @param {number} azimuth - View azimuth in degrees
     * @param {number} dist - Distance to the destination point coordinates in meters
     * @returns {{ destination: LonLat; finalAzimuth: number }} - Destination point coordinates
     */
    direct(lonLat, azimuth, dist) {
      let lon1 = lonLat.lon, lat1 = lonLat.lat;
      let a6 = this._a, b4 = this._b, f8 = this._flattening, s7 = dist, alpha1 = azimuth * RADIANS, sinAlpha1 = Math.sin(alpha1), cosAlpha1 = Math.cos(alpha1), tanU1 = (1 - f8) * Math.tan(lat1 * RADIANS), cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1), sinU1 = tanU1 * cosU1, sigma1 = Math.atan2(tanU1, cosAlpha1), sinAlpha = cosU1 * sinAlpha1, cosSqAlpha = 1 - sinAlpha * sinAlpha, uSq = cosSqAlpha * (a6 * a6 - b4 * b4) / (b4 * b4), A3 = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))), B3 = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))), sigma = s7 / (b4 * A3), sigmaP = 2 * Math.PI;
      let cos2SigmaM = 0, sinSigma = 0, cosSigma = 0, deltaSigma = 0;
      while (Math.abs(sigma - sigmaP) > 1e-12) {
        cos2SigmaM = Math.cos(2 * sigma1 + sigma);
        sinSigma = Math.sin(sigma);
        cosSigma = Math.cos(sigma);
        deltaSigma = B3 * sinSigma * (cos2SigmaM + B3 / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B3 / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
        sigmaP = sigma;
        sigma = s7 / (b4 * A3) + deltaSigma;
      }
      let tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1, lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f8) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp)), lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1), C2 = f8 / 16 * cosSqAlpha * (4 + f8 * (4 - 3 * cosSqAlpha)), L2 = lambda - (1 - C2) * f8 * sinAlpha * (sigma + C2 * sinSigma * (cos2SigmaM + C2 * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM))), revAz = Math.atan2(sinAlpha, -tmp);
      return {
        destination: new LonLat(lon1 + L2 * DEGREES, lat2 * DEGREES),
        finalAzimuth: revAz * DEGREES
      };
    }
    /**
     * Returns cartesian coordinates of the intersection of a ray and an ellipsoid.
     * If the ray doesn't hit ellipsoid returns null.
     * @public
     * @param {Vec3} origin - Ray origin point.
     * @param {Vec3} direction - Ray direction.
     * @returns {Vec3} -
     */
    hitRay(origin, direction) {
      let q2 = this._invRadii.mul(origin);
      let w3 = this._invRadii.mul(direction);
      let q22 = q2.dot(q2);
      let qw = q2.dot(w3);
      let difference, w22, product, discriminant, temp;
      if (q22 > 1) {
        if (qw >= 0) {
          return void 0;
        }
        var qw2 = qw * qw;
        difference = q22 - 1;
        w22 = w3.dot(w3);
        product = w22 * difference;
        let eps = Math.abs(qw2 - product);
        if (eps > EPS15 && qw2 < product) {
          return void 0;
        } else if (qw2 > product) {
          discriminant = qw * qw - product;
          temp = -qw + Math.sqrt(discriminant);
          var root0 = temp / w22;
          var root1 = difference / temp;
          if (root0 < root1) {
            return origin.add(direction.scaleTo(root0));
          }
          return origin.add(direction.scaleTo(root1));
        } else {
          var root = Math.sqrt(difference / w22);
          return origin.add(direction.scaleTo(root));
        }
      } else if (q22 < 1) {
        difference = q22 - 1;
        w22 = w3.dot(w3);
        product = w22 * difference;
        discriminant = qw * qw - product;
        temp = -qw + Math.sqrt(discriminant);
        return origin.add(direction.scaleTo(temp / w22));
      } else {
        if (qw < 0) {
          w22 = w3.dot(w3);
          return origin.add(direction.scaleTo(-qw / w22));
        }
      }
    }
    getNorthFrameRotation(cartesian) {
      let n7 = this.getSurfaceNormal3v(cartesian);
      let t9 = Vec3.proj_b_to_plane(Vec3.NORTH, n7);
      return Quat.getLookRotation(t9, n7);
    }
    /**
     * @todo this is not precise function, needs to be replaced or removed
     * @param lonLat1
     * @param bearing
     * @param distance
     * @returns {LonLat}
     */
    getBearingDestination(lonLat1, bearing = 0, distance = 0) {
      bearing = bearing * RADIANS;
      var nlon = (lonLat1.lon + 540) % 360 - 180;
      var f1 = lonLat1.lat * RADIANS, l1 = nlon * RADIANS;
      var dR = distance / this._a;
      var f22 = Math.asin(Math.sin(f1) * Math.cos(dR) + Math.cos(f1) * Math.sin(dR) * Math.cos(bearing));
      return new LonLat((l1 + Math.atan2(Math.sin(bearing) * Math.sin(dR) * Math.cos(f1), Math.cos(dR) - Math.sin(f1) * Math.sin(f22))) * DEGREES, f22 * DEGREES);
    }
    /**
     * Returns the point at given fraction between two points on the great circle.
     * @param   {LonLat} lonLat1 - Longitude/Latitude of source point.
     * @param   {LonLat} lonLat2 - Longitude/Latitude of destination point.
     * @param   {number} fraction - Fraction between the two points (0 = source point, 1 = destination point).
     * @returns {LonLat} Intermediate point between points.
     */
    static getIntermediatePointOnGreatCircle(lonLat1, lonLat2, fraction) {
      var f1 = lonLat1.lat * RADIANS, l1 = lonLat1.lon * RADIANS;
      var f22 = lonLat2.lat * RADIANS, l22 = lonLat2.lon * RADIANS;
      var sinf1 = Math.sin(f1), cosf1 = Math.cos(f1), sinl1 = Math.sin(l1), cosl1 = Math.cos(l1);
      var sinf2 = Math.sin(f22), cosf2 = Math.cos(f22), sinl2 = Math.sin(l22), cosl2 = Math.cos(l22);
      var df = f22 - f1, dl = l22 - l1;
      var a6 = Math.sin(df / 2) * Math.sin(df / 2) + Math.cos(f1) * Math.cos(f22) * Math.sin(dl / 2) * Math.sin(dl / 2);
      var d4 = 2 * Math.atan2(Math.sqrt(a6), Math.sqrt(1 - a6));
      var A3 = Math.sin((1 - fraction) * d4) / Math.sin(d4);
      var B3 = Math.sin(fraction * d4) / Math.sin(d4);
      var x3 = A3 * cosf1 * cosl1 + B3 * cosf2 * cosl2;
      var y4 = A3 * cosf1 * sinl1 + B3 * cosf2 * sinl2;
      var z3 = A3 * sinf1 + B3 * sinf2;
      var f32 = Math.atan2(z3, Math.sqrt(x3 * x3 + y4 * y4));
      var l32 = Math.atan2(y4, x3);
      return new LonLat((l32 * DEGREES + 540) % 360 - 180, f32 * DEGREES);
    }
    static getRhumbBearing(lonLat1, lonLat2) {
      var dLon = (lonLat2.lon - lonLat1.lon) * RADIANS;
      var dPhi = Math.log(Math.tan(lonLat2.lat * RADIANS / 2 + Math.PI / 4) / Math.tan(lonLat1.lat * RADIANS / 2 + Math.PI / 4));
      if (Math.abs(dLon) > Math.PI) {
        if (dLon > 0) {
          dLon = (2 * Math.PI - dLon) * -1;
        } else {
          dLon = 2 * Math.PI + dLon;
        }
      }
      return (Math.atan2(dLon, dPhi) * DEGREES + 360) % 360;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/ellipsoid/wgs84.js
  var wgs84 = new Ellipsoid(6378137, 6356752314245179e-9);

  // frontend/node_modules/@openglobus/og/lib/js/scene/Planet.js
  var CUR_LOD_SIZE = 250;
  var MIN_LOD_SIZE = 312;
  var MAX_LOD_SIZE = 190;
  var _tempPickingPix_ = new Uint8Array(4);
  var _tempDepthColor_ = new Uint8Array(4);
  var DEPTH_DISTANCE = 11;
  var MAX_NODES = 200;
  var HORIZON_TANGENT = 0.81;
  var Planet = class extends RenderNode {
    constructor(options2 = {}) {
      super(options2.name);
      this._renderingFadingNodes = (nodes, sh, currentNode, sl, sliceIndex, outTransparentSegments) => {
        let isFirstPass = sliceIndex === 0;
        let isEq = this.terrain.equalizeVertices;
        for (let j2 = 0, len = currentNode._fadingNodes.length; j2 < len; j2++) {
          let f8 = currentNode._fadingNodes[j2].segment;
          if (this._fadingNodes.has(currentNode._fadingNodes[0].__id) && !nodes.has(f8.node.__id)) {
            nodes.set(f8.node.__id, true);
            if (f8._transitionOpacity < 1) {
              outTransparentSegments.push(f8);
            } else {
              if (isFirstPass) {
                isEq && f8.equalize();
                f8.readyToEngage && f8.engage();
                f8.screenRendering(sh, sl, sliceIndex);
              } else {
                f8.screenRendering(sh, sl, sliceIndex, this.transparentTexture, true);
              }
            }
          }
        }
      };
      this._renderingFadingNodesNoDepth = (nodes, sh, currentNode, sl, sliceIndex) => {
        let isFirstPass = sliceIndex === 0;
        let isEq = this.terrain.equalizeVertices;
        let gl = sh.gl;
        gl.disable(gl.DEPTH_TEST);
        for (let j2 = 0, len = currentNode._fadingNodes.length; j2 < len; j2++) {
          let f8 = currentNode._fadingNodes[j2].segment;
          if (this._fadingNodes.has(currentNode._fadingNodes[0].__id) && !nodes.has(f8.node.__id)) {
            nodes.set(f8.node.__id, true);
            if (isFirstPass) {
              isEq && f8.equalize();
              f8.readyToEngage && f8.engage();
              f8.screenRendering(sh, sl, sliceIndex);
            } else {
              f8.screenRendering(sh, sl, sliceIndex, this.transparentTexture, true);
            }
          }
        }
        gl.enable(gl.DEPTH_TEST);
      };
      this._atmosphere = new Atmosphere(options2.atmosphereParameters);
      this._prevNodes = /* @__PURE__ */ new Map();
      this._currNodes = /* @__PURE__ */ new Map();
      this.transitionTime = 580;
      this.ellipsoid = options2.ellipsoid || wgs84;
      this.lightEnabled = true;
      this._planetRadius2 = this.ellipsoid.getPolarSize() * this.ellipsoid.getPolarSize();
      this._layers = [];
      this._updateLayer = false;
      this.visibleTileLayers = [];
      this.visibleVectorLayers = [];
      this._visibleTileLayerSlices = [];
      this._frustumEntityCollections = [];
      this.baseLayer = null;
      this.terrain = null;
      this.camera = new PlanetCamera(this, {
        frustums: options2.frustums,
        eye: new Vec3(25e6, 0, 0),
        look: Vec3.ZERO,
        up: Vec3.NORTH,
        minAltitude: options2.minAltitude,
        maxAltitude: options2.maxAltitude
      });
      this.maxEqualZoomAltitude = options2.maxEqualZoomAltitude || 15e6;
      this.minEqualZoomAltitude = options2.minEqualZoomAltitude || 1e4;
      this.minEqualZoomCameraSlope = options2.minEqualZoomCameraSlope || 0.8;
      this.mousePositionOnEarth = new Vec3();
      this.emptyTexture = null;
      this.transparentTexture = null;
      this.defaultTexture = null;
      this.minCurrZoom = MAX;
      this.maxCurrZoom = MIN;
      this._viewExtent = new Extent(new LonLat(180, 180), new LonLat(-180, -180));
      this._skipPreRender = false;
      this._initialViewExtent = null;
      this._createdNodesCount = 0;
      this._renderedNodes = [];
      this._renderedNodesInFrustum = [];
      this._fadingNodes = /* @__PURE__ */ new Map();
      this._fadingNodesInFrustum = [];
      this._visibleNodes = {};
      this._visibleNodesNorth = {};
      this._visibleNodesSouth = {};
      this.layerLock = new Lock();
      this.terrainLock = new Lock();
      this._heightFactor = 1;
      this._indexesCache = [];
      this._indexesCacheToRemove = [];
      this._indexesCacheToRemoveCounter = 0;
      this._textureCoordsBufferCache = [];
      this.quadTreeStrategy = options2.quadTreeStrategyPrototype ? new options2.quadTreeStrategyPrototype(this) : new EarthQuadTreeStrategy(this);
      this._nightTexture = null;
      this._specularTexture = null;
      let a6 = createColorRGB(options2.ambient, new Vec3(0.2, 0.2, 0.3));
      let d4 = createColorRGB(options2.diffuse, new Vec3(1, 1, 1));
      let s7 = createColorRGB(options2.specular, new Vec3(63e-5, 55e-5, 32e-5));
      let shininess = options2.shininess || 18;
      this._ambient = new Float32Array([a6.x, a6.y, a6.z]);
      this._diffuse = new Float32Array([d4.x, d4.y, d4.z]);
      this._specular = new Float32Array([s7.x, s7.y, s7.z, shininess]);
      this._maxGridSize = Math.log2(options2.maxGridSize || 256);
      this.SLICE_SIZE = 4;
      this.SLICE_SIZE_4 = this.SLICE_SIZE * 4;
      this.SLICE_SIZE_3 = this.SLICE_SIZE * 3;
      this._lodSize = CUR_LOD_SIZE;
      this._curLodSize = CUR_LOD_SIZE;
      this._minLodSize = MIN_LOD_SIZE;
      this._maxLodSize = MAX_LOD_SIZE;
      this._pickingColorArr = new Float32Array(this.SLICE_SIZE_4);
      this._samplerArr = new Int32Array(this.SLICE_SIZE);
      this._pickingMaskArr = new Int32Array(this.SLICE_SIZE);
      this._geoImageCreator = new GeoImageCreator(this);
      this._vectorTileCreator = new VectorTileCreator(this);
      this._normalMapCreator = new NormalMapCreator(this);
      this._terrainWorker = new TerrainWorker(3);
      this._plainSegmentWorker = new PlainSegmentWorker(3);
      this._tileLoader = new Loader(options2.maxLoadingRequests || 12);
      this._memKey = new Key();
      this.events = createEvents(PLANET_EVENTS);
      this._distBeforeMemClear = 0;
      this._prevCamEye = new Vec3();
      this._initialized = false;
      this.always = [];
      this._renderCompleted = false;
      this._renderCompletedActivated = false;
      this._terrainCompleted = false;
      this._terrainCompletedActivated = false;
      this._collectRenderNodesIsActive = true;
      this.nightTextureCoefficient = 2;
      this._renderScreenNodesPASS = this._renderScreenNodesPASSNoAtmos;
      this._renderScreenNodesWithHeightPASS = this._renderScreenNodesWithHeightPASSNoAtmos;
      this._atmosphereEnabled = options2.atmosphereEnabled || false;
      this._atmosphereMaxMinOpacity = new Float32Array([1, 0.41]);
      this.solidTextureOne = null;
      this.solidTextureTwo = null;
      this._nightTextureSrc = options2.nightTextureSrc || null;
      this._specularTextureSrc = options2.specularTextureSrc || null;
      this._transitionOpacityEnabled = options2.transitionOpacityEnabled != void 0 ? options2.transitionOpacityEnabled : true;
    }
    /**
     * Returns true if current terrain data set is loaded
     */
    get terrainReady() {
      return this._terrainCompleted && this._terrainCompletedActivated;
    }
    get maxGridSize() {
      return this._maxGridSize;
    }
    getNorthFrameRotation(cartesian) {
      return this.ellipsoid.getNorthFrameRotation(cartesian);
    }
    set atmosphereMaxOpacity(opacity) {
      this._atmosphereMaxMinOpacity[0] = opacity;
    }
    get atmosphereMaxOpacity() {
      return this._atmosphereMaxMinOpacity[0];
    }
    set atmosphereMinOpacity(opacity) {
      this._atmosphereMaxMinOpacity[1] = opacity;
    }
    get atmosphereMinOpacity() {
      return this._atmosphereMaxMinOpacity[1];
    }
    set atmosphereEnabled(enabled) {
      if (enabled != this._atmosphereEnabled) {
        this._atmosphereEnabled = enabled;
        this._initializeAtmosphere();
      }
    }
    get atmosphereEnabled() {
      return this._atmosphereEnabled;
    }
    set diffuse(rgb) {
      let vec = createColorRGB(rgb);
      this._diffuse = new Float32Array(vec.toArray());
    }
    set ambient(rgb) {
      let vec = createColorRGB(rgb);
      this._ambient = new Float32Array(vec.toArray());
    }
    set specular(rgb) {
      let vec = createColorRGB(rgb);
      this._specular = new Float32Array([vec.x, vec.y, vec.y, this._specular[3]]);
    }
    set shininess(v4) {
      this._specular[3] = v4;
    }
    get normalMapCreator() {
      return this._normalMapCreator;
    }
    get layers() {
      return [...this._layers];
    }
    /**
     * @todo: remove after tests
     * Get the collection of layers associated with this planet.
     * @return {Array.<Layer>} Layers array.
     * @public
     */
    getLayers() {
      return this.layers;
    }
    get sunPos() {
      return this.renderer.controls.sun.sunlight.getPosition();
    }
    /**
     * Add the given control to the renderer of the planet scene.
     * @param {Control} control - Control.
     */
    addControl(control) {
      control.planet = this;
      control.addTo(this.renderer);
    }
    get lodSize() {
      return this._lodSize;
    }
    setLodSize(currentLodSize, minLodSize, maxLodSize) {
      this._maxLodSize = maxLodSize || this._maxLodSize;
      this._minLodSize = minLodSize || this._minLodSize;
      this._curLodSize = currentLodSize;
      this._renderCompletedActivated = false;
      this._terrainCompletedActivated = false;
    }
    /**
     * Add the given controls array to the renderer of the planet.
     * @param {Array.<Control>} cArr - Control array.
     */
    addControls(cArr) {
      for (let i9 = 0; i9 < cArr.length; i9++) {
        this.addControl(cArr[i9]);
      }
    }
    /**
     * Return layer by it name
     * @param {string} name - Name of the layer. og.Layer.prototype.name
     * @public
     * @returns {Layer} -
     */
    getLayerByName(name) {
      for (let i9 = 0, len = this._layers.length; i9 < len; i9++) {
        if (name === this._layers[i9].name) {
          return this._layers[i9];
        }
      }
    }
    /**
     * Adds layer to the planet.
     * @param {Layer} layer - Layer object.
     * @public
     */
    addLayer(layer) {
      layer.addTo(this);
    }
    /**
     * Dispatch layer visibility changing event.
     * @param {Layer} layer - Changed layer.
     * @public
     */
    _onLayerVisibilityChanged(layer) {
      this.events.dispatch(this.events.layervisibilitychange, layer);
    }
    /**
     * Adds the given layers array to the planet.
     * @param {Array.<Layer>} layers - Layers array.
     * @public
     */
    addLayers(layers) {
      for (let i9 = 0, len = layers.length; i9 < len; i9++) {
        this.addLayer(layers[i9]);
      }
    }
    /**
     * Removes the given layer from the planet.
     * @param {Layer} layer - Layer to remove.
     * @public
     */
    removeLayer(layer) {
      layer.remove();
    }
    /**
     *
     * @public
     * @param {Layer} layer - Material layer.
     */
    _clearLayerMaterial(layer) {
      this.quadTreeStrategy.clearLayerMaterial(layer);
    }
    /**
     * Sets base layer coverage to the planet.
     * @param {Layer} layer - Layer object.
     * @public
     */
    setBaseLayer(layer) {
      if (this.baseLayer) {
        if (!this.baseLayer.isEqual(layer)) {
          this.baseLayer.setVisibility(false);
          this.baseLayer = layer;
          layer.setVisibility(true);
          this.events.dispatch(this.events.baselayerchange, layer);
        }
      } else {
        this.baseLayer = layer;
        this.baseLayer.setVisibility(true);
        this.events.dispatch(this.events.baselayerchange, layer);
      }
    }
    /**
     * Sets elevation scale. 1.0 is default.
     * @param {number} factor - Elevation scale.
     */
    setHeightFactor(factor) {
      this._renderCompletedActivated = false;
      this._terrainCompletedActivated = false;
      if (this._heightFactor !== factor) {
        this._heightFactor = factor;
        this.quadTreeStrategy.destroyBranches();
        this._clearRenderedNodeList();
        this._clearRenderNodesInFrustum();
      }
    }
    /**
     * Gets elevation scale.
     * @returns {number} Terrain elevation scale
     */
    getHeightFactor() {
      return this._heightFactor;
    }
    /**
     * Sets terrain provider
     * @public
     * @param {EmptyTerrain} terrain - Terrain provider.
     */
    setTerrain(terrain) {
      this._renderCompletedActivated = false;
      this._terrainCompletedActivated = false;
      if (this._initialized) {
        this.memClear();
      }
      if (this.terrain) {
        this.terrain.abortLoading();
        this.terrain.clearCache();
        this.terrain._planet = null;
      }
      this.terrain = terrain;
      this.terrain._planet = this;
      this.quadTreeStrategy.destroyBranches();
      if (terrain._geoid.model) {
        this._plainSegmentWorker.setGeoid(terrain.getGeoid());
        terrain._isReady = true;
      } else {
        Geoid.loadModel(terrain.geoid.src).then((m5) => {
          terrain.geoid.setModel(m5);
          this._plainSegmentWorker.setGeoid(terrain.getGeoid());
          terrain._isReady = true;
        }).catch((err) => {
          console.warn(err);
        });
      }
    }
    initAtmosphereShader(atmosParams) {
      if (this.renderer && this.renderer.handler && this._atmosphereEnabled) {
        let h8 = this.renderer.handler;
        if (h8.isWebGl2()) {
          h8.removeProgram("drawnode_screen_wl");
          h8.addProgram(drawnode_screen_wl_webgl2Atmos(atmosParams), true);
        } else {
          console.warn("Atmosphere WebGL2 only");
        }
      }
    }
    get atmosphereControl() {
      return this._atmosphere;
    }
    _initializeAtmosphere() {
      if (!this.renderer)
        return;
      let h8 = this.renderer.handler;
      h8.removeProgram("drawnode_screen_wl");
      if (this._atmosphereEnabled) {
        this._renderScreenNodesPASS = this._renderScreenNodesPASSAtmos;
        this._renderScreenNodesWithHeightPASS = this._renderScreenNodesWithHeightPASSAtmos;
        if (!this.renderer.controls.Atmosphere) {
          this.addControl(this._atmosphere);
        }
        this._atmosphere.activate();
        if (h8.isWebGl2()) {
          h8.addProgram(drawnode_screen_wl_webgl2Atmos(this._atmosphere.parameters), true);
        } else {
          h8.addProgram(drawnode_screen_wl_webgl1NoAtmos(), true);
        }
        if (this.renderer.controls.SimpleSkyBackground) {
          this.renderer.controls.SimpleSkyBackground.deactivate();
        }
      } else {
        this._renderScreenNodesPASS = this._renderScreenNodesPASSNoAtmos;
        this._renderScreenNodesWithHeightPASS = this._renderScreenNodesWithHeightPASSNoAtmos;
        this._atmosphere.deactivate();
        if (!this.renderer.controls.SimpleSkyBackground) {
          this.addControl(new SimpleSkyBackground());
        } else {
          this.renderer.controls.SimpleSkyBackground.activate();
        }
        if (h8.isWebGl2()) {
          h8.addProgram(drawnode_screen_wl_webgl2NoAtmos(), true);
        } else {
          h8.addProgram(drawnode_screen_wl_webgl1NoAtmos(), true);
        }
      }
    }
    _initializeShaders() {
      let h8 = this.renderer.handler;
      h8.addProgram(drawnode_screen_nl(), true);
      h8.addProgram(drawnode_colorPicking(), true);
      h8.addProgram(drawnode_depth(), true);
      h8.addProgram(drawnode_heightPicking(), true);
      this.renderer.addPickingCallback(this, this._renderColorPickingFramebufferPASS);
      this.renderer.addDepthCallback(this, this._renderDepthFramebufferPASS);
      this.renderer.addDistanceCallback(this, this._renderDistanceFramebufferPASS);
    }
    _onLayerLoadend(layer) {
      this.events.dispatch(this.events.layerloadend, layer);
    }
    init() {
      this._tileLoader.events.on("layerloadend", this._onLayerLoadend, this);
      getInstance().setMaxGridSize(this._maxGridSize);
      const TABLESIZE = this._maxGridSize;
      let kk = 0;
      for (let i9 = 0; i9 <= TABLESIZE; i9++) {
        !this._indexesCache[i9] && (this._indexesCache[i9] = new Array(TABLESIZE));
        for (let j2 = 0; j2 <= TABLESIZE; j2++) {
          !this._indexesCache[i9][j2] && (this._indexesCache[i9][j2] = new Array(TABLESIZE));
          for (let k3 = 0; k3 <= TABLESIZE; k3++) {
            !this._indexesCache[i9][j2][k3] && (this._indexesCache[i9][j2][k3] = new Array(TABLESIZE));
            for (let m5 = 0; m5 <= TABLESIZE; m5++) {
              !this._indexesCache[i9][j2][k3][m5] && (this._indexesCache[i9][j2][k3][m5] = new Array(TABLESIZE));
              for (let q2 = 0; q2 <= TABLESIZE; q2++) {
                let ptr = {
                  buffer: null
                };
                if (i9 >= 1 && i9 === j2 && i9 === k3 && i9 === m5 && i9 === q2) {
                  let indexes = getInstance().createSegmentIndexes(i9, [j2, k3, m5, q2]);
                  ptr.buffer = this.renderer.handler.createElementArrayBuffer(indexes, 1);
                } else {
                  this._indexesCacheToRemove[kk++] = ptr;
                }
                this._indexesCache[i9][j2][k3][m5][q2] = ptr;
              }
            }
          }
        }
      }
      this.renderer.events.on("resize", () => {
        this._renderCompletedActivated = false;
        this._terrainCompletedActivated = false;
      });
      this.renderer.events.on("drawtransparent", () => {
        this._renderScreenNodesWithHeightPASS();
      });
      this._textureCoordsBufferCache = [];
      let texCoordCache = getInstance().initTextureCoordsTable(TABLESIZE + 1);
      for (let i9 = 0; i9 <= TABLESIZE; i9++) {
        this._textureCoordsBufferCache[i9] = this.renderer.handler.createArrayBuffer(texCoordCache[i9], 2, ((1 << i9) + 1) * ((1 << i9) + 1));
      }
      this.renderer.handler.createDefaultTexture(null, (t9) => {
        this.solidTextureOne = t9;
        this.solidTextureTwo = t9;
      });
      this.transparentTexture = this.renderer.handler.transparentTexture;
      this._renderedNodesInFrustum = new Array(this.camera.frustums.length);
      for (let i9 = 0, len = this._renderedNodesInFrustum.length; i9 < len; i9++) {
        this._renderedNodesInFrustum[i9] = [];
      }
      this.quadTreeStrategy.init();
      this.drawMode = this.renderer.handler.gl.TRIANGLE_STRIP;
      this._initializeShaders();
      this._initializeAtmosphere();
      this._updateVisibleLayers();
      this.renderer.addPickingCallback(this, this._frustumEntityCollectionPickingCallback);
      if (this._nightTextureSrc) {
        let img = new Image();
        img.crossOrigin = "Anonymous";
        img.onload = () => {
          this._nightTexture = this.renderer.handler.createTextureDefault(img);
          this._nightTexture.default = true;
        };
        img.src = this._nightTextureSrc;
      }
      if (this._specularTextureSrc) {
        let img = new Image();
        img.crossOrigin = "Anonymous";
        img.onload = () => {
          this._specularTexture = this.renderer.handler.createTextureDefault(img);
          this._specularTexture.default = true;
        };
        img.src = this._specularTextureSrc;
      }
      this._geoImageCreator.init();
      this._vectorTileCreator.init();
      this._normalMapCreator.init();
      this.renderer.events.on("draw", this._globalPreDraw, this, -100);
      this._preRender();
      this.renderer.events.on("postdraw", () => {
        this._checkRendercompleted();
      });
      this.initLayers();
      this._initialized = true;
      if (this._initialViewExtent) {
        this.viewExtent(this._initialViewExtent);
      }
      this.renderer.activeCamera = this.camera;
      this.camera.bindRenderer(this.renderer);
      this.camera.update();
    }
    initLayers() {
      let temp = [...this._layers];
      for (let i9 = 0; i9 < temp.length; i9++) {
        this.removeLayer(temp[i9]);
        this.addLayer(temp[i9]);
      }
    }
    _clearIndexesCache() {
      this._indexesCacheToRemoveCounter = 0;
      let c7 = this._indexesCacheToRemove, gl = this.renderer.handler.gl;
      for (let i9 = 0, len = c7.length; i9 < len; i9++) {
        let ci = c7[i9];
        gl.deleteBuffer(ci.buffer);
        ci.buffer = null;
      }
    }
    _preRender() {
      this.quadTreeStrategy.preRender();
      this._preLoad();
    }
    _preLoad() {
      this._clearRenderedNodeList();
      this._skipPreRender = false;
      this.quadTreeStrategy.preLoad();
    }
    /**
     * Creates default textures first for the North Pole and whole globe and second for the South Pole.
     * @public
     * @param{IDefaultTextureParams} param0 -
     * @param{IDefaultTextureParams} param1 -
     */
    createDefaultTextures(param0, param1) {
      this.renderer.handler.gl.deleteTexture(this.solidTextureOne);
      this.renderer.handler.gl.deleteTexture(this.solidTextureTwo);
      this.renderer.handler.createDefaultTexture(param0, (texture) => {
        this.solidTextureOne = texture;
      });
      this.renderer.handler.createDefaultTexture(param1, (texture) => {
        this.solidTextureTwo = texture;
      });
    }
    _getLayerAttributionHTML(layer) {
      return `<div class="og-attribution__layer">${layer.getAttribution()}</div>`;
    }
    /**
     * Updates attribution lists
     * @public
     */
    updateAttributionsList() {
      let html = "";
      for (let i9 = 0, len = this._layers.length; i9 < len; i9++) {
        let li = this._layers[i9];
        if (li.getVisibility()) {
          if (li.getAttribution().length) {
            html += this._getLayerAttributionHTML(li);
          }
        }
      }
      this._applyAttribution(html);
    }
    updateVisibleLayers() {
      this._updateLayer = true;
    }
    _updateVisibleLayers() {
      this.visibleTileLayers = [];
      this.visibleTileLayers.length = 0;
      this.visibleVectorLayers = [];
      this.visibleVectorLayers.length = 0;
      let html = "";
      for (let i9 = 0, len = this._layers.length; i9 < len; i9++) {
        let li = this._layers[i9];
        if (li.getVisibility()) {
          if (li.isBaseLayer()) {
            this.createDefaultTextures(li._defaultTextures[0], li._defaultTextures[1]);
            this.baseLayer = li;
          }
          if (li.hasImageryTiles()) {
            this.visibleTileLayers.push(li);
          }
          if (li.isVector) {
            this.visibleVectorLayers.push(li);
          }
          if (li.getAttribution().length) {
            html += this._getLayerAttributionHTML(li);
          }
        } else if (li._fading && li._fadingOpacity > 0) {
          if (li.hasImageryTiles()) {
            this.visibleTileLayers.push(li);
          }
          if (li.isVector) {
            this.visibleVectorLayers.push(li);
          }
        }
      }
      this._applyAttribution(html);
      this._sortLayers();
    }
    /**
     * Apply to render list of layer attributions
     * @protected
     */
    _applyAttribution(html) {
      if (this.renderer && this.renderer.div) {
        if (html.length) {
          if (this.renderer.div.attributions.innerHTML !== html) {
            this.renderer.div.attributions.innerHTML = html;
          }
        } else {
          this.renderer.div.attributions.innerHTML = "";
        }
      }
    }
    /**
     * Sort visible layer - preparing for rendering.
     * @protected
     */
    _sortLayers() {
      this.visibleVectorLayers.sort((a6, b4) => a6.getZIndex() - b4.getZIndex() || a6.getHeight() - b4.getHeight());
      this._visibleTileLayerSlices = [];
      this._visibleTileLayerSlices.length = 0;
      if (this.visibleTileLayers.length) {
        this.visibleTileLayers.sort((a6, b4) => a6.getHeight() - b4.getHeight() || a6.getZIndex() - b4.getZIndex());
        let k3 = -1;
        let currHeight = this.visibleTileLayers[0].getHeight();
        for (let i9 = 0, len = this.visibleTileLayers.length; i9 < len; i9++) {
          if (i9 % this.SLICE_SIZE === 0 || this.visibleTileLayers[i9].getHeight() !== currHeight) {
            k3++;
            this._visibleTileLayerSlices[k3] = [];
            currHeight = this.visibleTileLayers[i9].getHeight();
          }
          this._visibleTileLayerSlices[k3].push(this.visibleTileLayers[i9]);
        }
      }
    }
    _clearRenderedNodeList() {
      this._renderedNodes.length = 0;
      this._renderedNodes = [];
    }
    _clearRenderNodesInFrustum() {
      for (let i9 = 0, len = this._renderedNodesInFrustum.length; i9 < len; i9++) {
        this._renderedNodesInFrustum[i9].length = 0;
        this._renderedNodesInFrustum[i9] = [];
      }
    }
    _collectRenderedNodesMaxZoom(cam) {
      if (cam.slope > this.minEqualZoomCameraSlope && cam._lonLat.height < this.maxEqualZoomAltitude && cam._lonLat.height > this.minEqualZoomAltitude) {
        this.minCurrZoom = this.maxCurrZoom;
        let temp = this._renderedNodes, rf = this._renderedNodesInFrustum, temp2 = [];
        this._clearRenderNodesInFrustum();
        this._renderedNodes = [];
        for (let i9 = 0, len = temp.length; i9 < len; i9++) {
          let ri = temp[i9];
          let ht2 = ri.segment.centerNormal.dot(cam._b);
          if (ri.segment.tileZoom === this.maxCurrZoom || ht2 < HORIZON_TANGENT) {
            this._renderedNodes.push(ri);
            let k3 = 0, inFrustum = ri.inFrustum;
            while (inFrustum) {
              if (inFrustum & 1) {
                rf[k3].push(ri);
              }
              k3++;
              inFrustum >>= 1;
            }
          } else {
            temp2.push(ri);
          }
        }
        for (let i9 = 0, len = temp2.length; i9 < len; i9++) {
          temp2[i9].renderTree(cam, this.maxCurrZoom, null, false, temp2[i9]);
        }
      }
    }
    set transitionOpacityEnabled(isEnabled) {
      this._transitionOpacityEnabled = isEnabled;
    }
    get transitionOpacityEnabled() {
      return this._transitionOpacityEnabled;
    }
    /**
     * Collects visible quad nodes.
     * @protected
     */
    _collectRenderNodes(cam) {
      this._lodSize = lerp(cam.slope < 0 ? 0 : cam.slope, this._curLodSize, this._minLodSize);
      cam._insideSegment = null;
      this._clearRenderedNodeList();
      this._clearRenderNodesInFrustum();
      this._viewExtent.southWest.set(180, 180);
      this._viewExtent.northEast.set(-180, -180);
      this._visibleNodes = {};
      this._visibleNodesNorth = {};
      this._visibleNodesSouth = {};
      this.minCurrZoom = MAX;
      this.maxCurrZoom = MIN;
      this.quadTreeStrategy.collectRenderNodes();
      this._collectRenderedNodesMaxZoom(cam);
      this._fadingNodes.clear();
      if (this._transitionOpacityEnabled) {
        let opaqueNodes = [];
        for (let i9 = 0; i9 < this._renderedNodes.length; i9++) {
          let ri = this._renderedNodes[i9];
          ri._collectFadingNodes();
          ri._refreshTransitionOpacity();
          if (ri.segment._transitionOpacity >= 1) {
            ri.clearNeighbors();
            ri.getRenderedNodesNeighbors(opaqueNodes);
            opaqueNodes.push(ri);
          } else {
            for (let j2 = 0; j2 < ri._fadingNodes.length; j2++) {
              let rij = ri._fadingNodes[j2];
              if (rij.segment && rij.segment._transitionOpacity >= 1) {
                rij.clearNeighbors();
                rij.getRenderedNodesNeighbors(opaqueNodes);
                opaqueNodes.push(rij);
              }
            }
          }
        }
      }
    }
    _renderScreenNodesPASSNoAtmos() {
      let cam = this.renderer.activeCamera;
      let sh = this._setUniformsNoAtmos(cam);
      this._renderingScreenNodes(sh, cam, this._renderedNodesInFrustum[cam.currentFrustumIndex]);
    }
    _renderScreenNodesPASSAtmos() {
      let cam = this.renderer.activeCamera;
      let sh = this._setUniformsAtmos(cam);
      this._renderingScreenNodes(sh, cam, this._renderedNodesInFrustum[cam.currentFrustumIndex]);
    }
    _renderScreenNodesWithHeightPASSNoAtmos() {
      let cam = this.renderer.activeCamera;
      let sh = this._setUniformsNoAtmos(cam);
      this._renderingScreenNodesWithHeight(sh, cam, this._renderedNodesInFrustum[cam.currentFrustumIndex]);
    }
    _renderScreenNodesWithHeightPASSAtmos() {
      let cam = this.renderer.activeCamera;
      let sh = this._setUniformsAtmos(cam);
      this._renderingScreenNodesWithHeight(sh, cam, this._renderedNodesInFrustum[cam.currentFrustumIndex]);
    }
    _globalPreDraw() {
      let cam = this.camera;
      this.renderer.__useDistanceFramebuffer__ = !this.terrain.isEmpty;
      this._distBeforeMemClear += this._prevCamEye.distance(cam.eye);
      this._prevCamEye.copy(cam.eye);
      cam.checkFly();
      if (this._createdNodesCount > MAX_NODES && this._distBeforeMemClear > 1e3) {
        this.terrain.clearCache();
        this.memClear();
      }
      if (this._indexesCacheToRemoveCounter > 600) {
        this._clearIndexesCache();
      }
    }
    /**
     * Render node callback.
     * @public
     */
    preFrame() {
      if (this._updateLayer) {
        this._updateLayer = false;
        this._updateVisibleLayers();
      }
      if (this.camera.isFirstPass) {
        this.camera.update();
        if (this._skipPreRender && this._collectRenderNodesIsActive) {
          this._collectRenderNodes(this.camera);
        }
        this._skipPreRender = true;
        this.transformLights();
        this._normalMapCreator.frame();
        this._geoImageCreator.frame();
        this._vectorTileCreator.frame();
        this.camera.checkTerrainCollision();
        this.camera.update();
        this.events.dispatch(this.events.draw, this);
        this._collectVectorLayerCollections();
      }
      this.drawEntityCollections(this._frustumEntityCollections);
    }
    /**
     * Render node callback.
     * Frame function is called for each renderer activrCamera frustum.
     * @public
     * @override
     */
    frame() {
      this._renderScreenNodesPASS();
    }
    _checkRendercompleted() {
      if (this._renderCompleted) {
        if (!this._renderCompletedActivated) {
          this._renderCompletedActivated = true;
          this.events.dispatch(this.events.rendercompleted, true);
        }
      } else {
        this._renderCompletedActivated = false;
      }
      this._renderCompleted = true;
      if (this._terrainCompleted) {
        if (!this._terrainCompletedActivated) {
          this._terrainCompletedActivated = true;
          this.events.dispatch(this.events.terraincompleted, true);
        }
      } else {
        this._terrainCompletedActivated = false;
      }
      this._terrainCompleted = true;
    }
    lockQuadTree() {
      this._collectRenderNodesIsActive = false;
      this.camera.setTerrainCollisionActivity(false);
    }
    unlockQuadTree() {
      this._collectRenderNodesIsActive = true;
      this.camera.setTerrainCollisionActivity(true);
    }
    _setUniformsNoAtmos(cam) {
      let sh, shu;
      let renderer = this.renderer;
      let h8 = renderer.handler;
      let gl = h8.gl;
      gl.enable(gl.CULL_FACE);
      renderer.enableBlendOneSrcAlpha();
      if (this.lightEnabled) {
        h8.programs.drawnode_screen_wl.activate();
        sh = h8.programs.drawnode_screen_wl._program;
        shu = sh.uniforms;
        gl.uniform3fv(shu.lightsPositions, this._lightsPositions);
        gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
        if (this.baseLayer) {
          gl.uniform3fv(shu.diffuse, this.baseLayer._diffuse || this._diffuse);
          gl.uniform3fv(shu.ambient, this.baseLayer._ambient || this._ambient);
          gl.uniform4fv(shu.specular, this.baseLayer._specular || this._specular);
          gl.uniform1f(shu.nightTextureCoefficient, this.baseLayer.nightTextureCoefficient || this.nightTextureCoefficient);
        } else {
          gl.uniform3fv(shu.diffuse, this._diffuse);
          gl.uniform3fv(shu.ambient, this._ambient);
          gl.uniform4fv(shu.specular, this._specular);
          gl.uniform1f(shu.nightTextureCoefficient, this.nightTextureCoefficient);
        }
        gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE);
        gl.bindTexture(gl.TEXTURE_2D, this._nightTexture || this.transparentTexture);
        gl.uniform1i(shu.nightTexture, this.SLICE_SIZE);
        gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE + 1);
        gl.bindTexture(gl.TEXTURE_2D, this._specularTexture || this.transparentTexture);
        gl.uniform1i(shu.specularTexture, this.SLICE_SIZE + 1);
        gl.uniform1f(shu.camHeight, cam.getHeight());
      } else {
        h8.programs.drawnode_screen_nl.activate();
        sh = h8.programs.drawnode_screen_nl._program;
        shu = sh.uniforms;
        gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
      }
      gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
      gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);
      return sh;
    }
    _setUniformsAtmos(cam) {
      let sh, shu;
      let renderer = this.renderer;
      let h8 = renderer.handler;
      let gl = h8.gl;
      gl.enable(gl.CULL_FACE);
      renderer.enableBlendOneSrcAlpha();
      if (this.lightEnabled) {
        h8.programs.drawnode_screen_wl.activate();
        sh = h8.programs.drawnode_screen_wl._program;
        shu = sh.uniforms;
        gl.uniform3fv(shu.lightsPositions, this._lightsPositions);
        gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
        if (this.baseLayer) {
          gl.uniform3fv(shu.diffuse, this.baseLayer._diffuse || this._diffuse);
          gl.uniform3fv(shu.ambient, this.baseLayer._ambient || this._ambient);
          gl.uniform4fv(shu.specular, this.baseLayer._specular || this._specular);
          gl.uniform1f(shu.nightTextureCoefficient, this.baseLayer.nightTextureCoefficient || this.nightTextureCoefficient);
        } else {
          gl.uniform3fv(shu.diffuse, this._diffuse);
          gl.uniform3fv(shu.ambient, this._ambient);
          gl.uniform4fv(shu.specular, this._specular);
          gl.uniform1f(shu.nightTextureCoefficient, this.nightTextureCoefficient);
        }
        gl.uniform2fv(shu.maxMinOpacity, this._atmosphereMaxMinOpacity);
        gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE);
        gl.bindTexture(gl.TEXTURE_2D, this._nightTexture || this.transparentTexture);
        gl.uniform1i(shu.nightTexture, this.SLICE_SIZE);
        gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE + 1);
        gl.bindTexture(gl.TEXTURE_2D, this._specularTexture || this.transparentTexture);
        gl.uniform1i(shu.specularTexture, this.SLICE_SIZE + 1);
        gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE + 4);
        gl.bindTexture(gl.TEXTURE_2D, renderer.controls.Atmosphere._transmittanceBuffer.textures[0]);
        gl.uniform1i(shu.transmittanceTexture, this.SLICE_SIZE + 4);
        gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE + 5);
        gl.bindTexture(gl.TEXTURE_2D, renderer.controls.Atmosphere._scatteringBuffer.textures[0]);
        gl.uniform1i(shu.scatteringTexture, this.SLICE_SIZE + 5);
        gl.uniform1f(shu.camHeight, cam.getHeight());
      } else {
        h8.programs.drawnode_screen_nl.activate();
        sh = h8.programs.drawnode_screen_nl._program;
        shu = sh.uniforms;
        gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
      }
      gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
      gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);
      return sh;
    }
    /**
     * Drawing nodes
     */
    _renderingScreenNodes(sh, cam, renderedNodes) {
      let firstPass = cam.isFirstPass;
      let sl = this._visibleTileLayerSlices;
      if (sl.length) {
        let sli = sl[0];
        for (let i10 = sli.length - 1; i10 >= 0; --i10) {
          let li = sli[i10];
          if (li._fading && firstPass && li._refreshFadingOpacity()) {
            sli.splice(i10, 1);
          }
        }
      }
      let nodes = /* @__PURE__ */ new Map();
      let transparentSegments = [];
      let isEq = this.terrain.equalizeVertices;
      let i9 = renderedNodes.length;
      if (cam.slope > 0.8) {
        while (i9--) {
          let ri = renderedNodes[i9];
          let s7 = ri.segment;
          this._renderingFadingNodesNoDepth(nodes, sh, ri, sl[0], 0);
          isEq && s7.equalize();
          s7.readyToEngage && s7.engage();
          s7.screenRendering(sh, sl[0], 0);
        }
      } else {
        while (i9--) {
          let ri = renderedNodes[i9];
          let s7 = ri.segment;
          this._renderingFadingNodes(nodes, sh, ri, sl[0], 0, transparentSegments);
          if (s7._transitionOpacity < 1) {
            transparentSegments.push(s7);
          } else {
            isEq && s7.equalize();
            s7.readyToEngage && s7.engage();
            s7.screenRendering(sh, sl[0], 0);
          }
        }
        for (let j2 = 0; j2 < transparentSegments.length; j2++) {
          let tj = transparentSegments[j2];
          isEq && tj.equalize();
          tj.readyToEngage && tj.engage();
          tj.screenRendering(sh, sl[0], 0);
        }
      }
    }
    _renderingScreenNodesWithHeight(sh, cam, renderedNodes) {
      let gl = this.renderer.handler.gl;
      let firstPass = cam.isFirstPass;
      let sl = this._visibleTileLayerSlices;
      gl.enable(gl.POLYGON_OFFSET_FILL);
      gl.disable(gl.CULL_FACE);
      let nodes = /* @__PURE__ */ new Map();
      let transparentSegments = [];
      for (let j2 = 1, len = sl.length; j2 < len; j2++) {
        let slj = sl[j2];
        for (let i10 = slj.length - 1; i10 >= 0; --i10) {
          let li = slj[i10];
          if (li._fading && firstPass && li._refreshFadingOpacity()) {
            slj.splice(i10, 1);
          }
        }
        gl.polygonOffset(0, -j2);
        let i9 = renderedNodes.length;
        while (i9--) {
          let ri = renderedNodes[i9];
          this._renderingFadingNodes(nodes, sh, ri, sl[j2], j2, transparentSegments);
          if (ri.segment._transitionOpacity < 1) {
            ri.segment.initSlice(j2);
          } else {
            ri.segment.screenRendering(sh, sl[j2], j2, this.transparentTexture, true);
          }
        }
      }
      gl.disable(gl.POLYGON_OFFSET_FILL);
      gl.enable(gl.CULL_FACE);
    }
    _renderDistanceFramebufferPASS() {
      if (!this.terrain.isEmpty) {
        let sh;
        let renderer = this.renderer;
        let h8 = renderer.handler;
        let gl = h8.gl;
        let cam = renderer.activeCamera;
        h8.programs.drawnode_heightPicking.activate();
        sh = h8.programs.drawnode_heightPicking._program;
        let shu = sh.uniforms;
        gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
        gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
        gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
        gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);
        let rn = this._renderedNodesInFrustum[cam.currentFrustumIndex];
        let sl = this._visibleTileLayerSlices;
        let i9 = rn.length;
        while (i9--) {
          rn[i9].segment.heightPickingRendering(sh, sl[0]);
        }
      }
    }
    _renderColorPickingFramebufferPASS() {
      let sh;
      let renderer = this.renderer;
      let h8 = renderer.handler;
      let gl = h8.gl;
      h8.programs.drawnode_colorPicking.activate();
      sh = h8.programs.drawnode_colorPicking._program;
      let shu = sh.uniforms;
      let cam = renderer.activeCamera;
      gl.enable(gl.CULL_FACE);
      gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
      gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
      gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
      gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);
      let rn = this._renderedNodesInFrustum[cam.getCurrentFrustum()];
      let sl = this._visibleTileLayerSlices;
      let i9 = rn.length;
      while (i9--) {
        rn[i9].segment.colorPickingRendering(sh, sl[0], 0);
      }
      renderer.enableBlendDefault();
      gl.enable(gl.POLYGON_OFFSET_FILL);
      for (let j2 = 1, len = sl.length; j2 < len; j2++) {
        i9 = rn.length;
        gl.polygonOffset(0, -j2);
        while (i9--) {
          rn[i9].segment.colorPickingRendering(sh, sl[j2], j2, this.transparentTexture, true);
        }
      }
      gl.disable(gl.POLYGON_OFFSET_FILL);
    }
    _renderDepthFramebufferPASS() {
      let sh;
      let renderer = this.renderer;
      let h8 = renderer.handler;
      let gl = h8.gl;
      h8.programs.drawnode_depth.activate();
      sh = h8.programs.drawnode_depth._program;
      let shu = sh.uniforms;
      let cam = renderer.activeCamera;
      gl.disable(gl.BLEND);
      gl.disable(gl.POLYGON_OFFSET_FILL);
      gl.uniformMatrix4fv(shu.viewMatrix, false, cam.getViewMatrix());
      gl.uniformMatrix4fv(shu.projectionMatrix, false, cam.getProjectionMatrix());
      gl.uniform3fv(shu.eyePositionHigh, cam.eyeHigh);
      gl.uniform3fv(shu.eyePositionLow, cam.eyeLow);
      gl.uniform3fv(shu.frustumPickingColor, cam.frustum._pickingColorU);
      let rn = this._renderedNodesInFrustum[cam.getCurrentFrustum()], sl = this._visibleTileLayerSlices;
      let i9 = rn.length;
      while (i9--) {
        rn[i9].segment.depthRendering(sh, sl[0]);
      }
      gl.enable(gl.BLEND);
    }
    _collectVectorLayerCollections() {
      this._frustumEntityCollections.length = 0;
      this._frustumEntityCollections = [];
      let i9 = this.visibleVectorLayers.length;
      while (i9--) {
        let vi = this.visibleVectorLayers[i9];
        if (vi._fading && vi._refreshFadingOpacity()) {
          this.visibleVectorLayers.splice(i9, 1);
        }
        vi.collectVisibleCollections(this._frustumEntityCollections);
        vi.update();
      }
    }
    _frustumEntityCollectionPickingCallback() {
      this.drawPickingEntityCollections(this._frustumEntityCollections);
    }
    /**
     * Starts clear memory thread.
     * @public
     */
    memClear() {
      this._distBeforeMemClear = 0;
      this.camera._insideSegment = null;
      this.layerLock.lock(this._memKey);
      this.terrainLock.lock(this._memKey);
      this._normalMapCreator.lock(this._memKey);
      this._normalMapCreator.clear();
      this.terrain.abortLoading();
      this._tileLoader.abortAll();
      this.quadTreeStrategy.clear();
      this.layerLock.free(this._memKey);
      this.terrainLock.free(this._memKey);
      this._normalMapCreator.free(this._memKey);
      this._createdNodesCount = 0;
    }
    /**
     * Returns ray vector hit ellipsoid coordinates.
     * If the ray doesn't hit ellipsoid it returns 'undefined'.
     * @public
     * @param {Ray} ray - Ray.
     * @returns {Vec3 | undefined} -
     */
    getRayIntersectionEllipsoid(ray) {
      return this.ellipsoid.hitRay(ray.origin, ray.direction);
    }
    /**
     * Project screen coordinates to the planet ellipsoid.
     * @public
     * @param {Vec2 | IBaseInputState } px - Screen coordinates.
     * @returns {Vec3 | undefined} - Cartesian coordinates.
     */
    getCartesianFromPixelEllipsoid(px) {
      let cam = this.renderer.activeCamera;
      return this.ellipsoid.hitRay(cam.eye, cam.unproject(px.x, px.y));
    }
    /**
     * Project screen coordinates to the planet ellipsoid.
     * @public
     * @param {Vec2 | IBaseInputState} px - Screen coordinates.
     * @returns {LonLat | undefined} - Geodetic coordinates.
     */
    getLonLatFromPixelEllipsoid(px) {
      let coords = this.getCartesianFromPixelEllipsoid(px);
      if (coords) {
        return this.ellipsoid.cartesianToLonLat(coords);
      }
    }
    /**
     * Returns mouse position cartesian coordinates on the current terrain.
     * @public
     * @returns {Vec3 | undefined} -
     */
    getCartesianFromMouseTerrain() {
      let ms2 = this.renderer.events.mouseState;
      let distance = this.getDistanceFromPixel(ms2);
      if (distance) {
        return ms2.direction.scaleTo(distance).addA(this.renderer.activeCamera.eye);
      }
    }
    /**
     * Returns screen coordinates cartesian coordinates on the current terrain.
     * position or null if input coordinates is outside the planet.
     * @public
     * @param {Vec2} px - Pixel screen 2d coordinates.
     * @returns {Vec3 | undefined} -
     */
    getCartesianFromPixelTerrain(px) {
      let distance = this.getDistanceFromPixel(px);
      if (distance) {
        let direction = px.direction || this.renderer.activeCamera.unproject(px.x, px.y);
        return direction.scaleTo(distance).addA(this.renderer.activeCamera.eye);
      }
    }
    /**
     * Returns geodetic coordinates on the current terrain planet by its screen coordinates.
     * position or null if input coordinates is outside the planet.
     * @public
     * @param {Vec2 | IBaseInputState} px - Pixel screen 2d coordinates.
     * @returns {LonLat | undefined} -
     */
    getLonLatFromPixelTerrain(px) {
      let coords = this.getCartesianFromPixelTerrain(px);
      if (coords) {
        return this.ellipsoid.cartesianToLonLat(coords);
      }
    }
    /**
     * Project cartesian coordinates to screen space.
     * @public
     * @param {Vec3} coords - Cartesian coordinates.
     * @returns {Vec2} - Screen coordinates.
     */
    getPixelFromCartesian(coords) {
      return this.renderer.activeCamera.project(coords);
    }
    /**
     * Project geodetic coordinates to screen space.
     * @public
     * @param {LonLat} lonlat - Geodetic coordinates.
     * @returns {Vec2 | undefined} - Screen coordinates.
     */
    getPixelFromLonLat(lonlat) {
      let coords = this.ellipsoid.lonLatToCartesian(lonlat);
      if (coords) {
        return this.renderer.activeCamera.project(coords);
      }
    }
    /**
     * Returns distance from an active (screen) camera to the planet ellipsoid.
     * @public
     * @param {Vec2} px - Screen coordinates.
     * @returns {number} -
     */
    getDistanceFromPixelEllipsoid(px) {
      let coords = this.getCartesianFromPixelEllipsoid(px);
      if (coords) {
        return coords.distance(this.renderer.activeCamera.eye);
      }
    }
    /**
     * Returns distance from active (screen) camera to the planet terrain by screen coordinates.
     * @public
     * @param {Vec2 | IBaseInputState} px - Screen coordinates.
     * @returns {number | undefined} -
     */
    getDistanceFromPixel(px) {
      if (this.terrain.isEmpty) {
        return this.getDistanceFromPixelEllipsoid(px) || 0;
      } else {
        let r8 = this.renderer;
        let cnv = r8.handler.canvas;
        let spx = px.x / cnv.width;
        let spy = (cnv.height - px.y) / cnv.height;
        _tempPickingPix_[0] = _tempPickingPix_[1] = _tempPickingPix_[2] = 0;
        let dist = 0;
        r8.readDistanceColor(spx, spy, _tempPickingPix_);
        dist = decodeFloatFromRGBAArr(_tempPickingPix_);
        if (!(_tempPickingPix_[0] || _tempPickingPix_[1] || _tempPickingPix_[2])) {
          dist = this.getDistanceFromPixelEllipsoid(px) || 0;
        } else if (dist < DEPTH_DISTANCE) {
          r8.screenDepthFramebuffer.activate();
          r8.screenDepthFramebuffer.readPixels(_tempDepthColor_, spx, spy);
          let screenPos = new Vec4(spx * 2 - 1, spy * 2 - 1, _tempDepthColor_[0] / 255 * 2 - 1, 1 * 2 - 1);
          let viewPosition = this.camera.frustums[0].inverseProjectionMatrix.mulVec4(screenPos);
          let dir = px.direction || r8.activeCamera.unproject(px.x, px.y);
          dist = -(viewPosition.z / viewPosition.w) / dir.dot(r8.activeCamera.getForward());
          r8.screenDepthFramebuffer.deactivate();
        }
        return dist;
      }
    }
    /**
     * Sets camera to the planet geographical extent.
     * @public
     * @param {Extent} extent - Geographical extent.
     */
    viewExtent(extent) {
      if (this.camera) {
        this.camera.viewExtent(extent);
      } else {
        this._initialViewExtent = extent;
      }
    }
    /**
     * Fits camera position for the view extent.
     * @public
     * @param {Array.<number>} extentArr - Geographical extent array, (exactly 4 entries)
     * where index 0 - southwest longitude, 1 - latitude southwest, 2 - longitude northeast, 3 - latitude northeast.
     */
    viewExtentArr(extentArr) {
      this.viewExtent(new Extent(new LonLat(extentArr[0], extentArr[1]), new LonLat(extentArr[2], extentArr[3])));
    }
    /**
     * Gets current camera view extent.
     * @public
     * @returns {Extent} -
     */
    getViewExtent() {
      return this._viewExtent;
    }
    /**
     * Sets camera to the planet geographical position.
     * @public
     * @param {LonLat} lonlat - Camera position.
     * @param {LonLat} [lookLonLat] - Viewpoint.
     * @param {Vec3} [up] - Camera up vector.
     */
    viewLonLat(lonlat, lookLonLat, up) {
      this.camera.setLonLat(lonlat, lookLonLat, up);
    }
    /**
     * Fly active camera to the view extent.
     * @public
     * @param {Extent} extent - Geographical extent.
     * @param {Number} [height] - Height on the end of the flight route.
     * @param {Vec3} [up] - Camera UP vector on the end of a flying.
     * @param {Number} [ampl] - Altitude amplitude factor.
     * @param {Function} [startCallback] - Callback that calls before the flying begins.
     * @param {Function} [completeCallback] - Callback that calls after flying when flying is finished.
     */
    flyExtent(extent, height, up, ampl, completeCallback, startCallback) {
      this.camera.flyExtent(extent, height, up, ampl, completeCallback, startCallback);
    }
    /**
     * Fly camera to the point.
     * @public
     * @param {Vec3} cartesian - Point coordinates.
     * @param {Vec3} [look] - Camera "look at" point.
     * @param {Vec3} [up] - Camera UP vector on the end of a flying.
     * @param {Number} [ampl] - Altitude amplitude factor.
     * @param {Function} [completeCallback] - Call the function in the end of flight
     * @param {Function} [startCallback] - Call the function in the beginning
     * @param {Function} [frameCallback] - Each frame callback
     */
    flyCartesian(cartesian, look, up, ampl, completeCallback, startCallback, frameCallback) {
      this.camera.flyCartesian(cartesian, look, up, ampl, completeCallback, startCallback, frameCallback);
    }
    /**
     * Fly camera to the geodetic position.
     * @public
     * @param {LonLat} lonlat - Fly geographical coordinates.
     * @param {Vec3 | LonLat} [look] - Camera viewpoint in the end of the flight.
     * @param {Vec3} [up] - Camera UP vector on the end of a flying.
     * @param {Number} [ampl] - Altitude amplitude factor.
     * @param [completeCallback]
     * @param [startCallback]
     * @param [frameCallback]
     */
    flyLonLat(lonlat, look, up, ampl, completeCallback, startCallback, frameCallback) {
      this.camera.flyLonLat(lonlat, look, up, ampl, completeCallback, startCallback, frameCallback);
    }
    /**
     * Stop current flight.
     * @public
     */
    stopFlying() {
      this.camera.stopFlying();
    }
    updateBillboardsTexCoords() {
      for (let i9 = 0; i9 < this.entityCollections.length; i9++) {
        this.entityCollections[i9].billboardHandler.refreshTexCoordsArr();
      }
      let readyCollections = {};
      for (let i9 = 0; i9 < this._layers.length; i9++) {
        let li = this._layers[i9];
        if (li instanceof Vector) {
          li.each(function(e9) {
            if (e9._entityCollection && !readyCollections[e9._entityCollection.id]) {
              e9._entityCollection.billboardHandler.refreshTexCoordsArr();
              readyCollections[e9._entityCollection.id] = true;
            }
          });
        }
      }
    }
    getEntityTerrainPoint(entity, res) {
      let n7 = this._renderedNodes, i9 = n7.length;
      while (i9--) {
        if (n7[i9].segment.isEntityInside(entity)) {
          return n7[i9].segment.getEntityTerrainPoint(entity, res);
        }
      }
    }
    async getHeightDefault(lonLat) {
      return new Promise((resolve) => {
        if (this.terrain) {
          this.terrain.getHeightAsync(lonLat.clone(), (alt) => {
            resolve(alt);
          });
        } else {
          resolve(0);
        }
      });
    }
    async getHeightAboveELL(lonLat) {
      return new Promise((resolve) => {
        if (this.terrain) {
          this.terrain.getHeightAsync(lonLat.clone(), (alt) => {
            resolve(alt + this.terrain.geoid.getHeightLonLat(lonLat));
          });
        } else {
          resolve(0);
        }
      });
    }
    onremove() {
      this.memClear();
      this.quadTreeStrategy.destroyBranches();
      this._renderedNodes = [];
    }
  };
  var PLANET_EVENTS = [
    /**
     * Triggered before globe frame begins to render.
     * @event og.scene.Planet#draw
     */
    "draw",
    /**
     * Triggered when layer has added to the planet.
     * @event og.scene.Planet#layeradd
     */
    "layeradd",
    /**
     * Triggered when base layer changed.
     * @event og.scene.Planet#baselayerchange
     */
    "baselayerchange",
    /**
     * Triggered when layer has removed from the planet.
     * @event og.scene.Planet#layerremove
     */
    "layerremove",
    /**
     * Triggered when some layer visibility changed.
     * @event og.scene.Planet#layervisibilitychange
     */
    "layervisibilitychange",
    /**
     * Triggered when all data is loaded
     * @event og.scene.Planet#rendercompleted
     */
    "rendercompleted",
    /**
     * Triggered when all data is loaded
     * @event og.scene.Planet#terraincompleted
     */
    "terraincompleted",
    /**
     * Triggered when layer data is laded
     * @event og.scene.Planet#terraincompleted
     */
    "layerloadend"
  ];

  // frontend/node_modules/@openglobus/og/lib/js/terrain/EmptyTerrain.js
  var EmptyTerrain = class _EmptyTerrain {
    constructor(options2 = {}) {
      this.__id = _EmptyTerrain.__counter__++;
      this.equalizeVertices = options2.equalizeVertices || false;
      this.equalizeNormals = false;
      this.isEmpty = true;
      this.name = options2.name || "empty";
      this.minZoom = options2.minZoom || 2;
      this.maxZoom = options2.maxZoom || 19;
      this.maxNativeZoom = options2.maxNativeZoom || this.maxZoom;
      this.gridSizeByZoom = options2.gridSizeByZoom || [
        64,
        32,
        16,
        8,
        4,
        4,
        4,
        4,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2
      ];
      this._maxNodeZoom = this.gridSizeByZoom.length - 1;
      this.plainGridSize = 2;
      this.noDataValues = [];
      this._planet = null;
      this._geoid = options2.geoid || new Geoid({
        src: options2.geoidSrc || null
      });
      this._isReady = false;
    }
    /**
     * Sets url rewrite callback, used for custom url rewriting for every tile loading.
     * @public
     * @param {UrlRewriteFunc} ur - The callback that returns tile custom created url.
     */
    setUrlRewriteCallback(ur) {
    }
    get isIdle() {
      return true;
    }
    isEqual(obj) {
      return obj.__id === this.__id;
    }
    static checkNoDataValue(noDataValues, value) {
      return binarySearchFast(noDataValues, value) !== -1;
    }
    isBlur(segment) {
      return false;
    }
    set maxNodeZoom(val) {
      if (val > this.gridSizeByZoom.length - 1) {
        val = this.gridSizeByZoom.length - 1;
      }
      this._maxNodeZoom = val;
    }
    get maxNodeZoom() {
      return this._maxNodeZoom;
    }
    set geoid(geoid) {
      this._geoid = geoid;
    }
    get geoid() {
      return this._geoid;
    }
    getGeoid() {
      return this._geoid;
    }
    /**
     * Loads or creates segment elevation data.
     * @public
     * @param {Segment} segment - Segment to create elevation data.
     */
    handleSegmentTerrain(segment) {
      segment.terrainIsLoading = false;
      segment.terrainReady = true;
      segment.terrainExists = true;
    }
    isReady() {
      return this._isReady;
    }
    abortLoading() {
    }
    clearCache() {
    }
    getHeightAsync(lonLat, callback) {
      callback(0);
      return true;
    }
    loadTerrain(segment, forceLoading = false) {
    }
  };
  EmptyTerrain.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/layer/XYZ.js
  var XYZ = class extends Layer {
    constructor(name, options2 = {}) {
      super(name, options2);
      this.events = this.events.registerNames(XYZ_EVENTS);
      this.url = options2.url || "";
      this._s = options2.subdomains || ["a", "b", "c"];
      this.minNativeZoom = options2.minNativeZoom || 0;
      this.maxNativeZoom = options2.maxNativeZoom || 19;
      this._urlRewriteCallback = options2.urlRewrite || null;
      this._requestsPeerSubdomains = 4;
      this._requestCount = 0;
    }
    /**
     * @warning Use XYZ.isIdle in requestAnimationFrame(after setVisibility)
     */
    get isIdle() {
      return super.isIdle && this._planet._tileLoader.getRequestCounter(this) === 0;
    }
    get instanceName() {
      return "XYZ";
    }
    /**
     * Abort loading tiles.
     * @public
     */
    abortLoading() {
      if (this._planet) {
        this._planet._tileLoader.abort(this);
      }
    }
    /**
     * Sets layer visibility.
     * @public
     * @param {boolean} visibility - Layer visibility.
     */
    setVisibility(visibility) {
      if (visibility !== this._visibility) {
        super.setVisibility(visibility);
        if (!visibility) {
          this.abortLoading();
        }
      }
    }
    remove() {
      this.abortLoading();
      super.remove();
      return this;
    }
    /**
     * Sets imagery tiles url source template.
     * @public
     * @param {string} url - Url template.
     * @example
     * http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png
     * where {z}, {x} and {y} - replaces by current tile values, {s} - random domain.
     */
    setUrl(url) {
      this.url = url;
    }
    _checkSegment(segment) {
      return segment._projection.id === this._planet.quadTreeStrategy.projection.id;
    }
    /**
     * Start to load tile material.
     * @public
     * @virtual
     * @param {Material} material - Loads current material.
     * @param {boolean} [forceLoading=false] -
     */
    loadMaterial(material, forceLoading = false) {
      let seg = material.segment;
      if (this._isBaseLayer) {
        material.texture = seg.getDefaultTexture();
      } else {
        material.texture = seg.planet.transparentTexture;
      }
      if (this._planet.layerLock.isFree() || material.segment.tileZoom < 2) {
        material.isReady = false;
        material.isLoading = true;
        if (this._checkSegment(seg)) {
          material.loadingAttempts++;
          this._planet._tileLoader.load(
            {
              sender: this,
              src: this._getHTTPRequestString(material.segment),
              type: "imageBitmap",
              filter: () => seg.initialized && seg.node.getState() === RENDERING || forceLoading,
              options: {}
            },
            (response) => {
              if (response.status === "ready") {
                if (material.isLoading) {
                  let e9 = this.events.load;
                  if (e9.handlers.length) {
                    this.events.dispatch(e9, material);
                  }
                  material.applyImage(response.data);
                  response.data = null;
                }
              } else if (response.status === "abort") {
                material.isLoading = false;
              } else if (response.status === "error") {
                if (material.isLoading) {
                  material.textureNotExists();
                }
              }
            }
            //,this.__id
          );
        } else {
          material.textureNotExists();
        }
      }
    }
    /**
     * Creates query url.
     * @protected
     * @virtual
     * @param {Segment} segment - Creates specific url for current segment.
     * @returns {string} - Returns url string.
     */
    _createUrl(segment) {
      return stringTemplate(this.url, {
        s: this._getSubdomain(),
        x: segment.tileX.toString(),
        y: segment.tileY.toString(),
        z: segment.tileZoom.toString()
      });
    }
    _getSubdomain() {
      this._requestCount++;
      return this._s[Math.floor(this._requestCount % (this._requestsPeerSubdomains * this._s.length) / this._requestsPeerSubdomains)];
    }
    /**
     * Returns actual url query string.
     * @protected
     * @param {Segment} segment - Segment that loads image data.
     * @returns {string} - Url string.
     */
    _getHTTPRequestString(segment) {
      return this._urlRewriteCallback ? this._urlRewriteCallback(segment, this.url) : this._createUrl(segment);
    }
    /**
     * Sets url rewrite callback, used for custom url rewriting for every tile loading.
     * @public
     * @param {Function} ur - The callback that returns tile custom created url.
     */
    setUrlRewriteCallback(ur) {
      this._urlRewriteCallback = ur;
    }
    applyMaterial(material, forceLoading = false) {
      if (material.isReady) {
        return material.texOffset;
      } else if (material.segment.tileZoom < this.minNativeZoom) {
        material.textureNotExists();
      } else {
        let segment = material.segment, pn = segment.node, notEmpty = false;
        let mId = this.__id;
        let psegm = material;
        while (pn.parentNode) {
          pn = pn.parentNode;
          psegm = pn.segment.materials[mId];
          if (psegm && psegm.textureExists) {
            notEmpty = true;
            break;
          }
        }
        if (segment.passReady) {
          let maxNativeZoom = material.layer.maxNativeZoom;
          if (pn.segment.tileZoom === maxNativeZoom) {
            material.textureNotExists();
          } else if (material.segment.tileZoom <= maxNativeZoom) {
            !material.isLoading && !material.isReady && this.loadMaterial(material, forceLoading);
          } else {
            let pn2 = segment.node;
            while (pn2.segment.tileZoom > material.layer.maxNativeZoom) {
              pn2 = pn2.parentNode;
            }
            let pnm = pn2.segment.materials[material.layer.__id];
            if (pnm) {
              !pnm.isLoading && !pnm.isReady && this.loadMaterial(pnm, true);
            } else {
              pnm = pn2.segment.materials[material.layer.__id] = material.layer.createMaterial(pn2.segment);
              this.loadMaterial(pnm, true);
            }
          }
        }
        if (notEmpty) {
          material.appliedNode = pn;
          material.appliedNodeId = pn.nodeId;
          material.texture = psegm.texture;
          let dZ2 = 1 / (2 << segment.tileZoom - pn.segment.tileZoom - 1);
          material.texOffset[0] = segment.tileX * dZ2 - pn.segment.tileX;
          material.texOffset[1] = segment.tileY * dZ2 - pn.segment.tileY;
          material.texOffset[2] = dZ2;
          material.texOffset[3] = dZ2;
        } else {
          material.texture = segment.planet.transparentTexture;
          material.texOffset[0] = 0;
          material.texOffset[1] = 0;
          material.texOffset[2] = 1;
          material.texOffset[3] = 1;
        }
      }
      return material.texOffset;
    }
    clearMaterial(material) {
      if (material.isReady && material.textureExists) {
        !material.texture.default && material.segment.handler.gl.deleteTexture(material.texture);
        material.texture = null;
      }
      material.isReady = false;
      material.textureExists = false;
      material.isLoading = false;
    }
    /**
     * @protected
     */
    _correctFullExtent() {
      let e9 = this._extent, em = this._extentMerc;
      let ENLARGE_MERCATOR_LON = POLE + 5e4;
      let ENLARGE_MERCATOR_LAT = POLE + 5e4;
      if (e9.northEast.lat === 90) {
        em.northEast.lat = ENLARGE_MERCATOR_LAT;
      }
      if (e9.northEast.lon === 180) {
        em.northEast.lon = ENLARGE_MERCATOR_LON;
      }
      if (e9.southWest.lat === -90) {
        em.southWest.lat = -ENLARGE_MERCATOR_LAT;
      }
      if (e9.southWest.lon === -180) {
        em.southWest.lon = -ENLARGE_MERCATOR_LON;
      }
      if (e9.northEast.lat >= MAX_LAT) {
        e9.northEast.lat = MAX_LAT;
      }
      if (e9.northEast.lat <= MIN_LAT) {
        e9.northEast.lat = MIN_LAT;
      }
    }
  };
  var XYZ_EVENTS = [
    /**
     * Triggered when current tile image has loaded before rendering.
     * @event #load
     */
    "load",
    /**
     * Triggered when all tiles have loaded or loading has stopped.
     * @event #loadend
     */
    "loadend"
  ];

  // frontend/node_modules/@openglobus/og/lib/js/terrain/GlobusRgbTerrain.js
  var urlPref = {
    [TILEGROUP_NORTH]: "north",
    [TILEGROUP_SOUTH]: "south"
  };

  // frontend/node_modules/@openglobus/og/lib/js/Clock.js
  var CLOCK_EVENTS = ["tick", "end", "start", "stop"];
  var Clock = class _Clock {
    constructor(params = {}) {
      this.__handler = null;
      this.active = true;
      this.__id = _Clock.__counter__++;
      this.events = createEvents(CLOCK_EVENTS, this);
      this.name = params.name || "";
      this.startDate = params.startDate || 0;
      this.endDate = params.endDate || 0;
      let currentDate = params.currentDate || DateToUTC(/* @__PURE__ */ new Date());
      if (params.startDate && currentDate < params.startDate) {
        currentDate = params.startDate;
      }
      if (params.endDate && currentDate > params.endDate) {
        currentDate = params.endDate;
      }
      this.currentDate = currentDate;
      this._multiplier = params.multiplier !== void 0 ? params.multiplier : 1;
      this._running = 1;
      this.deltaTicks = 0;
      this.active = true;
      this._intervalDelay = 0;
      this._intervalStart = 0;
      this._intervalCallback = null;
    }
    clearInterval() {
      this._intervalDelay = 0;
      this._intervalStart = 0;
      this._intervalCallback = null;
    }
    setInterval(delay, callback) {
      this._intervalStart = this.currentDate;
      this._intervalDelay = delay * ONE_BY_MILLISECONDS_PER_DAY;
      this._intervalCallback = callback;
    }
    /**
     * Sets current clock datetime.
     * @public
     * @param {Object} date - JavaScript Date object.
     */
    setDate(date) {
      let d4 = DateToUTC(date);
      if (this.startDate && d4 < this.startDate) {
        d4 = this.startDate;
      }
      if (this.endDate && d4 > this.endDate) {
        d4 = this.endDate;
      }
      this.currentDate = d4;
    }
    /**
     * Returns current application date.
     * @public
     * @returns {Date} - Current date.
     */
    getDate() {
      return UTCtoDate(this.currentDate);
    }
    reset() {
      if (this.startDate) {
        this.currentDate = this.startDate;
      }
    }
    tick(dt2) {
      let m5 = this._multiplier * this._running;
      this.deltaTicks = dt2 * m5;
      if (this.active) {
        let cd = addMilliseconds(this.currentDate, this.deltaTicks);
        if (m5 > 0) {
          if (this.endDate && cd > this.endDate) {
            this.currentDate = this.startDate;
            this.events.dispatch(this.events.end, this);
          } else {
            this.currentDate = cd;
          }
        } else {
          if (this.startDate && cd < this.startDate) {
            this.currentDate = this.endDate;
            this.events.dispatch(this.events.end, this);
          } else {
            this.currentDate = cd;
          }
        }
        if (this._intervalCallback) {
          if (this.currentDate - this._intervalStart >= this._intervalDelay) {
            this._intervalStart = this.currentDate;
            this._intervalCallback(this);
          }
        }
        this.events.dispatch(this.events.tick, this);
      }
    }
    /**
     * @public
     * @param {Clock} clock - Clock instance to compare.
     * @returns {boolean} - Returns true if a clock is the same instance.
     */
    isEqual(clock) {
      return this.__id === clock.__id;
    }
    start() {
      if (this._running === 0) {
        this._running = 1;
        this.events.dispatch(this.events.start, this);
      }
    }
    get multiplier() {
      return this._multiplier;
    }
    set multiplier(value) {
      this._multiplier = value;
    }
    stop() {
      if (this._running === 1) {
        this._running = 0;
        this.events.dispatch(this.events.stop, this);
      }
    }
  };
  Clock.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/webgl/ProgramController.js
  var ProgramController = class {
    constructor(handler, program) {
      this._program = program;
      this._handler = handler;
      this._activated = false;
    }
    /**
     * Lazy create program call.
     * @public
     */
    initialize() {
      if (this._handler.gl) {
        this._program.createProgram(this._handler.gl);
      }
    }
    /**
     * Returns controller's shader program.
     * @public
     * @return {Program} -
     */
    getProgram() {
      return this._program;
    }
    /**
     * Activates current shader program.
     * @public
     * @returns {ProgramController} -
     */
    activate() {
      if (!this._activated) {
        this._handler.activeProgram.deactivate();
        this._handler.activeProgram = this;
        let p4 = this._program;
        this._activated = true;
        p4.enableAttribArrays();
        p4.use();
      }
      return this;
    }
    /**
     * Remove program from handler
     * @public
     */
    remove() {
      let p4 = this._handler.programs;
      if (p4[this._program.name]) {
        if (this._activated) {
          this.deactivate();
        }
        this._program.delete();
        delete p4[this._program.name];
      }
    }
    /**
     * Deactivate shader program. This is not necessary while activate function used.
     * @public
     */
    deactivate() {
      this._program.disableAttribArrays();
      this._activated = false;
    }
    /**
     * Returns program activity.
     * @public
     * @return {boolean} -
     */
    isActive() {
      return this._activated;
    }
    /**
     * Sets program uniforms and attributes values and return controller instance.
     * @public
     * @param {Record<string, any>} params - Object with variable name and value like { value: 12, someArray:[1,2,3], uSampler: texture,... }
     * @return {ProgramController} -
     */
    set(params) {
      this.activate();
      this._program.set(params);
      return this;
    }
    /**
     * Draw index buffer with this program.
     * @public
     * @param {number} mode - Gl draw mode
     * @param {WebGLBuffer} buffer - Buffer to draw.
     * @return {ProgramController} Returns current shader controller instance.
     */
    drawIndexBuffer(mode2, buffer) {
      this._program.drawIndexBuffer(mode2, buffer);
      return this;
    }
    /**
     * Calls Gl drawArray function.
     * @param {number} mode - Gl draw mode.
     * @param {number} numItems - draw items count.
     * @return {ProgramController} Returns current shader controller instance.
     */
    drawArrays(mode2, numItems) {
      this._program.drawArrays(mode2, numItems);
      return this;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/Stack.js
  var Node3 = class {
    constructor() {
      this.next = null;
      this.prev = null;
      this.data = null;
    }
  };
  var Stack = class {
    constructor(size = 256) {
      this._current = new Node3();
      this._head = this._current;
      for (let i9 = 0; i9 < size; i9++) {
        let n7 = new Node3();
        n7.prev = this._current;
        this._current.next = n7;
        this._current = n7;
      }
      this._current = this._head;
    }
    current() {
      return this._current;
    }
    push(data) {
      this._current = this._current.next;
      this._current.data = data;
    }
    pop() {
      let res = this._current.data;
      this._current = this._current.prev;
      return res;
    }
    popPrev() {
      this._current = this._current.prev;
      return this._current.data;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/webgl/Handler.js
  var vendorPrefixes = ["", "WEBKIT_", "MOZ_"];
  var CONTEXT_TYPE = ["webgl2", "webgl"];
  var MAX_LEVELS = 2;
  var Handler = class _Handler {
    constructor(canvasTarget, params = {}) {
      this.framebufferStack = new Stack();
      this._requestAnimationFrameId = 0;
      this.drawFrame = () => {
        let now = window.performance.now();
        this.deltaTime = now - this._lastAnimationFrameTime;
        this._lastAnimationFrameTime = now;
        this.defaultClock.tick(this.deltaTime);
        for (let i9 = 0; i9 < this._clocks.length; i9++) {
          this._clocks[i9].tick(this.deltaTime);
        }
        let canvas = this.canvas;
        if (Math.floor(canvas.clientWidth * this._params.pixelRatio) !== canvas.width || Math.floor(canvas.clientHeight * this._params.pixelRatio) !== canvas.height) {
          if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {
            this.stop();
          } else if (!document.hidden) {
            this.start();
            this.setSize(canvas.clientWidth, canvas.clientHeight);
          }
        }
        this._frameCallback();
      };
      this.events = createEvents(["visibilitychange", "resize"]);
      this._throttledDrawFrame = this.drawFrame;
      this.defaultClock = new Clock();
      this._clocks = [];
      this.deltaTime = 0;
      this.canvas = null;
      this.gl = null;
      this.programs = {};
      this.activeProgram = null;
      this._canvasSize = [0, 0];
      this._params = {
        anisotropy: params.anisotropy || 4,
        width: params.width || 256,
        height: params.height || 256,
        pixelRatio: getUrlParam("og_dpi") || params.pixelRatio || 1,
        extensions: params.extensions || [],
        context: params.context || {}
      };
      this._oneByHeight = 1 / (this._params.height * this._params.pixelRatio);
      this.extensions = {};
      this._canvasTarget = canvasTarget;
      this._lastAnimationFrameTime = 0;
      this._initialized = false;
      this._frameCallback = function() {
      };
      this.transparentTexture = null;
      this.defaultTexture = null;
      this.framebufferStack = new Stack();
      this.createTexture_n = this.createTexture_n_webgl2.bind(this);
      this.createTexture_l = this.createTexture_l_webgl2.bind(this);
      this.createTexture_mm = this.createTexture_mm_webgl2.bind(this);
      this.createTexture_a = this.createTexture_a_webgl2.bind(this);
      this.createTexture = {
        "NEAREST": this.createTexture_n,
        "LINEAR": this.createTexture_l,
        "MIPMAP": this.createTexture_mm,
        "ANISOTROPIC": this.createTexture_a
      };
      this.createTextureDefault = this.createTexture_n;
      this.ONCANVASRESIZE = null;
      this._createCanvas();
      if (params.autoActivate || isEmpty(params.autoActivate)) {
        this.initialize();
      }
    }
    set frameDelay(delay) {
      if (delay === 0) {
        this._throttledDrawFrame = this.drawFrame;
      } else {
        this._throttledDrawFrame = throttle(this.drawFrame, delay);
      }
    }
    isInitialized() {
      return this._initialized;
    }
    _createCanvas() {
      if (this._canvasTarget) {
        if (this._canvasTarget instanceof HTMLElement) {
          this.canvas = this._canvasTarget;
        } else {
          this.canvas = document.getElementById(this._canvasTarget) || document.querySelector(this._canvasTarget);
        }
      } else {
        this.canvas = document.createElement("canvas");
        this.canvas.width = this._params.width;
        this.canvas.height = this._params.height;
      }
    }
    /**
     * The return value is null if the extension is not supported, or an extension object otherwise.
     * @param {WebGLRenderingContext | WebGL2RenderingContext | null} gl - WebGl context pointer.
     * @param {string} name - Extension name.
     * @returns {any} -
     */
    static getExtension(gl, name) {
      if (!gl)
        return;
      let i9, ext;
      for (i9 in vendorPrefixes) {
        ext = gl.getExtension(vendorPrefixes[i9] + name);
        if (ext) {
          return ext;
        }
      }
    }
    /**
     * Returns a drawing context on the canvas, or null if the context identifier is not supported.
     * @param {HTMLCanvasElement} canvas - HTML canvas object.
     * @param {any} [contextAttributes] - See canvas.getContext contextAttributes.
     * @returns {WebGLContextExt | null} -
     */
    static getContext(canvas, contextAttributes) {
      let ctx = null;
      try {
        let urlParams = new URLSearchParams(location.search);
        let ver = urlParams.get("og_ver");
        if (ver) {
          ctx = canvas.getContext(ver, contextAttributes);
          if (ctx) {
            ctx.type = ver;
          }
        } else {
          for (let i9 = 0; i9 < CONTEXT_TYPE.length; i9++) {
            ctx = canvas.getContext(CONTEXT_TYPE[i9], contextAttributes);
            if (ctx) {
              ctx.type = CONTEXT_TYPE[i9];
              break;
            }
          }
        }
      } catch (ex) {
        cons.logErr("exception during the GL context initialization");
      }
      if (!ctx) {
        cons.logErr("could not initialise WebGL");
      }
      return ctx;
    }
    /**
     * Sets animation frame function.
     * @public
     * @param {Function} callback - Frame callback.
     */
    setFrameCallback(callback) {
      callback && (this._frameCallback = callback);
    }
    /**
     * Creates empty texture.
     * @public
     * @param {number} [width=1] - Specifies the width of the texture image.
     * @param {number} [height=1] - Specifies the width of the texture image.
     * @param {string} [filter="NEAREST"] - Specifies GL_TEXTURE_MIN(MAX)_FILTER texture value.
     * @param {string} [internalFormat="RGBA"] - Specifies the color components in the texture.
     * @param {string} [format="RGBA"] - Specifies the format of the texel data.
     * @param {string} [type="UNSIGNED_BYTE"] - Specifies the data type of the texel data.
     * @param {number} [level=0] - Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createEmptyTexture2DExt(width = 1, height = 1, filter2 = "NEAREST", internalFormat = "RGBA", format = "RGBA", type = "UNSIGNED_BYTE", level = 0) {
      let gl = this.gl;
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, level, gl[internalFormat.toUpperCase()], width, height, 0, gl[format.toUpperCase()], gl[type.toUpperCase()], null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[filter2.toUpperCase()]);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl[filter2.toUpperCase()]);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates Empty NEAREST filtered texture.
     * @public
     * @param {number} width - Empty texture width.
     * @param {number} height - Empty texture height.
     * @param {number} [internalFormat]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createEmptyTexture_n(width, height, internalFormat) {
      let gl = this.gl;
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates empty LINEAR filtered texture.
     * @public
     * @param {number} width - Empty texture width.
     * @param {number} height - Empty texture height.
     * @param {number} [internalFormat]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createEmptyTexture_l(width, height, internalFormat) {
      let gl = this.gl;
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates NEAREST filter texture.
     * @public
     * @param {HTMLCanvasElement | Image} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture=null]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_n_webgl1(image, internalFormat, texture = null) {
      let gl = this.gl;
      texture = texture || gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates LINEAR filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_l_webgl1(image, internalFormat, texture = null) {
      let gl = this.gl;
      texture = texture || gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates MIPMAP filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_mm_webgl1(image, internalFormat, texture = null) {
      let gl = this.gl;
      texture = texture || gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates ANISOTROPY filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_a_webgl1(image, internalFormat, texture = null) {
      let gl = this.gl;
      texture = texture || gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat || gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.texParameterf(gl.TEXTURE_2D, this.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._params.anisotropy);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates NEAREST filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_n_webgl2(image, internalFormat, texture = null) {
      let gl = this.gl;
      texture = texture || gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texStorage2D(gl.TEXTURE_2D, 1, internalFormat || gl.RGBA8, image.width, image.height);
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates LINEAR filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_l_webgl2(image, internalFormat, texture = null) {
      let gl = this.gl;
      texture = texture || gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texStorage2D(gl.TEXTURE_2D, 1, internalFormat || gl.RGBA8, image.width, image.height);
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates MIPMAP filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_mm_webgl2(image, internalFormat, texture = null) {
      let gl = this.gl;
      texture = texture || gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texStorage2D(gl.TEXTURE_2D, MAX_LEVELS, internalFormat || gl.RGBA8, image.width, image.height);
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates ANISOTROPY filter texture.
     * @public
     * @param {ImageSource} image - Image or Canvas object.
     * @param {number} [internalFormat]
     * @param {WebGLTexture | null} [texture]
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    createTexture_a_webgl2(image, internalFormat, texture = null) {
      let gl = this.gl;
      texture = texture || gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texStorage2D(gl.TEXTURE_2D, MAX_LEVELS, internalFormat || gl.RGBA8, image.width, image.height);
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.texParameterf(gl.TEXTURE_2D, this.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._params.anisotropy);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates cube texture.
     * @public
     * @param {Texture3DParams} params - Face image urls:
     * @param {string} params.px - Positive X or right image url.
     * @param {string} params.nx - Negative X or left image url.
     * @param {string} params.py - Positive Y or up image url.
     * @param {string} params.ny - Negative Y or bottom image url.
     * @param {string} params.pz - Positive Z or face image url.
     * @param {string} params.nz - Negative Z or back image url.
     * @returns {WebGLTexture | null} - WebGL texture object.
     */
    loadCubeMapTexture(params) {
      let gl = this.gl;
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      let faces = [
        [params.px, gl.TEXTURE_CUBE_MAP_POSITIVE_X],
        [params.nx, gl.TEXTURE_CUBE_MAP_NEGATIVE_X],
        [params.py, gl.TEXTURE_CUBE_MAP_POSITIVE_Y],
        [params.ny, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y],
        [params.pz, gl.TEXTURE_CUBE_MAP_POSITIVE_Z],
        [params.nz, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
      ];
      let imageCanvas = new ImageCanvas();
      imageCanvas.fillEmpty();
      let emptyImage = imageCanvas.getImage();
      for (let i9 = 0; i9 < faces.length; i9++) {
        let face = faces[i9][1];
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
        gl.texImage2D(face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, emptyImage);
      }
      for (let i9 = 0; i9 < faces.length; i9++) {
        let face = faces[i9][1];
        let image = new Image();
        image.crossOrigin = "";
        image.onload = /* @__PURE__ */ function(texture2, face2, image2) {
          return function() {
            if (gl && texture2) {
              gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture2);
              gl.texImage2D(face2, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image2);
            }
          };
        }(texture, face, image);
        image.src = faces[i9][0];
      }
      return texture;
    }
    /**
     * Adds shader program to the handler.
     * @public
     * @param {Program} program - Shader program.
     * @param {boolean} [notActivate] - If it's true program will not compile.
     * @return {Program} -
     */
    addProgram(program, notActivate = false) {
      if (!this.programs[program.name]) {
        let sc = new ProgramController(this, program);
        this.programs[program.name] = sc;
        this._initProgramController(sc);
        if (notActivate) {
          sc._activated = false;
        }
      } else {
        console.warn(`Shader program: "${program.name}" already exists.`);
      }
      return program;
    }
    /**
     * Removes shader program from handler.
     * @public
     * @param {string} name - Shader program name.
     */
    removeProgram(name) {
      this.programs[name] && this.programs[name].remove();
    }
    /**
     * Adds shader programs to the handler.
     * @public
     * @param {Array.<Program>} programsArr - Shader program array.
     */
    addPrograms(programsArr) {
      for (let i9 = 0; i9 < programsArr.length; i9++) {
        this.addProgram(programsArr[i9]);
      }
    }
    /**
     * Used in addProgram
     * @protected
     * @param {ProgramController} sc - Program controller
     */
    _initProgramController(sc) {
      if (this._initialized) {
        sc.initialize();
        if (!this.activeProgram) {
          this.activeProgram = sc;
          sc.activate();
        } else {
          sc.deactivate();
          this.activeProgram._program.enableAttribArrays();
          this.activeProgram._program.use();
        }
      }
    }
    /**
     * Used in init function.
     * @private
     */
    _initPrograms() {
      for (let p4 in this.programs) {
        this._initProgramController(this.programs[p4]);
      }
    }
    /**
     * Initialize additional WebGL extensions.
     * @public
     * @param {string} extensionStr - Extension name.
     * @param {boolean} showLog - Show logging.
     * @return {any} -
     */
    initializeExtension(extensionStr, showLog = false) {
      if (!(this.extensions && this.extensions[extensionStr])) {
        let ext = _Handler.getExtension(this.gl, extensionStr);
        if (ext) {
          this.extensions[extensionStr] = ext;
        } else if (showLog) {
          console.warn("og.webgl.Handler: extension '" + extensionStr + "' doesn't initialize.");
        }
      }
      return this.extensions && this.extensions[extensionStr];
    }
    /**
     * Main function that initialize handler.
     * @public
     */
    initialize() {
      if (this._initialized)
        return;
      if (!this.canvas)
        return;
      this.gl = _Handler.getContext(this.canvas, this._params.context);
      if (!this.gl)
        return;
      this._initialized = true;
      this._params.extensions.push("EXT_texture_filter_anisotropic");
      if (this.gl.type === "webgl") {
        this._params.extensions.push("OES_standard_derivatives");
        this._params.extensions.push("OES_element_index_uint");
        this._params.extensions.push("WEBGL_depth_texture");
        this._params.extensions.push("ANGLE_instanced_arrays");
      } else {
        this._params.extensions.push("EXT_color_buffer_float");
        this._params.extensions.push("OES_texture_float_linear");
      }
      let i9 = this._params.extensions.length;
      while (i9--) {
        this.initializeExtension(this._params.extensions[i9], true);
      }
      if (this.gl.type === "webgl") {
        this.createTexture_n = this.createTexture_n_webgl1.bind(this);
        this.createTexture_l = this.createTexture_l_webgl1.bind(this);
        this.createTexture_mm = this.createTexture_mm_webgl1.bind(this);
        this.createTexture_a = this.createTexture_a_webgl1.bind(this);
      } else {
        this.createTexture_n = this.createTexture_n_webgl2.bind(this);
        this.createTexture_l = this.createTexture_l_webgl2.bind(this);
        this.createTexture_mm = this.createTexture_mm_webgl2.bind(this);
        this.createTexture_a = this.createTexture_a_webgl2.bind(this);
      }
      this.createTexture["NEAREST"] = this.createTexture_n;
      this.createTexture["LINEAR"] = this.createTexture_l;
      this.createTexture["MIPMAP"] = this.createTexture_mm;
      this.createTexture["ANISOTROPIC"] = this.createTexture_a;
      if (!this.extensions.EXT_texture_filter_anisotropic) {
        this.createTextureDefault = this.createTexture_mm;
      } else {
        this.createTextureDefault = this.createTexture_a;
      }
      this._initPrograms();
      this._setDefaults();
      this.intersectionObserver = new IntersectionObserver((entries) => {
        this._toggleVisibilityChange(entries[0].isIntersecting);
      }, { threshold: 0 });
      this.intersectionObserver.observe(this.canvas);
      this.resizeObserver = new ResizeObserver((entries) => {
        this._toggleVisibilityChange(entries[0].contentRect.width !== 0 && entries[0].contentRect.height !== 0);
      });
      this.resizeObserver.observe(this.canvas);
      document.addEventListener("visibilitychange", () => {
        this._toggleVisibilityChange(document.visibilityState === "visible");
      });
    }
    _toggleVisibilityChange(visibility) {
      if (visibility) {
        this.start();
        this.ONCANVASRESIZE && this.ONCANVASRESIZE();
        this.events.dispatch(this.events.visibilitychange, true);
      } else {
        this.events.dispatch(this.events.visibilitychange, false);
        this.stop();
      }
    }
    /**
     * Sets default gl render parameters. Used in init function.
     * @protected
     */
    _setDefaults() {
      let gl = this.gl;
      if (!gl)
        return;
      if (!this.canvas)
        return;
      gl.depthFunc(gl.LESS);
      gl.enable(gl.DEPTH_TEST);
      this.setSize(this.canvas.clientWidth || this._params.width, this.canvas.clientHeight || this._params.height);
      gl.frontFace(gl.CCW);
      gl.cullFace(gl.BACK);
      gl.enable(gl.CULL_FACE);
      gl.disable(gl.BLEND);
      this.createDefaultTexture({ color: "rgba(0,0,0,0.0)" }, (t9) => {
        this.transparentTexture = t9;
      });
      this.createDefaultTexture({ color: "rgba(255, 255, 255, 1.0)" }, (t9) => {
        this.defaultTexture = t9;
      });
    }
    getCanvasSize() {
      return this._canvasSize;
    }
    /**
     * Creates STREAM_DRAW ARRAY buffer.
     * @public
     * @param {number} itemSize - Array item size.
     * @param {number} numItems - Items quantity.
     * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
     * @param {number} [bytes=4] -
     * @return {WebGLBufferExt} -
     */
    createStreamArrayBuffer(itemSize, numItems, usage, bytes = 4) {
      let gl = this.gl;
      let buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, numItems * itemSize * bytes, usage || gl.STREAM_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      buffer.itemSize = itemSize;
      buffer.numItems = numItems;
      return buffer;
    }
    /**
     * Sets stream buffer.
     * @public
     * @param {WebGLBufferExt} buffer -
     * @param {TypedArray} array -
     * @param {number} [offset=0] -
     * @return {WebGLBufferExt} -
     */
    setStreamArrayBuffer(buffer, array, offset = 0) {
      let gl = this.gl;
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      return buffer;
    }
    /**
     * Creates ARRAY buffer.
     * @public
     * @param {TypedArray} array - Input array.
     * @param {number} itemSize - Array item size.
     * @param {number} numItems - Items quantity.
     * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
     * @return {WebGLBufferExt} -
     */
    createArrayBuffer(array, itemSize, numItems, usage) {
      let gl = this.gl;
      let buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, array, usage || gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      buffer.itemSize = itemSize;
      buffer.numItems = numItems;
      return buffer;
    }
    /**
     * Creates ARRAY buffer specific length.
     * @public
     * @param {number} size -
     * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
     * @return {WebGLBufferExt} -
     */
    createArrayBufferLength(size, usage) {
      let gl = this.gl;
      let buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, size, usage || gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      buffer.itemSize = 1;
      buffer.numItems = size;
      return buffer;
    }
    /**
     * Creates ELEMENT ARRAY buffer.
     * @public
     * @param {TypedArray} array - Input array.
     * @param {number} itemSize - Array item size.
     * @param {number} numItems - Items quantity.
     * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
     * @return {Object} -
     */
    createElementArrayBuffer(array, itemSize, numItems, usage) {
      let gl = this.gl;
      let buffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, usage || gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      buffer.itemSize = itemSize;
      buffer.numItems = numItems || array.length;
      return buffer;
    }
    /**
     * Sets handler canvas size.
     * @public
     * @param {number} w - Canvas width.
     * @param {number} h - Canvas height.
     */
    setSize(w3, h8) {
      this._params.width = w3;
      this._params.height = h8;
      if (this.canvas) {
        this.canvas.width = w3 * this._params.pixelRatio;
        this.canvas.height = h8 * this._params.pixelRatio;
        this._canvasSize[0] = this.canvas.width;
        this._canvasSize[1] = this.canvas.height;
        this._oneByHeight = 1 / this.canvas.height;
        this.gl && this.gl.viewport(0, 0, w3, h8);
        this.ONCANVASRESIZE && this.ONCANVASRESIZE(this.canvas);
        this.events.dispatch(this.events.resize, this);
      }
    }
    get pixelRatio() {
      return this._params.pixelRatio;
    }
    set pixelRatio(pr) {
      this._params.pixelRatio = pr;
      this.setSize(this._params.width, this._params.height);
    }
    /**
     * Returns context screen width.
     * @public
     * @returns {number} -
     */
    getWidth() {
      return this.canvas ? this.canvas.width : 0;
    }
    /**
     * Returns context screen height.
     * @public
     * @returns {number} -
     */
    getHeight() {
      return this.canvas ? this.canvas.height : 0;
    }
    /**
     * Returns canvas aspect ratio.
     * @public
     * @returns {number} -
     */
    getClientAspect() {
      return this.canvas ? this.canvas.clientWidth / this.canvas.clientHeight : 0;
    }
    /**
     * Returns canvas center coordinates.
     * @public
     * @returns {number} -
     */
    getCenter() {
      let c7 = this.canvas;
      return c7 ? new Vec2(Math.round(c7.width * 0.5), Math.round(c7.height * 0.5)) : new Vec2();
    }
    /**
     * Clearing gl frame.
     * @public
     */
    clearFrame() {
      let gl = this.gl;
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
    /**
     * Starts animation loop.
     * @public
     */
    start() {
      if (!this._requestAnimationFrameId && this._initialized) {
        this._animationFrameCallback();
      }
    }
    stop() {
      if (this._requestAnimationFrameId) {
        window.cancelAnimationFrame(this._requestAnimationFrameId);
        this._requestAnimationFrameId = 0;
      }
    }
    isStopped() {
      return !this._requestAnimationFrameId;
    }
    /**
     * Check is gl context type equals webgl2
     * @public
     */
    isWebGl2() {
      return this.gl ? this.gl.type === "webgl2" : false;
    }
    /**
     * Make animation.
     * @protected
     */
    _animationFrameCallback() {
      this._requestAnimationFrameId = window.requestAnimationFrame(() => {
        this._throttledDrawFrame();
        this._requestAnimationFrameId && this._animationFrameCallback();
      });
    }
    /**
     * Creates default texture object
     * @public
     * @param {IDefaultTextureParams | null} params - Texture parameters:
     * @param {(texture: WebGLTextureExt) => void} [success] - Creation callback
     */
    createDefaultTexture(params, success) {
      let imgCnv;
      let texture;
      if (params && params.color) {
        imgCnv = new ImageCanvas(2, 2);
        imgCnv.fillColor(params.color);
        texture = this.createTexture_n(imgCnv.getCanvas());
        texture.default = true;
        success(texture);
      } else if (params && params.url) {
        let img = new Image();
        let that = this;
        img.onload = function() {
          texture = that.createTextureDefault(img);
          texture.default = true;
          success(texture);
        };
        img.src = params.url;
      } else {
        imgCnv = new ImageCanvas(2, 2);
        imgCnv.fillColor("#C5C5C5");
        texture = this.createTexture_n(imgCnv.getCanvas());
        texture.default = true;
        success(texture);
      }
    }
    deleteTexture(texture) {
      if (texture && !texture.default) {
        this.gl.deleteTexture(texture);
      }
    }
    /**
     * @public
     */
    destroy() {
      this.resizeObserver?.disconnect();
      this.intersectionObserver?.disconnect();
      this.stop();
      for (let p4 in this.programs) {
        this.removeProgram(p4);
      }
      let gl = this.gl;
      if (gl) {
        gl.deleteTexture(this.transparentTexture);
        this.transparentTexture = null;
        gl.deleteTexture(this.defaultTexture);
        this.defaultTexture = null;
        this.framebufferStack = new Stack();
        let numAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        let tmp = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tmp);
        for (let ii = 0; ii < numAttribs; ++ii) {
          gl.disableVertexAttribArray(ii);
          gl.vertexAttribPointer(ii, 4, gl.FLOAT, false, 0, 0);
          gl.vertexAttrib1f(ii, 0);
        }
        gl.deleteBuffer(tmp);
        let numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        for (let ii = 0; ii < numTextureUnits; ++ii) {
          gl.activeTexture(gl.TEXTURE0 + ii);
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
          gl.bindTexture(gl.TEXTURE_2D, null);
        }
        gl.activeTexture(gl.TEXTURE0);
        gl.useProgram(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.disable(gl.BLEND);
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.DITHER);
        gl.disable(gl.SCISSOR_TEST);
        gl.blendColor(0, 0, 0, 0);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ZERO);
        gl.clearColor(0, 0, 0, 0);
        gl.clearDepth(1);
        gl.clearStencil(-1);
      }
      if (this.canvas) {
        if (this.canvas.parentNode) {
          this.canvas.parentNode.removeChild(this.canvas);
        }
        this.canvas.width = 1;
        this.canvas.height = 1;
        this.canvas = null;
      }
      this.gl = null;
      this._initialized = false;
    }
    addClock(clock) {
      if (!clock.__handler) {
        clock.__handler = this;
        this._clocks.push(clock);
      }
    }
    addClocks(clockArr) {
      for (let i9 = 0; i9 < clockArr.length; i9++) {
        this.addClock(clockArr[i9]);
      }
    }
    removeClock(clock) {
      if (clock.__handler) {
        let c7 = this._clocks;
        let i9 = c7.length;
        while (i9--) {
          if (c7[i9].isEqual(clock)) {
            clock.__handler = null;
            c7.splice(i9, 1);
            break;
          }
        }
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/webgl/Multisample.js
  var Multisample = class extends BaseFramebuffer {
    constructor(handler, options2 = {}) {
      super(handler, options2);
      this._internalFormat = options2.internalFormat ? options2.internalFormat.toUpperCase() : "RGBA8";
      this._msaa = options2.msaa != void 0 ? options2.msaa : 4;
      this._glFilter = 0;
      this.renderbuffers = new Array(this._size);
    }
    destroy() {
      let gl = this.handler.gl;
      if (!gl)
        return;
      for (let i9 = 0; i9 < this.renderbuffers.length; i9++) {
        gl.deleteRenderbuffer(this.renderbuffers[i9]);
      }
      this.renderbuffers = new Array(this._size);
      gl.deleteFramebuffer(this._fbo);
      gl.deleteRenderbuffer(this._depthRenderbuffer);
      this._depthRenderbuffer = null;
      this._fbo = null;
      this._active = false;
    }
    /**
     * Framebuffer initialization.
     * @public
     */
    init() {
      let gl = this.handler.gl;
      if (!gl)
        return;
      this._glFilter = gl[this._filter];
      this._fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
      let colorAttachments = [];
      for (let i9 = 0; i9 < this.renderbuffers.length; i9++) {
        let rb = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, rb);
        if (this._msaa > 0) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._msaa, gl[this._internalFormat], this._width, this._height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl[this._internalFormat], this._width, this._height);
        }
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i9, gl.RENDERBUFFER, rb);
        colorAttachments.push(gl.COLOR_ATTACHMENT0 + i9);
        this.renderbuffers[i9] = rb;
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      }
      gl.drawBuffers(colorAttachments);
      if (this._useDepth) {
        this._depthRenderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderbuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._msaa, gl[this._depthComponent], this._width, this._height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depthRenderbuffer);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    blitTo(framebuffer, attachmentIndex = 0) {
      let gl = this.handler.gl;
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._fbo);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer._fbo);
      gl.readBuffer(gl.COLOR_ATTACHMENT0 + attachmentIndex);
      gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 1]);
      gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, framebuffer._width, framebuffer._height, gl.COLOR_BUFFER_BIT, this._glFilter);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/input/KeyboardHandler.js
  var STAMP_SPACER = "_";
  var _sortByPriority = function(a6, b4) {
    return Number(a6.priority < b4.priority);
  };
  var KeyboardHandler = class {
    constructor() {
      this._currentlyPressedKeys = {};
      this._pressedKeysCallbacks = {};
      this._unpressedKeysCallbacks = {};
      this._charkeysCallbacks = {};
      this._anykeyCallback = null;
      this._event = null;
      this._active = true;
      this._stampCache = {};
      document.onkeydown = (event) => {
        this._event = event;
        this._active && this.handleKeyDown();
      };
      document.onkeyup = (event) => {
        this._event = event;
        this._active && this.handleKeyUp();
      };
    }
    getcurrentlyPressedKeys() {
      return this._currentlyPressedKeys;
    }
    getPressedKeysCallbacks() {
      return this._pressedKeysCallbacks;
    }
    getUnpressedKeysCallbacks() {
      return this._unpressedKeysCallbacks;
    }
    getCharkeysCallbacks() {
      return this._charkeysCallbacks;
    }
    removeEvent(event, keyCode, callback) {
      let st2 = this._getStamp(event, keyCode, callback._openglobus_id);
      if (callback._openglobus_id && this._stampCache[st2]) {
        delete this._stampCache[st2];
        if (event === "keypress") {
          this._removeCallback(this._pressedKeysCallbacks[keyCode], callback);
        } else if (event === "keyfree") {
          this._removeCallback(this._unpressedKeysCallbacks[keyCode], callback);
        } else if (event === "charkeypress") {
          this._removeCallback(this._charkeysCallbacks[keyCode], callback);
        }
      }
    }
    _removeCallback(handlers, callback) {
      for (let i9 = 0; i9 < handlers.length; i9++) {
        if (handlers[i9].callback._openglobus_id === callback._openglobus_id) {
          handlers.splice(i9, 1);
        }
      }
    }
    _getStamp(name, keyCode, ogid) {
      return `${name}${STAMP_SPACER}${keyCode}${STAMP_SPACER}${ogid}`;
    }
    _stamp(name, keyCode, obj) {
      const ogid = stamp(obj);
      const st2 = this._getStamp(name, keyCode, ogid);
      if (!this._stampCache[st2]) {
        this._stampCache[st2] = ogid;
        return true;
      }
      return false;
    }
    setActivity(activity) {
      this._active = activity;
    }
    releaseKeys() {
      this._currentlyPressedKeys = {};
    }
    addEvent(event, keyCode, callback, sender, priority) {
      if (!this._stamp(event, keyCode, callback))
        return;
      if (priority === void 0) {
        priority = 1600;
      }
      switch (event) {
        case "keyfree":
          if (!this._unpressedKeysCallbacks[keyCode]) {
            this._unpressedKeysCallbacks[keyCode] = [];
          }
          this._unpressedKeysCallbacks[keyCode].push({ callback, sender, priority });
          this._unpressedKeysCallbacks[keyCode].sort(_sortByPriority);
          break;
        case "keypress":
          if (keyCode == null) {
            this._anykeyCallback = { callback, sender: sender || this };
          } else {
            if (!this._pressedKeysCallbacks[keyCode]) {
              this._pressedKeysCallbacks[keyCode] = [];
            }
            this._pressedKeysCallbacks[keyCode].push({ callback, sender, priority });
            this._pressedKeysCallbacks[keyCode].sort(_sortByPriority);
          }
          break;
        case "charkeypress":
          if (!this._charkeysCallbacks[keyCode]) {
            this._charkeysCallbacks[keyCode] = [];
          }
          this._charkeysCallbacks[keyCode].push({ callback, sender, priority });
          this._charkeysCallbacks[keyCode].sort(_sortByPriority);
          break;
      }
    }
    isKeyPressed(keyCode) {
      return this._currentlyPressedKeys[keyCode];
    }
    handleKeyDown() {
      this._anykeyCallback && this._anykeyCallback.callback.call(this._anykeyCallback.sender, this._event);
      this._currentlyPressedKeys[this._event.keyCode] = true;
      for (let ch in this._charkeysCallbacks) {
        if (String.fromCharCode(this._event.keyCode) === String.fromCharCode(Number(ch))) {
          let ccl = this._charkeysCallbacks[ch];
          for (let i9 = 0; i9 < ccl.length; i9++) {
            ccl[i9].callback.call(ccl[i9].sender, this._event);
          }
        }
      }
      if (this._event.keyCode == input.KEY_ALT || this._event.keyCode == input.KEY_SHIFT) {
        this._event.preventDefault();
      }
    }
    handleKeyUp() {
      if (this._currentlyPressedKeys[this._event.keyCode] || this._event.keyCode === input.KEY_PRINTSCREEN) {
        for (let pk in this._unpressedKeysCallbacks) {
          if (this._currentlyPressedKeys[pk] || this._event.keyCode === input.KEY_PRINTSCREEN && Number(pk) === input.KEY_PRINTSCREEN) {
            let cpk = this._unpressedKeysCallbacks[pk];
            for (let i9 = 0; i9 < cpk.length; i9++) {
              cpk[i9].callback.call(cpk[i9].sender, this._event);
            }
          }
        }
      }
      this._currentlyPressedKeys[this._event.keyCode] = false;
    }
    handleEvents() {
      for (let pk in this._pressedKeysCallbacks) {
        if (this._currentlyPressedKeys[pk]) {
          let cpk = this._pressedKeysCallbacks[pk];
          for (let i9 = 0; i9 < cpk.length; i9++) {
            cpk[i9].callback.call(cpk[i9].sender, this._event);
          }
        }
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/input/MouseHandler.js
  var MouseHandler = class {
    constructor(htmlObject) {
      this._htmlObject = htmlObject;
    }
    setEvent(event, sender, callback) {
      switch (event) {
        case "mousewheel":
          this._htmlObject.addEventListener("wheel", function(event2) {
            let delta = event2.deltaY || event2.detail || event2.wheelDelta || 0;
            if (event2.wheelDelta == void 0) {
              event2.wheelDelta = delta * -120;
            }
            callback.call(sender, event2);
            event2.preventDefault();
          }, false);
          break;
        case "mousedown":
          this._htmlObject.addEventListener("mousedown", function(event2) {
            let rect = this.getBoundingClientRect();
            callback.call(sender, event2, {
              button: event2.button,
              clientX: event2.clientX - rect.left,
              clientY: event2.clientY - rect.top
            });
          });
          this._htmlObject.addEventListener("contextmenu", function(event2) {
            event2.preventDefault();
            return false;
          });
          break;
        case "mouseup":
          this._htmlObject.addEventListener("mouseup", function(event2) {
            let rect = this.getBoundingClientRect();
            callback.call(sender, event2, {
              button: event2.button,
              clientX: event2.clientX - rect.left,
              clientY: event2.clientY - rect.top
            });
          });
          break;
        case "mousemove":
          this._htmlObject.addEventListener("mousemove", function(event2) {
            let rect = this.getBoundingClientRect();
            callback.call(sender, event2, {
              clientX: event2.clientX - rect.left,
              clientY: event2.clientY - rect.top
            });
          });
          break;
        case "mouseleave":
          this._htmlObject.addEventListener("mouseleave", function(event2) {
            callback.call(sender, event2);
          });
          break;
        case "mouseout":
          this._htmlObject.addEventListener("mouseout", function(event2) {
            callback.call(sender, event2);
          });
          break;
        case "mouseover":
          this._htmlObject.addEventListener("mouseover", function(event2) {
            callback.call(sender, event2);
          });
          break;
        case "mouseenter":
          this._htmlObject.addEventListener("mouseenter", function(event2) {
            callback.call(sender, event2);
          });
          break;
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/input/TouchHandler.js
  var TouchHandler = class {
    constructor(htmlObject) {
      this._htmlObject = htmlObject;
    }
    setEvent(event, sender, callback) {
      switch (event) {
        case "touchcancel":
          this._htmlObject.addEventListener("touchcancel", function(event2) {
            event2.preventDefault();
            const rect = this.getBoundingClientRect();
            const eventExt = Object.assign(event2, { offsetLeft: rect.left, offsetTop: rect.top });
            callback.call(sender, eventExt);
          });
          break;
        case "touchstart":
          this._htmlObject.addEventListener("touchstart", function(event2) {
            event2.preventDefault();
            const rect = this.getBoundingClientRect();
            const eventExt = Object.assign(event2, { offsetLeft: rect.left, offsetTop: rect.top });
            callback.call(sender, eventExt);
          });
          break;
        case "touchend":
          this._htmlObject.addEventListener("touchend", function(event2) {
            event2.preventDefault();
            const rect = this.getBoundingClientRect();
            const eventExt = Object.assign(event2, { offsetLeft: rect.left, offsetTop: rect.top });
            callback.call(sender, eventExt);
          });
          break;
        case "touchmove":
          this._htmlObject.addEventListener("touchmove", function(event2) {
            event2.preventDefault();
            const rect = this.getBoundingClientRect();
            const eventExt = Object.assign(event2, { offsetLeft: rect.left, offsetTop: rect.top });
            callback.call(sender, eventExt);
          });
          break;
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/renderer/RendererEvents.js
  function createRendererEvents(renderer) {
    return new RendererEvents(renderer);
  }
  var LB_M = 1;
  var RB_M = 2;
  var MB_M = 4;
  var ISBLACK = (c7) => !(c7[0] || c7[1] || c7[2]);
  var NOTBLACK = (c7) => !!(c7[0] || c7[1] || c7[2]);
  var _currPickingColor = new Uint8Array(4);
  var _tempCurrPickingColor = new Uint8Array(4);
  var _prevPickingColor = new Uint8Array(4);
  var RendererEvents = class extends Events {
    constructor(renderer) {
      super(RENDERER_EVENTS);
      this.renderer = renderer;
      this._touchHandler = new TouchHandler(renderer.handler.canvas);
      this._mouseHandler = new MouseHandler(renderer.handler.canvas);
      this._keyboardHandler = new KeyboardHandler();
      this._active = true;
      this.clickRadius = 15;
      this.mouseState = {
        clientX: 0,
        clientY: 0,
        pos: new Vec2(),
        x: 0,
        y: 0,
        nx: 0,
        ny: 0,
        prev_x: 0,
        prev_y: 0,
        direction: new Vec3(),
        leftButtonUp: false,
        rightButtonUp: false,
        middleButtonUp: false,
        leftButtonDown: false,
        rightButtonDown: false,
        middleButtonDown: false,
        leftButtonHold: false,
        rightButtonHold: false,
        middleButtonHold: false,
        leftButtonDoubleClick: false,
        rightButtonDoubleClick: false,
        middleButtonDoubleClick: false,
        leftButtonClick: false,
        rightButtonClick: false,
        middleButtonClick: false,
        moving: false,
        justStopped: false,
        doubleClickDelay: 500,
        clickDelay: 200,
        wheelDelta: 0,
        sys: null,
        pickingObject: null,
        renderer
      };
      this.touchState = {
        moving: false,
        touchEnd: false,
        touchStart: false,
        touchCancel: false,
        doubleTouch: false,
        doubleTouchDelay: 550,
        doubleTouchRadius: 10,
        clientX: 0,
        clientY: 0,
        pos: new Vec2(),
        x: 0,
        y: 0,
        nx: 0,
        ny: 0,
        prev_x: 0,
        prev_y: 0,
        direction: new Vec3(),
        sys: null,
        pickingObject: null,
        renderer
      };
      this._isMouseInside = false;
      this._entityPickingEventsActive = true;
      this._dblTchCoords = new Vec2();
      this._oneTouchStart = false;
      this._dblTchBegins = 0;
      this._mousestopThread = null;
      this._ldblClkBegins = 0;
      this._rdblClkBegins = 0;
      this._mdblClkBegins = 0;
      this._lClkBegins = 0;
      this._rClkBegins = 0;
      this._mClkBegins = 0;
      this._lclickX = 0;
      this._lclickY = 0;
      this._rclickX = 0;
      this._rclickY = 0;
      this._mclickX = 0;
      this._mclickY = 0;
    }
    pointerEvent() {
      let ms2 = this.mouseState, ts = this.touchState;
      return ms2.moving || ms2.justStopped || ts.moving || ts.touchStart || ts.touchEnd || ms2.wheelDelta !== 0;
    }
    get active() {
      return this._active;
    }
    set active(isActive) {
      this._active = isActive;
      this._keyboardHandler.setActivity(isActive);
    }
    /**
     * Used in render node frame.
     * @public
     */
    handleEvents() {
      if (this._active) {
        this.mouseState.direction = this.renderer.activeCamera.unproject(this.mouseState.x, this.mouseState.y);
        this.touchState.direction = this.renderer.activeCamera.unproject(this.touchState.x, this.touchState.y);
        this._keyboardHandler.handleEvents();
        this.handleMouseEvents();
        this.handleTouchEvents();
        this.entityPickingEvents();
      }
    }
    on(name, p0, p1, p22, keyPriority) {
      if (name === "keypress" || name === "charkeypress" || name === "keyfree") {
        this._keyboardHandler.addEvent(name, p0, p1, p22, keyPriority);
      } else {
        super.on(name, p0, p1, p22);
      }
    }
    off(name, p1, p22) {
      if (name === "keypress" || name === "charkeypress" || name === "keyfree") {
        this._keyboardHandler.removeEvent(name, p1, p22);
      } else {
        super.off(name, p1);
      }
    }
    /**
     * Check key is pressed.
     * @public
     * @param {number} keyCode - Key code
     * @return {boolean}
     */
    isKeyPressed(keyCode) {
      return this._keyboardHandler.isKeyPressed(keyCode);
    }
    releaseKeys() {
      this._keyboardHandler.releaseKeys();
    }
    /**
     * Renderer events initialization.
     * @public
     */
    initialize() {
      this._mouseHandler.setEvent("mouseup", this, this.onMouseUp);
      this._mouseHandler.setEvent("mousemove", this, this.onMouseMove);
      this._mouseHandler.setEvent("mousedown", this, this.onMouseDown);
      this._mouseHandler.setEvent("mousewheel", this, this.onMouseWheel);
      this._mouseHandler.setEvent("mouseleave", this, this.onMouseLeave);
      this._mouseHandler.setEvent("mouseenter", this, this.onMouseEnter);
      this._touchHandler.setEvent("touchstart", this, this.onTouchStart);
      this._touchHandler.setEvent("touchend", this, this.onTouchEnd);
      this._touchHandler.setEvent("touchcancel", this, this.onTouchCancel);
      this._touchHandler.setEvent("touchmove", this, this.onTouchMove);
    }
    /**
     * @protected
     */
    onMouseWheel(event) {
      this.mouseState.sys = event;
      this.mouseState.wheelDelta = event.wheelDelta || 0;
    }
    updateButtonsStates(buttons) {
      let ms2 = this.mouseState;
      if (buttons & LB_M && ms2.leftButtonDown) {
        ms2.leftButtonDown = true;
      } else {
        ms2.leftButtonHold = false;
        ms2.leftButtonDown = false;
      }
      if (buttons & RB_M && ms2.rightButtonDown) {
        ms2.rightButtonDown = true;
      } else {
        ms2.rightButtonHold = false;
        ms2.rightButtonDown = false;
      }
      if (buttons & MB_M && ms2.middleButtonDown) {
        ms2.middleButtonDown = true;
      } else {
        ms2.middleButtonHold = false;
        ms2.middleButtonDown = false;
      }
    }
    onMouseMove(sys, event) {
      let ms2 = this.mouseState;
      this.updateButtonsStates(sys.buttons);
      ms2.sys = sys;
      let ex = event.clientX, ey = event.clientY, r8 = this.clickRadius;
      if (Math.abs(this._lclickX - ex) >= r8 && Math.abs(this._lclickY - ey) >= r8) {
        this._ldblClkBegins = 0;
        this._lClkBegins = 0;
      }
      if (Math.abs(this._rclickX - ex) >= r8 && Math.abs(this._rclickY - ey) >= r8) {
        this._rdblClkBegins = 0;
        this._rClkBegins = 0;
      }
      if (Math.abs(this._mclickX - ex) >= r8 && Math.abs(this._mclickY - ey) >= r8) {
        this._mdblClkBegins = 0;
        this._mClkBegins = 0;
      }
      if (ms2.clientX === event.clientX && ms2.clientY === event.clientY) {
        return;
      }
      ms2.clientX = event.clientX;
      ms2.clientY = event.clientY;
      let h8 = this.renderer.handler;
      ms2.pos.x = ms2.x = event.clientX * h8.pixelRatio;
      ms2.pos.y = ms2.y = event.clientY * h8.pixelRatio;
      ms2.nx = ms2.x / h8.canvas.width;
      ms2.ny = ms2.y / h8.canvas.height;
      ms2.moving = true;
      clearTimeout(this._mousestopThread);
      this._mousestopThread = setTimeout(function() {
        ms2.justStopped = true;
      }, 100);
    }
    onMouseLeave(sys) {
      this._isMouseInside = false;
      this.mouseState.sys = sys;
      this.dispatch(this.mouseleave, this.mouseState);
    }
    onMouseEnter(sys) {
      this._isMouseInside = true;
      this.mouseState.sys = sys;
      this.dispatch(this.mouseenter, this.mouseState);
    }
    onMouseDown(sys, event) {
      if (event.button === input.MB_LEFT) {
        this._lClkBegins = window.performance.now();
        this._lclickX = event.clientX;
        this._lclickY = event.clientY;
        this.mouseState.sys = sys;
        this.mouseState.leftButtonDown = true;
      } else if (event.button === input.MB_RIGHT) {
        this._rClkBegins = window.performance.now();
        this._rclickX = event.clientX;
        this._rclickY = event.clientY;
        this.mouseState.sys = sys;
        this.mouseState.rightButtonDown = true;
      } else if (event.button === input.MB_MIDDLE) {
        this._mClkBegins = window.performance.now();
        this._mclickX = event.clientX;
        this._mclickY = event.clientY;
        this.mouseState.sys = sys;
        this.mouseState.middleButtonDown = true;
      }
    }
    onMouseUp(sys, event) {
      let ms2 = this.mouseState;
      ms2.sys = sys;
      let t9 = window.performance.now();
      if (event.button === input.MB_LEFT) {
        ms2.leftButtonDown = false;
        ms2.leftButtonUp = true;
        if (Math.abs(this._lclickX - event.clientX) < this.clickRadius && Math.abs(this._lclickY - event.clientY) < this.clickRadius && t9 - this._lClkBegins <= ms2.clickDelay) {
          if (this._ldblClkBegins) {
            let deltatime = window.performance.now() - this._ldblClkBegins;
            if (deltatime <= ms2.doubleClickDelay) {
              ms2.leftButtonDoubleClick = true;
            }
            this._ldblClkBegins = 0;
          } else {
            this._ldblClkBegins = window.performance.now();
          }
          ms2.leftButtonClick = true;
          this._lClkBegins = 0;
        }
      } else if (event.button === input.MB_RIGHT) {
        ms2.rightButtonDown = false;
        ms2.rightButtonUp = true;
        if (Math.abs(this._rclickX - event.clientX) < this.clickRadius && Math.abs(this._rclickY - event.clientY) < this.clickRadius && t9 - this._rClkBegins <= ms2.clickDelay) {
          if (this._rdblClkBegins) {
            let deltatime = window.performance.now() - this._rdblClkBegins;
            if (deltatime <= ms2.doubleClickDelay) {
              ms2.rightButtonDoubleClick = true;
            }
            this._rdblClkBegins = 0;
          } else {
            this._rdblClkBegins = window.performance.now();
          }
          ms2.rightButtonClick = true;
          this._rClkBegins = 0;
        }
      } else if (event.button === input.MB_MIDDLE) {
        ms2.middleButtonDown = false;
        ms2.middleButtonUp = true;
        if (Math.abs(this._mclickX - event.clientX) < this.clickRadius && Math.abs(this._mclickY - event.clientY) < this.clickRadius && t9 - this._mClkBegins <= ms2.clickDelay) {
          if (this._mdblClkBegins) {
            let deltatime = window.performance.now() - this._mdblClkBegins;
            if (deltatime <= ms2.doubleClickDelay) {
              ms2.middleButtonDoubleClick = true;
            }
            this._mdblClkBegins = 0;
          } else {
            this._mdblClkBegins = window.performance.now();
          }
          ms2.middleButtonClick = true;
          this._mClkBegins = 0;
        }
      }
    }
    onTouchStart(event) {
      let ts = this.touchState;
      ts.sys = event;
      ts.clientX = event.touches.item(0).clientX - event.offsetLeft;
      ts.clientY = event.touches.item(0).clientY - event.offsetTop;
      let h8 = this.renderer.handler;
      ts.pos.x = ts.x = ts.clientX * h8.pixelRatio;
      ts.pos.y = ts.y = ts.clientY * h8.pixelRatio;
      ts.nx = ts.x / h8.canvas.width;
      ts.ny = ts.y / h8.canvas.height;
      ts.prev_x = ts.x;
      ts.prev_y = ts.y;
      ts.touchStart = true;
      if (event.touches.length === 1) {
        this._dblTchCoords.x = ts.x;
        this._dblTchCoords.y = ts.y;
        this._oneTouchStart = true;
      } else {
        this._oneTouchStart = false;
      }
    }
    /**
     * @protected
     */
    onTouchEnd(event) {
      let ts = this.touchState;
      ts.sys = event;
      ts.touchEnd = true;
      if (event.touches.length === 0) {
        ts.prev_x = ts.x;
        ts.prev_y = ts.y;
        if (this._oneTouchStart) {
          if (this._dblTchBegins) {
            let deltatime = window.performance.now() - this._dblTchBegins;
            if (deltatime <= ts.doubleTouchDelay) {
              ts.doubleTouch = true;
            }
            this._dblTchBegins = 0;
          }
          this._dblTchBegins = window.performance.now();
          this._oneTouchStart = false;
        }
      }
    }
    onTouchCancel(event) {
      let ts = this.touchState;
      ts.sys = event;
      ts.touchCancel = true;
    }
    onTouchMove(event) {
      let ts = this.touchState;
      ts.clientX = event.touches.item(0).clientX - event.offsetLeft;
      ts.clientY = event.touches.item(0).clientY - event.offsetTop;
      let h8 = this.renderer.handler;
      ts.x = ts.clientX * h8.pixelRatio;
      ts.y = ts.clientY * h8.pixelRatio;
      ts.nx = ts.x / h8.canvas.width;
      ts.ny = ts.y / h8.canvas.height;
      ts.sys = event;
      ts.moving = true;
      let dX = ts.x - ts.prev_x;
      let dY = ts.y - ts.prev_y;
      if (Math.abs(dX) > 9 || Math.abs(dY) > 9) {
        this._dblTchBegins = 0;
        this._oneTouchStart = false;
      }
    }
    entityPickingEvents() {
      let ts = this.touchState, ms2 = this.mouseState;
      if (this._isMouseInside !== this._entityPickingEventsActive) {
        this._entityPickingEventsActive = this._isMouseInside;
        if (!this._entityPickingEventsActive) {
          let r8 = this.renderer;
          let c7 = _currPickingColor;
          let co = r8.getPickingObjectArr(c7);
          if (co) {
            let pe = co.rendererEvents;
            ms2.pickingObject = co;
            pe && pe.dispatch(pe.mouseleave, ms2);
            ts.pickingObject = co;
            pe && pe.dispatch(pe.touchleave, ts);
          }
          _currPickingColor[0] = _currPickingColor[1] = _currPickingColor[2] = _currPickingColor[3] = _prevPickingColor[0] = _prevPickingColor[1] = _prevPickingColor[2] = _prevPickingColor[3] = _tempCurrPickingColor[0] = _tempCurrPickingColor[1] = _tempCurrPickingColor[2] = _tempCurrPickingColor[3] = 0;
        }
      }
      if (this._isMouseInside && !(ms2.leftButtonHold || ms2.rightButtonHold || ms2.middleButtonHold)) {
        let r8 = this.renderer;
        let c7 = _currPickingColor, p4 = _prevPickingColor, t9 = _tempCurrPickingColor;
        if (ts.x || ts.y) {
          r8.readPickingColor(ts.nx, 1 - ts.ny, t9);
        } else {
          r8.readPickingColor(ms2.nx, 1 - ms2.ny, t9);
        }
        p4[0] = c7[0];
        p4[1] = c7[1];
        p4[2] = c7[2];
        c7[0] = t9[0];
        c7[1] = t9[1];
        c7[2] = t9[2];
        ms2.pickingObject = null;
        ts.pickingObject = null;
        let co = r8.getPickingObjectArr(c7);
        ms2.pickingObject = co;
        ts.pickingObject = co;
        if (c7[0] !== p4[0] || c7[1] !== p4[1] || c7[2] !== p4[2]) {
          if (ISBLACK(c7)) {
            let po = r8.getPickingObjectArr(p4);
            if (po) {
              let pe = po.rendererEvents;
              ms2.pickingObject = po;
              pe && pe.dispatch(pe.mouseleave, ms2);
              ts.pickingObject = po;
              pe && pe.dispatch(pe.touchleave, ts);
            }
          } else {
            if (NOTBLACK(p4)) {
              let po = r8.getPickingObjectArr(p4);
              if (po) {
                let pe = po.rendererEvents;
                ms2.pickingObject = po;
                pe && pe.dispatch(pe.mouseleave, ms2);
                ts.pickingObject = po;
                pe && pe.dispatch(pe.touchleave, ts);
              }
            }
            if (co) {
              let ce = co.rendererEvents;
              ms2.pickingObject = co;
              ce && ce.dispatch(ce.mouseenter, ms2);
              ts.pickingObject = co;
              ce && ce.dispatch(ce.touchenter, ts);
            }
          }
        }
      }
    }
    handleMouseEvents() {
      let _this = this;
      let ms2 = this.mouseState;
      let po = ms2.pickingObject, pe = null;
      if (ms2.leftButtonClick) {
        if (po) {
          pe = po.rendererEvents;
          pe && pe.dispatch(pe.lclick, ms2);
        }
        this.dispatch(_this.lclick, ms2);
        ms2.leftButtonClick = false;
      }
      if (ms2.rightButtonClick) {
        if (po) {
          pe = po.rendererEvents;
          pe && pe.dispatch(pe.rclick, ms2);
        }
        this.dispatch(_this.rclick, ms2);
        ms2.rightButtonClick = false;
      }
      if (ms2.middleButtonClick) {
        if (po) {
          pe = po.rendererEvents;
          pe && pe.dispatch(pe.mclick, ms2);
        }
        this.dispatch(_this.mclick, ms2);
        ms2.middleButtonClick = false;
      }
      if (ms2.leftButtonDown) {
        if (ms2.leftButtonHold) {
          if (po) {
            pe = po.rendererEvents;
            pe && pe.dispatch(pe.lhold, ms2);
          }
          this.dispatch(_this.lhold, ms2);
        } else {
          ms2.leftButtonHold = true;
          if (po) {
            pe = po.rendererEvents;
            pe && pe.dispatch(pe.ldown, ms2);
          }
          this.dispatch(_this.ldown, ms2);
        }
      }
      if (ms2.rightButtonDown) {
        if (ms2.rightButtonHold) {
          if (po) {
            pe = po.rendererEvents;
            pe && pe.dispatch(pe.rhold, ms2);
          }
          this.dispatch(_this.rhold, ms2);
        } else {
          ms2.rightButtonHold = true;
          if (po) {
            pe = po.rendererEvents;
            pe && pe.dispatch(pe.rdown, ms2);
          }
          this.dispatch(_this.rdown, ms2);
        }
      }
      if (ms2.middleButtonDown) {
        if (ms2.middleButtonHold) {
          if (po) {
            pe = po.rendererEvents;
            pe && pe.dispatch(pe.mhold, ms2);
          }
          this.dispatch(_this.mhold, ms2);
        } else {
          ms2.middleButtonHold = true;
          if (po) {
            pe = po.rendererEvents;
            pe && pe.dispatch(pe.mdown, ms2);
          }
          this.dispatch(_this.mdown, ms2);
        }
      }
      if (ms2.leftButtonUp) {
        if (po) {
          pe = po.rendererEvents;
          pe && pe.dispatch(pe.lup, ms2);
        }
        this.dispatch(_this.lup, ms2);
        ms2.leftButtonUp = false;
        ms2.leftButtonHold = false;
      }
      if (ms2.rightButtonUp) {
        if (po) {
          pe = po.rendererEvents;
          pe && pe.dispatch(pe.rup, ms2);
        }
        this.dispatch(_this.rup, ms2);
        ms2.rightButtonUp = false;
        ms2.rightButtonHold = false;
      }
      if (ms2.middleButtonUp) {
        if (po) {
          pe = po.rendererEvents;
          pe && pe.dispatch(pe.mup, ms2);
        }
        this.dispatch(_this.mup, ms2);
        ms2.middleButtonUp = false;
        ms2.middleButtonHold = false;
      }
      if (ms2.leftButtonDoubleClick) {
        if (po) {
          pe = po.rendererEvents;
          pe && pe.dispatch(pe.ldblclick, ms2);
        }
        this.dispatch(_this.ldblclick, ms2);
        ms2.leftButtonDoubleClick = false;
      }
      if (ms2.rightButtonDoubleClick) {
        if (po) {
          pe = po.rendererEvents;
          pe && pe.dispatch(pe.rdblclick, ms2);
        }
        this.dispatch(_this.rdblclick, ms2);
        ms2.rightButtonDoubleClick = false;
      }
      if (ms2.middleButtonDoubleClick) {
        if (po) {
          pe = po.rendererEvents;
          pe && pe.dispatch(pe.mdblclick, ms2);
        }
        this.dispatch(_this.mdblclick, ms2);
        ms2.middleButtonDoubleClick = false;
      }
      if (ms2.wheelDelta) {
        if (po) {
          pe = po.rendererEvents;
          pe && pe.dispatch(pe.mousewheel, ms2);
        }
        this.dispatch(_this.mousewheel, ms2);
      }
      if (ms2.moving) {
        if (po) {
          pe = po.rendererEvents;
          pe && pe.dispatch(pe.mousemove, ms2);
        }
        this.dispatch(_this.mousemove, ms2);
        ms2.prev_x = ms2.x;
        ms2.prev_y = ms2.y;
      }
      if (ms2.justStopped) {
        this.dispatch(_this.mousestop, ms2);
      }
    }
    /**
     * @protected
     */
    handleTouchEvents() {
      let _this = this;
      let ts = this.touchState;
      let tpo = ts.pickingObject, tpe = null;
      if (ts.touchCancel) {
        this.dispatch(_this.touchcancel, ts);
        ts.touchCancel = false;
      }
      if (ts.touchStart) {
        let r8 = this.renderer;
        r8.pickingFramebuffer.activate();
        r8.pickingFramebuffer.readPixels(_currPickingColor, ts.nx, 1 - ts.ny, 1);
        r8.pickingFramebuffer.deactivate();
        let co = r8.getPickingObjectArr(_currPickingColor);
        tpo = ts.pickingObject = co;
        if (tpo) {
          tpe = tpo.rendererEvents;
          tpe && tpe.dispatch(tpe.touchstart, ts);
        }
        this.dispatch(_this.touchstart, ts);
        ts.touchStart = false;
      }
      if (ts.doubleTouch) {
        if (tpo) {
          tpe = tpo.rendererEvents;
          tpe && tpe.dispatch(tpe.doubletouch, ts);
        }
        this.dispatch(_this.doubletouch, ts);
        ts.doubleTouch = false;
      }
      if (ts.touchEnd) {
        if (tpo) {
          tpe = tpo.rendererEvents;
          tpe && tpe.dispatch(tpe.touchend, ts);
        }
        this.dispatch(_this.touchend, ts);
        ts.x = 0;
        ts.y = 0;
        ts.touchEnd = false;
      }
      if (ts.moving) {
        if (tpo) {
          tpe = tpo.rendererEvents;
          tpe && tpe.dispatch(tpe.touchmove, ts);
        }
        this.dispatch(_this.touchmove, ts);
        ts.prev_x = ts.x;
        ts.prev_y = ts.y;
      }
    }
  };
  var RENDERER_EVENTS = [
    /**
     * Triggered before scene frame is rendered(before render nodes).
     * @event og.RendererEvents#draw
     */
    "draw",
    /**
     * Triggered after all transparent object are drawn
     * @event og.RendererEvents#drawtransparent
     */
    "drawtransparent",
    /**
     * Triggered after scene frame is rendered(after render nodes).
     * @event og.RendererEvents#postdraw
     */
    "postdraw",
    /**
     * Triggered when screen is resized.
     * @event og.RendererEvents#resize
     */
    "resize",
    /**
     * Triggered when screen is resized.
     * @event og.RendererEvents#resizeend
     */
    "resizeend",
    /**
     * Mouse enters the work screen
     * @event og.RendererEvents#mouseenter
     */
    "mouseenter",
    /**
     * Mouse leaves the work screen
     * @event og.RendererEvents#mouseleave
     */
    "mouseleave",
    /**
     * Mouse is moving.
     * @event og.RendererEvents#mousemove
     */
    "mousemove",
    /**
     * Mouse is just stopped.
     * @event og.RendererEvents#mousestop
     */
    "mousestop",
    /**
     * Mouse left button clicked.
     * @event og.RendererEvents#lclick
     */
    "lclick",
    /**
     * Mouse right button clicked.
     * @event og.RendererEvents#rclick
     */
    "rclick",
    /**
     * Mouse middle button clicked.
     * @event og.RendererEvents#mclick
     */
    "mclick",
    /**
     * Mouse left button double click.
     * @event og.RendererEvents#ldblclick
     */
    "ldblclick",
    /**
     * Mouse right button double click.
     * @event og.RendererEvents#rdblclick
     */
    "rdblclick",
    /**
     * Mouse middle button double click.
     * @event og.RendererEvents#mdblclick
     */
    "mdblclick",
    /**
     * Mouse left button up(stop pressing).
     * @event og.RendererEvents#lup
     */
    "lup",
    /**
     * Mouse right button up(stop pressing).
     * @event og.RendererEvents#rup
     */
    "rup",
    /**
     * Mouse middle button up(stop pressing).
     * @event og.RendererEvents#mup
     */
    "mup",
    /**
     * Mouse left button is just pressed down(start pressing).
     * @event og.RendererEvents#ldown
     */
    "ldown",
    /**
     * Mouse right button is just pressed down(start pressing).
     * @event og.RendererEvents#rdown
     */
    "rdown",
    /**
     * Mouse middle button is just pressed down(start pressing).
     * @event og.RendererEvents#mdown
     */
    "mdown",
    /**
     * Mouse left button is pressing.
     * @event og.RendererEvents#lhold
     */
    "lhold",
    /**
     * Mouse right button is pressing.
     * @event og.RendererEvents#rhold
     */
    "rhold",
    /**
     * Mouse middle button is pressing.
     * @event og.RendererEvents#mhold
     */
    "mhold",
    /**
     * Mouse wheel is rotated.
     * @event og.RendererEvents#mousewheel
     */
    "mousewheel",
    /**
     * Triggered when touching starts.
     * @event og.RendererEvents#touchstart
     */
    "touchstart",
    /**
     * Triggered when touching ends.
     * @event og.RendererEvents#touchend
     */
    "touchend",
    /**
     * Triggered when touching cancel.
     * @event og.RendererEvents#touchcancel
     */
    "touchcancel",
    /**
     * Triggered when touch is move.
     * @event og.RendererEvents#touchmove
     */
    "touchmove",
    /**
     * Triggered when double touch.
     * @event og.RendererEvents#doubletouch
     */
    "doubletouch",
    /**
     * Triggered when touch leaves picked object.
     * @event og.RendererEvents#touchleave
     */
    "touchleave",
    /**
     * Triggered when touch enter picking object.
     * @event og.RendererEvents#touchenter
     */
    "touchenter"
  ];

  // frontend/node_modules/@openglobus/og/lib/js/shaders/depth.js
  function depth() {
    return new Program("depth", {
      uniforms: {
        depthTexture: "sampler2d"
      },
      attributes: {
        corners: "vec2"
      },
      vertexShader: `#version 300 es
            
            in vec2 corners;
            
            out vec2 tc;

            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`,
      fragmentShader: `#version 300 es

            precision highp float;

            #define MAX_FRUSTUMS 4

            uniform sampler2D depthTexture;
           
            in vec2 tc;

            layout(location = 0) out vec4 fragColor;

            float LinearizeDepth(in vec2 uv)
            {
                float depth = texture(depthTexture, tc).x;
                return depth;//(2.0 * zNear) / (zFar + zNear - depth * (zFar - zNear));
            }
            
            void main(void) {
                float c = LinearizeDepth(tc);
                fragColor = vec4(c, c, c, 1.0);
            }`
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/Rectangle.js
  var Rectangle = class _Rectangle {
    constructor(left = 0, top = 0, right = 0, bottom = 0) {
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
    }
    set(left = 0, top = 0, right = 0, bottom = 0) {
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
    }
    /**
     * Clone rectangle object.
     * @public
     * @returns {Rectangle}
     */
    clone() {
      return new _Rectangle(this.left, this.top, this.right, this.bottom);
    }
    /**
     * Returns rectangle width.
     * @public
     * @type {number}
     */
    getWidth() {
      return Math.abs(this.right - this.left);
    }
    /**
     * Returns rectangle height.
     * @public
     * @type {number}
     */
    getHeight() {
      return Math.abs(this.bottom - this.top);
    }
    /**
     * Returns rectangle area.
     * @public
     * @type {number}
     */
    getSquare() {
      return this.getHeight() * this.getWidth();
    }
    /**
     * Returns rectangle diagonal size.
     * @public
     * @type {number}
     */
    getDiagonal() {
      let w3 = this.getWidth(), h8 = this.getHeight();
      return Math.sqrt(h8 * h8 + w3 * w3);
    }
    /**
     * Returns true if rectangle fits their size in width and height.
     * @public
     * @param {number} width - Width.
     * @param {number} height - Height.
     * @type {boolean}
     */
    fit(width, height) {
      return this.getWidth() === width && this.getHeight() === height;
    }
    isInside(x3, y4) {
      return x3 >= this.left && x3 <= this.right && y4 >= this.top && y4 <= this.bottom;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/ImagesCacheManager.js
  var ImagesCacheManager = class {
    constructor() {
      this.imagesCache = {};
      this._counter = 0;
      this._pendingsQueue = new QueueArray();
      this._imageIndexCounter = 0;
    }
    load(src, success) {
      if (this.imagesCache[src]) {
        success(this.imagesCache[src]);
      } else {
        let req = { "src": src, "success": success };
        if (this._counter >= 1) {
          this._pendingsQueue.unshift(req);
        } else {
          this._exec(req);
        }
      }
    }
    _exec(req) {
      this._counter++;
      const that = this;
      let img = new Image();
      img.crossOrigin = "";
      img.onload = function() {
        that.imagesCache[req.src] = img;
        img.__nodeIndex = that._imageIndexCounter++;
        req.success(img);
        that._dequeueRequest();
      };
      img.onerror = function() {
        that._dequeueRequest();
      };
      img.src = req.src;
    }
    _dequeueRequest() {
      this._counter--;
      if (this._pendingsQueue.length && this._counter < 1) {
        while (this._pendingsQueue.length) {
          let req = this._pendingsQueue.pop();
          if (req) {
            if (this.imagesCache[req.src]) {
              if (this._counter <= 0) {
                this._counter = 0;
              } else {
                this._counter--;
              }
              req.success(this.imagesCache[req.src]);
            } else {
              this._exec(req);
              break;
            }
          }
        }
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/TextureAtlas.js
  var TextureAtlas = class {
    constructor(width = 1024, height = 1024) {
      this.nodes = /* @__PURE__ */ new Map();
      this.texture = null;
      this.canvas = new ImageCanvas(width, height);
      this.clearCanvas();
      this._handler = null;
      this._images = [];
      this._btree = null;
      this._imagesCacheManager = new ImagesCacheManager();
      this.borderSize = 4;
    }
    /**
     * Returns atlas javascript image object.
     * @public
     * @returns {HTMLImageElement} -
     */
    getImage() {
      return this.canvas.getImage();
    }
    /**
     * Returns canvas object.
     * @public
     * @returns {HTMLCanvasElement} -
     */
    getCanvas() {
      return this.canvas.getCanvas();
    }
    /**
     * Clear atlas with black.
     * @public
     */
    clearCanvas() {
      this.canvas.fillEmpty();
    }
    /**
     * Sets openglobus gl handler that creates gl texture.
     * @public
     * @param {Handler} handler - WebGL handler.
     */
    assignHandler(handler) {
      this._handler = handler;
      this.createTexture();
    }
    /**
     * Returns image diagonal size.
     * @param {HTMLImageElementExt} image - Image object.
     * @returns {number} -
     */
    getDiagonal(image) {
      let w3 = image.atlasWidth || image.width, h8 = image.atlasHeight || image.height;
      return Math.sqrt(w3 * w3 + h8 * h8);
    }
    /**
     * Adds image to the atlas and returns created node with texture coordinates of the stored image.
     * @public
     * @param {HTMLImageElementExt} image - Input javascript image object.
     * @param {boolean} [fastInsert] - If it's true atlas doesn't restore all images again
     * and store image in the current atlas scheme.
     * @returns {TextureAtlasNode | undefined} -
     */
    addImage(image, fastInsert = false) {
      if (!(image.width && image.height)) {
        return;
      }
      this._images.push(image);
      this._makeAtlas(fastInsert);
      if (image.__nodeIndex != void 0) {
        return this.get(image.__nodeIndex);
      }
    }
    _completeNode(nodes, node) {
      if (node) {
        let w3 = this.canvas.getWidth(), h8 = this.canvas.getHeight();
        let im = node.image;
        let r8 = node.rect;
        let bs = Math.round(this.borderSize * 0.5);
        this.canvas.drawImage(im, r8.left + bs, r8.top + bs, im.atlasWidth || 0, im.atlasHeight || 0);
        let tc = node.texCoords;
        tc[0] = (r8.left + bs) / w3;
        tc[1] = (r8.top + bs) / h8;
        tc[2] = (r8.left + bs) / w3;
        tc[3] = (r8.bottom - bs) / h8;
        tc[4] = (r8.right - bs) / w3;
        tc[5] = (r8.bottom - bs) / h8;
        tc[6] = (r8.right - bs) / w3;
        tc[7] = (r8.bottom - bs) / h8;
        tc[8] = (r8.right - bs) / w3;
        tc[9] = (r8.top + bs) / h8;
        tc[10] = (r8.left + bs) / w3;
        tc[11] = (r8.top + bs) / h8;
        nodes.set(im.__nodeIndex, node);
      }
    }
    /**
     * Main atlas making function.
     * @protected
     * @param {boolean} [fastInsert] - If it's true atlas doesn't restore all images again
     * and store image in the current atlas scheme.
     */
    _makeAtlas(fastInsert = false) {
      if (fastInsert && this._btree) {
        let im = this._images[this._images.length - 1];
        this._completeNode(this.nodes, this._btree.insert(im));
      } else {
        let im = this._images.slice(0);
        im.sort(function(b4, a6) {
          return (a6.atlasWidth || a6.width) - (b4.atlasWidth || b4.width) || (a6.atlasHeight || a6.height) - (b4.atlasHeight || b4.height);
        });
        this._btree = new TextureAtlasNode(new Rectangle(0, 0, this.canvas.getWidth(), this.canvas.getHeight()));
        this._btree.atlas = this;
        this.clearCanvas();
        let newNodes = /* @__PURE__ */ new Map();
        for (let i9 = 0; i9 < im.length; i9++) {
          this._completeNode(newNodes, this._btree.insert(im[i9]));
        }
        this.nodes = null;
        this.nodes = newNodes;
      }
    }
    get(key) {
      return this.nodes.get(key);
    }
    set(key, value) {
      this.nodes.set(key, value);
    }
    /**
     * Creates atlas gl texture.
     * @public
     */
    createTexture(img, internalFormat) {
      if (this._handler) {
        this._handler.gl.deleteTexture(this.texture);
        if (img) {
          this.canvas.resize(img.width, img.height);
          this.canvas.drawImage(img, 0, 0, img.width, img.height);
        }
        this.texture = this._handler.createTexture_l(this.canvas.getCanvas(), internalFormat);
      }
    }
    /**
     * Asynchronous function that loads and creates image to the image cache, and call success callback when it's done.
     * @public
     * @param {string} src - Image object src string.
     * @param {ImagesCacheManagerCallback} success - The callback that handles the image loads done.
     */
    loadImage(src, success) {
      this._imagesCacheManager.load(src, success);
    }
    getImageTexCoordinates(img) {
      if (img.__nodeIndex != null) {
        let n7 = this.get(img.__nodeIndex);
        if (n7) {
          return n7.texCoords;
        }
      }
    }
  };
  var TextureAtlasNode = class _TextureAtlasNode {
    constructor(rect, texCoords) {
      this.childNodes = null;
      this.image = null;
      this.rect = rect || new Rectangle();
      this.texCoords = texCoords || [];
      this.atlas = null;
    }
    insert(img) {
      if (this.childNodes) {
        let newNode = this.childNodes[0].insert(img);
        if (newNode) {
          return newNode;
        }
        return this.childNodes[1].insert(img);
      } else {
        if (this.image != null) {
          return;
        }
        let rc = this.rect;
        const w3 = (img.atlasWidth || img.width) + this.atlas.borderSize;
        const h8 = (img.atlasHeight || img.height) + this.atlas.borderSize;
        if (w3 > rc.getWidth() || h8 > rc.getHeight()) {
          return;
        }
        if (rc.fit(w3, h8)) {
          this.image = img;
          return this;
        }
        this.childNodes = new Array(2);
        this.childNodes[0] = new _TextureAtlasNode();
        this.childNodes[0].atlas = this.atlas;
        this.childNodes[1] = new _TextureAtlasNode();
        this.childNodes[1].atlas = this.atlas;
        const dw = rc.getWidth() - w3;
        const dh = rc.getHeight() - h8;
        if (dw > dh) {
          this.childNodes[0].rect.set(rc.left, rc.top, rc.left + w3, rc.bottom);
          this.childNodes[1].rect.set(rc.left + w3, rc.top, rc.right, rc.bottom);
        } else {
          this.childNodes[0].rect.set(rc.left, rc.top, rc.right, rc.top + h8);
          this.childNodes[1].rect.set(rc.left, rc.top + h8, rc.right, rc.bottom);
        }
        return this.childNodes[0].insert(img);
      }
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/utils/FontAtlas.js
  var MAX_SIZE = 11;
  var FontTextureAtlas = class extends TextureAtlas {
    constructor(width, height) {
      super(width, height);
      this.width = 0;
      this.height = 0;
      this.gliphSize = 0;
      this.distanceRange = 0;
      this.nodes = /* @__PURE__ */ new Map();
      this.kernings = {};
    }
    get(key) {
      return this.nodes.get(key);
    }
  };
  var FontTextureAtlasNode = class extends TextureAtlasNode {
    constructor(rect, texCoords) {
      super(rect, texCoords);
      this.emptySize = 1;
      this.metrics = {
        id: 0,
        char: "",
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        chnl: 0,
        index: 0,
        page: 0,
        xadvance: 0,
        xoffset: 0,
        yoffset: 0,
        nChar: "",
        nCode: 0,
        nWidth: 0,
        nHeight: 0,
        nAdvance: 0,
        nXOffset: 0,
        nYOffset: 0
      };
    }
  };
  var FontAtlas = class {
    constructor(catalogSrc) {
      this.atlasesArr = [];
      this.atlasIndexes = {};
      this.atlasIndexesDeferred = {};
      this.tokenImageSize = 64;
      this.samplerArr = new Uint32Array(MAX_SIZE);
      this.sdfParamsArr = new Float32Array(MAX_SIZE * 4);
      this._handler = null;
      this.catalogSrc = catalogSrc || "./";
    }
    assignHandler(handler) {
      this._handler = handler;
    }
    getFontIndex(face) {
      let fullName = this.getFullIndex(face);
      if (!this.atlasIndexes[fullName]) {
        this.loadFont(face, this.catalogSrc, `${face}.json`);
      }
      if (!this.atlasIndexesDeferred[fullName]) {
        this.atlasIndexesDeferred[fullName] = new Deferred();
      }
      return this.atlasIndexesDeferred[fullName].promise;
    }
    getFullIndex(face) {
      return face.trim().toLowerCase();
    }
    _applyFontDataToAtlas(atlas, data, index = 0) {
      let chars = data.chars;
      atlas.height = data.common.scaleH;
      atlas.width = data.common.scaleW;
      atlas.gliphSize = data.info.size;
      atlas.distanceRange = data.distanceField.distanceRange;
      let w3 = atlas.width, h8 = atlas.height, s7 = atlas.gliphSize;
      this.sdfParamsArr[index * 4] = w3;
      this.sdfParamsArr[index * 4 + 1] = h8;
      this.sdfParamsArr[index * 4 + 2] = s7;
      this.sdfParamsArr[index * 4 + 3] = atlas.distanceRange;
      let idToChar = {};
      for (let i9 = 0; i9 < chars.length; i9++) {
        let ci = chars[i9];
        let ti = ci.char;
        idToChar[ci.id] = ti;
        let r8 = new Rectangle(ci.x, ci.y, ci.x + ci.width, ci.y + ci.height);
        let tc = new Array(12);
        tc[0] = r8.left / w3;
        tc[1] = r8.top / h8;
        tc[2] = r8.left / w3;
        tc[3] = r8.bottom / h8;
        tc[4] = r8.right / w3;
        tc[5] = r8.bottom / h8;
        tc[6] = r8.right / w3;
        tc[7] = r8.bottom / h8;
        tc[8] = r8.right / w3;
        tc[9] = r8.top / h8;
        tc[10] = r8.left / w3;
        tc[11] = r8.top / h8;
        let taNode = new FontTextureAtlasNode(r8, tc);
        let ciNorm = ci.char.normalize("NFKC");
        let ciCode = ciNorm.charCodeAt(0);
        let m5 = taNode.metrics;
        m5.id = ci.id;
        m5.char = ci.char;
        m5.width = ci.width;
        m5.height = ci.height;
        m5.x = ci.x;
        m5.y = ci.y;
        m5.chnl = ci.chnl;
        m5.index = ci.index;
        m5.page = ci.page;
        m5.xadvance = ci.xadvance;
        m5.xoffset = ci.xoffset;
        m5.yoffset = ci.yoffset;
        m5.nChar = ciNorm;
        m5.nCode = ciCode;
        m5.nWidth = taNode.metrics.width / s7;
        m5.nHeight = taNode.metrics.height / s7;
        m5.nAdvance = taNode.metrics.xadvance / s7;
        m5.nXOffset = taNode.metrics.xoffset / s7;
        m5.nYOffset = 1 - taNode.metrics.yoffset / s7;
        taNode.emptySize = 1;
        atlas.nodes.set(ciNorm.charCodeAt(0), taNode);
      }
      atlas.kernings = {};
      for (let i9 = 0; i9 < data.kernings.length; i9++) {
        let ki = data.kernings[i9];
        let first = ki.first, second = ki.second;
        if (!atlas.kernings[first]) {
          atlas.kernings[first] = {};
        }
        atlas.kernings[first][second] = ki.amount / s7;
      }
    }
    initFont(faceName, dataJson, imageBase64) {
      let index = this.atlasesArr.length;
      let fullName = this.getFullIndex(faceName);
      this.atlasIndexes[fullName] = index;
      let def = this.atlasIndexesDeferred[fullName];
      if (!def) {
        def = this.atlasIndexesDeferred[fullName] = new Deferred();
      }
      this.samplerArr[this.atlasesArr.length] = index;
      let atlas = new FontTextureAtlas();
      atlas.height = 0;
      atlas.width = 0;
      atlas.gliphSize = 0;
      atlas.distanceRange = 0;
      atlas.kernings = {};
      atlas.assignHandler(this._handler);
      this.atlasesArr[index] = atlas;
      this._applyFontDataToAtlas(atlas, dataJson, index);
      let img = new Image();
      img.onload = () => {
        this._createTexture(atlas, img);
        def.resolve(index);
      };
      img.src = imageBase64;
    }
    _createTexture(atlas, img) {
      atlas.createTexture(img);
    }
    loadFont(faceName, srcDir, atlasUrl) {
      let index = this.atlasesArr.length;
      let fullName = this.getFullIndex(faceName);
      this.atlasIndexes[fullName] = index;
      let def = this.atlasIndexesDeferred[fullName];
      if (!def) {
        def = this.atlasIndexesDeferred[fullName] = new Deferred();
      }
      this.samplerArr[this.atlasesArr.length] = index;
      let atlas = new FontTextureAtlas();
      atlas.height = 0;
      atlas.width = 0;
      atlas.gliphSize = 0;
      atlas.distanceRange = 0;
      atlas.kernings = {};
      atlas.assignHandler(this._handler);
      this.atlasesArr[index] = atlas;
      fetch(`${srcDir}/${atlasUrl}`).then((response) => {
        if (!response.ok) {
          throw Error(`Unable to load "${srcDir}/${atlasUrl}"`);
        }
        return response.json();
      }).then((data) => {
        this._applyFontDataToAtlas(atlas, data, index);
        let img = new Image();
        img.onload = () => {
          this._createTexture(atlas, img);
          def.resolve(index);
        };
        img.src = `${srcDir}/${data.pages[0]}`;
        img.crossOrigin = "Anonymous";
      }).catch((err) => {
        def.reject();
        return { "status": "error", "msg": err.toString() };
      });
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/shaders/screenFrame.js
  function screenFrame() {
    return new Program("screenFrame", {
      uniforms: {
        texture: "sampler2d"
      },
      attributes: {
        corners: "vec3"
      },
      vertexShader: `attribute vec2 corners;
            
            varying vec2 tc;
            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`,
      fragmentShader: `precision highp float;
            uniform sampler2D texture;
            
            varying vec2 tc;
            
            void main(void) {
                gl_FragColor = texture2D( texture, tc );
            }`
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/shaders/toneMapping.js
  function toneMapping() {
    return new Program("toneMapping", {
      uniforms: {
        hdrBuffer: "sampler2d",
        exposure: "float",
        gamma: "float",
        whitepoint: "float"
      },
      attributes: {
        corners: "vec3"
      },
      vertexShader: `#version 300 es
            
            in vec2 corners;
            
            out vec2 tc;

            void main(void) {
                gl_Position = vec4(corners, 0.0, 1.0);
                tc = corners * 0.5 + 0.5;
            }`,
      fragmentShader: `#version 300 es

            precision highp float;

            #ifndef saturate
                #define saturate(a) clamp(a, 0.0, 1.0)
            #endif

            uniform sampler2D hdrBuffer;

            uniform float whitepoint;
            uniform float exposure;
            uniform float gamma;

            vec3 LinearToneMapping(vec3 color) {
                return exposure * color;
            }

            vec3 ReinhardToneMapping2(vec3 color) {
                return vec3(1.0) - exp(-color * exposure);
            }

            vec3 ReinhardToneMapping(vec3 color) {
                color *= exposure;
                return saturate(color / (vec3(1.0) + color));
            }

            #define Uncharted2Helper(x) max(((x * (0.15 * x + 0.10 * 0.50) + 0.20 * 0.02) / (x * (0.15 * x + 0.50) + 0.20 * 0.30)) - 0.02 / 0.30, vec3(0.0))

            vec3 Uncharted2ToneMapping(vec3 color) {
                color *= exposure;
                return saturate(Uncharted2Helper(color) / Uncharted2Helper(vec3(whitepoint)));
            }

            vec3 OptimizedCineonToneMapping(vec3 color) {
                color *= exposure;
                color = max(vec3(0.0), color - 0.004);
                return pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));
            }

            vec3 ACESFilmicToneMapping(vec3 color) {
                color *= exposure;
                return saturate((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14));
            }

            in vec2 tc;

            layout(location = 0) out vec4 fragColor;
            
            void main(void) {
                vec4 hdrColor = texture(hdrBuffer, tc).rgba;
                
                float oneByGamma = gamma / gamma;
                float oneByWhitePoint = whitepoint / whitepoint;
                vec3 mapped = ReinhardToneMapping2(hdrColor.rgb) * oneByGamma * oneByWhitePoint;
                //vec3 mapped = ACESFilmicToneMapping(hdrColor.rgb) * oneByGamma * oneByWhitePoint;

                mapped = pow(mapped, vec3(1.0 / gamma));
        
                fragColor = vec4(mapped, hdrColor.a);
            }`
    });
  }

  // frontend/node_modules/@openglobus/og/lib/js/renderer/Renderer.js
  var MSAA_DEFAULT = 0;
  var __pickingCallbackCounter__ = 0;
  var __depthCallbackCounter__ = 0;
  var __distanceCallbackCounter__ = 0;
  function clientWaitAsync(gl, sync, flags) {
    return new Promise((resolve, reject) => {
      function check() {
        const res = gl.clientWaitSync(sync, flags, 0);
        if (res == gl.WAIT_FAILED) {
          reject();
        } else if (res == gl.TIMEOUT_EXPIRED) {
          requestAnimationFrame(check);
        } else {
          resolve();
        }
      }
      check();
    });
  }
  var Renderer = class {
    constructor(handler, params = {}) {
      this._readPickingBuffer_webgl1 = () => {
        this.pickingFramebuffer.activate();
        this.pickingFramebuffer.readAllPixels(this._tempPickingPix_);
        this.pickingFramebuffer.deactivate();
      };
      this._readPickingBuffer_webgl2 = () => {
        const gl = this.handler.gl;
        const buf = this._pickingPixelBuffer;
        if (!this._skipPickingFrame) {
          this._skipPickingFrame = true;
          let dest = this._tempPickingPix_;
          let w3 = this.pickingFramebuffer.width, h8 = this.pickingFramebuffer.height;
          this.pickingFramebuffer.activate();
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
          gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
          gl.readPixels(0, 0, w3, h8, gl.RGBA, gl.UNSIGNED_BYTE, 0);
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
          this.pickingFramebuffer.deactivate();
          const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
          gl.flush();
          clientWaitAsync(gl, sync, 0).then(() => {
            this._skipPickingFrame = false;
            gl.deleteSync(sync);
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
            gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dest);
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
          });
        }
      };
      this._readDistanceBuffer_webgl1 = () => {
        this.distanceFramebuffer.activate();
        this.distanceFramebuffer.readAllPixels(this._tempDistancePix_);
        this.distanceFramebuffer.deactivate();
      };
      this._readDistanceBuffer_webgl2 = () => {
        const gl = this.handler.gl;
        const buf = this._distancePixelBuffer;
        if (!this._skipDistanceFrame) {
          this._skipDistanceFrame = true;
          let dest = this._tempDistancePix_;
          let w3 = this.distanceFramebuffer.width, h8 = this.distanceFramebuffer.height;
          this.distanceFramebuffer.activate();
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
          gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
          gl.readPixels(0, 0, w3, h8, gl.RGBA, gl.UNSIGNED_BYTE, 0);
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
          this.distanceFramebuffer.deactivate();
          const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
          gl.flush();
          clientWaitAsync(gl, sync, 0).then(() => {
            this._skipDistanceFrame = false;
            gl.deleteSync(sync);
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
            gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dest);
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
          });
        }
      };
      this.div = null;
      this.handler = handler;
      this.exposure = 3.01;
      this.gamma = 0.47;
      this.whitepoint = 1;
      this.brightThreshold = 0.9;
      this._renderNodesArr = [];
      this.renderNodes = {};
      this.activeCamera = null;
      this.events = createRendererEvents(this);
      this.controls = {};
      if (params.controls) {
        for (let i9 in params.controls) {
          this.controls[params.controls[i9].name] = params.controls[i9];
        }
      }
      this.controlsBag = {};
      this.colorObjects = /* @__PURE__ */ new Map();
      this._pickingCallbacks = [];
      this.pickingFramebuffer = null;
      this._tempPickingPix_ = new Uint8Array([]);
      this.distanceFramebuffer = null;
      this._distanceCallbacks = [];
      this._tempDistancePix_ = new Uint8Array([]);
      this._depthCallbacks = [];
      this.depthFramebuffer = null;
      let urlParams = new URLSearchParams(location.search);
      let msaaParam = urlParams.get("og_msaa");
      if (msaaParam) {
        this._msaa = Number(urlParams.get("og_msaa"));
      } else {
        this._msaa = params.msaa != void 0 ? params.msaa : MSAA_DEFAULT;
      }
      this._internalFormat = "RGBA16F";
      this._format = "RGBA";
      this._type = "FLOAT";
      this.sceneFramebuffer = null;
      this.blitFramebuffer = null;
      this.toneMappingFramebuffer = null;
      this._initialized = false;
      this.billboardsTextureAtlas = new TextureAtlas();
      this.geoObjectsTextureAtlas = new TextureAtlas();
      this.fontAtlas = new FontAtlas(params.fontsSrc);
      this._entityCollections = [];
      this._currentOutput = "screen";
      this._fnScreenFrame = null;
      this.labelWorker = new LabelWorker(4);
      this.__useDistanceFramebuffer__ = true;
      this.screenDepthFramebuffer = null;
      this.screenFramePositionBuffer = null;
      this.screenTexture = {};
      this.outputTexture = null;
      this._skipDistanceFrame = false;
      this._distancePixelBuffer = null;
      this._skipPickingFrame = false;
      this._pickingPixelBuffer = null;
      this._readDistanceBuffer = this._readDistanceBuffer_webgl2;
      this._readPickingBuffer = this._readPickingBuffer_webgl2;
      if (params.autoActivate || isEmpty(params.autoActivate)) {
        this.start();
      }
    }
    enableBlendOneSrcAlpha() {
      let gl = this.handler.gl;
      gl.enable(gl.BLEND);
      gl.blendEquation(gl.FUNC_ADD);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
    enableBlendDefault() {
      let gl = this.handler.gl;
      gl.enable(gl.BLEND);
      gl.blendEquation(gl.FUNC_ADD);
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
    }
    /**
     * Sets renderer events activity.
     * @param {Boolean} activity - Events activity.
     */
    setEventsActivity(activity) {
      this.events.active = activity;
    }
    addDepthCallback(sender, callback) {
      let id = __depthCallbackCounter__++;
      this._depthCallbacks.push({
        id,
        callback,
        sender
      });
      return id;
    }
    removeDepthCallback(id) {
      for (let i9 = 0; i9 < this._depthCallbacks.length; i9++) {
        if (id === this._depthCallbacks[i9].id) {
          this._depthCallbacks.splice(i9, 1);
          break;
        }
      }
    }
    addDistanceCallback(sender, callback) {
      let id = __distanceCallbackCounter__++;
      this._distanceCallbacks.push({
        id,
        callback,
        sender
      });
      return id;
    }
    removeDistanceCallback(id) {
      for (let i9 = 0; i9 < this._distanceCallbacks.length; i9++) {
        if (id === this._distanceCallbacks[i9].id) {
          this._distanceCallbacks.splice(i9, 1);
          break;
        }
      }
    }
    /**
     * Adds picking rendering callback function.
     * @param {object} sender - Callback context.
     * @param {Function} callback - Rendering callback.
     * @returns {Number} Handler id
     */
    addPickingCallback(sender, callback) {
      let id = __pickingCallbackCounter__++;
      this._pickingCallbacks.push({
        id,
        callback,
        sender
      });
      return id;
    }
    /**
     * Removes picking rendering callback function.
     * @param {Number} id - Handler id to remove.
     */
    removePickingCallback(id) {
      for (let i9 = 0; i9 < this._pickingCallbacks.length; i9++) {
        if (id === this._pickingCallbacks[i9].id) {
          this._pickingCallbacks.splice(i9, 1);
          break;
        }
      }
    }
    getPickingObject(r8, g4, b4) {
      return this.colorObjects.get(`${r8}_${g4}_${b4}`);
    }
    getPickingObjectArr(arr) {
      return this.colorObjects.get(`${arr[0]}_${arr[1]}_${arr[2]}`);
    }
    getPickingObject3v(vec) {
      return this.colorObjects.get(`${vec.x}_${vec.y}_${vec.z}`);
    }
    /**
     * Assign picking color to the object.
     * @public
     * @param {Object} obj - Object that presume to be picked.
     */
    assignPickingColor(obj) {
      if (!obj._pickingColor || obj._pickingColor.isZero()) {
        let r8 = 0, g4 = 0, b4 = 0;
        let str = "0_0_0";
        while (!(r8 || g4 || b4) || this.colorObjects.has(str)) {
          r8 = randomi(1, 255);
          g4 = randomi(1, 255);
          b4 = randomi(1, 255);
          str = `${r8}_${g4}_${b4}`;
        }
        if (!obj._pickingColor) {
          obj._pickingColor = new Vec3(r8, g4, b4);
        } else {
          obj._pickingColor.set(r8, g4, b4);
        }
        obj._pickingColorU = new Float32Array([r8 / 255, g4 / 255, b4 / 255]);
        this.colorObjects.set(str, obj);
      }
    }
    /**
     * Removes picking color from object.
     * @public
     * @param {Object} obj - Object to remove picking color.
     */
    clearPickingColor(obj) {
      if (obj._pickingColor && !obj._pickingColor.isZero()) {
        let c7 = obj._pickingColor;
        if (!c7.isZero()) {
          this.colorObjects.delete(`${c7.x}_${c7.y}_${c7.z}`);
          c7.x = c7.y = c7.z = 0;
        }
      }
    }
    /**
     * Get the client width.
     * @public
     * @returns {number} -
     */
    getWidth() {
      return this.handler.canvas.clientWidth;
    }
    /**
     * Get the client height.
     * @public
     * @returns {number} -
     */
    getHeight() {
      return this.handler.canvas.clientHeight;
    }
    /**
     * Get center of the canvas
     * @public
     * @returns {Vec2} -
     */
    getCenter() {
      let cnv = this.handler.canvas;
      return new Vec2(Math.round(cnv.width * 0.5), Math.round(cnv.height * 0.5));
    }
    /**
     * Get center of the screen viewport
     * @public
     * @returns {Vec2} -
     */
    getClientCenter() {
      let cnv = this.handler.canvas;
      return new Vec2(Math.round(cnv.clientWidth * 0.5), Math.round(cnv.clientHeight * 0.5));
    }
    /**
     * Add the given control to the renderer.
     * @param {Control} control - Control.
     */
    addControl(control) {
      control.addTo(this);
    }
    /**
     * Add the given controls array to the planet node.
     * @param {Array.<Control>} cArr - Control array.
     */
    addControls(cArr) {
      for (let i9 = 0; i9 < cArr.length; i9++) {
        cArr[i9].addTo(this);
      }
    }
    /**
     * Remove control from the renderer.
     * @param {Control} control  - Control.
     */
    removeControl(control) {
      control.remove();
    }
    isInitialized() {
      return this._initialized;
    }
    /**
     * Renderer initialization.
     * @public
     */
    initialize() {
      if (this._initialized) {
        return;
      } else {
        this._initialized = true;
      }
      this.handler.initialize();
      this.billboardsTextureAtlas.assignHandler(this.handler);
      this.geoObjectsTextureAtlas.assignHandler(this.handler);
      this.fontAtlas.assignHandler(this.handler);
      this.handler.setFrameCallback(() => {
        this.draw();
      });
      this.activeCamera = new Camera(this, {
        eye: new Vec3(0, 0, 0),
        look: new Vec3(0, 0, -1),
        up: new Vec3(0, 1, 0)
      });
      this.events.initialize();
      this.events.on("charkeypress", input.KEY_APOSTROPHE, function() {
        cons.setVisibility(!cons.getVisibility());
      });
      this.handler.addProgram(screenFrame());
      this.pickingFramebuffer = new Framebuffer(this.handler, {
        width: 640,
        height: 480
      });
      this.pickingFramebuffer.init();
      this._tempPickingPix_ = new Uint8Array(this.pickingFramebuffer.width * this.pickingFramebuffer.height * 4);
      this.distanceFramebuffer = new Framebuffer(this.handler, {
        width: 320,
        height: 240
      });
      this.distanceFramebuffer.init();
      this._tempDistancePix_ = new Uint8Array(this.distanceFramebuffer.width * this.distanceFramebuffer.height * 4);
      this.depthFramebuffer = new Framebuffer(this.handler, {
        size: 2,
        internalFormat: ["RGBA", "DEPTH_COMPONENT24"],
        format: ["RGBA", "DEPTH_COMPONENT"],
        type: ["UNSIGNED_BYTE", "UNSIGNED_INT"],
        attachment: ["COLOR_ATTACHMENT", "DEPTH_ATTACHMENT"],
        useDepth: false
      });
      this.depthFramebuffer.init();
      this.screenDepthFramebuffer = new Framebuffer(this.handler, {
        useDepth: false
      });
      this.screenDepthFramebuffer.init();
      if (this.handler.gl.type === "webgl") {
        this._readDistanceBuffer = this._readDistanceBuffer_webgl1;
        this._readPickingBuffer = this._readPickingBuffer_webgl1;
        this.sceneFramebuffer = new Framebuffer(this.handler);
        this.sceneFramebuffer.init();
        this._fnScreenFrame = this._screenFrameNoMSAA;
        this.screenTexture = {
          screen: this.sceneFramebuffer.textures[0],
          picking: this.pickingFramebuffer.textures[0],
          distance: this.distanceFramebuffer.textures[0],
          depth: this.screenDepthFramebuffer.textures[0]
        };
      } else {
        let _maxMSAA = this.getMaxMSAA(this._internalFormat);
        if (this._msaa > _maxMSAA) {
          this._msaa = _maxMSAA;
        }
        this.handler.addPrograms([toneMapping()]);
        this.handler.addPrograms([depth()]);
        this.sceneFramebuffer = new Multisample(this.handler, {
          size: 1,
          msaa: this._msaa,
          internalFormat: this._internalFormat,
          filter: "LINEAR"
        });
        this.sceneFramebuffer.init();
        this.blitFramebuffer = new Framebuffer(this.handler, {
          size: 1,
          useDepth: false,
          internalFormat: this._internalFormat,
          format: this._format,
          type: this._type,
          filter: "NEAREST"
        });
        this.blitFramebuffer.init();
        this.toneMappingFramebuffer = new Framebuffer(this.handler, {
          useDepth: false
        });
        this.toneMappingFramebuffer.init();
        this._fnScreenFrame = this._screenFrameMSAA;
        this.screenTexture = {
          screen: this.toneMappingFramebuffer.textures[0],
          picking: this.pickingFramebuffer.textures[0],
          distance: this.distanceFramebuffer.textures[0],
          depth: this.screenDepthFramebuffer.textures[0],
          frustum: this.depthFramebuffer.textures[0]
        };
        this._initReadPixelsBuffers();
      }
      this.handler.ONCANVASRESIZE = () => {
        this._resizeStart();
        this.events.dispatch(this.events.resize, this.handler.canvas);
        this._resizeEnd();
        this.events.dispatch(this.events.resizeend, this.handler.canvas);
      };
      this.screenFramePositionBuffer = this.handler.createArrayBuffer(new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), 2, 4);
      this.outputTexture = this.screenTexture.screen;
      this._initializeRenderNodes();
      this._initializeControls();
    }
    _initReadPixelsBuffers() {
      let gl = this.handler.gl;
      this._distancePixelBuffer = gl.createBuffer();
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this._distancePixelBuffer);
      gl.bufferData(gl.PIXEL_PACK_BUFFER, this.distanceFramebuffer.width * this.distanceFramebuffer.height * 4, gl.STREAM_READ);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
      this._pickingPixelBuffer = gl.createBuffer();
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this._pickingPixelBuffer);
      gl.bufferData(gl.PIXEL_PACK_BUFFER, this.pickingFramebuffer.width * this.pickingFramebuffer.height * 4, gl.STREAM_READ);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    }
    _initializeControls() {
      let temp = this.controls;
      this.controls = {};
      for (let i9 in temp) {
        this.addControl(temp[i9]);
      }
    }
    resize() {
      this._resizeEnd();
    }
    setCurrentScreen(screenName) {
      this._currentOutput = screenName;
      if (this.screenTexture[screenName]) {
        this.outputTexture = this.screenTexture[screenName];
      }
    }
    _resizeStart() {
      let c7 = this.handler.canvas;
      this.activeCamera.setAspectRatio(c7.width / c7.height);
      this.sceneFramebuffer.setSize(c7.width * 0.5, c7.height * 0.5);
      this.blitFramebuffer && this.blitFramebuffer.setSize(c7.width * 0.5, c7.height * 0.5, true);
    }
    _resizeEnd() {
      let c7 = this.handler.canvas;
      this.activeCamera.setAspectRatio(c7.width / c7.height);
      this.sceneFramebuffer.setSize(c7.width, c7.height);
      this.blitFramebuffer && this.blitFramebuffer.setSize(c7.width, c7.height, true);
      this.toneMappingFramebuffer && this.toneMappingFramebuffer.setSize(c7.width, c7.height, true);
      this.depthFramebuffer && this.depthFramebuffer.setSize(c7.clientWidth, c7.clientHeight, true);
      this.screenDepthFramebuffer && this.screenDepthFramebuffer.setSize(c7.clientWidth, c7.clientHeight, true);
      if (this.handler.gl.type === "webgl") {
        this.screenTexture.screen = this.sceneFramebuffer.textures[0];
        this.screenTexture.picking = this.pickingFramebuffer.textures[0];
        this.screenTexture.distance = this.distanceFramebuffer.textures[0];
        this.screenTexture.depth = this.screenDepthFramebuffer.textures[0];
        this.screenTexture.frustum = this.depthFramebuffer.textures[0];
      } else {
        this.screenTexture.screen = this.toneMappingFramebuffer.textures[0];
        this.screenTexture.picking = this.pickingFramebuffer.textures[0];
        this.screenTexture.distance = this.distanceFramebuffer.textures[0];
        this.screenTexture.depth = this.screenDepthFramebuffer.textures[0];
        this.screenTexture.frustum = this.depthFramebuffer.textures[0];
      }
      this.setCurrentScreen(this._currentOutput);
    }
    removeNode(renderNode) {
      renderNode.remove();
    }
    /**
     * Adds render node to the renderer.
     * @public
     * @param {RenderNode} renderNode - Render node.
     */
    addNode(renderNode) {
      if (!this.renderNodes[renderNode.name]) {
        renderNode.assign(this);
        this._renderNodesArr.unshift(renderNode);
        this.renderNodes[renderNode.name] = renderNode;
      } else {
        cons.logWrn(`Node name ${renderNode.name} already exists.`);
      }
    }
    _initializeRenderNodes() {
      for (let i9 = 0; i9 < this._renderNodesArr.length; i9++) {
        this._renderNodesArr[i9].initialize();
      }
    }
    /**
     * Adds render node to the renderer before specific node.
     * @public
     * @param {RenderNode} renderNode - Render node.
     * @param {RenderNode} renderNodeBefore - Insert before the renderNodeBefore node.
     */
    addNodeBefore(renderNode, renderNodeBefore) {
      if (!this.renderNodes[renderNode.name]) {
        renderNode.assign(this);
        this.renderNodes[renderNode.name] = renderNode;
        for (let i9 = 0; i9 < this._renderNodesArr.length; i9++) {
          if (this._renderNodesArr[i9].isEqual(renderNodeBefore)) {
            this._renderNodesArr.splice(i9, 0, renderNode);
            break;
          }
        }
        this._renderNodesArr.unshift(renderNode);
      } else {
        cons.logWrn(`Node name ${renderNode.name} already exists.`);
      }
    }
    /**
     * Adds render nodes array to the renderer.
     * @public
     * @param {Array.<RenderNode>} nodesArr - Render nodes array.
     */
    addNodes(nodesArr) {
      for (let i9 = 0; i9 < nodesArr.length; i9++) {
        this.addNode(nodesArr[i9]);
      }
    }
    getMaxMSAA(internalFormat) {
      let gl = this.handler.gl;
      let samples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl[internalFormat], gl.SAMPLES);
      return samples[0];
    }
    getMSAA() {
      return this._msaa;
    }
    /**
     * TODO: replace with cache friendly linked list by BillboardHandler, LabelHandler etc.
     */
    enqueueEntityCollectionsToDraw(ecArr) {
      this._entityCollections.push.apply(this._entityCollections, ecArr);
    }
    /**
     * Draws opaque items entity collections.
     * @protected
     */
    _drawOpaqueEntityCollections() {
      let ec = this._entityCollections;
      if (ec.length) {
        this.enableBlendDefault();
        let i9 = ec.length;
        while (i9--) {
          ec[i9]._fadingOpacity && ec[i9].pointCloudHandler.draw();
        }
      }
    }
    /**
     * Draws transparent items entity collections.
     * @protected
     */
    _drawTransparentEntityCollections() {
      let ec = this._entityCollections;
      if (ec.length) {
        let gl = this.handler.gl;
        this.enableBlendDefault();
        let i9 = ec.length;
        while (i9--) {
          let eci = ec[i9];
          if (ec[i9]._fadingOpacity) {
            eci.events.dispatch(eci.events.draw, eci);
            ec[i9].geoObjectHandler.draw();
          }
        }
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.billboardsTextureAtlas.texture);
        i9 = ec.length;
        while (i9--) {
          let eci = ec[i9];
          eci._fadingOpacity && eci.billboardHandler.draw();
        }
        let fa = this.fontAtlas.atlasesArr;
        for (i9 = 0; i9 < fa.length; i9++) {
          gl.activeTexture(gl.TEXTURE0 + i9);
          gl.bindTexture(gl.TEXTURE_2D, fa[i9].texture);
        }
        i9 = ec.length;
        while (i9--) {
          ec[i9]._fadingOpacity && ec[i9].labelHandler.draw();
        }
        i9 = ec.length;
        while (i9--) {
          ec[i9]._fadingOpacity && ec[i9].rayHandler.draw();
        }
        i9 = ec.length;
        while (i9--) {
          ec[i9]._fadingOpacity && ec[i9].polylineHandler.draw();
        }
        i9 = ec.length;
        while (i9--) {
          ec[i9]._fadingOpacity && ec[i9].stripHandler.draw();
        }
      }
    }
    _clearEntityCollectionQueue() {
      this._entityCollections.length = 0;
      this._entityCollections = [];
    }
    /**
     * Draw nodes.
     * @public
     */
    draw() {
      this.activeCamera.checkMoveEnd();
      let e9 = this.events;
      e9.handleEvents();
      let sceneFramebuffer = this.sceneFramebuffer;
      sceneFramebuffer.activate();
      let h8 = this.handler, gl = h8.gl;
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      this.enableBlendDefault();
      e9.dispatch(e9.draw, this);
      let frustums = this.activeCamera.frustums;
      let pointerEvent = e9.pointerEvent();
      let mouseHold = e9.mouseState.leftButtonDown || e9.mouseState.rightButtonDown;
      let rn = this._renderNodesArr;
      let k3 = frustums.length;
      while (k3--) {
        this.activeCamera.setCurrentFrustum(k3);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        let i9 = rn.length;
        while (i9--) {
          rn[i9].preDrawNode();
        }
        this._drawOpaqueEntityCollections();
        i9 = rn.length;
        while (i9--) {
          this.enableBlendDefault();
          rn[i9].drawNode();
        }
        this._drawTransparentEntityCollections();
        this._clearEntityCollectionQueue();
        e9.dispatch(e9.drawtransparent, this);
        if (pointerEvent && !mouseHold) {
          this._drawPickingBuffer();
        }
        this.__useDistanceFramebuffer__ && this._drawDistanceBuffer();
      }
      sceneFramebuffer.deactivate();
      this.blitFramebuffer && sceneFramebuffer.blitTo(this.blitFramebuffer, 0);
      if (pointerEvent) {
        if (h8.isWebGl2()) {
          this._drawDepthBuffer();
        }
        this._readPickingBuffer();
      }
      this.__useDistanceFramebuffer__ && this._readDistanceBuffer();
      this._fnScreenFrame();
      e9.dispatch(e9.postdraw, this);
      e9.mouseState.wheelDelta = 0;
      e9.mouseState.justStopped = false;
      e9.mouseState.moving = false;
      e9.touchState.moving = false;
    }
    _screenFrameMSAA() {
      let h8 = this.handler;
      let sh = h8.programs.toneMapping, p4 = sh._program, gl = h8.gl;
      gl.disable(gl.DEPTH_TEST);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.screenFramePositionBuffer);
      gl.vertexAttribPointer(p4.attributes.corners, 2, gl.FLOAT, false, 0, 0);
      this.toneMappingFramebuffer.activate();
      sh.activate();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.blitFramebuffer.textures[0]);
      gl.uniform1i(p4.uniforms.hdrBuffer, 0);
      gl.uniform1f(p4.uniforms.gamma, this.gamma);
      gl.uniform1f(p4.uniforms.exposure, this.exposure);
      gl.uniform1f(p4.uniforms.whitepoint, this.whitepoint);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      this.toneMappingFramebuffer.deactivate();
      sh = h8.programs.screenFrame;
      p4 = sh._program;
      sh.activate();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.outputTexture);
      gl.uniform1i(p4.uniforms.texture, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.enable(gl.DEPTH_TEST);
    }
    _screenFrameNoMSAA() {
      let h8 = this.handler;
      let sh = h8.programs.screenFrame, p4 = sh._program, gl = h8.gl;
      gl.disable(gl.DEPTH_TEST);
      sh.activate();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.outputTexture);
      gl.uniform1i(p4.uniforms.texture, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.screenFramePositionBuffer);
      gl.vertexAttribPointer(p4.attributes.corners, 2, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.enable(gl.DEPTH_TEST);
    }
    /**
     * Draw picking objects framebuffer.
     * @private
     */
    _drawPickingBuffer() {
      this.pickingFramebuffer.activate();
      let h8 = this.handler;
      let gl = h8.gl;
      if (this.activeCamera.isFirstPass) {
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      } else {
        gl.clear(gl.DEPTH_BUFFER_BIT);
      }
      let dp = this._pickingCallbacks;
      for (let i9 = 0, len = dp.length; i9 < len; i9++) {
        gl.disable(gl.BLEND);
        dp[i9].callback.call(dp[i9].sender);
        gl.enable(gl.BLEND);
      }
      this.pickingFramebuffer.deactivate();
    }
    /**
     * Draw picking objects framebuffer.
     * @protected
     */
    _drawDistanceBuffer() {
      this.distanceFramebuffer.activate();
      let h8 = this.handler;
      let gl = h8.gl;
      if (this.activeCamera.isFirstPass) {
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      } else {
        gl.clear(gl.DEPTH_BUFFER_BIT);
      }
      gl.disable(gl.BLEND);
      let dp = this._distanceCallbacks;
      let i9 = dp.length;
      while (i9--) {
        dp[i9].callback.call(dp[i9].sender);
      }
      gl.enable(gl.BLEND);
      this.distanceFramebuffer.deactivate();
    }
    _drawDepthBuffer() {
      this.depthFramebuffer.activate();
      let h8 = this.handler;
      let gl = h8.gl;
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);
      let dp = this._depthCallbacks;
      let i9 = dp.length;
      while (i9--) {
        dp[i9].callback.call(dp[i9].sender);
      }
      this.depthFramebuffer.deactivate();
      this.screenDepthFramebuffer.activate();
      let sh = h8.programs.depth, p4 = sh._program;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.screenFramePositionBuffer);
      gl.vertexAttribPointer(p4.attributes.corners, 2, gl.FLOAT, false, 0, 0);
      sh.activate();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.depthFramebuffer.textures[1]);
      gl.uniform1i(p4.uniforms.depthTexture, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      this.screenDepthFramebuffer.deactivate();
    }
    readPickingColor(x3, y4, outColor) {
      let w3 = this.pickingFramebuffer.width;
      let h8 = this.pickingFramebuffer.height;
      x3 = Math.round(x3 * w3);
      y4 = Math.round(y4 * h8);
      let ind = (y4 * w3 + x3) * 4;
      outColor[0] = this._tempPickingPix_[ind];
      outColor[1] = this._tempPickingPix_[ind + 1];
      outColor[2] = this._tempPickingPix_[ind + 2];
    }
    readDistanceColor(x3, y4, outColor) {
      let w3 = this.distanceFramebuffer.width;
      let h8 = this.distanceFramebuffer.height;
      x3 = Math.round(x3 * w3);
      y4 = Math.round(y4 * h8);
      let ind = (y4 * w3 + x3) * 4;
      outColor[0] = this._tempDistancePix_[ind];
      outColor[1] = this._tempDistancePix_[ind + 1];
      outColor[2] = this._tempDistancePix_[ind + 2];
    }
    /**
     * Function starts renderer
     * @public
     */
    start() {
      if (!this._initialized) {
        this.initialize();
      }
      this.handler.start();
    }
    destroy() {
      for (let i9 in this.controls) {
        this.controls[i9].remove();
      }
      for (let i9 = 0; i9 < this._renderNodesArr.length; i9++) {
        this._renderNodesArr[i9].remove();
      }
      this.div = null;
      this._renderNodesArr = [];
      this.renderNodes = {};
      this.activeCamera = null;
      this.controls = {};
      this.controlsBag = {};
      this.colorObjects.clear();
      this.colorObjects = null;
      this._pickingCallbacks = [];
      this.pickingFramebuffer = null;
      this._tempPickingPix_ = null;
      this.distanceFramebuffer = null;
      this._distanceCallbacks = [];
      this._tempDistancePix_ = null;
      this._depthCallbacks = [];
      this.depthFramebuffer = null;
      this.sceneFramebuffer = null;
      this.blitFramebuffer = null;
      this.toneMappingFramebuffer = null;
      this._entityCollections = [];
      this.handler.ONCANVASRESIZE = null;
      this.handler.destroy();
      this.handler = null;
      this._initialized = false;
    }
  };

  // frontend/node_modules/@openglobus/og/lib/js/Globe.js
  var DEFAULT_NIGHT_SRC = `/night.png`;
  var DEFAULT_SPEC_SRC = `/spec.png`;
  var DEFAULT_RESOURCES_SRC = "/res";
  var PLANET_NAME_PREFIX = "globus_planet_";
  var Globe = class _Globe {
    constructor(options2) {
      this.$target = null;
      this._instanceID = `__globus${_Globe.__counter__++ ? _Globe.__counter__ : ""}__`;
      window[this._instanceID] = this;
      this._canvas = document.createElement("canvas");
      this._canvas.id = `canvas${this._instanceID}`;
      this._canvas.style.width = "100%";
      this._canvas.style.height = "100%";
      this._canvas.style.display = "block";
      this._canvas.style.opacity = "0.0";
      this._canvas.style.transition = "opacity 150ms";
      this.$inner = document.createElement("div");
      this.$inner.classList.add("og-inner");
      this.$inner.appendChild(this._canvas);
      this.$inner.attributions = document.createElement("div");
      if (options2.attributionContainer) {
        options2.attributionContainer.appendChild(this.$inner.attributions);
      } else {
        this.$inner.attributions.classList.add("og-attribution");
        this.$inner.appendChild(this.$inner.attributions);
      }
      if (options2.target) {
        this.attachTo(options2.target);
      }
      const _disableWheel = (e9) => {
        e9.preventDefault();
      };
      this._canvas.onmouseenter = function() {
        document.addEventListener("mousewheel", _disableWheel, {
          capture: false,
          passive: false
        });
      };
      this._canvas.onmouseleave = function() {
        document.removeEventListener("mousewheel", _disableWheel);
      };
      this.renderer = new Renderer(new Handler(this._canvas, {
        autoActivate: false,
        pixelRatio: options2.dpi || window.devicePixelRatio + 0.15,
        context: {
          //alpha: false,
          antialias: false,
          premultipliedAlpha: false
        }
      }), {
        autoActivate: false,
        msaa: options2.msaa,
        fontsSrc: options2.fontsSrc
      });
      this.renderer.div = this.$inner;
      if (options2.skybox) {
        this.renderer.addNode(options2.skybox);
      }
      this._planetName = options2.name ? options2.name : PLANET_NAME_PREFIX + _Globe.__counter__;
      this.planet = new Planet({
        name: this._planetName,
        frustums: options2.frustums,
        ellipsoid: options2.ellipsoid,
        maxGridSize: options2.maxGridSize,
        nightTextureSrc: options2.nightTextureSrc === null ? null : `${options2.resourcesSrc || DEFAULT_RESOURCES_SRC}${DEFAULT_NIGHT_SRC}`,
        specularTextureSrc: options2.specularTextureSrc === null ? null : `${options2.resourcesSrc || DEFAULT_RESOURCES_SRC}${DEFAULT_SPEC_SRC}`,
        minAltitude: options2.minAltitude,
        maxAltitude: options2.maxAltitude || 15e6,
        maxEqualZoomAltitude: options2.maxEqualZoomAltitude,
        minEqualZoomAltitude: options2.minEqualZoomAltitude,
        minEqualZoomCameraSlope: options2.minEqualZoomCameraSlope,
        quadTreeStrategyPrototype: options2.quadTreeStrategyPrototype,
        maxLoadingRequests: options2.maxLoadingRequests,
        atmosphereEnabled: options2.atmosphereEnabled,
        transitionOpacityEnabled: options2.transitionOpacityEnabled,
        atmosphereParameters: options2.atmosphereParameters
      });
      if (options2.terrain) {
        if (Array.isArray(options2.terrain)) {
          this.planet.setTerrain(options2.terrain[0]);
        } else {
          this.planet.setTerrain(options2.terrain);
        }
      } else {
        this.planet.setTerrain(new EmptyTerrain());
      }
      this.renderer.addNode(this.planet);
      if (options2.controls) {
        this.planet.addControls(options2.controls);
      } else {
        this.planet.addControls([
          new ZoomControl(),
          options2.useEarthNavigation ? new EarthNavigation() : new MouseNavigation({ minSlope: options2.minSlope }),
          new TouchNavigation(),
          new EarthCoordinates(),
          new ScaleControl(),
          new CompassButton()
        ]);
      }
      const _controls = this.renderer.controls;
      let sun;
      for (let i9 in _controls) {
        if (_controls[i9] instanceof Sun) {
          sun = _controls[i9];
          break;
        }
      }
      if (!sun) {
        this.sun = new Sun();
        this.planet.addControl(this.sun);
      } else {
        this.sun = sun;
      }
      if (options2.sun) {
        if (options2.sun.active !== void 0 && !options2.sun.active) {
          this.sun.deactivate();
        }
        if (options2.sun.stopped === true) {
          this.sun.stop();
        }
      }
      if (options2.layers) {
        this.planet.addLayers(options2.layers);
      }
      let ve = options2.viewExtent;
      if (ve) {
        if (ve instanceof Array) {
          this.planet.viewExtentArr(ve);
        } else {
          this.planet.viewExtent(ve);
        }
      }
      if (options2.autoActivate || isEmpty(options2.autoActivate)) {
        this.start();
      }
    }
    start() {
      this.renderer.start();
      this.fadeIn();
    }
    /**
     * Starts screen brightness fading in effect by the duration time.
     * @public
     */
    fadeIn() {
      this._canvas.style.opacity = "1.0";
    }
    /**
     * Starts screen brightness fading out effect by the duration time.
     * @public
     */
    fadeOut() {
      this._canvas.style.opacity = "0";
    }
    attachTo(target) {
      this.detach();
      let t9;
      if (target instanceof HTMLElement) {
        t9 = target;
      } else {
        t9 = document.getElementById(target) || document.querySelector(target);
      }
      if (t9) {
        this.$target = t9;
        t9.appendChild(this.$inner);
      }
    }
    detach() {
      if (this.$target) {
        this.$target.removeChild(this.$inner);
      }
    }
    destroy() {
      this.detach();
      this.planet.layers.forEach((l4) => l4.remove());
      this.planet.destroy();
      this.renderer.destroy();
      window[this._instanceID] = null;
    }
  };
  Globe.__counter__ = 0;

  // frontend/node_modules/@openglobus/og/lib/js/Popup.js
  var TEMPLATE14 = `<div class="og-popup {className}">
      <div class="og-popup-content-wrapper">
        <div class="og-popup-content"></div>
      </div>
      <div class="og-popup-tip-container">
        <div class="og-popup-tip"></div>
      </div>
      <div class="og-popup-toolbar">
        <div class="og-popup-btn og-popup-close">${CLOSE_ICON}</div>
      </div>
      <div class="og-popup-title">{title}</div>
    </div>`;
  var POPUP_EVENTS = ["open", "close"];
  var Popup = class extends View {
    constructor(options2) {
      super({
        template: stringTemplate(TEMPLATE14, {
          title: options2.title || ""
        }),
        classList: options2.className ? [options2.className] : [],
        ...options2
      });
      this.events = this.events.registerNames(POPUP_EVENTS);
      this._content = options2.content || "";
      this.$content = null;
      this.$tip = null;
      this.$title = null;
      this._planet = options2.planet;
      this._offset = options2.offset || [0, 0];
      this._lonLat = createLonLat(options2.lonLat);
      this._cartPos = new Vec3();
      this._visibility = options2.visibility || false;
      this.render();
    }
    _updatePosition() {
      this.setCartesian3v(this._cartPos);
    }
    setScreen(p4) {
      if (this._planet) {
        let r8 = this._planet.renderer.handler.pixelRatio;
        this.el.style.transform = `translate(${p4.x / r8 - this.clientWidth * 0.5}px, ${p4.y / r8 - this._planet.renderer.handler.canvas.clientHeight - this.$tip.clientHeight}px)`;
      }
    }
    get clientWidth() {
      return this.el ? this.el.clientWidth : 0;
    }
    get clientHeight() {
      return this.el ? this.el.clientHeight : 0;
    }
    setOffset(x3 = 0, y4 = 0) {
      this._offset[0] = x3;
      this._offset[1] = y4;
      if (this.el) {
        this.el.style.left = `${x3}px`;
        this.el.style.bottom = `${y4}px`;
      }
      return this;
    }
    render(params) {
      super.render(params);
      this.$content = this.select(".og-popup-content");
      this.$title = this.select(".og-popup-title");
      this.$tip = this.select(".og-popup-tip-container");
      this.setOffset(this._offset[0], this._offset[1]);
      this.setContent(this._content);
      this.setLonLat(this._lonLat);
      this.setVisibility(this._visibility);
      this.select(".og-popup-close").addEventListener("click", () => {
        this.hide();
      });
      return this;
    }
    setVisibility(visibility) {
      if (visibility) {
        this.show();
      } else {
        this.hide();
      }
      return this;
    }
    getContainer() {
      return this.$content;
    }
    getToolbarContainer() {
      return this.select(".og-popup-toolbar");
    }
    show() {
      this._visibility = true;
      if (this._planet) {
        this._planet.events.on("draw", this._updatePosition, this);
        this.appendTo(this._planet.renderer.div);
        this.events.dispatch(this.events.open, this);
      }
      return this;
    }
    hide() {
      this._visibility = false;
      if (this.el && this.el.parentNode) {
        this._planet.events.off("draw", this._updatePosition);
        this.el.parentNode.removeChild(this.el);
        this.events.dispatch(this.events.close, this);
      }
      return this;
    }
    setCartesian3v(cart, height = 0) {
      this._cartPos = cart;
      if (this._planet) {
        let cam = this._planet.camera;
        let f8 = this._planet.ellipsoid.equatorialSize + height, g4 = cam._lonLat.height;
        let look = cart.sub(cam.eye), v4 = Math.sqrt((f8 + g4) * (f8 + g4) - f8 * f8);
        if (v4 > look.length() && cam.getForward().dot(look.normalize()) > 0) {
          this.el.style.display = "block";
          this.setScreen(cam.project(cart));
        } else {
          this.el.style.display = "none";
        }
      }
      return this;
    }
    setTitle(html) {
      if (this.$title) {
        this.$title.innerHTML = html;
      }
    }
    setLonLat(lonLat) {
      this._lonLat = lonLat;
      if (this._planet) {
        this.setCartesian3v(this._planet.ellipsoid.lonLatToCartesian(lonLat), lonLat.height);
      }
    }
    setContent(content) {
      if (content) {
        this.clear();
        this._content = content;
        if (this.$content) {
          if (typeof content === "string") {
            this.$content.innerHTML = content;
          } else {
            this.$content.appendChild(content);
          }
        }
      }
    }
    clear() {
      this._content = null;
      if (this.$content) {
        this.$content.innerHTML = "";
      }
    }
  };

  // frontend/ts/globe/osmLayer.ts
  var OsmLayer = class extends XYZ {
    constructor() {
      const name = "OSMLayer";
      super(name, {
        iconSrc: "https://tile.openstreetmap.org/8/138/95.png",
        url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        attribution: "Data @ OpenStreetMap contributors, ODbL",
        isBaseLayer: true,
        visibility: false,
        maxNativeZoom: 19,
        defaultTextures: [{ color: "#AAD3DF" }, { color: "#F2EFE9" }],
        isSRGB: false,
        shininess: 18,
        specular: [63e-5, 55e-5, 32e-5],
        ambient: [0.2, 0.2, 0.3],
        diffuse: [0.9, 0.9, 0.7],
        urlRewrite: (s7, u4) => {
          return stringTemplate(u4, {
            "s": this._getSubdomain(),
            "x": s7.tileX,
            "y": s7.tileY,
            "z": s7.tileZoom
          });
        }
      });
    }
  };

  // frontend/ts/globe/satLayer.ts
  function toQuadKey(x3, y4, z3) {
    var index = "";
    for (let i9 = z3; i9 > 0; i9--) {
      var b4 = 0;
      var mask = 1 << i9 - 1;
      if ((x3 & mask) !== 0) b4++;
      if ((y4 & mask) !== 0) b4 += 2;
      index += b4.toString();
    }
    return index;
  }
  var SatLayer = class extends XYZ {
    constructor() {
      const name = "SatLayer";
      super(name, {
        iconSrc: "https://ecn.t0.tiles.virtualearth.net/tiles/a120.jpeg?n=z&g=7146",
        subdomains: ["t0", "t1", "t2", "t3"],
        url: "https://ecn.{s}.tiles.virtualearth.net/tiles/a{quad}.jpeg?n=z&g=7146",
        isBaseLayer: true,
        visibility: true,
        maxNativeZoom: 17,
        defaultTextures: [{ color: "#001522" }, { color: "#E4E6F3" }],
        attribution: `<div style="transform: scale(0.8); margin-top:-2px;"><a href="https://www.bing.com" target="_blank"><img style="position: relative; top: 2px;" title="Bing Imagery" src="https://sandcastle.cesium.com/CesiumUnminified/Assets/Images/bing_maps_credit.png"></a> \xA9 2021 Microsoft Corporation</div>`,
        urlRewrite: (s7, u4) => {
          return stringTemplate(u4, {
            "s": this._getSubdomain(),
            "quad": toQuadKey(s7.tileX, s7.tileY, s7.tileZoom)
          });
        },
        specular: [63e-5, 55e-5, 32e-5],
        ambient: "rgb(90,90,90)",
        diffuse: "rgb(350,350,350)",
        shininess: 20,
        nightTextureCoefficient: 2.7
      });
    }
  };

  // frontend/ts/proto/jon/jon_shared_data_types.ts
  var import_minimal = __toESM(require_minimal2());
  function jonGuiDataVideoChannelHeatFiltersFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_HOT_WHITE":
        return 1 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_HOT_WHITE */;
      case 2:
      case "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_HOT_BLACK":
        return 2 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_HOT_BLACK */;
      case 3:
      case "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_SEPIA":
        return 3 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_SEPIA */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataVideoChannelHeatFiltersToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_UNSPECIFIED */:
        return "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_HOT_WHITE */:
        return "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_HOT_WHITE";
      case 2 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_HOT_BLACK */:
        return "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_HOT_BLACK";
      case 3 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_SEPIA */:
        return "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_FILTER_SEPIA";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataVideoChannelHeatAGCModesFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_1":
        return 1 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_1 */;
      case 2:
      case "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_2":
        return 2 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_2 */;
      case 3:
      case "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_3":
        return 3 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_3 */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataVideoChannelHeatAGCModesToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_UNSPECIFIED */:
        return "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_1 */:
        return "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_1";
      case 2 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_2 */:
        return "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_2";
      case 3 /* JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_3 */:
        return "JON_GUI_DATA_VIDEO_CHANNEL_HEAT_AGC_MODE_3";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataGpsFixTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_GPS_FIX_TYPE_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_GPS_FIX_TYPE_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_GPS_FIX_TYPE_NONE":
        return 1 /* JON_GUI_DATA_GPS_FIX_TYPE_NONE */;
      case 2:
      case "JON_GUI_DATA_GPS_FIX_TYPE_1D":
        return 2 /* JON_GUI_DATA_GPS_FIX_TYPE_1D */;
      case 3:
      case "JON_GUI_DATA_GPS_FIX_TYPE_2D":
        return 3 /* JON_GUI_DATA_GPS_FIX_TYPE_2D */;
      case 4:
      case "JON_GUI_DATA_GPS_FIX_TYPE_3D":
        return 4 /* JON_GUI_DATA_GPS_FIX_TYPE_3D */;
      case 5:
      case "JON_GUI_DATA_GPS_FIX_TYPE_MANUAL":
        return 5 /* JON_GUI_DATA_GPS_FIX_TYPE_MANUAL */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataGpsFixTypeToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_GPS_FIX_TYPE_UNSPECIFIED */:
        return "JON_GUI_DATA_GPS_FIX_TYPE_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_GPS_FIX_TYPE_NONE */:
        return "JON_GUI_DATA_GPS_FIX_TYPE_NONE";
      case 2 /* JON_GUI_DATA_GPS_FIX_TYPE_1D */:
        return "JON_GUI_DATA_GPS_FIX_TYPE_1D";
      case 3 /* JON_GUI_DATA_GPS_FIX_TYPE_2D */:
        return "JON_GUI_DATA_GPS_FIX_TYPE_2D";
      case 4 /* JON_GUI_DATA_GPS_FIX_TYPE_3D */:
        return "JON_GUI_DATA_GPS_FIX_TYPE_3D";
      case 5 /* JON_GUI_DATA_GPS_FIX_TYPE_MANUAL */:
        return "JON_GUI_DATA_GPS_FIX_TYPE_MANUAL";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataRotaryDirectionFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_ROTARY_DIRECTION_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_ROTARY_DIRECTION_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_ROTARY_DIRECTION_CLOCKWISE":
        return 1 /* JON_GUI_DATA_ROTARY_DIRECTION_CLOCKWISE */;
      case 2:
      case "JON_GUI_DATA_ROTARY_DIRECTION_COUNTER_CLOCKWISE":
        return 2 /* JON_GUI_DATA_ROTARY_DIRECTION_COUNTER_CLOCKWISE */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataRotaryDirectionToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_ROTARY_DIRECTION_UNSPECIFIED */:
        return "JON_GUI_DATA_ROTARY_DIRECTION_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_ROTARY_DIRECTION_CLOCKWISE */:
        return "JON_GUI_DATA_ROTARY_DIRECTION_CLOCKWISE";
      case 2 /* JON_GUI_DATA_ROTARY_DIRECTION_COUNTER_CLOCKWISE */:
        return "JON_GUI_DATA_ROTARY_DIRECTION_COUNTER_CLOCKWISE";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataLrfScanModesFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_LRF_SCAN_MODE_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_LRF_SCAN_MODE_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_LRF_SCAN_MODE_1_HZ_CONTINUOUS":
        return 1 /* JON_GUI_DATA_LRF_SCAN_MODE_1_HZ_CONTINUOUS */;
      case 2:
      case "JON_GUI_DATA_LRF_SCAN_MODE_4_HZ_CONTINUOUS":
        return 2 /* JON_GUI_DATA_LRF_SCAN_MODE_4_HZ_CONTINUOUS */;
      case 3:
      case "JON_GUI_DATA_LRF_SCAN_MODE_10_HZ_CONTINUOUS":
        return 3 /* JON_GUI_DATA_LRF_SCAN_MODE_10_HZ_CONTINUOUS */;
      case 4:
      case "JON_GUI_DATA_LRF_SCAN_MODE_20_HZ_CONTINUOUS":
        return 4 /* JON_GUI_DATA_LRF_SCAN_MODE_20_HZ_CONTINUOUS */;
      case 5:
      case "JON_GUI_DATA_LRF_SCAN_MODE_100_HZ_CONTINUOUS":
        return 5 /* JON_GUI_DATA_LRF_SCAN_MODE_100_HZ_CONTINUOUS */;
      case 6:
      case "JON_GUI_DATA_LRF_SCAN_MODE_200_HZ_CONTINUOUS":
        return 6 /* JON_GUI_DATA_LRF_SCAN_MODE_200_HZ_CONTINUOUS */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataLrfScanModesToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_LRF_SCAN_MODE_UNSPECIFIED */:
        return "JON_GUI_DATA_LRF_SCAN_MODE_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_LRF_SCAN_MODE_1_HZ_CONTINUOUS */:
        return "JON_GUI_DATA_LRF_SCAN_MODE_1_HZ_CONTINUOUS";
      case 2 /* JON_GUI_DATA_LRF_SCAN_MODE_4_HZ_CONTINUOUS */:
        return "JON_GUI_DATA_LRF_SCAN_MODE_4_HZ_CONTINUOUS";
      case 3 /* JON_GUI_DATA_LRF_SCAN_MODE_10_HZ_CONTINUOUS */:
        return "JON_GUI_DATA_LRF_SCAN_MODE_10_HZ_CONTINUOUS";
      case 4 /* JON_GUI_DATA_LRF_SCAN_MODE_20_HZ_CONTINUOUS */:
        return "JON_GUI_DATA_LRF_SCAN_MODE_20_HZ_CONTINUOUS";
      case 5 /* JON_GUI_DATA_LRF_SCAN_MODE_100_HZ_CONTINUOUS */:
        return "JON_GUI_DATA_LRF_SCAN_MODE_100_HZ_CONTINUOUS";
      case 6 /* JON_GUI_DATA_LRF_SCAN_MODE_200_HZ_CONTINUOUS */:
        return "JON_GUI_DATA_LRF_SCAN_MODE_200_HZ_CONTINUOUS";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataCompassCalibrateStatusFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_NOT_CALIBRATING":
        return 1 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_NOT_CALIBRATING */;
      case 2:
      case "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_CALIBRATING_SHORT":
        return 2 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_CALIBRATING_SHORT */;
      case 3:
      case "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_CALIBRATING_LONG":
        return 3 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_CALIBRATING_LONG */;
      case 4:
      case "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_FINISHED":
        return 4 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_FINISHED */;
      case 5:
      case "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_ERROR":
        return 5 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_ERROR */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataCompassCalibrateStatusToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_UNSPECIFIED */:
        return "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_NOT_CALIBRATING */:
        return "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_NOT_CALIBRATING";
      case 2 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_CALIBRATING_SHORT */:
        return "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_CALIBRATING_SHORT";
      case 3 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_CALIBRATING_LONG */:
        return "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_CALIBRATING_LONG";
      case 4 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_FINISHED */:
        return "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_FINISHED";
      case 5 /* JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_ERROR */:
        return "JON_GUI_DATA_COMPASS_CALIBRATE_STATUS_ERROR";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataEnvironmentWeatherConditionFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_ENVIRONMENT_WEATHER_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_ENVIRONMENT_WEATHER_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_ENVIRONMENT_WEATHER_CLEAR":
        return 1 /* JON_GUI_DATA_ENVIRONMENT_WEATHER_CLEAR */;
      case 2:
      case "JON_GUI_DATA_ENVIRONMENT_WEATHER_CLOUDY":
        return 2 /* JON_GUI_DATA_ENVIRONMENT_WEATHER_CLOUDY */;
      case 3:
      case "JON_GUI_DATA_ENVIRONMENT_WEATHER_FOGGY":
        return 3 /* JON_GUI_DATA_ENVIRONMENT_WEATHER_FOGGY */;
      case 4:
      case "JON_GUI_DATA_ENVIRONMENT_WEATHER_HAZY":
        return 4 /* JON_GUI_DATA_ENVIRONMENT_WEATHER_HAZY */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataEnvironmentWeatherConditionToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_ENVIRONMENT_WEATHER_UNSPECIFIED */:
        return "JON_GUI_DATA_ENVIRONMENT_WEATHER_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_ENVIRONMENT_WEATHER_CLEAR */:
        return "JON_GUI_DATA_ENVIRONMENT_WEATHER_CLEAR";
      case 2 /* JON_GUI_DATA_ENVIRONMENT_WEATHER_CLOUDY */:
        return "JON_GUI_DATA_ENVIRONMENT_WEATHER_CLOUDY";
      case 3 /* JON_GUI_DATA_ENVIRONMENT_WEATHER_FOGGY */:
        return "JON_GUI_DATA_ENVIRONMENT_WEATHER_FOGGY";
      case 4 /* JON_GUI_DATA_ENVIRONMENT_WEATHER_HAZY */:
        return "JON_GUI_DATA_ENVIRONMENT_WEATHER_HAZY";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataEnvironmentLightingConditionFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHTING_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_ENVIRONMENT_LIGHTING_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHTING_DAY":
        return 1 /* JON_GUI_DATA_ENVIRONMENT_LIGHTING_DAY */;
      case 2:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHTING_NIGHT":
        return 2 /* JON_GUI_DATA_ENVIRONMENT_LIGHTING_NIGHT */;
      case 3:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHTING_DUSK":
        return 3 /* JON_GUI_DATA_ENVIRONMENT_LIGHTING_DUSK */;
      case 4:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHTING_DAWN":
        return 4 /* JON_GUI_DATA_ENVIRONMENT_LIGHTING_DAWN */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataEnvironmentLightingConditionToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_ENVIRONMENT_LIGHTING_UNSPECIFIED */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHTING_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_ENVIRONMENT_LIGHTING_DAY */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHTING_DAY";
      case 2 /* JON_GUI_DATA_ENVIRONMENT_LIGHTING_NIGHT */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHTING_NIGHT";
      case 3 /* JON_GUI_DATA_ENVIRONMENT_LIGHTING_DUSK */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHTING_DUSK";
      case 4 /* JON_GUI_DATA_ENVIRONMENT_LIGHTING_DAWN */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHTING_DAWN";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataEnvironmentPrecipitationTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_ENVIRONMENT_PRECIP_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_ENVIRONMENT_PRECIP_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_ENVIRONMENT_PRECIP_NONE":
        return 1 /* JON_GUI_DATA_ENVIRONMENT_PRECIP_NONE */;
      case 2:
      case "JON_GUI_DATA_ENVIRONMENT_PRECIP_RAIN":
        return 2 /* JON_GUI_DATA_ENVIRONMENT_PRECIP_RAIN */;
      case 3:
      case "JON_GUI_DATA_ENVIRONMENT_PRECIP_SNOW":
        return 3 /* JON_GUI_DATA_ENVIRONMENT_PRECIP_SNOW */;
      case 4:
      case "JON_GUI_DATA_ENVIRONMENT_PRECIP_SLEET":
        return 4 /* JON_GUI_DATA_ENVIRONMENT_PRECIP_SLEET */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataEnvironmentPrecipitationTypeToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_ENVIRONMENT_PRECIP_UNSPECIFIED */:
        return "JON_GUI_DATA_ENVIRONMENT_PRECIP_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_ENVIRONMENT_PRECIP_NONE */:
        return "JON_GUI_DATA_ENVIRONMENT_PRECIP_NONE";
      case 2 /* JON_GUI_DATA_ENVIRONMENT_PRECIP_RAIN */:
        return "JON_GUI_DATA_ENVIRONMENT_PRECIP_RAIN";
      case 3 /* JON_GUI_DATA_ENVIRONMENT_PRECIP_SNOW */:
        return "JON_GUI_DATA_ENVIRONMENT_PRECIP_SNOW";
      case 4 /* JON_GUI_DATA_ENVIRONMENT_PRECIP_SLEET */:
        return "JON_GUI_DATA_ENVIRONMENT_PRECIP_SLEET";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataEnvironmentGroundConditionFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_ENVIRONMENT_GROUND_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_ENVIRONMENT_GROUND_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_ENVIRONMENT_GROUND_DRY":
        return 1 /* JON_GUI_DATA_ENVIRONMENT_GROUND_DRY */;
      case 2:
      case "JON_GUI_DATA_ENVIRONMENT_GROUND_WET":
        return 2 /* JON_GUI_DATA_ENVIRONMENT_GROUND_WET */;
      case 3:
      case "JON_GUI_DATA_ENVIRONMENT_GROUND_SNOWY":
        return 3 /* JON_GUI_DATA_ENVIRONMENT_GROUND_SNOWY */;
      case 4:
      case "JON_GUI_DATA_ENVIRONMENT_GROUND_ICY":
        return 4 /* JON_GUI_DATA_ENVIRONMENT_GROUND_ICY */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataEnvironmentGroundConditionToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_ENVIRONMENT_GROUND_UNSPECIFIED */:
        return "JON_GUI_DATA_ENVIRONMENT_GROUND_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_ENVIRONMENT_GROUND_DRY */:
        return "JON_GUI_DATA_ENVIRONMENT_GROUND_DRY";
      case 2 /* JON_GUI_DATA_ENVIRONMENT_GROUND_WET */:
        return "JON_GUI_DATA_ENVIRONMENT_GROUND_WET";
      case 3 /* JON_GUI_DATA_ENVIRONMENT_GROUND_SNOWY */:
        return "JON_GUI_DATA_ENVIRONMENT_GROUND_SNOWY";
      case 4 /* JON_GUI_DATA_ENVIRONMENT_GROUND_ICY */:
        return "JON_GUI_DATA_ENVIRONMENT_GROUND_ICY";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataEnvironmentOpticalVisibilityFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_HIGH_CONTRAST":
        return 1 /* JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_HIGH_CONTRAST */;
      case 2:
      case "JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_LOW_CONTRAST":
        return 2 /* JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_LOW_CONTRAST */;
      case 3:
      case "JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_GLARE":
        return 3 /* JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_GLARE */;
      case 4:
      case "JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_SHADOW":
        return 4 /* JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_SHADOW */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataEnvironmentOpticalVisibilityToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_UNSPECIFIED */:
        return "JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_HIGH_CONTRAST */:
        return "JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_HIGH_CONTRAST";
      case 2 /* JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_LOW_CONTRAST */:
        return "JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_LOW_CONTRAST";
      case 3 /* JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_GLARE */:
        return "JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_GLARE";
      case 4 /* JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_SHADOW */:
        return "JON_GUI_DATA_ENVIRONMENT_OPTICAL_VISIBILITY_SHADOW";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataEnvironmentThermalConditionFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_ENVIRONMENT_THERMAL_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_ENVIRONMENT_THERMAL_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_ENVIRONMENT_THERMAL_HIGH_HEAT_CONTRAST":
        return 1 /* JON_GUI_DATA_ENVIRONMENT_THERMAL_HIGH_HEAT_CONTRAST */;
      case 2:
      case "JON_GUI_DATA_ENVIRONMENT_THERMAL_LOW_HEAT_CONTRAST":
        return 2 /* JON_GUI_DATA_ENVIRONMENT_THERMAL_LOW_HEAT_CONTRAST */;
      case 3:
      case "JON_GUI_DATA_ENVIRONMENT_THERMAL_AMBIENT_WARM":
        return 3 /* JON_GUI_DATA_ENVIRONMENT_THERMAL_AMBIENT_WARM */;
      case 4:
      case "JON_GUI_DATA_ENVIRONMENT_THERMAL_AMBIENT_COLD":
        return 4 /* JON_GUI_DATA_ENVIRONMENT_THERMAL_AMBIENT_COLD */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataEnvironmentThermalConditionToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_ENVIRONMENT_THERMAL_UNSPECIFIED */:
        return "JON_GUI_DATA_ENVIRONMENT_THERMAL_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_ENVIRONMENT_THERMAL_HIGH_HEAT_CONTRAST */:
        return "JON_GUI_DATA_ENVIRONMENT_THERMAL_HIGH_HEAT_CONTRAST";
      case 2 /* JON_GUI_DATA_ENVIRONMENT_THERMAL_LOW_HEAT_CONTRAST */:
        return "JON_GUI_DATA_ENVIRONMENT_THERMAL_LOW_HEAT_CONTRAST";
      case 3 /* JON_GUI_DATA_ENVIRONMENT_THERMAL_AMBIENT_WARM */:
        return "JON_GUI_DATA_ENVIRONMENT_THERMAL_AMBIENT_WARM";
      case 4 /* JON_GUI_DATA_ENVIRONMENT_THERMAL_AMBIENT_COLD */:
        return "JON_GUI_DATA_ENVIRONMENT_THERMAL_AMBIENT_COLD";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataEnvironmentNetworkStatusFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_ENVIRONMENT_NETWORK_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_ENVIRONMENT_NETWORK_DISCONNECTED":
        return 1 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_DISCONNECTED */;
      case 2:
      case "JON_GUI_DATA_ENVIRONMENT_NETWORK_FLAKY":
        return 2 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_FLAKY */;
      case 3:
      case "JON_GUI_DATA_ENVIRONMENT_NETWORK_LOW_BANDWIDTH":
        return 3 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_LOW_BANDWIDTH */;
      case 4:
      case "JON_GUI_DATA_ENVIRONMENT_NETWORK_MEDIUM_BANDWIDTH":
        return 4 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_MEDIUM_BANDWIDTH */;
      case 5:
      case "JON_GUI_DATA_ENVIRONMENT_NETWORK_LAN":
        return 5 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_LAN */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataEnvironmentNetworkStatusToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_UNSPECIFIED */:
        return "JON_GUI_DATA_ENVIRONMENT_NETWORK_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_DISCONNECTED */:
        return "JON_GUI_DATA_ENVIRONMENT_NETWORK_DISCONNECTED";
      case 2 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_FLAKY */:
        return "JON_GUI_DATA_ENVIRONMENT_NETWORK_FLAKY";
      case 3 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_LOW_BANDWIDTH */:
        return "JON_GUI_DATA_ENVIRONMENT_NETWORK_LOW_BANDWIDTH";
      case 4 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_MEDIUM_BANDWIDTH */:
        return "JON_GUI_DATA_ENVIRONMENT_NETWORK_MEDIUM_BANDWIDTH";
      case 5 /* JON_GUI_DATA_ENVIRONMENT_NETWORK_LAN */:
        return "JON_GUI_DATA_ENVIRONMENT_NETWORK_LAN";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataEnvironmentLightSourceFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_NONE":
        return 1 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_NONE */;
      case 2:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_FULL_MOON":
        return 2 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_FULL_MOON */;
      case 3:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_STARRY_NIGHT":
        return 3 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_STARRY_NIGHT */;
      case 4:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_ABOVE":
        return 4 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_ABOVE */;
      case 5:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_FRONT":
        return 5 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_FRONT */;
      case 6:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_BEHIND":
        return 6 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_BEHIND */;
      case 7:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_DIFFUSED_STRONG":
        return 7 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_DIFFUSED_STRONG */;
      case 8:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_DIFFUSED_WEAK":
        return 8 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_DIFFUSED_WEAK */;
      case 9:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_PROJECTOR":
        return 9 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_PROJECTOR */;
      case 10:
      case "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_LIT_TARGET":
        return 10 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_LIT_TARGET */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataEnvironmentLightSourceToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_UNSPECIFIED */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_NONE */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_NONE";
      case 2 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_FULL_MOON */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_FULL_MOON";
      case 3 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_STARRY_NIGHT */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_STARRY_NIGHT";
      case 4 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_ABOVE */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_ABOVE";
      case 5 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_FRONT */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_FRONT";
      case 6 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_BEHIND */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_SUN_BEHIND";
      case 7 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_DIFFUSED_STRONG */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_DIFFUSED_STRONG";
      case 8 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_DIFFUSED_WEAK */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_DIFFUSED_WEAK";
      case 9 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_PROJECTOR */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_PROJECTOR";
      case 10 /* JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_LIT_TARGET */:
        return "JON_GUI_DATA_ENVIRONMENT_LIGHT_SOURCE_LIT_TARGET";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataRotaryModeFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_ROTARY_MODE_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_ROTARY_MODE_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_ROTARY_MODE_INITIALIZATION":
        return 1 /* JON_GUI_DATA_ROTARY_MODE_INITIALIZATION */;
      case 2:
      case "JON_GUI_DATA_ROTARY_MODE_SPEED":
        return 2 /* JON_GUI_DATA_ROTARY_MODE_SPEED */;
      case 3:
      case "JON_GUI_DATA_ROTARY_MODE_POSITION":
        return 3 /* JON_GUI_DATA_ROTARY_MODE_POSITION */;
      case 4:
      case "JON_GUI_DATA_ROTARY_MODE_STABILIZATION":
        return 4 /* JON_GUI_DATA_ROTARY_MODE_STABILIZATION */;
      case 5:
      case "JON_GUI_DATA_ROTARY_MODE_TARGETING":
        return 5 /* JON_GUI_DATA_ROTARY_MODE_TARGETING */;
      case 6:
      case "JON_GUI_DATA_ROTARY_MODE_VIDEO_TRACKER":
        return 6 /* JON_GUI_DATA_ROTARY_MODE_VIDEO_TRACKER */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataRotaryModeToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_ROTARY_MODE_UNSPECIFIED */:
        return "JON_GUI_DATA_ROTARY_MODE_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_ROTARY_MODE_INITIALIZATION */:
        return "JON_GUI_DATA_ROTARY_MODE_INITIALIZATION";
      case 2 /* JON_GUI_DATA_ROTARY_MODE_SPEED */:
        return "JON_GUI_DATA_ROTARY_MODE_SPEED";
      case 3 /* JON_GUI_DATA_ROTARY_MODE_POSITION */:
        return "JON_GUI_DATA_ROTARY_MODE_POSITION";
      case 4 /* JON_GUI_DATA_ROTARY_MODE_STABILIZATION */:
        return "JON_GUI_DATA_ROTARY_MODE_STABILIZATION";
      case 5 /* JON_GUI_DATA_ROTARY_MODE_TARGETING */:
        return "JON_GUI_DATA_ROTARY_MODE_TARGETING";
      case 6 /* JON_GUI_DATA_ROTARY_MODE_VIDEO_TRACKER */:
        return "JON_GUI_DATA_ROTARY_MODE_VIDEO_TRACKER";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function jonGuiDataPowerCanDeviceFromJSON(object) {
    switch (object) {
      case 0:
      case "JON_GUI_DATA_POWER_CAN_DEVICE_UNSPECIFIED":
        return 0 /* JON_GUI_DATA_POWER_CAN_DEVICE_UNSPECIFIED */;
      case 1:
      case "JON_GUI_DATA_POWER_CAN_DEVICE_NONE":
        return 1 /* JON_GUI_DATA_POWER_CAN_DEVICE_NONE */;
      case 2:
      case "JON_GUI_DATA_POWER_CAN_DEVICE_COMPASS":
        return 2 /* JON_GUI_DATA_POWER_CAN_DEVICE_COMPASS */;
      case 3:
      case "JON_GUI_DATA_POWER_CAN_DEVICE_GPS":
        return 3 /* JON_GUI_DATA_POWER_CAN_DEVICE_GPS */;
      case 4:
      case "JON_GUI_DATA_POWER_CAN_DEVICE_CAM_DAY":
        return 4 /* JON_GUI_DATA_POWER_CAN_DEVICE_CAM_DAY */;
      case 5:
      case "JON_GUI_DATA_POWER_CAN_DEVICE_CAM_HEAT":
        return 5 /* JON_GUI_DATA_POWER_CAN_DEVICE_CAM_HEAT */;
      case 6:
      case "JON_GUI_DATA_POWER_CAN_DEVICE_LRF":
        return 6 /* JON_GUI_DATA_POWER_CAN_DEVICE_LRF */;
      case -1:
      case "UNRECOGNIZED":
      default:
        return -1 /* UNRECOGNIZED */;
    }
  }
  function jonGuiDataPowerCanDeviceToJSON(object) {
    switch (object) {
      case 0 /* JON_GUI_DATA_POWER_CAN_DEVICE_UNSPECIFIED */:
        return "JON_GUI_DATA_POWER_CAN_DEVICE_UNSPECIFIED";
      case 1 /* JON_GUI_DATA_POWER_CAN_DEVICE_NONE */:
        return "JON_GUI_DATA_POWER_CAN_DEVICE_NONE";
      case 2 /* JON_GUI_DATA_POWER_CAN_DEVICE_COMPASS */:
        return "JON_GUI_DATA_POWER_CAN_DEVICE_COMPASS";
      case 3 /* JON_GUI_DATA_POWER_CAN_DEVICE_GPS */:
        return "JON_GUI_DATA_POWER_CAN_DEVICE_GPS";
      case 4 /* JON_GUI_DATA_POWER_CAN_DEVICE_CAM_DAY */:
        return "JON_GUI_DATA_POWER_CAN_DEVICE_CAM_DAY";
      case 5 /* JON_GUI_DATA_POWER_CAN_DEVICE_CAM_HEAT */:
        return "JON_GUI_DATA_POWER_CAN_DEVICE_CAM_HEAT";
      case 6 /* JON_GUI_DATA_POWER_CAN_DEVICE_LRF */:
        return "JON_GUI_DATA_POWER_CAN_DEVICE_LRF";
      case -1 /* UNRECOGNIZED */:
      default:
        return "UNRECOGNIZED";
    }
  }
  function createBaseJonGuiDataMeteo() {
    return { temperature: 0, humidity: 0, pressure: 0 };
  }
  var JonGuiDataMeteo = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      if (message.temperature !== 0) {
        writer.uint32(13).float(message.temperature);
      }
      if (message.humidity !== 0) {
        writer.uint32(21).float(message.humidity);
      }
      if (message.pressure !== 0) {
        writer.uint32(29).float(message.pressure);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal.default.Reader ? input2 : import_minimal.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataMeteo();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.temperature = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.humidity = reader.float();
            continue;
          case 3:
            if (tag !== 29) {
              break;
            }
            message.pressure = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
        humidity: isSet(object.humidity) ? globalThis.Number(object.humidity) : 0,
        pressure: isSet(object.pressure) ? globalThis.Number(object.pressure) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.temperature !== 0) {
        obj.temperature = message.temperature;
      }
      if (message.humidity !== 0) {
        obj.humidity = message.humidity;
      }
      if (message.pressure !== 0) {
        obj.pressure = message.pressure;
      }
      return obj;
    },
    create(base) {
      return JonGuiDataMeteo.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataMeteo();
      message.temperature = object.temperature ?? 0;
      message.humidity = object.humidity ?? 0;
      message.pressure = object.pressure ?? 0;
      return message;
    }
  };
  function isSet(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_cmd_gps.ts
  var import_minimal2 = __toESM(require_minimal2());
  function createBaseRoot() {
    return {
      start: void 0,
      stop: void 0,
      setRefreshRate: void 0,
      setManualPosition: void 0,
      setUseManualPosition: void 0,
      getMeteo: void 0
    };
  }
  var Root = {
    encode(message, writer = import_minimal2.default.Writer.create()) {
      if (message.start !== void 0) {
        Start.encode(message.start, writer.uint32(10).fork()).ldelim();
      }
      if (message.stop !== void 0) {
        Stop.encode(message.stop, writer.uint32(18).fork()).ldelim();
      }
      if (message.setRefreshRate !== void 0) {
        SetRefreshRate.encode(message.setRefreshRate, writer.uint32(26).fork()).ldelim();
      }
      if (message.setManualPosition !== void 0) {
        SetManualPosition.encode(message.setManualPosition, writer.uint32(34).fork()).ldelim();
      }
      if (message.setUseManualPosition !== void 0) {
        SetUseManualPosition.encode(message.setUseManualPosition, writer.uint32(42).fork()).ldelim();
      }
      if (message.getMeteo !== void 0) {
        GetMeteo.encode(message.getMeteo, writer.uint32(50).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal2.default.Reader ? input2 : import_minimal2.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.start = Start.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.stop = Stop.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.setRefreshRate = SetRefreshRate.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.setManualPosition = SetManualPosition.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.setUseManualPosition = SetUseManualPosition.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.getMeteo = GetMeteo.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        start: isSet2(object.start) ? Start.fromJSON(object.start) : void 0,
        stop: isSet2(object.stop) ? Stop.fromJSON(object.stop) : void 0,
        setRefreshRate: isSet2(object.setRefreshRate) ? SetRefreshRate.fromJSON(object.setRefreshRate) : void 0,
        setManualPosition: isSet2(object.setManualPosition) ? SetManualPosition.fromJSON(object.setManualPosition) : void 0,
        setUseManualPosition: isSet2(object.setUseManualPosition) ? SetUseManualPosition.fromJSON(object.setUseManualPosition) : void 0,
        getMeteo: isSet2(object.getMeteo) ? GetMeteo.fromJSON(object.getMeteo) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.start !== void 0) {
        obj.start = Start.toJSON(message.start);
      }
      if (message.stop !== void 0) {
        obj.stop = Stop.toJSON(message.stop);
      }
      if (message.setRefreshRate !== void 0) {
        obj.setRefreshRate = SetRefreshRate.toJSON(message.setRefreshRate);
      }
      if (message.setManualPosition !== void 0) {
        obj.setManualPosition = SetManualPosition.toJSON(message.setManualPosition);
      }
      if (message.setUseManualPosition !== void 0) {
        obj.setUseManualPosition = SetUseManualPosition.toJSON(message.setUseManualPosition);
      }
      if (message.getMeteo !== void 0) {
        obj.getMeteo = GetMeteo.toJSON(message.getMeteo);
      }
      return obj;
    },
    create(base) {
      return Root.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot();
      message.start = object.start !== void 0 && object.start !== null ? Start.fromPartial(object.start) : void 0;
      message.stop = object.stop !== void 0 && object.stop !== null ? Stop.fromPartial(object.stop) : void 0;
      message.setRefreshRate = object.setRefreshRate !== void 0 && object.setRefreshRate !== null ? SetRefreshRate.fromPartial(object.setRefreshRate) : void 0;
      message.setManualPosition = object.setManualPosition !== void 0 && object.setManualPosition !== null ? SetManualPosition.fromPartial(object.setManualPosition) : void 0;
      message.setUseManualPosition = object.setUseManualPosition !== void 0 && object.setUseManualPosition !== null ? SetUseManualPosition.fromPartial(object.setUseManualPosition) : void 0;
      message.getMeteo = object.getMeteo !== void 0 && object.getMeteo !== null ? GetMeteo.fromPartial(object.getMeteo) : void 0;
      return message;
    }
  };
  function createBaseStart() {
    return {};
  }
  var Start = {
    encode(_5, writer = import_minimal2.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal2.default.Reader ? input2 : import_minimal2.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStart();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Start.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStart();
      return message;
    }
  };
  function createBaseStop() {
    return {};
  }
  var Stop = {
    encode(_5, writer = import_minimal2.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal2.default.Reader ? input2 : import_minimal2.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStop();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Stop.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStop();
      return message;
    }
  };
  function createBaseGetMeteo() {
    return {};
  }
  var GetMeteo = {
    encode(_5, writer = import_minimal2.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal2.default.Reader ? input2 : import_minimal2.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGetMeteo();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return GetMeteo.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseGetMeteo();
      return message;
    }
  };
  function createBaseSetRefreshRate() {
    return { value: 0 };
  }
  var SetRefreshRate = {
    encode(message, writer = import_minimal2.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).uint32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal2.default.Reader ? input2 : import_minimal2.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetRefreshRate();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.uint32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet2(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = Math.round(message.value);
      }
      return obj;
    },
    create(base) {
      return SetRefreshRate.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetRefreshRate();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetUseManualPosition() {
    return { flag: false };
  }
  var SetUseManualPosition = {
    encode(message, writer = import_minimal2.default.Writer.create()) {
      if (message.flag !== false) {
        writer.uint32(8).bool(message.flag);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal2.default.Reader ? input2 : import_minimal2.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetUseManualPosition();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.flag = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { flag: isSet2(object.flag) ? globalThis.Boolean(object.flag) : false };
    },
    toJSON(message) {
      const obj = {};
      if (message.flag !== false) {
        obj.flag = message.flag;
      }
      return obj;
    },
    create(base) {
      return SetUseManualPosition.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetUseManualPosition();
      message.flag = object.flag ?? false;
      return message;
    }
  };
  function createBaseSetManualPosition() {
    return { latitude: 0, longitude: 0, altitude: 0 };
  }
  var SetManualPosition = {
    encode(message, writer = import_minimal2.default.Writer.create()) {
      if (message.latitude !== 0) {
        writer.uint32(13).float(message.latitude);
      }
      if (message.longitude !== 0) {
        writer.uint32(21).float(message.longitude);
      }
      if (message.altitude !== 0) {
        writer.uint32(29).float(message.altitude);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal2.default.Reader ? input2 : import_minimal2.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetManualPosition();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.latitude = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.longitude = reader.float();
            continue;
          case 3:
            if (tag !== 29) {
              break;
            }
            message.altitude = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        latitude: isSet2(object.latitude) ? globalThis.Number(object.latitude) : 0,
        longitude: isSet2(object.longitude) ? globalThis.Number(object.longitude) : 0,
        altitude: isSet2(object.altitude) ? globalThis.Number(object.altitude) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.latitude !== 0) {
        obj.latitude = message.latitude;
      }
      if (message.longitude !== 0) {
        obj.longitude = message.longitude;
      }
      if (message.altitude !== 0) {
        obj.altitude = message.altitude;
      }
      return obj;
    },
    create(base) {
      return SetManualPosition.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetManualPosition();
      message.latitude = object.latitude ?? 0;
      message.longitude = object.longitude ?? 0;
      message.altitude = object.altitude ?? 0;
      return message;
    }
  };
  function isSet2(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_cmd_osd.ts
  var import_minimal3 = __toESM(require_minimal2());
  function createBaseRoot2() {
    return {
      showDefaultScreen: void 0,
      showLrfMeasureScreen: void 0,
      showLrfResultScreen: void 0,
      showLrfResultSimplifiedScreen: void 0
    };
  }
  var Root2 = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      if (message.showDefaultScreen !== void 0) {
        ShowDefaultScreen.encode(message.showDefaultScreen, writer.uint32(10).fork()).ldelim();
      }
      if (message.showLrfMeasureScreen !== void 0) {
        ShowLRFMeasureScreen.encode(message.showLrfMeasureScreen, writer.uint32(18).fork()).ldelim();
      }
      if (message.showLrfResultScreen !== void 0) {
        ShowLRFResultScreen.encode(message.showLrfResultScreen, writer.uint32(26).fork()).ldelim();
      }
      if (message.showLrfResultSimplifiedScreen !== void 0) {
        ShowLRFResultSimplifiedScreen.encode(message.showLrfResultSimplifiedScreen, writer.uint32(34).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal3.default.Reader ? input2 : import_minimal3.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.showDefaultScreen = ShowDefaultScreen.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.showLrfMeasureScreen = ShowLRFMeasureScreen.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.showLrfResultScreen = ShowLRFResultScreen.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.showLrfResultSimplifiedScreen = ShowLRFResultSimplifiedScreen.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        showDefaultScreen: isSet3(object.showDefaultScreen) ? ShowDefaultScreen.fromJSON(object.showDefaultScreen) : void 0,
        showLrfMeasureScreen: isSet3(object.showLrfMeasureScreen) ? ShowLRFMeasureScreen.fromJSON(object.showLrfMeasureScreen) : void 0,
        showLrfResultScreen: isSet3(object.showLrfResultScreen) ? ShowLRFResultScreen.fromJSON(object.showLrfResultScreen) : void 0,
        showLrfResultSimplifiedScreen: isSet3(object.showLrfResultSimplifiedScreen) ? ShowLRFResultSimplifiedScreen.fromJSON(object.showLrfResultSimplifiedScreen) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.showDefaultScreen !== void 0) {
        obj.showDefaultScreen = ShowDefaultScreen.toJSON(message.showDefaultScreen);
      }
      if (message.showLrfMeasureScreen !== void 0) {
        obj.showLrfMeasureScreen = ShowLRFMeasureScreen.toJSON(message.showLrfMeasureScreen);
      }
      if (message.showLrfResultScreen !== void 0) {
        obj.showLrfResultScreen = ShowLRFResultScreen.toJSON(message.showLrfResultScreen);
      }
      if (message.showLrfResultSimplifiedScreen !== void 0) {
        obj.showLrfResultSimplifiedScreen = ShowLRFResultSimplifiedScreen.toJSON(message.showLrfResultSimplifiedScreen);
      }
      return obj;
    },
    create(base) {
      return Root2.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot2();
      message.showDefaultScreen = object.showDefaultScreen !== void 0 && object.showDefaultScreen !== null ? ShowDefaultScreen.fromPartial(object.showDefaultScreen) : void 0;
      message.showLrfMeasureScreen = object.showLrfMeasureScreen !== void 0 && object.showLrfMeasureScreen !== null ? ShowLRFMeasureScreen.fromPartial(object.showLrfMeasureScreen) : void 0;
      message.showLrfResultScreen = object.showLrfResultScreen !== void 0 && object.showLrfResultScreen !== null ? ShowLRFResultScreen.fromPartial(object.showLrfResultScreen) : void 0;
      message.showLrfResultSimplifiedScreen = object.showLrfResultSimplifiedScreen !== void 0 && object.showLrfResultSimplifiedScreen !== null ? ShowLRFResultSimplifiedScreen.fromPartial(object.showLrfResultSimplifiedScreen) : void 0;
      return message;
    }
  };
  function createBaseShowDefaultScreen() {
    return {};
  }
  var ShowDefaultScreen = {
    encode(_5, writer = import_minimal3.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal3.default.Reader ? input2 : import_minimal3.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseShowDefaultScreen();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return ShowDefaultScreen.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseShowDefaultScreen();
      return message;
    }
  };
  function createBaseShowLRFMeasureScreen() {
    return {};
  }
  var ShowLRFMeasureScreen = {
    encode(_5, writer = import_minimal3.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal3.default.Reader ? input2 : import_minimal3.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseShowLRFMeasureScreen();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return ShowLRFMeasureScreen.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseShowLRFMeasureScreen();
      return message;
    }
  };
  function createBaseShowLRFResultScreen() {
    return {};
  }
  var ShowLRFResultScreen = {
    encode(_5, writer = import_minimal3.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal3.default.Reader ? input2 : import_minimal3.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseShowLRFResultScreen();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return ShowLRFResultScreen.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseShowLRFResultScreen();
      return message;
    }
  };
  function createBaseShowLRFResultSimplifiedScreen() {
    return {};
  }
  var ShowLRFResultSimplifiedScreen = {
    encode(_5, writer = import_minimal3.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal3.default.Reader ? input2 : import_minimal3.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseShowLRFResultSimplifiedScreen();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return ShowLRFResultSimplifiedScreen.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseShowLRFResultSimplifiedScreen();
      return message;
    }
  };
  function isSet3(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/index.cmd.GeoTest.ts
  var index_cmd_GeoTest_exports = {};
  __export(index_cmd_GeoTest_exports, {
    Root: () => Root3
  });

  // frontend/ts/proto/jon/jon_shared_cmd_geo_test.ts
  var import_minimal4 = __toESM(require_minimal2());
  function createBaseRoot3() {
    return { longitude: 0, latitude: 0, altitude: 0, range: 0, azimuth: 0, elevation: 0, bank: 0 };
  }
  var Root3 = {
    encode(message, writer = import_minimal4.default.Writer.create()) {
      if (message.longitude !== 0) {
        writer.uint32(9).double(message.longitude);
      }
      if (message.latitude !== 0) {
        writer.uint32(17).double(message.latitude);
      }
      if (message.altitude !== 0) {
        writer.uint32(25).double(message.altitude);
      }
      if (message.range !== 0) {
        writer.uint32(33).double(message.range);
      }
      if (message.azimuth !== 0) {
        writer.uint32(41).double(message.azimuth);
      }
      if (message.elevation !== 0) {
        writer.uint32(49).double(message.elevation);
      }
      if (message.bank !== 0) {
        writer.uint32(57).double(message.bank);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal4.default.Reader ? input2 : import_minimal4.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot3();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 9) {
              break;
            }
            message.longitude = reader.double();
            continue;
          case 2:
            if (tag !== 17) {
              break;
            }
            message.latitude = reader.double();
            continue;
          case 3:
            if (tag !== 25) {
              break;
            }
            message.altitude = reader.double();
            continue;
          case 4:
            if (tag !== 33) {
              break;
            }
            message.range = reader.double();
            continue;
          case 5:
            if (tag !== 41) {
              break;
            }
            message.azimuth = reader.double();
            continue;
          case 6:
            if (tag !== 49) {
              break;
            }
            message.elevation = reader.double();
            continue;
          case 7:
            if (tag !== 57) {
              break;
            }
            message.bank = reader.double();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        longitude: isSet4(object.longitude) ? globalThis.Number(object.longitude) : 0,
        latitude: isSet4(object.latitude) ? globalThis.Number(object.latitude) : 0,
        altitude: isSet4(object.altitude) ? globalThis.Number(object.altitude) : 0,
        range: isSet4(object.range) ? globalThis.Number(object.range) : 0,
        azimuth: isSet4(object.azimuth) ? globalThis.Number(object.azimuth) : 0,
        elevation: isSet4(object.elevation) ? globalThis.Number(object.elevation) : 0,
        bank: isSet4(object.bank) ? globalThis.Number(object.bank) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.longitude !== 0) {
        obj.longitude = message.longitude;
      }
      if (message.latitude !== 0) {
        obj.latitude = message.latitude;
      }
      if (message.altitude !== 0) {
        obj.altitude = message.altitude;
      }
      if (message.range !== 0) {
        obj.range = message.range;
      }
      if (message.azimuth !== 0) {
        obj.azimuth = message.azimuth;
      }
      if (message.elevation !== 0) {
        obj.elevation = message.elevation;
      }
      if (message.bank !== 0) {
        obj.bank = message.bank;
      }
      return obj;
    },
    create(base) {
      return Root3.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot3();
      message.longitude = object.longitude ?? 0;
      message.latitude = object.latitude ?? 0;
      message.altitude = object.altitude ?? 0;
      message.range = object.range ?? 0;
      message.azimuth = object.azimuth ?? 0;
      message.elevation = object.elevation ?? 0;
      message.bank = object.bank ?? 0;
      return message;
    }
  };
  function isSet4(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/index.cmd.RotaryPlatform.ts
  var index_cmd_RotaryPlatform_exports = {};
  __export(index_cmd_RotaryPlatform_exports, {
    Axis: () => Axis,
    Azimuth: () => Azimuth,
    Elevation: () => Elevation,
    GetMeteo: () => GetMeteo2,
    Halt: () => Halt,
    HaltAzimuth: () => HaltAzimuth,
    HaltElevation: () => HaltElevation,
    Root: () => Root4,
    RotateAzimuth: () => RotateAzimuth,
    RotateAzimuthRelative: () => RotateAzimuthRelative,
    RotateAzimuthRelativeSet: () => RotateAzimuthRelativeSet,
    RotateAzimuthTo: () => RotateAzimuthTo,
    RotateElevation: () => RotateElevation,
    RotateElevationRelative: () => RotateElevationRelative,
    RotateElevationRelativeSet: () => RotateElevationRelativeSet,
    RotateElevationTo: () => RotateElevationTo,
    RotateToGPS: () => RotateToGPS,
    SetAzimuthValue: () => SetAzimuthValue,
    SetCalculateBasePositionFromCompass: () => SetCalculateBasePositionFromCompass,
    SetElevationValue: () => SetElevationValue,
    SetMode: () => SetMode,
    SetOriginGPS: () => SetOriginGPS,
    SetPlatformAzimuth: () => SetPlatformAzimuth,
    SetPlatformBank: () => SetPlatformBank,
    SetPlatformElevation: () => SetPlatformElevation,
    Start: () => Start2,
    Stop: () => Stop2
  });

  // frontend/ts/proto/jon/jon_shared_cmd_rotary.ts
  var import_minimal5 = __toESM(require_minimal2());
  function createBaseRoot4() {
    return {
      start: void 0,
      stop: void 0,
      axis: void 0,
      setPlatformAzimuth: void 0,
      setPlatformElevation: void 0,
      setPlatformBank: void 0,
      halt: void 0,
      setCalculateBasePositionFromCompass: void 0,
      rotateToGps: void 0,
      setOriginGps: void 0,
      getMeteo: void 0,
      setMode: void 0
    };
  }
  var Root4 = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.start !== void 0) {
        Start2.encode(message.start, writer.uint32(10).fork()).ldelim();
      }
      if (message.stop !== void 0) {
        Stop2.encode(message.stop, writer.uint32(18).fork()).ldelim();
      }
      if (message.axis !== void 0) {
        Axis.encode(message.axis, writer.uint32(26).fork()).ldelim();
      }
      if (message.setPlatformAzimuth !== void 0) {
        SetPlatformAzimuth.encode(message.setPlatformAzimuth, writer.uint32(34).fork()).ldelim();
      }
      if (message.setPlatformElevation !== void 0) {
        SetPlatformElevation.encode(message.setPlatformElevation, writer.uint32(42).fork()).ldelim();
      }
      if (message.setPlatformBank !== void 0) {
        SetPlatformBank.encode(message.setPlatformBank, writer.uint32(50).fork()).ldelim();
      }
      if (message.halt !== void 0) {
        Halt.encode(message.halt, writer.uint32(58).fork()).ldelim();
      }
      if (message.setCalculateBasePositionFromCompass !== void 0) {
        SetCalculateBasePositionFromCompass.encode(message.setCalculateBasePositionFromCompass, writer.uint32(66).fork()).ldelim();
      }
      if (message.rotateToGps !== void 0) {
        RotateToGPS.encode(message.rotateToGps, writer.uint32(74).fork()).ldelim();
      }
      if (message.setOriginGps !== void 0) {
        SetOriginGPS.encode(message.setOriginGps, writer.uint32(82).fork()).ldelim();
      }
      if (message.getMeteo !== void 0) {
        GetMeteo2.encode(message.getMeteo, writer.uint32(90).fork()).ldelim();
      }
      if (message.setMode !== void 0) {
        SetMode.encode(message.setMode, writer.uint32(98).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot4();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.start = Start2.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.stop = Stop2.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.axis = Axis.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.setPlatformAzimuth = SetPlatformAzimuth.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.setPlatformElevation = SetPlatformElevation.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.setPlatformBank = SetPlatformBank.decode(reader, reader.uint32());
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }
            message.halt = Halt.decode(reader, reader.uint32());
            continue;
          case 8:
            if (tag !== 66) {
              break;
            }
            message.setCalculateBasePositionFromCompass = SetCalculateBasePositionFromCompass.decode(
              reader,
              reader.uint32()
            );
            continue;
          case 9:
            if (tag !== 74) {
              break;
            }
            message.rotateToGps = RotateToGPS.decode(reader, reader.uint32());
            continue;
          case 10:
            if (tag !== 82) {
              break;
            }
            message.setOriginGps = SetOriginGPS.decode(reader, reader.uint32());
            continue;
          case 11:
            if (tag !== 90) {
              break;
            }
            message.getMeteo = GetMeteo2.decode(reader, reader.uint32());
            continue;
          case 12:
            if (tag !== 98) {
              break;
            }
            message.setMode = SetMode.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        start: isSet5(object.start) ? Start2.fromJSON(object.start) : void 0,
        stop: isSet5(object.stop) ? Stop2.fromJSON(object.stop) : void 0,
        axis: isSet5(object.axis) ? Axis.fromJSON(object.axis) : void 0,
        setPlatformAzimuth: isSet5(object.setPlatformAzimuth) ? SetPlatformAzimuth.fromJSON(object.setPlatformAzimuth) : void 0,
        setPlatformElevation: isSet5(object.setPlatformElevation) ? SetPlatformElevation.fromJSON(object.setPlatformElevation) : void 0,
        setPlatformBank: isSet5(object.setPlatformBank) ? SetPlatformBank.fromJSON(object.setPlatformBank) : void 0,
        halt: isSet5(object.halt) ? Halt.fromJSON(object.halt) : void 0,
        setCalculateBasePositionFromCompass: isSet5(object.setCalculateBasePositionFromCompass) ? SetCalculateBasePositionFromCompass.fromJSON(object.setCalculateBasePositionFromCompass) : void 0,
        rotateToGps: isSet5(object.rotateToGps) ? RotateToGPS.fromJSON(object.rotateToGps) : void 0,
        setOriginGps: isSet5(object.setOriginGps) ? SetOriginGPS.fromJSON(object.setOriginGps) : void 0,
        getMeteo: isSet5(object.getMeteo) ? GetMeteo2.fromJSON(object.getMeteo) : void 0,
        setMode: isSet5(object.setMode) ? SetMode.fromJSON(object.setMode) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.start !== void 0) {
        obj.start = Start2.toJSON(message.start);
      }
      if (message.stop !== void 0) {
        obj.stop = Stop2.toJSON(message.stop);
      }
      if (message.axis !== void 0) {
        obj.axis = Axis.toJSON(message.axis);
      }
      if (message.setPlatformAzimuth !== void 0) {
        obj.setPlatformAzimuth = SetPlatformAzimuth.toJSON(message.setPlatformAzimuth);
      }
      if (message.setPlatformElevation !== void 0) {
        obj.setPlatformElevation = SetPlatformElevation.toJSON(message.setPlatformElevation);
      }
      if (message.setPlatformBank !== void 0) {
        obj.setPlatformBank = SetPlatformBank.toJSON(message.setPlatformBank);
      }
      if (message.halt !== void 0) {
        obj.halt = Halt.toJSON(message.halt);
      }
      if (message.setCalculateBasePositionFromCompass !== void 0) {
        obj.setCalculateBasePositionFromCompass = SetCalculateBasePositionFromCompass.toJSON(
          message.setCalculateBasePositionFromCompass
        );
      }
      if (message.rotateToGps !== void 0) {
        obj.rotateToGps = RotateToGPS.toJSON(message.rotateToGps);
      }
      if (message.setOriginGps !== void 0) {
        obj.setOriginGps = SetOriginGPS.toJSON(message.setOriginGps);
      }
      if (message.getMeteo !== void 0) {
        obj.getMeteo = GetMeteo2.toJSON(message.getMeteo);
      }
      if (message.setMode !== void 0) {
        obj.setMode = SetMode.toJSON(message.setMode);
      }
      return obj;
    },
    create(base) {
      return Root4.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot4();
      message.start = object.start !== void 0 && object.start !== null ? Start2.fromPartial(object.start) : void 0;
      message.stop = object.stop !== void 0 && object.stop !== null ? Stop2.fromPartial(object.stop) : void 0;
      message.axis = object.axis !== void 0 && object.axis !== null ? Axis.fromPartial(object.axis) : void 0;
      message.setPlatformAzimuth = object.setPlatformAzimuth !== void 0 && object.setPlatformAzimuth !== null ? SetPlatformAzimuth.fromPartial(object.setPlatformAzimuth) : void 0;
      message.setPlatformElevation = object.setPlatformElevation !== void 0 && object.setPlatformElevation !== null ? SetPlatformElevation.fromPartial(object.setPlatformElevation) : void 0;
      message.setPlatformBank = object.setPlatformBank !== void 0 && object.setPlatformBank !== null ? SetPlatformBank.fromPartial(object.setPlatformBank) : void 0;
      message.halt = object.halt !== void 0 && object.halt !== null ? Halt.fromPartial(object.halt) : void 0;
      message.setCalculateBasePositionFromCompass = object.setCalculateBasePositionFromCompass !== void 0 && object.setCalculateBasePositionFromCompass !== null ? SetCalculateBasePositionFromCompass.fromPartial(object.setCalculateBasePositionFromCompass) : void 0;
      message.rotateToGps = object.rotateToGps !== void 0 && object.rotateToGps !== null ? RotateToGPS.fromPartial(object.rotateToGps) : void 0;
      message.setOriginGps = object.setOriginGps !== void 0 && object.setOriginGps !== null ? SetOriginGPS.fromPartial(object.setOriginGps) : void 0;
      message.getMeteo = object.getMeteo !== void 0 && object.getMeteo !== null ? GetMeteo2.fromPartial(object.getMeteo) : void 0;
      message.setMode = object.setMode !== void 0 && object.setMode !== null ? SetMode.fromPartial(object.setMode) : void 0;
      return message;
    }
  };
  function createBaseAxis() {
    return { azimuth: void 0, elevation: void 0 };
  }
  var Axis = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.azimuth !== void 0) {
        Azimuth.encode(message.azimuth, writer.uint32(10).fork()).ldelim();
      }
      if (message.elevation !== void 0) {
        Elevation.encode(message.elevation, writer.uint32(18).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseAxis();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.azimuth = Azimuth.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.elevation = Elevation.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        azimuth: isSet5(object.azimuth) ? Azimuth.fromJSON(object.azimuth) : void 0,
        elevation: isSet5(object.elevation) ? Elevation.fromJSON(object.elevation) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.azimuth !== void 0) {
        obj.azimuth = Azimuth.toJSON(message.azimuth);
      }
      if (message.elevation !== void 0) {
        obj.elevation = Elevation.toJSON(message.elevation);
      }
      return obj;
    },
    create(base) {
      return Axis.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseAxis();
      message.azimuth = object.azimuth !== void 0 && object.azimuth !== null ? Azimuth.fromPartial(object.azimuth) : void 0;
      message.elevation = object.elevation !== void 0 && object.elevation !== null ? Elevation.fromPartial(object.elevation) : void 0;
      return message;
    }
  };
  function createBaseSetMode() {
    return { mode: 0 };
  }
  var SetMode = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.mode !== 0) {
        writer.uint32(8).int32(message.mode);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetMode();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.mode = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { mode: isSet5(object.mode) ? jonGuiDataRotaryModeFromJSON(object.mode) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.mode !== 0) {
        obj.mode = jonGuiDataRotaryModeToJSON(message.mode);
      }
      return obj;
    },
    create(base) {
      return SetMode.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetMode();
      message.mode = object.mode ?? 0;
      return message;
    }
  };
  function createBaseSetAzimuthValue() {
    return { value: 0, direction: 0 };
  }
  var SetAzimuthValue = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      if (message.direction !== 0) {
        writer.uint32(16).int32(message.direction);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetAzimuthValue();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.direction = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        value: isSet5(object.value) ? globalThis.Number(object.value) : 0,
        direction: isSet5(object.direction) ? jonGuiDataRotaryDirectionFromJSON(object.direction) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      if (message.direction !== 0) {
        obj.direction = jonGuiDataRotaryDirectionToJSON(message.direction);
      }
      return obj;
    },
    create(base) {
      return SetAzimuthValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetAzimuthValue();
      message.value = object.value ?? 0;
      message.direction = object.direction ?? 0;
      return message;
    }
  };
  function createBaseRotateAzimuthTo() {
    return { targetValue: 0, speed: 0, direction: 0 };
  }
  var RotateAzimuthTo = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.targetValue !== 0) {
        writer.uint32(13).float(message.targetValue);
      }
      if (message.speed !== 0) {
        writer.uint32(21).float(message.speed);
      }
      if (message.direction !== 0) {
        writer.uint32(24).int32(message.direction);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRotateAzimuthTo();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.targetValue = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.speed = reader.float();
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }
            message.direction = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        targetValue: isSet5(object.targetValue) ? globalThis.Number(object.targetValue) : 0,
        speed: isSet5(object.speed) ? globalThis.Number(object.speed) : 0,
        direction: isSet5(object.direction) ? jonGuiDataRotaryDirectionFromJSON(object.direction) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.targetValue !== 0) {
        obj.targetValue = message.targetValue;
      }
      if (message.speed !== 0) {
        obj.speed = message.speed;
      }
      if (message.direction !== 0) {
        obj.direction = jonGuiDataRotaryDirectionToJSON(message.direction);
      }
      return obj;
    },
    create(base) {
      return RotateAzimuthTo.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRotateAzimuthTo();
      message.targetValue = object.targetValue ?? 0;
      message.speed = object.speed ?? 0;
      message.direction = object.direction ?? 0;
      return message;
    }
  };
  function createBaseRotateAzimuth() {
    return { speed: 0, direction: 0 };
  }
  var RotateAzimuth = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.speed !== 0) {
        writer.uint32(13).float(message.speed);
      }
      if (message.direction !== 0) {
        writer.uint32(16).int32(message.direction);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRotateAzimuth();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.speed = reader.float();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.direction = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        speed: isSet5(object.speed) ? globalThis.Number(object.speed) : 0,
        direction: isSet5(object.direction) ? jonGuiDataRotaryDirectionFromJSON(object.direction) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.speed !== 0) {
        obj.speed = message.speed;
      }
      if (message.direction !== 0) {
        obj.direction = jonGuiDataRotaryDirectionToJSON(message.direction);
      }
      return obj;
    },
    create(base) {
      return RotateAzimuth.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRotateAzimuth();
      message.speed = object.speed ?? 0;
      message.direction = object.direction ?? 0;
      return message;
    }
  };
  function createBaseRotateElevation() {
    return { speed: 0, direction: 0 };
  }
  var RotateElevation = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.speed !== 0) {
        writer.uint32(13).float(message.speed);
      }
      if (message.direction !== 0) {
        writer.uint32(16).int32(message.direction);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRotateElevation();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.speed = reader.float();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.direction = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        speed: isSet5(object.speed) ? globalThis.Number(object.speed) : 0,
        direction: isSet5(object.direction) ? jonGuiDataRotaryDirectionFromJSON(object.direction) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.speed !== 0) {
        obj.speed = message.speed;
      }
      if (message.direction !== 0) {
        obj.direction = jonGuiDataRotaryDirectionToJSON(message.direction);
      }
      return obj;
    },
    create(base) {
      return RotateElevation.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRotateElevation();
      message.speed = object.speed ?? 0;
      message.direction = object.direction ?? 0;
      return message;
    }
  };
  function createBaseSetElevationValue() {
    return { value: 0 };
  }
  var SetElevationValue = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetElevationValue();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet5(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetElevationValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetElevationValue();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseRotateElevationTo() {
    return { targetValue: 0, speed: 0 };
  }
  var RotateElevationTo = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.targetValue !== 0) {
        writer.uint32(13).float(message.targetValue);
      }
      if (message.speed !== 0) {
        writer.uint32(21).float(message.speed);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRotateElevationTo();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.targetValue = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.speed = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        targetValue: isSet5(object.targetValue) ? globalThis.Number(object.targetValue) : 0,
        speed: isSet5(object.speed) ? globalThis.Number(object.speed) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.targetValue !== 0) {
        obj.targetValue = message.targetValue;
      }
      if (message.speed !== 0) {
        obj.speed = message.speed;
      }
      return obj;
    },
    create(base) {
      return RotateElevationTo.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRotateElevationTo();
      message.targetValue = object.targetValue ?? 0;
      message.speed = object.speed ?? 0;
      return message;
    }
  };
  function createBaseRotateElevationRelative() {
    return { value: 0, speed: 0, direction: 0 };
  }
  var RotateElevationRelative = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      if (message.speed !== 0) {
        writer.uint32(21).float(message.speed);
      }
      if (message.direction !== 0) {
        writer.uint32(24).int32(message.direction);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRotateElevationRelative();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.speed = reader.float();
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }
            message.direction = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        value: isSet5(object.value) ? globalThis.Number(object.value) : 0,
        speed: isSet5(object.speed) ? globalThis.Number(object.speed) : 0,
        direction: isSet5(object.direction) ? jonGuiDataRotaryDirectionFromJSON(object.direction) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      if (message.speed !== 0) {
        obj.speed = message.speed;
      }
      if (message.direction !== 0) {
        obj.direction = jonGuiDataRotaryDirectionToJSON(message.direction);
      }
      return obj;
    },
    create(base) {
      return RotateElevationRelative.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRotateElevationRelative();
      message.value = object.value ?? 0;
      message.speed = object.speed ?? 0;
      message.direction = object.direction ?? 0;
      return message;
    }
  };
  function createBaseRotateElevationRelativeSet() {
    return { value: 0, direction: 0 };
  }
  var RotateElevationRelativeSet = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      if (message.direction !== 0) {
        writer.uint32(16).int32(message.direction);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRotateElevationRelativeSet();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.direction = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        value: isSet5(object.value) ? globalThis.Number(object.value) : 0,
        direction: isSet5(object.direction) ? jonGuiDataRotaryDirectionFromJSON(object.direction) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      if (message.direction !== 0) {
        obj.direction = jonGuiDataRotaryDirectionToJSON(message.direction);
      }
      return obj;
    },
    create(base) {
      return RotateElevationRelativeSet.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRotateElevationRelativeSet();
      message.value = object.value ?? 0;
      message.direction = object.direction ?? 0;
      return message;
    }
  };
  function createBaseRotateAzimuthRelative() {
    return { value: 0, speed: 0, direction: 0 };
  }
  var RotateAzimuthRelative = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      if (message.speed !== 0) {
        writer.uint32(21).float(message.speed);
      }
      if (message.direction !== 0) {
        writer.uint32(24).int32(message.direction);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRotateAzimuthRelative();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.speed = reader.float();
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }
            message.direction = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        value: isSet5(object.value) ? globalThis.Number(object.value) : 0,
        speed: isSet5(object.speed) ? globalThis.Number(object.speed) : 0,
        direction: isSet5(object.direction) ? jonGuiDataRotaryDirectionFromJSON(object.direction) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      if (message.speed !== 0) {
        obj.speed = message.speed;
      }
      if (message.direction !== 0) {
        obj.direction = jonGuiDataRotaryDirectionToJSON(message.direction);
      }
      return obj;
    },
    create(base) {
      return RotateAzimuthRelative.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRotateAzimuthRelative();
      message.value = object.value ?? 0;
      message.speed = object.speed ?? 0;
      message.direction = object.direction ?? 0;
      return message;
    }
  };
  function createBaseRotateAzimuthRelativeSet() {
    return { value: 0, direction: 0 };
  }
  var RotateAzimuthRelativeSet = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      if (message.direction !== 0) {
        writer.uint32(16).int32(message.direction);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRotateAzimuthRelativeSet();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.direction = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        value: isSet5(object.value) ? globalThis.Number(object.value) : 0,
        direction: isSet5(object.direction) ? jonGuiDataRotaryDirectionFromJSON(object.direction) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      if (message.direction !== 0) {
        obj.direction = jonGuiDataRotaryDirectionToJSON(message.direction);
      }
      return obj;
    },
    create(base) {
      return RotateAzimuthRelativeSet.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRotateAzimuthRelativeSet();
      message.value = object.value ?? 0;
      message.direction = object.direction ?? 0;
      return message;
    }
  };
  function createBaseSetPlatformAzimuth() {
    return { value: 0 };
  }
  var SetPlatformAzimuth = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetPlatformAzimuth();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet5(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetPlatformAzimuth.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetPlatformAzimuth();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetPlatformElevation() {
    return { value: 0 };
  }
  var SetPlatformElevation = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetPlatformElevation();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet5(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetPlatformElevation.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetPlatformElevation();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetPlatformBank() {
    return { value: 0 };
  }
  var SetPlatformBank = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetPlatformBank();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet5(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetPlatformBank.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetPlatformBank();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseGetMeteo2() {
    return {};
  }
  var GetMeteo2 = {
    encode(_5, writer = import_minimal5.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGetMeteo2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return GetMeteo2.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseGetMeteo2();
      return message;
    }
  };
  function createBaseAzimuth() {
    return {
      setValue: void 0,
      rotateTo: void 0,
      rotate: void 0,
      relative: void 0,
      relativeSet: void 0,
      halt: void 0
    };
  }
  var Azimuth = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.setValue !== void 0) {
        SetAzimuthValue.encode(message.setValue, writer.uint32(10).fork()).ldelim();
      }
      if (message.rotateTo !== void 0) {
        RotateAzimuthTo.encode(message.rotateTo, writer.uint32(18).fork()).ldelim();
      }
      if (message.rotate !== void 0) {
        RotateAzimuth.encode(message.rotate, writer.uint32(26).fork()).ldelim();
      }
      if (message.relative !== void 0) {
        RotateAzimuthRelative.encode(message.relative, writer.uint32(34).fork()).ldelim();
      }
      if (message.relativeSet !== void 0) {
        RotateAzimuthRelativeSet.encode(message.relativeSet, writer.uint32(42).fork()).ldelim();
      }
      if (message.halt !== void 0) {
        HaltAzimuth.encode(message.halt, writer.uint32(50).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseAzimuth();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.setValue = SetAzimuthValue.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.rotateTo = RotateAzimuthTo.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.rotate = RotateAzimuth.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.relative = RotateAzimuthRelative.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.relativeSet = RotateAzimuthRelativeSet.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.halt = HaltAzimuth.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        setValue: isSet5(object.setValue) ? SetAzimuthValue.fromJSON(object.setValue) : void 0,
        rotateTo: isSet5(object.rotateTo) ? RotateAzimuthTo.fromJSON(object.rotateTo) : void 0,
        rotate: isSet5(object.rotate) ? RotateAzimuth.fromJSON(object.rotate) : void 0,
        relative: isSet5(object.relative) ? RotateAzimuthRelative.fromJSON(object.relative) : void 0,
        relativeSet: isSet5(object.relativeSet) ? RotateAzimuthRelativeSet.fromJSON(object.relativeSet) : void 0,
        halt: isSet5(object.halt) ? HaltAzimuth.fromJSON(object.halt) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.setValue !== void 0) {
        obj.setValue = SetAzimuthValue.toJSON(message.setValue);
      }
      if (message.rotateTo !== void 0) {
        obj.rotateTo = RotateAzimuthTo.toJSON(message.rotateTo);
      }
      if (message.rotate !== void 0) {
        obj.rotate = RotateAzimuth.toJSON(message.rotate);
      }
      if (message.relative !== void 0) {
        obj.relative = RotateAzimuthRelative.toJSON(message.relative);
      }
      if (message.relativeSet !== void 0) {
        obj.relativeSet = RotateAzimuthRelativeSet.toJSON(message.relativeSet);
      }
      if (message.halt !== void 0) {
        obj.halt = HaltAzimuth.toJSON(message.halt);
      }
      return obj;
    },
    create(base) {
      return Azimuth.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseAzimuth();
      message.setValue = object.setValue !== void 0 && object.setValue !== null ? SetAzimuthValue.fromPartial(object.setValue) : void 0;
      message.rotateTo = object.rotateTo !== void 0 && object.rotateTo !== null ? RotateAzimuthTo.fromPartial(object.rotateTo) : void 0;
      message.rotate = object.rotate !== void 0 && object.rotate !== null ? RotateAzimuth.fromPartial(object.rotate) : void 0;
      message.relative = object.relative !== void 0 && object.relative !== null ? RotateAzimuthRelative.fromPartial(object.relative) : void 0;
      message.relativeSet = object.relativeSet !== void 0 && object.relativeSet !== null ? RotateAzimuthRelativeSet.fromPartial(object.relativeSet) : void 0;
      message.halt = object.halt !== void 0 && object.halt !== null ? HaltAzimuth.fromPartial(object.halt) : void 0;
      return message;
    }
  };
  function createBaseStart2() {
    return {};
  }
  var Start2 = {
    encode(_5, writer = import_minimal5.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStart2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Start2.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStart2();
      return message;
    }
  };
  function createBaseStop2() {
    return {};
  }
  var Stop2 = {
    encode(_5, writer = import_minimal5.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStop2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Stop2.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStop2();
      return message;
    }
  };
  function createBaseHalt() {
    return {};
  }
  var Halt = {
    encode(_5, writer = import_minimal5.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseHalt();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Halt.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseHalt();
      return message;
    }
  };
  function createBaseHaltAzimuth() {
    return {};
  }
  var HaltAzimuth = {
    encode(_5, writer = import_minimal5.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseHaltAzimuth();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return HaltAzimuth.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseHaltAzimuth();
      return message;
    }
  };
  function createBaseHaltElevation() {
    return {};
  }
  var HaltElevation = {
    encode(_5, writer = import_minimal5.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseHaltElevation();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return HaltElevation.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseHaltElevation();
      return message;
    }
  };
  function createBaseElevation() {
    return {
      setValue: void 0,
      rotateTo: void 0,
      rotate: void 0,
      relative: void 0,
      relativeSet: void 0,
      halt: void 0
    };
  }
  var Elevation = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.setValue !== void 0) {
        SetElevationValue.encode(message.setValue, writer.uint32(10).fork()).ldelim();
      }
      if (message.rotateTo !== void 0) {
        RotateElevationTo.encode(message.rotateTo, writer.uint32(18).fork()).ldelim();
      }
      if (message.rotate !== void 0) {
        RotateElevation.encode(message.rotate, writer.uint32(26).fork()).ldelim();
      }
      if (message.relative !== void 0) {
        RotateElevationRelative.encode(message.relative, writer.uint32(34).fork()).ldelim();
      }
      if (message.relativeSet !== void 0) {
        RotateElevationRelativeSet.encode(message.relativeSet, writer.uint32(42).fork()).ldelim();
      }
      if (message.halt !== void 0) {
        HaltElevation.encode(message.halt, writer.uint32(50).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseElevation();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.setValue = SetElevationValue.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.rotateTo = RotateElevationTo.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.rotate = RotateElevation.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.relative = RotateElevationRelative.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.relativeSet = RotateElevationRelativeSet.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.halt = HaltElevation.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        setValue: isSet5(object.setValue) ? SetElevationValue.fromJSON(object.setValue) : void 0,
        rotateTo: isSet5(object.rotateTo) ? RotateElevationTo.fromJSON(object.rotateTo) : void 0,
        rotate: isSet5(object.rotate) ? RotateElevation.fromJSON(object.rotate) : void 0,
        relative: isSet5(object.relative) ? RotateElevationRelative.fromJSON(object.relative) : void 0,
        relativeSet: isSet5(object.relativeSet) ? RotateElevationRelativeSet.fromJSON(object.relativeSet) : void 0,
        halt: isSet5(object.halt) ? HaltElevation.fromJSON(object.halt) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.setValue !== void 0) {
        obj.setValue = SetElevationValue.toJSON(message.setValue);
      }
      if (message.rotateTo !== void 0) {
        obj.rotateTo = RotateElevationTo.toJSON(message.rotateTo);
      }
      if (message.rotate !== void 0) {
        obj.rotate = RotateElevation.toJSON(message.rotate);
      }
      if (message.relative !== void 0) {
        obj.relative = RotateElevationRelative.toJSON(message.relative);
      }
      if (message.relativeSet !== void 0) {
        obj.relativeSet = RotateElevationRelativeSet.toJSON(message.relativeSet);
      }
      if (message.halt !== void 0) {
        obj.halt = HaltElevation.toJSON(message.halt);
      }
      return obj;
    },
    create(base) {
      return Elevation.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseElevation();
      message.setValue = object.setValue !== void 0 && object.setValue !== null ? SetElevationValue.fromPartial(object.setValue) : void 0;
      message.rotateTo = object.rotateTo !== void 0 && object.rotateTo !== null ? RotateElevationTo.fromPartial(object.rotateTo) : void 0;
      message.rotate = object.rotate !== void 0 && object.rotate !== null ? RotateElevation.fromPartial(object.rotate) : void 0;
      message.relative = object.relative !== void 0 && object.relative !== null ? RotateElevationRelative.fromPartial(object.relative) : void 0;
      message.relativeSet = object.relativeSet !== void 0 && object.relativeSet !== null ? RotateElevationRelativeSet.fromPartial(object.relativeSet) : void 0;
      message.halt = object.halt !== void 0 && object.halt !== null ? HaltElevation.fromPartial(object.halt) : void 0;
      return message;
    }
  };
  function createBaseSetCalculateBasePositionFromCompass() {
    return { flag: false };
  }
  var SetCalculateBasePositionFromCompass = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.flag !== false) {
        writer.uint32(8).bool(message.flag);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetCalculateBasePositionFromCompass();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.flag = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { flag: isSet5(object.flag) ? globalThis.Boolean(object.flag) : false };
    },
    toJSON(message) {
      const obj = {};
      if (message.flag !== false) {
        obj.flag = message.flag;
      }
      return obj;
    },
    create(base) {
      return SetCalculateBasePositionFromCompass.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetCalculateBasePositionFromCompass();
      message.flag = object.flag ?? false;
      return message;
    }
  };
  function createBaseRotateToGPS() {
    return { latitude: 0, longitude: 0, altitude: 0 };
  }
  var RotateToGPS = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.latitude !== 0) {
        writer.uint32(13).float(message.latitude);
      }
      if (message.longitude !== 0) {
        writer.uint32(21).float(message.longitude);
      }
      if (message.altitude !== 0) {
        writer.uint32(29).float(message.altitude);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRotateToGPS();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.latitude = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.longitude = reader.float();
            continue;
          case 3:
            if (tag !== 29) {
              break;
            }
            message.altitude = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        latitude: isSet5(object.latitude) ? globalThis.Number(object.latitude) : 0,
        longitude: isSet5(object.longitude) ? globalThis.Number(object.longitude) : 0,
        altitude: isSet5(object.altitude) ? globalThis.Number(object.altitude) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.latitude !== 0) {
        obj.latitude = message.latitude;
      }
      if (message.longitude !== 0) {
        obj.longitude = message.longitude;
      }
      if (message.altitude !== 0) {
        obj.altitude = message.altitude;
      }
      return obj;
    },
    create(base) {
      return RotateToGPS.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRotateToGPS();
      message.latitude = object.latitude ?? 0;
      message.longitude = object.longitude ?? 0;
      message.altitude = object.altitude ?? 0;
      return message;
    }
  };
  function createBaseSetOriginGPS() {
    return { latitude: 0, longitude: 0, altitude: 0 };
  }
  var SetOriginGPS = {
    encode(message, writer = import_minimal5.default.Writer.create()) {
      if (message.latitude !== 0) {
        writer.uint32(13).float(message.latitude);
      }
      if (message.longitude !== 0) {
        writer.uint32(21).float(message.longitude);
      }
      if (message.altitude !== 0) {
        writer.uint32(29).float(message.altitude);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal5.default.Reader ? input2 : import_minimal5.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetOriginGPS();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.latitude = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.longitude = reader.float();
            continue;
          case 3:
            if (tag !== 29) {
              break;
            }
            message.altitude = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        latitude: isSet5(object.latitude) ? globalThis.Number(object.latitude) : 0,
        longitude: isSet5(object.longitude) ? globalThis.Number(object.longitude) : 0,
        altitude: isSet5(object.altitude) ? globalThis.Number(object.altitude) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.latitude !== 0) {
        obj.latitude = message.latitude;
      }
      if (message.longitude !== 0) {
        obj.longitude = message.longitude;
      }
      if (message.altitude !== 0) {
        obj.altitude = message.altitude;
      }
      return obj;
    },
    create(base) {
      return SetOriginGPS.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetOriginGPS();
      message.latitude = object.latitude ?? 0;
      message.longitude = object.longitude ?? 0;
      message.altitude = object.altitude ?? 0;
      return message;
    }
  };
  function isSet5(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_cmd_heat_camera.ts
  var import_minimal6 = __toESM(require_minimal2());
  function createBaseRoot5() {
    return {
      focus: void 0,
      zoom: void 0,
      setAgc: void 0,
      setFilter: void 0,
      setAutoFocus: void 0,
      setRecording: void 0,
      start: void 0,
      stop: void 0,
      photo: void 0,
      syncZoom: void 0,
      getPos: void 0,
      zoomIn: void 0,
      zoomOut: void 0,
      zoomStop: void 0,
      focusIn: void 0,
      focusOut: void 0,
      focusStop: void 0,
      calibrate: void 0,
      haltAll: void 0,
      getMeteo: void 0,
      setDdeLevel: void 0,
      enableDde: void 0,
      disableDde: void 0
    };
  }
  var Root5 = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.focus !== void 0) {
        Focus.encode(message.focus, writer.uint32(10).fork()).ldelim();
      }
      if (message.zoom !== void 0) {
        Zoom.encode(message.zoom, writer.uint32(18).fork()).ldelim();
      }
      if (message.setAgc !== void 0) {
        SetAGC.encode(message.setAgc, writer.uint32(26).fork()).ldelim();
      }
      if (message.setFilter !== void 0) {
        SetFilters.encode(message.setFilter, writer.uint32(34).fork()).ldelim();
      }
      if (message.setAutoFocus !== void 0) {
        SetAutoFocus.encode(message.setAutoFocus, writer.uint32(42).fork()).ldelim();
      }
      if (message.setRecording !== void 0) {
        SetRecording.encode(message.setRecording, writer.uint32(50).fork()).ldelim();
      }
      if (message.start !== void 0) {
        Start3.encode(message.start, writer.uint32(58).fork()).ldelim();
      }
      if (message.stop !== void 0) {
        Stop3.encode(message.stop, writer.uint32(66).fork()).ldelim();
      }
      if (message.photo !== void 0) {
        Photo.encode(message.photo, writer.uint32(74).fork()).ldelim();
      }
      if (message.syncZoom !== void 0) {
        SyncZoomToHeatCamera.encode(message.syncZoom, writer.uint32(82).fork()).ldelim();
      }
      if (message.getPos !== void 0) {
        GetPos.encode(message.getPos, writer.uint32(90).fork()).ldelim();
      }
      if (message.zoomIn !== void 0) {
        ZoomIn.encode(message.zoomIn, writer.uint32(98).fork()).ldelim();
      }
      if (message.zoomOut !== void 0) {
        ZoomOut.encode(message.zoomOut, writer.uint32(106).fork()).ldelim();
      }
      if (message.zoomStop !== void 0) {
        ZoomStop.encode(message.zoomStop, writer.uint32(114).fork()).ldelim();
      }
      if (message.focusIn !== void 0) {
        FocusIn.encode(message.focusIn, writer.uint32(122).fork()).ldelim();
      }
      if (message.focusOut !== void 0) {
        FocusOut.encode(message.focusOut, writer.uint32(130).fork()).ldelim();
      }
      if (message.focusStop !== void 0) {
        FocusStop.encode(message.focusStop, writer.uint32(138).fork()).ldelim();
      }
      if (message.calibrate !== void 0) {
        Calibrate.encode(message.calibrate, writer.uint32(146).fork()).ldelim();
      }
      if (message.haltAll !== void 0) {
        HaltAll.encode(message.haltAll, writer.uint32(154).fork()).ldelim();
      }
      if (message.getMeteo !== void 0) {
        GetMeteo3.encode(message.getMeteo, writer.uint32(162).fork()).ldelim();
      }
      if (message.setDdeLevel !== void 0) {
        SetDDELevel.encode(message.setDdeLevel, writer.uint32(170).fork()).ldelim();
      }
      if (message.enableDde !== void 0) {
        EnableDDE.encode(message.enableDde, writer.uint32(178).fork()).ldelim();
      }
      if (message.disableDde !== void 0) {
        DisableDDE.encode(message.disableDde, writer.uint32(186).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot5();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.focus = Focus.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.zoom = Zoom.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.setAgc = SetAGC.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.setFilter = SetFilters.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.setAutoFocus = SetAutoFocus.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.setRecording = SetRecording.decode(reader, reader.uint32());
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }
            message.start = Start3.decode(reader, reader.uint32());
            continue;
          case 8:
            if (tag !== 66) {
              break;
            }
            message.stop = Stop3.decode(reader, reader.uint32());
            continue;
          case 9:
            if (tag !== 74) {
              break;
            }
            message.photo = Photo.decode(reader, reader.uint32());
            continue;
          case 10:
            if (tag !== 82) {
              break;
            }
            message.syncZoom = SyncZoomToHeatCamera.decode(reader, reader.uint32());
            continue;
          case 11:
            if (tag !== 90) {
              break;
            }
            message.getPos = GetPos.decode(reader, reader.uint32());
            continue;
          case 12:
            if (tag !== 98) {
              break;
            }
            message.zoomIn = ZoomIn.decode(reader, reader.uint32());
            continue;
          case 13:
            if (tag !== 106) {
              break;
            }
            message.zoomOut = ZoomOut.decode(reader, reader.uint32());
            continue;
          case 14:
            if (tag !== 114) {
              break;
            }
            message.zoomStop = ZoomStop.decode(reader, reader.uint32());
            continue;
          case 15:
            if (tag !== 122) {
              break;
            }
            message.focusIn = FocusIn.decode(reader, reader.uint32());
            continue;
          case 16:
            if (tag !== 130) {
              break;
            }
            message.focusOut = FocusOut.decode(reader, reader.uint32());
            continue;
          case 17:
            if (tag !== 138) {
              break;
            }
            message.focusStop = FocusStop.decode(reader, reader.uint32());
            continue;
          case 18:
            if (tag !== 146) {
              break;
            }
            message.calibrate = Calibrate.decode(reader, reader.uint32());
            continue;
          case 19:
            if (tag !== 154) {
              break;
            }
            message.haltAll = HaltAll.decode(reader, reader.uint32());
            continue;
          case 20:
            if (tag !== 162) {
              break;
            }
            message.getMeteo = GetMeteo3.decode(reader, reader.uint32());
            continue;
          case 21:
            if (tag !== 170) {
              break;
            }
            message.setDdeLevel = SetDDELevel.decode(reader, reader.uint32());
            continue;
          case 22:
            if (tag !== 178) {
              break;
            }
            message.enableDde = EnableDDE.decode(reader, reader.uint32());
            continue;
          case 23:
            if (tag !== 186) {
              break;
            }
            message.disableDde = DisableDDE.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        focus: isSet6(object.focus) ? Focus.fromJSON(object.focus) : void 0,
        zoom: isSet6(object.zoom) ? Zoom.fromJSON(object.zoom) : void 0,
        setAgc: isSet6(object.setAgc) ? SetAGC.fromJSON(object.setAgc) : void 0,
        setFilter: isSet6(object.setFilter) ? SetFilters.fromJSON(object.setFilter) : void 0,
        setAutoFocus: isSet6(object.setAutoFocus) ? SetAutoFocus.fromJSON(object.setAutoFocus) : void 0,
        setRecording: isSet6(object.setRecording) ? SetRecording.fromJSON(object.setRecording) : void 0,
        start: isSet6(object.start) ? Start3.fromJSON(object.start) : void 0,
        stop: isSet6(object.stop) ? Stop3.fromJSON(object.stop) : void 0,
        photo: isSet6(object.photo) ? Photo.fromJSON(object.photo) : void 0,
        syncZoom: isSet6(object.syncZoom) ? SyncZoomToHeatCamera.fromJSON(object.syncZoom) : void 0,
        getPos: isSet6(object.getPos) ? GetPos.fromJSON(object.getPos) : void 0,
        zoomIn: isSet6(object.zoomIn) ? ZoomIn.fromJSON(object.zoomIn) : void 0,
        zoomOut: isSet6(object.zoomOut) ? ZoomOut.fromJSON(object.zoomOut) : void 0,
        zoomStop: isSet6(object.zoomStop) ? ZoomStop.fromJSON(object.zoomStop) : void 0,
        focusIn: isSet6(object.focusIn) ? FocusIn.fromJSON(object.focusIn) : void 0,
        focusOut: isSet6(object.focusOut) ? FocusOut.fromJSON(object.focusOut) : void 0,
        focusStop: isSet6(object.focusStop) ? FocusStop.fromJSON(object.focusStop) : void 0,
        calibrate: isSet6(object.calibrate) ? Calibrate.fromJSON(object.calibrate) : void 0,
        haltAll: isSet6(object.haltAll) ? HaltAll.fromJSON(object.haltAll) : void 0,
        getMeteo: isSet6(object.getMeteo) ? GetMeteo3.fromJSON(object.getMeteo) : void 0,
        setDdeLevel: isSet6(object.setDdeLevel) ? SetDDELevel.fromJSON(object.setDdeLevel) : void 0,
        enableDde: isSet6(object.enableDde) ? EnableDDE.fromJSON(object.enableDde) : void 0,
        disableDde: isSet6(object.disableDde) ? DisableDDE.fromJSON(object.disableDde) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.focus !== void 0) {
        obj.focus = Focus.toJSON(message.focus);
      }
      if (message.zoom !== void 0) {
        obj.zoom = Zoom.toJSON(message.zoom);
      }
      if (message.setAgc !== void 0) {
        obj.setAgc = SetAGC.toJSON(message.setAgc);
      }
      if (message.setFilter !== void 0) {
        obj.setFilter = SetFilters.toJSON(message.setFilter);
      }
      if (message.setAutoFocus !== void 0) {
        obj.setAutoFocus = SetAutoFocus.toJSON(message.setAutoFocus);
      }
      if (message.setRecording !== void 0) {
        obj.setRecording = SetRecording.toJSON(message.setRecording);
      }
      if (message.start !== void 0) {
        obj.start = Start3.toJSON(message.start);
      }
      if (message.stop !== void 0) {
        obj.stop = Stop3.toJSON(message.stop);
      }
      if (message.photo !== void 0) {
        obj.photo = Photo.toJSON(message.photo);
      }
      if (message.syncZoom !== void 0) {
        obj.syncZoom = SyncZoomToHeatCamera.toJSON(message.syncZoom);
      }
      if (message.getPos !== void 0) {
        obj.getPos = GetPos.toJSON(message.getPos);
      }
      if (message.zoomIn !== void 0) {
        obj.zoomIn = ZoomIn.toJSON(message.zoomIn);
      }
      if (message.zoomOut !== void 0) {
        obj.zoomOut = ZoomOut.toJSON(message.zoomOut);
      }
      if (message.zoomStop !== void 0) {
        obj.zoomStop = ZoomStop.toJSON(message.zoomStop);
      }
      if (message.focusIn !== void 0) {
        obj.focusIn = FocusIn.toJSON(message.focusIn);
      }
      if (message.focusOut !== void 0) {
        obj.focusOut = FocusOut.toJSON(message.focusOut);
      }
      if (message.focusStop !== void 0) {
        obj.focusStop = FocusStop.toJSON(message.focusStop);
      }
      if (message.calibrate !== void 0) {
        obj.calibrate = Calibrate.toJSON(message.calibrate);
      }
      if (message.haltAll !== void 0) {
        obj.haltAll = HaltAll.toJSON(message.haltAll);
      }
      if (message.getMeteo !== void 0) {
        obj.getMeteo = GetMeteo3.toJSON(message.getMeteo);
      }
      if (message.setDdeLevel !== void 0) {
        obj.setDdeLevel = SetDDELevel.toJSON(message.setDdeLevel);
      }
      if (message.enableDde !== void 0) {
        obj.enableDde = EnableDDE.toJSON(message.enableDde);
      }
      if (message.disableDde !== void 0) {
        obj.disableDde = DisableDDE.toJSON(message.disableDde);
      }
      return obj;
    },
    create(base) {
      return Root5.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot5();
      message.focus = object.focus !== void 0 && object.focus !== null ? Focus.fromPartial(object.focus) : void 0;
      message.zoom = object.zoom !== void 0 && object.zoom !== null ? Zoom.fromPartial(object.zoom) : void 0;
      message.setAgc = object.setAgc !== void 0 && object.setAgc !== null ? SetAGC.fromPartial(object.setAgc) : void 0;
      message.setFilter = object.setFilter !== void 0 && object.setFilter !== null ? SetFilters.fromPartial(object.setFilter) : void 0;
      message.setAutoFocus = object.setAutoFocus !== void 0 && object.setAutoFocus !== null ? SetAutoFocus.fromPartial(object.setAutoFocus) : void 0;
      message.setRecording = object.setRecording !== void 0 && object.setRecording !== null ? SetRecording.fromPartial(object.setRecording) : void 0;
      message.start = object.start !== void 0 && object.start !== null ? Start3.fromPartial(object.start) : void 0;
      message.stop = object.stop !== void 0 && object.stop !== null ? Stop3.fromPartial(object.stop) : void 0;
      message.photo = object.photo !== void 0 && object.photo !== null ? Photo.fromPartial(object.photo) : void 0;
      message.syncZoom = object.syncZoom !== void 0 && object.syncZoom !== null ? SyncZoomToHeatCamera.fromPartial(object.syncZoom) : void 0;
      message.getPos = object.getPos !== void 0 && object.getPos !== null ? GetPos.fromPartial(object.getPos) : void 0;
      message.zoomIn = object.zoomIn !== void 0 && object.zoomIn !== null ? ZoomIn.fromPartial(object.zoomIn) : void 0;
      message.zoomOut = object.zoomOut !== void 0 && object.zoomOut !== null ? ZoomOut.fromPartial(object.zoomOut) : void 0;
      message.zoomStop = object.zoomStop !== void 0 && object.zoomStop !== null ? ZoomStop.fromPartial(object.zoomStop) : void 0;
      message.focusIn = object.focusIn !== void 0 && object.focusIn !== null ? FocusIn.fromPartial(object.focusIn) : void 0;
      message.focusOut = object.focusOut !== void 0 && object.focusOut !== null ? FocusOut.fromPartial(object.focusOut) : void 0;
      message.focusStop = object.focusStop !== void 0 && object.focusStop !== null ? FocusStop.fromPartial(object.focusStop) : void 0;
      message.calibrate = object.calibrate !== void 0 && object.calibrate !== null ? Calibrate.fromPartial(object.calibrate) : void 0;
      message.haltAll = object.haltAll !== void 0 && object.haltAll !== null ? HaltAll.fromPartial(object.haltAll) : void 0;
      message.getMeteo = object.getMeteo !== void 0 && object.getMeteo !== null ? GetMeteo3.fromPartial(object.getMeteo) : void 0;
      message.setDdeLevel = object.setDdeLevel !== void 0 && object.setDdeLevel !== null ? SetDDELevel.fromPartial(object.setDdeLevel) : void 0;
      message.enableDde = object.enableDde !== void 0 && object.enableDde !== null ? EnableDDE.fromPartial(object.enableDde) : void 0;
      message.disableDde = object.disableDde !== void 0 && object.disableDde !== null ? DisableDDE.fromPartial(object.disableDde) : void 0;
      return message;
    }
  };
  function createBaseHaltAll() {
    return {};
  }
  var HaltAll = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseHaltAll();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return HaltAll.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseHaltAll();
      return message;
    }
  };
  function createBaseEnableDDE() {
    return {};
  }
  var EnableDDE = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseEnableDDE();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return EnableDDE.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseEnableDDE();
      return message;
    }
  };
  function createBaseDisableDDE() {
    return {};
  }
  var DisableDDE = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseDisableDDE();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return DisableDDE.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseDisableDDE();
      return message;
    }
  };
  function createBaseSetValue() {
    return { value: 0 };
  }
  var SetValue = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetValue();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet6(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetValue();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetDDELevel() {
    return { value: 0 };
  }
  var SetDDELevel = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetDDELevel();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet6(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = Math.round(message.value);
      }
      return obj;
    },
    create(base) {
      return SetDDELevel.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetDDELevel();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseMove() {
    return { targetValue: 0, speed: 0 };
  }
  var Move = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.targetValue !== 0) {
        writer.uint32(13).float(message.targetValue);
      }
      if (message.speed !== 0) {
        writer.uint32(21).float(message.speed);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseMove();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.targetValue = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.speed = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        targetValue: isSet6(object.targetValue) ? globalThis.Number(object.targetValue) : 0,
        speed: isSet6(object.speed) ? globalThis.Number(object.speed) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.targetValue !== 0) {
        obj.targetValue = message.targetValue;
      }
      if (message.speed !== 0) {
        obj.speed = message.speed;
      }
      return obj;
    },
    create(base) {
      return Move.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseMove();
      message.targetValue = object.targetValue ?? 0;
      message.speed = object.speed ?? 0;
      return message;
    }
  };
  function createBaseZoomIn() {
    return {};
  }
  var ZoomIn = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseZoomIn();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return ZoomIn.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseZoomIn();
      return message;
    }
  };
  function createBaseZoomOut() {
    return {};
  }
  var ZoomOut = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseZoomOut();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return ZoomOut.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseZoomOut();
      return message;
    }
  };
  function createBaseZoomStop() {
    return {};
  }
  var ZoomStop = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseZoomStop();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return ZoomStop.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseZoomStop();
      return message;
    }
  };
  function createBaseFocusIn() {
    return {};
  }
  var FocusIn = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseFocusIn();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return FocusIn.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseFocusIn();
      return message;
    }
  };
  function createBaseFocusOut() {
    return {};
  }
  var FocusOut = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseFocusOut();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return FocusOut.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseFocusOut();
      return message;
    }
  };
  function createBaseFocusStop() {
    return {};
  }
  var FocusStop = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseFocusStop();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return FocusStop.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseFocusStop();
      return message;
    }
  };
  function createBaseCalibrate() {
    return {};
  }
  var Calibrate = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseCalibrate();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Calibrate.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseCalibrate();
      return message;
    }
  };
  function createBaseGetPos() {
    return {};
  }
  var GetPos = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGetPos();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return GetPos.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseGetPos();
      return message;
    }
  };
  function createBaseFocus() {
    return { setValue: void 0, move: void 0, halt: void 0 };
  }
  var Focus = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.setValue !== void 0) {
        SetValue.encode(message.setValue, writer.uint32(10).fork()).ldelim();
      }
      if (message.move !== void 0) {
        Move.encode(message.move, writer.uint32(18).fork()).ldelim();
      }
      if (message.halt !== void 0) {
        Halt2.encode(message.halt, writer.uint32(26).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseFocus();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.setValue = SetValue.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.move = Move.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.halt = Halt2.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        setValue: isSet6(object.setValue) ? SetValue.fromJSON(object.setValue) : void 0,
        move: isSet6(object.move) ? Move.fromJSON(object.move) : void 0,
        halt: isSet6(object.halt) ? Halt2.fromJSON(object.halt) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.setValue !== void 0) {
        obj.setValue = SetValue.toJSON(message.setValue);
      }
      if (message.move !== void 0) {
        obj.move = Move.toJSON(message.move);
      }
      if (message.halt !== void 0) {
        obj.halt = Halt2.toJSON(message.halt);
      }
      return obj;
    },
    create(base) {
      return Focus.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseFocus();
      message.setValue = object.setValue !== void 0 && object.setValue !== null ? SetValue.fromPartial(object.setValue) : void 0;
      message.move = object.move !== void 0 && object.move !== null ? Move.fromPartial(object.move) : void 0;
      message.halt = object.halt !== void 0 && object.halt !== null ? Halt2.fromPartial(object.halt) : void 0;
      return message;
    }
  };
  function createBaseZoom() {
    return {
      setValue: void 0,
      setZoomTableValue: void 0,
      move: void 0,
      halt: void 0,
      nextZoomTablePos: void 0,
      prevZoomTablePos: void 0
    };
  }
  var Zoom = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.setValue !== void 0) {
        SetValue.encode(message.setValue, writer.uint32(10).fork()).ldelim();
      }
      if (message.setZoomTableValue !== void 0) {
        SetZoomTableValue.encode(message.setZoomTableValue, writer.uint32(18).fork()).ldelim();
      }
      if (message.move !== void 0) {
        Move.encode(message.move, writer.uint32(26).fork()).ldelim();
      }
      if (message.halt !== void 0) {
        Halt2.encode(message.halt, writer.uint32(34).fork()).ldelim();
      }
      if (message.nextZoomTablePos !== void 0) {
        NextZoomTablePos.encode(message.nextZoomTablePos, writer.uint32(42).fork()).ldelim();
      }
      if (message.prevZoomTablePos !== void 0) {
        PrevZoomTablePos.encode(message.prevZoomTablePos, writer.uint32(50).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseZoom();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.setValue = SetValue.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.setZoomTableValue = SetZoomTableValue.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.move = Move.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.halt = Halt2.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.nextZoomTablePos = NextZoomTablePos.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.prevZoomTablePos = PrevZoomTablePos.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        setValue: isSet6(object.setValue) ? SetValue.fromJSON(object.setValue) : void 0,
        setZoomTableValue: isSet6(object.setZoomTableValue) ? SetZoomTableValue.fromJSON(object.setZoomTableValue) : void 0,
        move: isSet6(object.move) ? Move.fromJSON(object.move) : void 0,
        halt: isSet6(object.halt) ? Halt2.fromJSON(object.halt) : void 0,
        nextZoomTablePos: isSet6(object.nextZoomTablePos) ? NextZoomTablePos.fromJSON(object.nextZoomTablePos) : void 0,
        prevZoomTablePos: isSet6(object.prevZoomTablePos) ? PrevZoomTablePos.fromJSON(object.prevZoomTablePos) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.setValue !== void 0) {
        obj.setValue = SetValue.toJSON(message.setValue);
      }
      if (message.setZoomTableValue !== void 0) {
        obj.setZoomTableValue = SetZoomTableValue.toJSON(message.setZoomTableValue);
      }
      if (message.move !== void 0) {
        obj.move = Move.toJSON(message.move);
      }
      if (message.halt !== void 0) {
        obj.halt = Halt2.toJSON(message.halt);
      }
      if (message.nextZoomTablePos !== void 0) {
        obj.nextZoomTablePos = NextZoomTablePos.toJSON(message.nextZoomTablePos);
      }
      if (message.prevZoomTablePos !== void 0) {
        obj.prevZoomTablePos = PrevZoomTablePos.toJSON(message.prevZoomTablePos);
      }
      return obj;
    },
    create(base) {
      return Zoom.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseZoom();
      message.setValue = object.setValue !== void 0 && object.setValue !== null ? SetValue.fromPartial(object.setValue) : void 0;
      message.setZoomTableValue = object.setZoomTableValue !== void 0 && object.setZoomTableValue !== null ? SetZoomTableValue.fromPartial(object.setZoomTableValue) : void 0;
      message.move = object.move !== void 0 && object.move !== null ? Move.fromPartial(object.move) : void 0;
      message.halt = object.halt !== void 0 && object.halt !== null ? Halt2.fromPartial(object.halt) : void 0;
      message.nextZoomTablePos = object.nextZoomTablePos !== void 0 && object.nextZoomTablePos !== null ? NextZoomTablePos.fromPartial(object.nextZoomTablePos) : void 0;
      message.prevZoomTablePos = object.prevZoomTablePos !== void 0 && object.prevZoomTablePos !== null ? PrevZoomTablePos.fromPartial(object.prevZoomTablePos) : void 0;
      return message;
    }
  };
  function createBaseSetZoomTableValue() {
    return { value: 0 };
  }
  var SetZoomTableValue = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetZoomTableValue();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet6(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = Math.round(message.value);
      }
      return obj;
    },
    create(base) {
      return SetZoomTableValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetZoomTableValue();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseNextZoomTablePos() {
    return {};
  }
  var NextZoomTablePos = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseNextZoomTablePos();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return NextZoomTablePos.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseNextZoomTablePos();
      return message;
    }
  };
  function createBasePrevZoomTablePos() {
    return {};
  }
  var PrevZoomTablePos = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBasePrevZoomTablePos();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return PrevZoomTablePos.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBasePrevZoomTablePos();
      return message;
    }
  };
  function createBaseSetAGC() {
    return { value: 0 };
  }
  var SetAGC = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetAGC();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet6(object.value) ? jonGuiDataVideoChannelHeatAGCModesFromJSON(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = jonGuiDataVideoChannelHeatAGCModesToJSON(message.value);
      }
      return obj;
    },
    create(base) {
      return SetAGC.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetAGC();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetFilters() {
    return { value: 0 };
  }
  var SetFilters = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetFilters();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet6(object.value) ? jonGuiDataVideoChannelHeatFiltersFromJSON(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = jonGuiDataVideoChannelHeatFiltersToJSON(message.value);
      }
      return obj;
    },
    create(base) {
      return SetFilters.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetFilters();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetAutoFocus() {
    return { value: false };
  }
  var SetAutoFocus = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.value !== false) {
        writer.uint32(8).bool(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetAutoFocus();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet6(object.value) ? globalThis.Boolean(object.value) : false };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== false) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetAutoFocus.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetAutoFocus();
      message.value = object.value ?? false;
      return message;
    }
  };
  function createBaseSetRecording() {
    return { value: false };
  }
  var SetRecording = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.value !== false) {
        writer.uint32(8).bool(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetRecording();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet6(object.value) ? globalThis.Boolean(object.value) : false };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== false) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetRecording.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetRecording();
      message.value = object.value ?? false;
      return message;
    }
  };
  function createBaseStart3() {
    return {};
  }
  var Start3 = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStart3();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Start3.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStart3();
      return message;
    }
  };
  function createBaseStop3() {
    return {};
  }
  var Stop3 = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStop3();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Stop3.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStop3();
      return message;
    }
  };
  function createBaseHalt2() {
    return {};
  }
  var Halt2 = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseHalt2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Halt2.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseHalt2();
      return message;
    }
  };
  function createBasePhoto() {
    return {};
  }
  var Photo = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBasePhoto();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Photo.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBasePhoto();
      return message;
    }
  };
  function createBaseGetMeteo3() {
    return {};
  }
  var GetMeteo3 = {
    encode(_5, writer = import_minimal6.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGetMeteo3();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return GetMeteo3.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseGetMeteo3();
      return message;
    }
  };
  function createBaseSyncZoomToHeatCamera() {
    return { value: false };
  }
  var SyncZoomToHeatCamera = {
    encode(message, writer = import_minimal6.default.Writer.create()) {
      if (message.value !== false) {
        writer.uint32(8).bool(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal6.default.Reader ? input2 : import_minimal6.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSyncZoomToHeatCamera();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet6(object.value) ? globalThis.Boolean(object.value) : false };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== false) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SyncZoomToHeatCamera.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSyncZoomToHeatCamera();
      message.value = object.value ?? false;
      return message;
    }
  };
  function isSet6(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_cmd_compass.ts
  var import_minimal7 = __toESM(require_minimal2());
  function createBaseRoot6() {
    return {
      start: void 0,
      stop: void 0,
      refreshRate: void 0,
      setMagneticDeclination: void 0,
      setOffsetAngleAzimuth: void 0,
      setOffsetAngleElevation: void 0,
      setUseRotaryPosition: void 0,
      startCalibrateLong: void 0,
      startCalibrateShort: void 0,
      calibrateNext: void 0,
      calibrateCencel: void 0,
      getMeteo: void 0
    };
  }
  var Root6 = {
    encode(message, writer = import_minimal7.default.Writer.create()) {
      if (message.start !== void 0) {
        Start4.encode(message.start, writer.uint32(10).fork()).ldelim();
      }
      if (message.stop !== void 0) {
        Stop4.encode(message.stop, writer.uint32(18).fork()).ldelim();
      }
      if (message.refreshRate !== void 0) {
        SetRefreshRate2.encode(message.refreshRate, writer.uint32(26).fork()).ldelim();
      }
      if (message.setMagneticDeclination !== void 0) {
        SetMagneticDeclination.encode(message.setMagneticDeclination, writer.uint32(34).fork()).ldelim();
      }
      if (message.setOffsetAngleAzimuth !== void 0) {
        SetOffsetAngleAzimuth.encode(message.setOffsetAngleAzimuth, writer.uint32(42).fork()).ldelim();
      }
      if (message.setOffsetAngleElevation !== void 0) {
        SetOffsetAngleElevation.encode(message.setOffsetAngleElevation, writer.uint32(50).fork()).ldelim();
      }
      if (message.setUseRotaryPosition !== void 0) {
        SetUseRotaryPosition.encode(message.setUseRotaryPosition, writer.uint32(58).fork()).ldelim();
      }
      if (message.startCalibrateLong !== void 0) {
        CalibrateStartLong.encode(message.startCalibrateLong, writer.uint32(66).fork()).ldelim();
      }
      if (message.startCalibrateShort !== void 0) {
        CalibrateStartShort.encode(message.startCalibrateShort, writer.uint32(74).fork()).ldelim();
      }
      if (message.calibrateNext !== void 0) {
        CalibrateNext.encode(message.calibrateNext, writer.uint32(82).fork()).ldelim();
      }
      if (message.calibrateCencel !== void 0) {
        CalibrateCencel.encode(message.calibrateCencel, writer.uint32(90).fork()).ldelim();
      }
      if (message.getMeteo !== void 0) {
        GetMeteo4.encode(message.getMeteo, writer.uint32(98).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot6();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.start = Start4.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.stop = Stop4.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.refreshRate = SetRefreshRate2.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.setMagneticDeclination = SetMagneticDeclination.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.setOffsetAngleAzimuth = SetOffsetAngleAzimuth.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.setOffsetAngleElevation = SetOffsetAngleElevation.decode(reader, reader.uint32());
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }
            message.setUseRotaryPosition = SetUseRotaryPosition.decode(reader, reader.uint32());
            continue;
          case 8:
            if (tag !== 66) {
              break;
            }
            message.startCalibrateLong = CalibrateStartLong.decode(reader, reader.uint32());
            continue;
          case 9:
            if (tag !== 74) {
              break;
            }
            message.startCalibrateShort = CalibrateStartShort.decode(reader, reader.uint32());
            continue;
          case 10:
            if (tag !== 82) {
              break;
            }
            message.calibrateNext = CalibrateNext.decode(reader, reader.uint32());
            continue;
          case 11:
            if (tag !== 90) {
              break;
            }
            message.calibrateCencel = CalibrateCencel.decode(reader, reader.uint32());
            continue;
          case 12:
            if (tag !== 98) {
              break;
            }
            message.getMeteo = GetMeteo4.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        start: isSet7(object.start) ? Start4.fromJSON(object.start) : void 0,
        stop: isSet7(object.stop) ? Stop4.fromJSON(object.stop) : void 0,
        refreshRate: isSet7(object.refreshRate) ? SetRefreshRate2.fromJSON(object.refreshRate) : void 0,
        setMagneticDeclination: isSet7(object.setMagneticDeclination) ? SetMagneticDeclination.fromJSON(object.setMagneticDeclination) : void 0,
        setOffsetAngleAzimuth: isSet7(object.setOffsetAngleAzimuth) ? SetOffsetAngleAzimuth.fromJSON(object.setOffsetAngleAzimuth) : void 0,
        setOffsetAngleElevation: isSet7(object.setOffsetAngleElevation) ? SetOffsetAngleElevation.fromJSON(object.setOffsetAngleElevation) : void 0,
        setUseRotaryPosition: isSet7(object.setUseRotaryPosition) ? SetUseRotaryPosition.fromJSON(object.setUseRotaryPosition) : void 0,
        startCalibrateLong: isSet7(object.startCalibrateLong) ? CalibrateStartLong.fromJSON(object.startCalibrateLong) : void 0,
        startCalibrateShort: isSet7(object.startCalibrateShort) ? CalibrateStartShort.fromJSON(object.startCalibrateShort) : void 0,
        calibrateNext: isSet7(object.calibrateNext) ? CalibrateNext.fromJSON(object.calibrateNext) : void 0,
        calibrateCencel: isSet7(object.calibrateCencel) ? CalibrateCencel.fromJSON(object.calibrateCencel) : void 0,
        getMeteo: isSet7(object.getMeteo) ? GetMeteo4.fromJSON(object.getMeteo) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.start !== void 0) {
        obj.start = Start4.toJSON(message.start);
      }
      if (message.stop !== void 0) {
        obj.stop = Stop4.toJSON(message.stop);
      }
      if (message.refreshRate !== void 0) {
        obj.refreshRate = SetRefreshRate2.toJSON(message.refreshRate);
      }
      if (message.setMagneticDeclination !== void 0) {
        obj.setMagneticDeclination = SetMagneticDeclination.toJSON(message.setMagneticDeclination);
      }
      if (message.setOffsetAngleAzimuth !== void 0) {
        obj.setOffsetAngleAzimuth = SetOffsetAngleAzimuth.toJSON(message.setOffsetAngleAzimuth);
      }
      if (message.setOffsetAngleElevation !== void 0) {
        obj.setOffsetAngleElevation = SetOffsetAngleElevation.toJSON(message.setOffsetAngleElevation);
      }
      if (message.setUseRotaryPosition !== void 0) {
        obj.setUseRotaryPosition = SetUseRotaryPosition.toJSON(message.setUseRotaryPosition);
      }
      if (message.startCalibrateLong !== void 0) {
        obj.startCalibrateLong = CalibrateStartLong.toJSON(message.startCalibrateLong);
      }
      if (message.startCalibrateShort !== void 0) {
        obj.startCalibrateShort = CalibrateStartShort.toJSON(message.startCalibrateShort);
      }
      if (message.calibrateNext !== void 0) {
        obj.calibrateNext = CalibrateNext.toJSON(message.calibrateNext);
      }
      if (message.calibrateCencel !== void 0) {
        obj.calibrateCencel = CalibrateCencel.toJSON(message.calibrateCencel);
      }
      if (message.getMeteo !== void 0) {
        obj.getMeteo = GetMeteo4.toJSON(message.getMeteo);
      }
      return obj;
    },
    create(base) {
      return Root6.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot6();
      message.start = object.start !== void 0 && object.start !== null ? Start4.fromPartial(object.start) : void 0;
      message.stop = object.stop !== void 0 && object.stop !== null ? Stop4.fromPartial(object.stop) : void 0;
      message.refreshRate = object.refreshRate !== void 0 && object.refreshRate !== null ? SetRefreshRate2.fromPartial(object.refreshRate) : void 0;
      message.setMagneticDeclination = object.setMagneticDeclination !== void 0 && object.setMagneticDeclination !== null ? SetMagneticDeclination.fromPartial(object.setMagneticDeclination) : void 0;
      message.setOffsetAngleAzimuth = object.setOffsetAngleAzimuth !== void 0 && object.setOffsetAngleAzimuth !== null ? SetOffsetAngleAzimuth.fromPartial(object.setOffsetAngleAzimuth) : void 0;
      message.setOffsetAngleElevation = object.setOffsetAngleElevation !== void 0 && object.setOffsetAngleElevation !== null ? SetOffsetAngleElevation.fromPartial(object.setOffsetAngleElevation) : void 0;
      message.setUseRotaryPosition = object.setUseRotaryPosition !== void 0 && object.setUseRotaryPosition !== null ? SetUseRotaryPosition.fromPartial(object.setUseRotaryPosition) : void 0;
      message.startCalibrateLong = object.startCalibrateLong !== void 0 && object.startCalibrateLong !== null ? CalibrateStartLong.fromPartial(object.startCalibrateLong) : void 0;
      message.startCalibrateShort = object.startCalibrateShort !== void 0 && object.startCalibrateShort !== null ? CalibrateStartShort.fromPartial(object.startCalibrateShort) : void 0;
      message.calibrateNext = object.calibrateNext !== void 0 && object.calibrateNext !== null ? CalibrateNext.fromPartial(object.calibrateNext) : void 0;
      message.calibrateCencel = object.calibrateCencel !== void 0 && object.calibrateCencel !== null ? CalibrateCencel.fromPartial(object.calibrateCencel) : void 0;
      message.getMeteo = object.getMeteo !== void 0 && object.getMeteo !== null ? GetMeteo4.fromPartial(object.getMeteo) : void 0;
      return message;
    }
  };
  function createBaseStart4() {
    return {};
  }
  var Start4 = {
    encode(_5, writer = import_minimal7.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStart4();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Start4.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStart4();
      return message;
    }
  };
  function createBaseStop4() {
    return {};
  }
  var Stop4 = {
    encode(_5, writer = import_minimal7.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStop4();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Stop4.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStop4();
      return message;
    }
  };
  function createBaseGetMeteo4() {
    return {};
  }
  var GetMeteo4 = {
    encode(_5, writer = import_minimal7.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGetMeteo4();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return GetMeteo4.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseGetMeteo4();
      return message;
    }
  };
  function createBaseCalibrateStartLong() {
    return {};
  }
  var CalibrateStartLong = {
    encode(_5, writer = import_minimal7.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseCalibrateStartLong();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return CalibrateStartLong.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseCalibrateStartLong();
      return message;
    }
  };
  function createBaseCalibrateStartShort() {
    return {};
  }
  var CalibrateStartShort = {
    encode(_5, writer = import_minimal7.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseCalibrateStartShort();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return CalibrateStartShort.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseCalibrateStartShort();
      return message;
    }
  };
  function createBaseCalibrateNext() {
    return {};
  }
  var CalibrateNext = {
    encode(_5, writer = import_minimal7.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseCalibrateNext();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return CalibrateNext.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseCalibrateNext();
      return message;
    }
  };
  function createBaseCalibrateCencel() {
    return {};
  }
  var CalibrateCencel = {
    encode(_5, writer = import_minimal7.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseCalibrateCencel();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return CalibrateCencel.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseCalibrateCencel();
      return message;
    }
  };
  function createBaseSetRefreshRate2() {
    return { value: 0 };
  }
  var SetRefreshRate2 = {
    encode(message, writer = import_minimal7.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).uint32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetRefreshRate2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.uint32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet7(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = Math.round(message.value);
      }
      return obj;
    },
    create(base) {
      return SetRefreshRate2.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetRefreshRate2();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetMagneticDeclination() {
    return { value: 0 };
  }
  var SetMagneticDeclination = {
    encode(message, writer = import_minimal7.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetMagneticDeclination();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet7(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetMagneticDeclination.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetMagneticDeclination();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetOffsetAngleAzimuth() {
    return { value: 0 };
  }
  var SetOffsetAngleAzimuth = {
    encode(message, writer = import_minimal7.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetOffsetAngleAzimuth();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet7(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetOffsetAngleAzimuth.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetOffsetAngleAzimuth();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetOffsetAngleElevation() {
    return { value: 0 };
  }
  var SetOffsetAngleElevation = {
    encode(message, writer = import_minimal7.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetOffsetAngleElevation();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet7(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetOffsetAngleElevation.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetOffsetAngleElevation();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetUseRotaryPosition() {
    return { flag: false };
  }
  var SetUseRotaryPosition = {
    encode(message, writer = import_minimal7.default.Writer.create()) {
      if (message.flag !== false) {
        writer.uint32(8).bool(message.flag);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal7.default.Reader ? input2 : import_minimal7.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetUseRotaryPosition();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.flag = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { flag: isSet7(object.flag) ? globalThis.Boolean(object.flag) : false };
    },
    toJSON(message) {
      const obj = {};
      if (message.flag !== false) {
        obj.flag = message.flag;
      }
      return obj;
    },
    create(base) {
      return SetUseRotaryPosition.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetUseRotaryPosition();
      message.flag = object.flag ?? false;
      return message;
    }
  };
  function isSet7(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/index.cmd.Lrf.ts
  var index_cmd_Lrf_exports = {};
  __export(index_cmd_Lrf_exports, {
    DisableFogMode: () => DisableFogMode,
    EnableFogMode: () => EnableFogMode,
    GetMeteo: () => GetMeteo5,
    Measure: () => Measure,
    NewSession: () => NewSession,
    Root: () => Root7,
    ScanOff: () => ScanOff,
    ScanOn: () => ScanOn,
    Start: () => Start5,
    Stop: () => Stop5,
    TargetDesignatorOff: () => TargetDesignatorOff,
    TargetDesignatorOnModeA: () => TargetDesignatorOnModeA,
    TargetDesignatorOnModeB: () => TargetDesignatorOnModeB,
    setScanMode: () => setScanMode
  });

  // frontend/ts/proto/jon/jon_shared_cmd_lrf.ts
  var import_minimal8 = __toESM(require_minimal2());
  function createBaseRoot7() {
    return {
      measure: void 0,
      scanOn: void 0,
      scanOff: void 0,
      start: void 0,
      stop: void 0,
      targetDesignatorOff: void 0,
      targetDesignatorOnModeA: void 0,
      targetDesignatorOnModeB: void 0,
      enableFogMode: void 0,
      disableFogMode: void 0,
      setScanMode: void 0,
      newSession: void 0,
      getMeteo: void 0
    };
  }
  var Root7 = {
    encode(message, writer = import_minimal8.default.Writer.create()) {
      if (message.measure !== void 0) {
        Measure.encode(message.measure, writer.uint32(10).fork()).ldelim();
      }
      if (message.scanOn !== void 0) {
        ScanOn.encode(message.scanOn, writer.uint32(18).fork()).ldelim();
      }
      if (message.scanOff !== void 0) {
        ScanOff.encode(message.scanOff, writer.uint32(26).fork()).ldelim();
      }
      if (message.start !== void 0) {
        Start5.encode(message.start, writer.uint32(34).fork()).ldelim();
      }
      if (message.stop !== void 0) {
        Stop5.encode(message.stop, writer.uint32(42).fork()).ldelim();
      }
      if (message.targetDesignatorOff !== void 0) {
        TargetDesignatorOff.encode(message.targetDesignatorOff, writer.uint32(50).fork()).ldelim();
      }
      if (message.targetDesignatorOnModeA !== void 0) {
        TargetDesignatorOnModeA.encode(message.targetDesignatorOnModeA, writer.uint32(58).fork()).ldelim();
      }
      if (message.targetDesignatorOnModeB !== void 0) {
        TargetDesignatorOnModeB.encode(message.targetDesignatorOnModeB, writer.uint32(66).fork()).ldelim();
      }
      if (message.enableFogMode !== void 0) {
        EnableFogMode.encode(message.enableFogMode, writer.uint32(74).fork()).ldelim();
      }
      if (message.disableFogMode !== void 0) {
        DisableFogMode.encode(message.disableFogMode, writer.uint32(82).fork()).ldelim();
      }
      if (message.setScanMode !== void 0) {
        setScanMode.encode(message.setScanMode, writer.uint32(90).fork()).ldelim();
      }
      if (message.newSession !== void 0) {
        NewSession.encode(message.newSession, writer.uint32(98).fork()).ldelim();
      }
      if (message.getMeteo !== void 0) {
        GetMeteo5.encode(message.getMeteo, writer.uint32(106).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot7();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.measure = Measure.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.scanOn = ScanOn.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.scanOff = ScanOff.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.start = Start5.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.stop = Stop5.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.targetDesignatorOff = TargetDesignatorOff.decode(reader, reader.uint32());
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }
            message.targetDesignatorOnModeA = TargetDesignatorOnModeA.decode(reader, reader.uint32());
            continue;
          case 8:
            if (tag !== 66) {
              break;
            }
            message.targetDesignatorOnModeB = TargetDesignatorOnModeB.decode(reader, reader.uint32());
            continue;
          case 9:
            if (tag !== 74) {
              break;
            }
            message.enableFogMode = EnableFogMode.decode(reader, reader.uint32());
            continue;
          case 10:
            if (tag !== 82) {
              break;
            }
            message.disableFogMode = DisableFogMode.decode(reader, reader.uint32());
            continue;
          case 11:
            if (tag !== 90) {
              break;
            }
            message.setScanMode = setScanMode.decode(reader, reader.uint32());
            continue;
          case 12:
            if (tag !== 98) {
              break;
            }
            message.newSession = NewSession.decode(reader, reader.uint32());
            continue;
          case 13:
            if (tag !== 106) {
              break;
            }
            message.getMeteo = GetMeteo5.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        measure: isSet8(object.measure) ? Measure.fromJSON(object.measure) : void 0,
        scanOn: isSet8(object.scanOn) ? ScanOn.fromJSON(object.scanOn) : void 0,
        scanOff: isSet8(object.scanOff) ? ScanOff.fromJSON(object.scanOff) : void 0,
        start: isSet8(object.start) ? Start5.fromJSON(object.start) : void 0,
        stop: isSet8(object.stop) ? Stop5.fromJSON(object.stop) : void 0,
        targetDesignatorOff: isSet8(object.targetDesignatorOff) ? TargetDesignatorOff.fromJSON(object.targetDesignatorOff) : void 0,
        targetDesignatorOnModeA: isSet8(object.targetDesignatorOnModeA) ? TargetDesignatorOnModeA.fromJSON(object.targetDesignatorOnModeA) : void 0,
        targetDesignatorOnModeB: isSet8(object.targetDesignatorOnModeB) ? TargetDesignatorOnModeB.fromJSON(object.targetDesignatorOnModeB) : void 0,
        enableFogMode: isSet8(object.enableFogMode) ? EnableFogMode.fromJSON(object.enableFogMode) : void 0,
        disableFogMode: isSet8(object.disableFogMode) ? DisableFogMode.fromJSON(object.disableFogMode) : void 0,
        setScanMode: isSet8(object.setScanMode) ? setScanMode.fromJSON(object.setScanMode) : void 0,
        newSession: isSet8(object.newSession) ? NewSession.fromJSON(object.newSession) : void 0,
        getMeteo: isSet8(object.getMeteo) ? GetMeteo5.fromJSON(object.getMeteo) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.measure !== void 0) {
        obj.measure = Measure.toJSON(message.measure);
      }
      if (message.scanOn !== void 0) {
        obj.scanOn = ScanOn.toJSON(message.scanOn);
      }
      if (message.scanOff !== void 0) {
        obj.scanOff = ScanOff.toJSON(message.scanOff);
      }
      if (message.start !== void 0) {
        obj.start = Start5.toJSON(message.start);
      }
      if (message.stop !== void 0) {
        obj.stop = Stop5.toJSON(message.stop);
      }
      if (message.targetDesignatorOff !== void 0) {
        obj.targetDesignatorOff = TargetDesignatorOff.toJSON(message.targetDesignatorOff);
      }
      if (message.targetDesignatorOnModeA !== void 0) {
        obj.targetDesignatorOnModeA = TargetDesignatorOnModeA.toJSON(message.targetDesignatorOnModeA);
      }
      if (message.targetDesignatorOnModeB !== void 0) {
        obj.targetDesignatorOnModeB = TargetDesignatorOnModeB.toJSON(message.targetDesignatorOnModeB);
      }
      if (message.enableFogMode !== void 0) {
        obj.enableFogMode = EnableFogMode.toJSON(message.enableFogMode);
      }
      if (message.disableFogMode !== void 0) {
        obj.disableFogMode = DisableFogMode.toJSON(message.disableFogMode);
      }
      if (message.setScanMode !== void 0) {
        obj.setScanMode = setScanMode.toJSON(message.setScanMode);
      }
      if (message.newSession !== void 0) {
        obj.newSession = NewSession.toJSON(message.newSession);
      }
      if (message.getMeteo !== void 0) {
        obj.getMeteo = GetMeteo5.toJSON(message.getMeteo);
      }
      return obj;
    },
    create(base) {
      return Root7.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot7();
      message.measure = object.measure !== void 0 && object.measure !== null ? Measure.fromPartial(object.measure) : void 0;
      message.scanOn = object.scanOn !== void 0 && object.scanOn !== null ? ScanOn.fromPartial(object.scanOn) : void 0;
      message.scanOff = object.scanOff !== void 0 && object.scanOff !== null ? ScanOff.fromPartial(object.scanOff) : void 0;
      message.start = object.start !== void 0 && object.start !== null ? Start5.fromPartial(object.start) : void 0;
      message.stop = object.stop !== void 0 && object.stop !== null ? Stop5.fromPartial(object.stop) : void 0;
      message.targetDesignatorOff = object.targetDesignatorOff !== void 0 && object.targetDesignatorOff !== null ? TargetDesignatorOff.fromPartial(object.targetDesignatorOff) : void 0;
      message.targetDesignatorOnModeA = object.targetDesignatorOnModeA !== void 0 && object.targetDesignatorOnModeA !== null ? TargetDesignatorOnModeA.fromPartial(object.targetDesignatorOnModeA) : void 0;
      message.targetDesignatorOnModeB = object.targetDesignatorOnModeB !== void 0 && object.targetDesignatorOnModeB !== null ? TargetDesignatorOnModeB.fromPartial(object.targetDesignatorOnModeB) : void 0;
      message.enableFogMode = object.enableFogMode !== void 0 && object.enableFogMode !== null ? EnableFogMode.fromPartial(object.enableFogMode) : void 0;
      message.disableFogMode = object.disableFogMode !== void 0 && object.disableFogMode !== null ? DisableFogMode.fromPartial(object.disableFogMode) : void 0;
      message.setScanMode = object.setScanMode !== void 0 && object.setScanMode !== null ? setScanMode.fromPartial(object.setScanMode) : void 0;
      message.newSession = object.newSession !== void 0 && object.newSession !== null ? NewSession.fromPartial(object.newSession) : void 0;
      message.getMeteo = object.getMeteo !== void 0 && object.getMeteo !== null ? GetMeteo5.fromPartial(object.getMeteo) : void 0;
      return message;
    }
  };
  function createBaseStart5() {
    return {};
  }
  var Start5 = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStart5();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Start5.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStart5();
      return message;
    }
  };
  function createBaseStop5() {
    return {};
  }
  var Stop5 = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStop5();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Stop5.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStop5();
      return message;
    }
  };
  function createBaseMeasure() {
    return {};
  }
  var Measure = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseMeasure();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Measure.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseMeasure();
      return message;
    }
  };
  function createBaseScanOn() {
    return {};
  }
  var ScanOn = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseScanOn();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return ScanOn.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseScanOn();
      return message;
    }
  };
  function createBaseScanOff() {
    return {};
  }
  var ScanOff = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseScanOff();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return ScanOff.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseScanOff();
      return message;
    }
  };
  function createBaseTargetDesignatorOff() {
    return {};
  }
  var TargetDesignatorOff = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseTargetDesignatorOff();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return TargetDesignatorOff.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseTargetDesignatorOff();
      return message;
    }
  };
  function createBaseTargetDesignatorOnModeA() {
    return {};
  }
  var TargetDesignatorOnModeA = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseTargetDesignatorOnModeA();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return TargetDesignatorOnModeA.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseTargetDesignatorOnModeA();
      return message;
    }
  };
  function createBaseTargetDesignatorOnModeB() {
    return {};
  }
  var TargetDesignatorOnModeB = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseTargetDesignatorOnModeB();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return TargetDesignatorOnModeB.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseTargetDesignatorOnModeB();
      return message;
    }
  };
  function createBaseEnableFogMode() {
    return {};
  }
  var EnableFogMode = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseEnableFogMode();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return EnableFogMode.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseEnableFogMode();
      return message;
    }
  };
  function createBaseDisableFogMode() {
    return {};
  }
  var DisableFogMode = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseDisableFogMode();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return DisableFogMode.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseDisableFogMode();
      return message;
    }
  };
  function createBaseGetMeteo5() {
    return {};
  }
  var GetMeteo5 = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGetMeteo5();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return GetMeteo5.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseGetMeteo5();
      return message;
    }
  };
  function createBasesetScanMode() {
    return { mode: 0 };
  }
  var setScanMode = {
    encode(message, writer = import_minimal8.default.Writer.create()) {
      if (message.mode !== 0) {
        writer.uint32(8).int32(message.mode);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBasesetScanMode();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.mode = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { mode: isSet8(object.mode) ? jonGuiDataLrfScanModesFromJSON(object.mode) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.mode !== 0) {
        obj.mode = jonGuiDataLrfScanModesToJSON(message.mode);
      }
      return obj;
    },
    create(base) {
      return setScanMode.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBasesetScanMode();
      message.mode = object.mode ?? 0;
      return message;
    }
  };
  function createBaseNewSession() {
    return {};
  }
  var NewSession = {
    encode(_5, writer = import_minimal8.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal8.default.Reader ? input2 : import_minimal8.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseNewSession();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return NewSession.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseNewSession();
      return message;
    }
  };
  function isSet8(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_cmd_day_camera.ts
  var import_minimal9 = __toESM(require_minimal2());
  function createBaseSetValue2() {
    return { value: 0 };
  }
  var SetValue2 = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetValue2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet9(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetValue2.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetValue2();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseMove2() {
    return { targetValue: 0, speed: 0 };
  }
  var Move2 = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.targetValue !== 0) {
        writer.uint32(13).float(message.targetValue);
      }
      if (message.speed !== 0) {
        writer.uint32(21).float(message.speed);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseMove2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.targetValue = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.speed = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        targetValue: isSet9(object.targetValue) ? globalThis.Number(object.targetValue) : 0,
        speed: isSet9(object.speed) ? globalThis.Number(object.speed) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.targetValue !== 0) {
        obj.targetValue = message.targetValue;
      }
      if (message.speed !== 0) {
        obj.speed = message.speed;
      }
      return obj;
    },
    create(base) {
      return Move2.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseMove2();
      message.targetValue = object.targetValue ?? 0;
      message.speed = object.speed ?? 0;
      return message;
    }
  };
  function createBaseRoot8() {
    return {
      focus: void 0,
      zoom: void 0,
      setExposure: void 0,
      setGain: void 0,
      setIris: void 0,
      setAutoFocus: void 0,
      setRecording: void 0,
      setInfraRedFilter: void 0,
      start: void 0,
      stop: void 0,
      photo: void 0,
      setAutoIris: void 0,
      syncZoom: void 0,
      getPos: void 0,
      haltAll: void 0,
      getMeteo: void 0
    };
  }
  var Root8 = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.focus !== void 0) {
        Focus2.encode(message.focus, writer.uint32(10).fork()).ldelim();
      }
      if (message.zoom !== void 0) {
        Zoom2.encode(message.zoom, writer.uint32(18).fork()).ldelim();
      }
      if (message.setExposure !== void 0) {
        SetExposure.encode(message.setExposure, writer.uint32(26).fork()).ldelim();
      }
      if (message.setGain !== void 0) {
        SetGain.encode(message.setGain, writer.uint32(34).fork()).ldelim();
      }
      if (message.setIris !== void 0) {
        SetIris.encode(message.setIris, writer.uint32(42).fork()).ldelim();
      }
      if (message.setAutoFocus !== void 0) {
        SetAutoFocus2.encode(message.setAutoFocus, writer.uint32(50).fork()).ldelim();
      }
      if (message.setRecording !== void 0) {
        SetRecording2.encode(message.setRecording, writer.uint32(58).fork()).ldelim();
      }
      if (message.setInfraRedFilter !== void 0) {
        SetInfraRedFilter.encode(message.setInfraRedFilter, writer.uint32(66).fork()).ldelim();
      }
      if (message.start !== void 0) {
        Start6.encode(message.start, writer.uint32(74).fork()).ldelim();
      }
      if (message.stop !== void 0) {
        Stop6.encode(message.stop, writer.uint32(82).fork()).ldelim();
      }
      if (message.photo !== void 0) {
        Photo2.encode(message.photo, writer.uint32(90).fork()).ldelim();
      }
      if (message.setAutoIris !== void 0) {
        SetAutoIris.encode(message.setAutoIris, writer.uint32(98).fork()).ldelim();
      }
      if (message.syncZoom !== void 0) {
        SyncZoomToDayCamera.encode(message.syncZoom, writer.uint32(106).fork()).ldelim();
      }
      if (message.getPos !== void 0) {
        GetPos2.encode(message.getPos, writer.uint32(114).fork()).ldelim();
      }
      if (message.haltAll !== void 0) {
        HaltAll2.encode(message.haltAll, writer.uint32(122).fork()).ldelim();
      }
      if (message.getMeteo !== void 0) {
        GetMeteo6.encode(message.getMeteo, writer.uint32(130).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot8();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.focus = Focus2.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.zoom = Zoom2.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.setExposure = SetExposure.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.setGain = SetGain.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.setIris = SetIris.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.setAutoFocus = SetAutoFocus2.decode(reader, reader.uint32());
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }
            message.setRecording = SetRecording2.decode(reader, reader.uint32());
            continue;
          case 8:
            if (tag !== 66) {
              break;
            }
            message.setInfraRedFilter = SetInfraRedFilter.decode(reader, reader.uint32());
            continue;
          case 9:
            if (tag !== 74) {
              break;
            }
            message.start = Start6.decode(reader, reader.uint32());
            continue;
          case 10:
            if (tag !== 82) {
              break;
            }
            message.stop = Stop6.decode(reader, reader.uint32());
            continue;
          case 11:
            if (tag !== 90) {
              break;
            }
            message.photo = Photo2.decode(reader, reader.uint32());
            continue;
          case 12:
            if (tag !== 98) {
              break;
            }
            message.setAutoIris = SetAutoIris.decode(reader, reader.uint32());
            continue;
          case 13:
            if (tag !== 106) {
              break;
            }
            message.syncZoom = SyncZoomToDayCamera.decode(reader, reader.uint32());
            continue;
          case 14:
            if (tag !== 114) {
              break;
            }
            message.getPos = GetPos2.decode(reader, reader.uint32());
            continue;
          case 15:
            if (tag !== 122) {
              break;
            }
            message.haltAll = HaltAll2.decode(reader, reader.uint32());
            continue;
          case 16:
            if (tag !== 130) {
              break;
            }
            message.getMeteo = GetMeteo6.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        focus: isSet9(object.focus) ? Focus2.fromJSON(object.focus) : void 0,
        zoom: isSet9(object.zoom) ? Zoom2.fromJSON(object.zoom) : void 0,
        setExposure: isSet9(object.setExposure) ? SetExposure.fromJSON(object.setExposure) : void 0,
        setGain: isSet9(object.setGain) ? SetGain.fromJSON(object.setGain) : void 0,
        setIris: isSet9(object.setIris) ? SetIris.fromJSON(object.setIris) : void 0,
        setAutoFocus: isSet9(object.setAutoFocus) ? SetAutoFocus2.fromJSON(object.setAutoFocus) : void 0,
        setRecording: isSet9(object.setRecording) ? SetRecording2.fromJSON(object.setRecording) : void 0,
        setInfraRedFilter: isSet9(object.setInfraRedFilter) ? SetInfraRedFilter.fromJSON(object.setInfraRedFilter) : void 0,
        start: isSet9(object.start) ? Start6.fromJSON(object.start) : void 0,
        stop: isSet9(object.stop) ? Stop6.fromJSON(object.stop) : void 0,
        photo: isSet9(object.photo) ? Photo2.fromJSON(object.photo) : void 0,
        setAutoIris: isSet9(object.setAutoIris) ? SetAutoIris.fromJSON(object.setAutoIris) : void 0,
        syncZoom: isSet9(object.syncZoom) ? SyncZoomToDayCamera.fromJSON(object.syncZoom) : void 0,
        getPos: isSet9(object.getPos) ? GetPos2.fromJSON(object.getPos) : void 0,
        haltAll: isSet9(object.haltAll) ? HaltAll2.fromJSON(object.haltAll) : void 0,
        getMeteo: isSet9(object.getMeteo) ? GetMeteo6.fromJSON(object.getMeteo) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.focus !== void 0) {
        obj.focus = Focus2.toJSON(message.focus);
      }
      if (message.zoom !== void 0) {
        obj.zoom = Zoom2.toJSON(message.zoom);
      }
      if (message.setExposure !== void 0) {
        obj.setExposure = SetExposure.toJSON(message.setExposure);
      }
      if (message.setGain !== void 0) {
        obj.setGain = SetGain.toJSON(message.setGain);
      }
      if (message.setIris !== void 0) {
        obj.setIris = SetIris.toJSON(message.setIris);
      }
      if (message.setAutoFocus !== void 0) {
        obj.setAutoFocus = SetAutoFocus2.toJSON(message.setAutoFocus);
      }
      if (message.setRecording !== void 0) {
        obj.setRecording = SetRecording2.toJSON(message.setRecording);
      }
      if (message.setInfraRedFilter !== void 0) {
        obj.setInfraRedFilter = SetInfraRedFilter.toJSON(message.setInfraRedFilter);
      }
      if (message.start !== void 0) {
        obj.start = Start6.toJSON(message.start);
      }
      if (message.stop !== void 0) {
        obj.stop = Stop6.toJSON(message.stop);
      }
      if (message.photo !== void 0) {
        obj.photo = Photo2.toJSON(message.photo);
      }
      if (message.setAutoIris !== void 0) {
        obj.setAutoIris = SetAutoIris.toJSON(message.setAutoIris);
      }
      if (message.syncZoom !== void 0) {
        obj.syncZoom = SyncZoomToDayCamera.toJSON(message.syncZoom);
      }
      if (message.getPos !== void 0) {
        obj.getPos = GetPos2.toJSON(message.getPos);
      }
      if (message.haltAll !== void 0) {
        obj.haltAll = HaltAll2.toJSON(message.haltAll);
      }
      if (message.getMeteo !== void 0) {
        obj.getMeteo = GetMeteo6.toJSON(message.getMeteo);
      }
      return obj;
    },
    create(base) {
      return Root8.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot8();
      message.focus = object.focus !== void 0 && object.focus !== null ? Focus2.fromPartial(object.focus) : void 0;
      message.zoom = object.zoom !== void 0 && object.zoom !== null ? Zoom2.fromPartial(object.zoom) : void 0;
      message.setExposure = object.setExposure !== void 0 && object.setExposure !== null ? SetExposure.fromPartial(object.setExposure) : void 0;
      message.setGain = object.setGain !== void 0 && object.setGain !== null ? SetGain.fromPartial(object.setGain) : void 0;
      message.setIris = object.setIris !== void 0 && object.setIris !== null ? SetIris.fromPartial(object.setIris) : void 0;
      message.setAutoFocus = object.setAutoFocus !== void 0 && object.setAutoFocus !== null ? SetAutoFocus2.fromPartial(object.setAutoFocus) : void 0;
      message.setRecording = object.setRecording !== void 0 && object.setRecording !== null ? SetRecording2.fromPartial(object.setRecording) : void 0;
      message.setInfraRedFilter = object.setInfraRedFilter !== void 0 && object.setInfraRedFilter !== null ? SetInfraRedFilter.fromPartial(object.setInfraRedFilter) : void 0;
      message.start = object.start !== void 0 && object.start !== null ? Start6.fromPartial(object.start) : void 0;
      message.stop = object.stop !== void 0 && object.stop !== null ? Stop6.fromPartial(object.stop) : void 0;
      message.photo = object.photo !== void 0 && object.photo !== null ? Photo2.fromPartial(object.photo) : void 0;
      message.setAutoIris = object.setAutoIris !== void 0 && object.setAutoIris !== null ? SetAutoIris.fromPartial(object.setAutoIris) : void 0;
      message.syncZoom = object.syncZoom !== void 0 && object.syncZoom !== null ? SyncZoomToDayCamera.fromPartial(object.syncZoom) : void 0;
      message.getPos = object.getPos !== void 0 && object.getPos !== null ? GetPos2.fromPartial(object.getPos) : void 0;
      message.haltAll = object.haltAll !== void 0 && object.haltAll !== null ? HaltAll2.fromPartial(object.haltAll) : void 0;
      message.getMeteo = object.getMeteo !== void 0 && object.getMeteo !== null ? GetMeteo6.fromPartial(object.getMeteo) : void 0;
      return message;
    }
  };
  function createBaseGetPos2() {
    return {};
  }
  var GetPos2 = {
    encode(_5, writer = import_minimal9.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGetPos2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return GetPos2.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseGetPos2();
      return message;
    }
  };
  function createBaseHaltAll2() {
    return {};
  }
  var HaltAll2 = {
    encode(_5, writer = import_minimal9.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseHaltAll2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return HaltAll2.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseHaltAll2();
      return message;
    }
  };
  function createBaseFocus2() {
    return { setValue: void 0, move: void 0, halt: void 0 };
  }
  var Focus2 = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.setValue !== void 0) {
        SetValue2.encode(message.setValue, writer.uint32(10).fork()).ldelim();
      }
      if (message.move !== void 0) {
        Move2.encode(message.move, writer.uint32(18).fork()).ldelim();
      }
      if (message.halt !== void 0) {
        Halt3.encode(message.halt, writer.uint32(26).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseFocus2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.setValue = SetValue2.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.move = Move2.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.halt = Halt3.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        setValue: isSet9(object.setValue) ? SetValue2.fromJSON(object.setValue) : void 0,
        move: isSet9(object.move) ? Move2.fromJSON(object.move) : void 0,
        halt: isSet9(object.halt) ? Halt3.fromJSON(object.halt) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.setValue !== void 0) {
        obj.setValue = SetValue2.toJSON(message.setValue);
      }
      if (message.move !== void 0) {
        obj.move = Move2.toJSON(message.move);
      }
      if (message.halt !== void 0) {
        obj.halt = Halt3.toJSON(message.halt);
      }
      return obj;
    },
    create(base) {
      return Focus2.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseFocus2();
      message.setValue = object.setValue !== void 0 && object.setValue !== null ? SetValue2.fromPartial(object.setValue) : void 0;
      message.move = object.move !== void 0 && object.move !== null ? Move2.fromPartial(object.move) : void 0;
      message.halt = object.halt !== void 0 && object.halt !== null ? Halt3.fromPartial(object.halt) : void 0;
      return message;
    }
  };
  function createBaseZoom2() {
    return {
      setValue: void 0,
      move: void 0,
      halt: void 0,
      setZoomTableValue: void 0,
      nextZoomTablePos: void 0,
      prevZoomTablePos: void 0
    };
  }
  var Zoom2 = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.setValue !== void 0) {
        SetValue2.encode(message.setValue, writer.uint32(10).fork()).ldelim();
      }
      if (message.move !== void 0) {
        Move2.encode(message.move, writer.uint32(18).fork()).ldelim();
      }
      if (message.halt !== void 0) {
        Halt3.encode(message.halt, writer.uint32(26).fork()).ldelim();
      }
      if (message.setZoomTableValue !== void 0) {
        SetZoomTableValue2.encode(message.setZoomTableValue, writer.uint32(34).fork()).ldelim();
      }
      if (message.nextZoomTablePos !== void 0) {
        NextZoomTablePos2.encode(message.nextZoomTablePos, writer.uint32(42).fork()).ldelim();
      }
      if (message.prevZoomTablePos !== void 0) {
        PrevZoomTablePos2.encode(message.prevZoomTablePos, writer.uint32(50).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseZoom2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.setValue = SetValue2.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.move = Move2.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.halt = Halt3.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.setZoomTableValue = SetZoomTableValue2.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.nextZoomTablePos = NextZoomTablePos2.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.prevZoomTablePos = PrevZoomTablePos2.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        setValue: isSet9(object.setValue) ? SetValue2.fromJSON(object.setValue) : void 0,
        move: isSet9(object.move) ? Move2.fromJSON(object.move) : void 0,
        halt: isSet9(object.halt) ? Halt3.fromJSON(object.halt) : void 0,
        setZoomTableValue: isSet9(object.setZoomTableValue) ? SetZoomTableValue2.fromJSON(object.setZoomTableValue) : void 0,
        nextZoomTablePos: isSet9(object.nextZoomTablePos) ? NextZoomTablePos2.fromJSON(object.nextZoomTablePos) : void 0,
        prevZoomTablePos: isSet9(object.prevZoomTablePos) ? PrevZoomTablePos2.fromJSON(object.prevZoomTablePos) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.setValue !== void 0) {
        obj.setValue = SetValue2.toJSON(message.setValue);
      }
      if (message.move !== void 0) {
        obj.move = Move2.toJSON(message.move);
      }
      if (message.halt !== void 0) {
        obj.halt = Halt3.toJSON(message.halt);
      }
      if (message.setZoomTableValue !== void 0) {
        obj.setZoomTableValue = SetZoomTableValue2.toJSON(message.setZoomTableValue);
      }
      if (message.nextZoomTablePos !== void 0) {
        obj.nextZoomTablePos = NextZoomTablePos2.toJSON(message.nextZoomTablePos);
      }
      if (message.prevZoomTablePos !== void 0) {
        obj.prevZoomTablePos = PrevZoomTablePos2.toJSON(message.prevZoomTablePos);
      }
      return obj;
    },
    create(base) {
      return Zoom2.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseZoom2();
      message.setValue = object.setValue !== void 0 && object.setValue !== null ? SetValue2.fromPartial(object.setValue) : void 0;
      message.move = object.move !== void 0 && object.move !== null ? Move2.fromPartial(object.move) : void 0;
      message.halt = object.halt !== void 0 && object.halt !== null ? Halt3.fromPartial(object.halt) : void 0;
      message.setZoomTableValue = object.setZoomTableValue !== void 0 && object.setZoomTableValue !== null ? SetZoomTableValue2.fromPartial(object.setZoomTableValue) : void 0;
      message.nextZoomTablePos = object.nextZoomTablePos !== void 0 && object.nextZoomTablePos !== null ? NextZoomTablePos2.fromPartial(object.nextZoomTablePos) : void 0;
      message.prevZoomTablePos = object.prevZoomTablePos !== void 0 && object.prevZoomTablePos !== null ? PrevZoomTablePos2.fromPartial(object.prevZoomTablePos) : void 0;
      return message;
    }
  };
  function createBaseNextZoomTablePos2() {
    return {};
  }
  var NextZoomTablePos2 = {
    encode(_5, writer = import_minimal9.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseNextZoomTablePos2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return NextZoomTablePos2.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseNextZoomTablePos2();
      return message;
    }
  };
  function createBasePrevZoomTablePos2() {
    return {};
  }
  var PrevZoomTablePos2 = {
    encode(_5, writer = import_minimal9.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBasePrevZoomTablePos2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return PrevZoomTablePos2.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBasePrevZoomTablePos2();
      return message;
    }
  };
  function createBaseSetExposure() {
    return { value: 0 };
  }
  var SetExposure = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetExposure();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet9(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetExposure.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetExposure();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetGain() {
    return { value: 0 };
  }
  var SetGain = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetGain();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet9(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetGain.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetGain();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetIris() {
    return { value: 0 };
  }
  var SetIris = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(13).float(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetIris();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.value = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet9(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetIris.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetIris();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetAutoFocus2() {
    return { value: false };
  }
  var SetAutoFocus2 = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.value !== false) {
        writer.uint32(8).bool(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetAutoFocus2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet9(object.value) ? globalThis.Boolean(object.value) : false };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== false) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetAutoFocus2.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetAutoFocus2();
      message.value = object.value ?? false;
      return message;
    }
  };
  function createBaseSetRecording2() {
    return { value: false };
  }
  var SetRecording2 = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.value !== false) {
        writer.uint32(8).bool(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetRecording2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet9(object.value) ? globalThis.Boolean(object.value) : false };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== false) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetRecording2.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetRecording2();
      message.value = object.value ?? false;
      return message;
    }
  };
  function createBaseSetInfraRedFilter() {
    return { value: false };
  }
  var SetInfraRedFilter = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.value !== false) {
        writer.uint32(8).bool(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetInfraRedFilter();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet9(object.value) ? globalThis.Boolean(object.value) : false };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== false) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetInfraRedFilter.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetInfraRedFilter();
      message.value = object.value ?? false;
      return message;
    }
  };
  function createBaseSetAutoIris() {
    return { value: false };
  }
  var SetAutoIris = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.value !== false) {
        writer.uint32(8).bool(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetAutoIris();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet9(object.value) ? globalThis.Boolean(object.value) : false };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== false) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SetAutoIris.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetAutoIris();
      message.value = object.value ?? false;
      return message;
    }
  };
  function createBaseSyncZoomToDayCamera() {
    return { value: false };
  }
  var SyncZoomToDayCamera = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.value !== false) {
        writer.uint32(8).bool(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSyncZoomToDayCamera();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet9(object.value) ? globalThis.Boolean(object.value) : false };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== false) {
        obj.value = message.value;
      }
      return obj;
    },
    create(base) {
      return SyncZoomToDayCamera.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSyncZoomToDayCamera();
      message.value = object.value ?? false;
      return message;
    }
  };
  function createBaseSetZoomTableValue2() {
    return { value: 0 };
  }
  var SetZoomTableValue2 = {
    encode(message, writer = import_minimal9.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetZoomTableValue2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet9(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = Math.round(message.value);
      }
      return obj;
    },
    create(base) {
      return SetZoomTableValue2.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetZoomTableValue2();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseStop6() {
    return {};
  }
  var Stop6 = {
    encode(_5, writer = import_minimal9.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStop6();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Stop6.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStop6();
      return message;
    }
  };
  function createBaseStart6() {
    return {};
  }
  var Start6 = {
    encode(_5, writer = import_minimal9.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStart6();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Start6.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStart6();
      return message;
    }
  };
  function createBasePhoto2() {
    return {};
  }
  var Photo2 = {
    encode(_5, writer = import_minimal9.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBasePhoto2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Photo2.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBasePhoto2();
      return message;
    }
  };
  function createBaseHalt3() {
    return {};
  }
  var Halt3 = {
    encode(_5, writer = import_minimal9.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseHalt3();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Halt3.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseHalt3();
      return message;
    }
  };
  function createBaseGetMeteo6() {
    return {};
  }
  var GetMeteo6 = {
    encode(_5, writer = import_minimal9.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal9.default.Reader ? input2 : import_minimal9.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGetMeteo6();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return GetMeteo6.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseGetMeteo6();
      return message;
    }
  };
  function isSet9(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_cmd_lrf_align.ts
  var import_minimal10 = __toESM(require_minimal2());
  function createBaseRoot9() {
    return { day: void 0, heat: void 0 };
  }
  var Root9 = {
    encode(message, writer = import_minimal10.default.Writer.create()) {
      if (message.day !== void 0) {
        Offsets.encode(message.day, writer.uint32(10).fork()).ldelim();
      }
      if (message.heat !== void 0) {
        Offsets.encode(message.heat, writer.uint32(18).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal10.default.Reader ? input2 : import_minimal10.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot9();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.day = Offsets.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.heat = Offsets.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        day: isSet10(object.day) ? Offsets.fromJSON(object.day) : void 0,
        heat: isSet10(object.heat) ? Offsets.fromJSON(object.heat) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.day !== void 0) {
        obj.day = Offsets.toJSON(message.day);
      }
      if (message.heat !== void 0) {
        obj.heat = Offsets.toJSON(message.heat);
      }
      return obj;
    },
    create(base) {
      return Root9.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot9();
      message.day = object.day !== void 0 && object.day !== null ? Offsets.fromPartial(object.day) : void 0;
      message.heat = object.heat !== void 0 && object.heat !== null ? Offsets.fromPartial(object.heat) : void 0;
      return message;
    }
  };
  function createBaseOffsets() {
    return { set: void 0, save: void 0, reset: void 0, shift: void 0 };
  }
  var Offsets = {
    encode(message, writer = import_minimal10.default.Writer.create()) {
      if (message.set !== void 0) {
        SetOffsets.encode(message.set, writer.uint32(10).fork()).ldelim();
      }
      if (message.save !== void 0) {
        SaveOffsets.encode(message.save, writer.uint32(18).fork()).ldelim();
      }
      if (message.reset !== void 0) {
        ResetOffsets.encode(message.reset, writer.uint32(26).fork()).ldelim();
      }
      if (message.shift !== void 0) {
        ShiftOffsetsBy.encode(message.shift, writer.uint32(34).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal10.default.Reader ? input2 : import_minimal10.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseOffsets();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.set = SetOffsets.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.save = SaveOffsets.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.reset = ResetOffsets.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.shift = ShiftOffsetsBy.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        set: isSet10(object.set) ? SetOffsets.fromJSON(object.set) : void 0,
        save: isSet10(object.save) ? SaveOffsets.fromJSON(object.save) : void 0,
        reset: isSet10(object.reset) ? ResetOffsets.fromJSON(object.reset) : void 0,
        shift: isSet10(object.shift) ? ShiftOffsetsBy.fromJSON(object.shift) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.set !== void 0) {
        obj.set = SetOffsets.toJSON(message.set);
      }
      if (message.save !== void 0) {
        obj.save = SaveOffsets.toJSON(message.save);
      }
      if (message.reset !== void 0) {
        obj.reset = ResetOffsets.toJSON(message.reset);
      }
      if (message.shift !== void 0) {
        obj.shift = ShiftOffsetsBy.toJSON(message.shift);
      }
      return obj;
    },
    create(base) {
      return Offsets.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseOffsets();
      message.set = object.set !== void 0 && object.set !== null ? SetOffsets.fromPartial(object.set) : void 0;
      message.save = object.save !== void 0 && object.save !== null ? SaveOffsets.fromPartial(object.save) : void 0;
      message.reset = object.reset !== void 0 && object.reset !== null ? ResetOffsets.fromPartial(object.reset) : void 0;
      message.shift = object.shift !== void 0 && object.shift !== null ? ShiftOffsetsBy.fromPartial(object.shift) : void 0;
      return message;
    }
  };
  function createBaseSetOffsets() {
    return { x: 0, y: 0 };
  }
  var SetOffsets = {
    encode(message, writer = import_minimal10.default.Writer.create()) {
      if (message.x !== 0) {
        writer.uint32(8).int32(message.x);
      }
      if (message.y !== 0) {
        writer.uint32(16).int32(message.y);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal10.default.Reader ? input2 : import_minimal10.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetOffsets();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.x = reader.int32();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.y = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        x: isSet10(object.x) ? globalThis.Number(object.x) : 0,
        y: isSet10(object.y) ? globalThis.Number(object.y) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.x !== 0) {
        obj.x = Math.round(message.x);
      }
      if (message.y !== 0) {
        obj.y = Math.round(message.y);
      }
      return obj;
    },
    create(base) {
      return SetOffsets.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetOffsets();
      message.x = object.x ?? 0;
      message.y = object.y ?? 0;
      return message;
    }
  };
  function createBaseShiftOffsetsBy() {
    return { x: 0, y: 0 };
  }
  var ShiftOffsetsBy = {
    encode(message, writer = import_minimal10.default.Writer.create()) {
      if (message.x !== 0) {
        writer.uint32(8).int32(message.x);
      }
      if (message.y !== 0) {
        writer.uint32(16).int32(message.y);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal10.default.Reader ? input2 : import_minimal10.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseShiftOffsetsBy();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.x = reader.int32();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.y = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        x: isSet10(object.x) ? globalThis.Number(object.x) : 0,
        y: isSet10(object.y) ? globalThis.Number(object.y) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.x !== 0) {
        obj.x = Math.round(message.x);
      }
      if (message.y !== 0) {
        obj.y = Math.round(message.y);
      }
      return obj;
    },
    create(base) {
      return ShiftOffsetsBy.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseShiftOffsetsBy();
      message.x = object.x ?? 0;
      message.y = object.y ?? 0;
      return message;
    }
  };
  function createBaseResetOffsets() {
    return {};
  }
  var ResetOffsets = {
    encode(_5, writer = import_minimal10.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal10.default.Reader ? input2 : import_minimal10.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseResetOffsets();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return ResetOffsets.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseResetOffsets();
      return message;
    }
  };
  function createBaseSaveOffsets() {
    return {};
  }
  var SaveOffsets = {
    encode(_5, writer = import_minimal10.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal10.default.Reader ? input2 : import_minimal10.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSaveOffsets();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return SaveOffsets.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseSaveOffsets();
      return message;
    }
  };
  function isSet10(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_cmd_system.ts
  var import_minimal11 = __toESM(require_minimal2());
  function createBaseRoot10() {
    return { startAll: void 0, stopAll: void 0, reboot: void 0, powerOff: void 0 };
  }
  var Root10 = {
    encode(message, writer = import_minimal11.default.Writer.create()) {
      if (message.startAll !== void 0) {
        StartALl.encode(message.startAll, writer.uint32(10).fork()).ldelim();
      }
      if (message.stopAll !== void 0) {
        StopALl.encode(message.stopAll, writer.uint32(18).fork()).ldelim();
      }
      if (message.reboot !== void 0) {
        Reboot.encode(message.reboot, writer.uint32(26).fork()).ldelim();
      }
      if (message.powerOff !== void 0) {
        PowerOff.encode(message.powerOff, writer.uint32(34).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal11.default.Reader ? input2 : import_minimal11.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot10();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.startAll = StartALl.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.stopAll = StopALl.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.reboot = Reboot.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.powerOff = PowerOff.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        startAll: isSet11(object.startAll) ? StartALl.fromJSON(object.startAll) : void 0,
        stopAll: isSet11(object.stopAll) ? StopALl.fromJSON(object.stopAll) : void 0,
        reboot: isSet11(object.reboot) ? Reboot.fromJSON(object.reboot) : void 0,
        powerOff: isSet11(object.powerOff) ? PowerOff.fromJSON(object.powerOff) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.startAll !== void 0) {
        obj.startAll = StartALl.toJSON(message.startAll);
      }
      if (message.stopAll !== void 0) {
        obj.stopAll = StopALl.toJSON(message.stopAll);
      }
      if (message.reboot !== void 0) {
        obj.reboot = Reboot.toJSON(message.reboot);
      }
      if (message.powerOff !== void 0) {
        obj.powerOff = PowerOff.toJSON(message.powerOff);
      }
      return obj;
    },
    create(base) {
      return Root10.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot10();
      message.startAll = object.startAll !== void 0 && object.startAll !== null ? StartALl.fromPartial(object.startAll) : void 0;
      message.stopAll = object.stopAll !== void 0 && object.stopAll !== null ? StopALl.fromPartial(object.stopAll) : void 0;
      message.reboot = object.reboot !== void 0 && object.reboot !== null ? Reboot.fromPartial(object.reboot) : void 0;
      message.powerOff = object.powerOff !== void 0 && object.powerOff !== null ? PowerOff.fromPartial(object.powerOff) : void 0;
      return message;
    }
  };
  function createBaseStartALl() {
    return {};
  }
  var StartALl = {
    encode(_5, writer = import_minimal11.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal11.default.Reader ? input2 : import_minimal11.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStartALl();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return StartALl.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStartALl();
      return message;
    }
  };
  function createBaseStopALl() {
    return {};
  }
  var StopALl = {
    encode(_5, writer = import_minimal11.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal11.default.Reader ? input2 : import_minimal11.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStopALl();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return StopALl.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseStopALl();
      return message;
    }
  };
  function createBaseReboot() {
    return {};
  }
  var Reboot = {
    encode(_5, writer = import_minimal11.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal11.default.Reader ? input2 : import_minimal11.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseReboot();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Reboot.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseReboot();
      return message;
    }
  };
  function createBasePowerOff() {
    return {};
  }
  var PowerOff = {
    encode(_5, writer = import_minimal11.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal11.default.Reader ? input2 : import_minimal11.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBasePowerOff();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return PowerOff.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBasePowerOff();
      return message;
    }
  };
  function isSet11(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_cmd_environment.ts
  var import_minimal12 = __toESM(require_minimal2());
  function createBaseRoot11() {
    return {
      setWeatherCondition: void 0,
      setLightingCondition: void 0,
      setPrecipitationType: void 0,
      setGroundCondition: void 0,
      setOpticalVisibility: void 0,
      setThermalCondition: void 0,
      setNetworkStatus: void 0,
      setLightSourceCondition: void 0
    };
  }
  var Root11 = {
    encode(message, writer = import_minimal12.default.Writer.create()) {
      if (message.setWeatherCondition !== void 0) {
        SetWeatherCondition.encode(message.setWeatherCondition, writer.uint32(10).fork()).ldelim();
      }
      if (message.setLightingCondition !== void 0) {
        SetLightingCondition.encode(message.setLightingCondition, writer.uint32(18).fork()).ldelim();
      }
      if (message.setPrecipitationType !== void 0) {
        SetPrecipitationType.encode(message.setPrecipitationType, writer.uint32(26).fork()).ldelim();
      }
      if (message.setGroundCondition !== void 0) {
        SetGroundCondition.encode(message.setGroundCondition, writer.uint32(34).fork()).ldelim();
      }
      if (message.setOpticalVisibility !== void 0) {
        SetOpticalVisibility.encode(message.setOpticalVisibility, writer.uint32(42).fork()).ldelim();
      }
      if (message.setThermalCondition !== void 0) {
        SetThermalCondition.encode(message.setThermalCondition, writer.uint32(50).fork()).ldelim();
      }
      if (message.setNetworkStatus !== void 0) {
        SetNetworkStatus.encode(message.setNetworkStatus, writer.uint32(58).fork()).ldelim();
      }
      if (message.setLightSourceCondition !== void 0) {
        SetLightSourceCondition.encode(message.setLightSourceCondition, writer.uint32(66).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal12.default.Reader ? input2 : import_minimal12.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot11();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.setWeatherCondition = SetWeatherCondition.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.setLightingCondition = SetLightingCondition.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.setPrecipitationType = SetPrecipitationType.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.setGroundCondition = SetGroundCondition.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.setOpticalVisibility = SetOpticalVisibility.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.setThermalCondition = SetThermalCondition.decode(reader, reader.uint32());
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }
            message.setNetworkStatus = SetNetworkStatus.decode(reader, reader.uint32());
            continue;
          case 8:
            if (tag !== 66) {
              break;
            }
            message.setLightSourceCondition = SetLightSourceCondition.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        setWeatherCondition: isSet12(object.setWeatherCondition) ? SetWeatherCondition.fromJSON(object.setWeatherCondition) : void 0,
        setLightingCondition: isSet12(object.setLightingCondition) ? SetLightingCondition.fromJSON(object.setLightingCondition) : void 0,
        setPrecipitationType: isSet12(object.setPrecipitationType) ? SetPrecipitationType.fromJSON(object.setPrecipitationType) : void 0,
        setGroundCondition: isSet12(object.setGroundCondition) ? SetGroundCondition.fromJSON(object.setGroundCondition) : void 0,
        setOpticalVisibility: isSet12(object.setOpticalVisibility) ? SetOpticalVisibility.fromJSON(object.setOpticalVisibility) : void 0,
        setThermalCondition: isSet12(object.setThermalCondition) ? SetThermalCondition.fromJSON(object.setThermalCondition) : void 0,
        setNetworkStatus: isSet12(object.setNetworkStatus) ? SetNetworkStatus.fromJSON(object.setNetworkStatus) : void 0,
        setLightSourceCondition: isSet12(object.setLightSourceCondition) ? SetLightSourceCondition.fromJSON(object.setLightSourceCondition) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.setWeatherCondition !== void 0) {
        obj.setWeatherCondition = SetWeatherCondition.toJSON(message.setWeatherCondition);
      }
      if (message.setLightingCondition !== void 0) {
        obj.setLightingCondition = SetLightingCondition.toJSON(message.setLightingCondition);
      }
      if (message.setPrecipitationType !== void 0) {
        obj.setPrecipitationType = SetPrecipitationType.toJSON(message.setPrecipitationType);
      }
      if (message.setGroundCondition !== void 0) {
        obj.setGroundCondition = SetGroundCondition.toJSON(message.setGroundCondition);
      }
      if (message.setOpticalVisibility !== void 0) {
        obj.setOpticalVisibility = SetOpticalVisibility.toJSON(message.setOpticalVisibility);
      }
      if (message.setThermalCondition !== void 0) {
        obj.setThermalCondition = SetThermalCondition.toJSON(message.setThermalCondition);
      }
      if (message.setNetworkStatus !== void 0) {
        obj.setNetworkStatus = SetNetworkStatus.toJSON(message.setNetworkStatus);
      }
      if (message.setLightSourceCondition !== void 0) {
        obj.setLightSourceCondition = SetLightSourceCondition.toJSON(message.setLightSourceCondition);
      }
      return obj;
    },
    create(base) {
      return Root11.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot11();
      message.setWeatherCondition = object.setWeatherCondition !== void 0 && object.setWeatherCondition !== null ? SetWeatherCondition.fromPartial(object.setWeatherCondition) : void 0;
      message.setLightingCondition = object.setLightingCondition !== void 0 && object.setLightingCondition !== null ? SetLightingCondition.fromPartial(object.setLightingCondition) : void 0;
      message.setPrecipitationType = object.setPrecipitationType !== void 0 && object.setPrecipitationType !== null ? SetPrecipitationType.fromPartial(object.setPrecipitationType) : void 0;
      message.setGroundCondition = object.setGroundCondition !== void 0 && object.setGroundCondition !== null ? SetGroundCondition.fromPartial(object.setGroundCondition) : void 0;
      message.setOpticalVisibility = object.setOpticalVisibility !== void 0 && object.setOpticalVisibility !== null ? SetOpticalVisibility.fromPartial(object.setOpticalVisibility) : void 0;
      message.setThermalCondition = object.setThermalCondition !== void 0 && object.setThermalCondition !== null ? SetThermalCondition.fromPartial(object.setThermalCondition) : void 0;
      message.setNetworkStatus = object.setNetworkStatus !== void 0 && object.setNetworkStatus !== null ? SetNetworkStatus.fromPartial(object.setNetworkStatus) : void 0;
      message.setLightSourceCondition = object.setLightSourceCondition !== void 0 && object.setLightSourceCondition !== null ? SetLightSourceCondition.fromPartial(object.setLightSourceCondition) : void 0;
      return message;
    }
  };
  function createBaseSetWeatherCondition() {
    return { value: 0 };
  }
  var SetWeatherCondition = {
    encode(message, writer = import_minimal12.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal12.default.Reader ? input2 : import_minimal12.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetWeatherCondition();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet12(object.value) ? jonGuiDataEnvironmentWeatherConditionFromJSON(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = jonGuiDataEnvironmentWeatherConditionToJSON(message.value);
      }
      return obj;
    },
    create(base) {
      return SetWeatherCondition.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetWeatherCondition();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetLightingCondition() {
    return { value: 0 };
  }
  var SetLightingCondition = {
    encode(message, writer = import_minimal12.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal12.default.Reader ? input2 : import_minimal12.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetLightingCondition();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet12(object.value) ? jonGuiDataEnvironmentLightingConditionFromJSON(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = jonGuiDataEnvironmentLightingConditionToJSON(message.value);
      }
      return obj;
    },
    create(base) {
      return SetLightingCondition.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetLightingCondition();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetPrecipitationType() {
    return { value: 0 };
  }
  var SetPrecipitationType = {
    encode(message, writer = import_minimal12.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal12.default.Reader ? input2 : import_minimal12.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetPrecipitationType();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet12(object.value) ? jonGuiDataEnvironmentPrecipitationTypeFromJSON(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = jonGuiDataEnvironmentPrecipitationTypeToJSON(message.value);
      }
      return obj;
    },
    create(base) {
      return SetPrecipitationType.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetPrecipitationType();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetGroundCondition() {
    return { value: 0 };
  }
  var SetGroundCondition = {
    encode(message, writer = import_minimal12.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal12.default.Reader ? input2 : import_minimal12.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetGroundCondition();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet12(object.value) ? jonGuiDataEnvironmentGroundConditionFromJSON(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = jonGuiDataEnvironmentGroundConditionToJSON(message.value);
      }
      return obj;
    },
    create(base) {
      return SetGroundCondition.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetGroundCondition();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetOpticalVisibility() {
    return { value: 0 };
  }
  var SetOpticalVisibility = {
    encode(message, writer = import_minimal12.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal12.default.Reader ? input2 : import_minimal12.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetOpticalVisibility();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet12(object.value) ? jonGuiDataEnvironmentOpticalVisibilityFromJSON(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = jonGuiDataEnvironmentOpticalVisibilityToJSON(message.value);
      }
      return obj;
    },
    create(base) {
      return SetOpticalVisibility.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetOpticalVisibility();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetThermalCondition() {
    return { value: 0 };
  }
  var SetThermalCondition = {
    encode(message, writer = import_minimal12.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal12.default.Reader ? input2 : import_minimal12.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetThermalCondition();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet12(object.value) ? jonGuiDataEnvironmentThermalConditionFromJSON(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = jonGuiDataEnvironmentThermalConditionToJSON(message.value);
      }
      return obj;
    },
    create(base) {
      return SetThermalCondition.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetThermalCondition();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetNetworkStatus() {
    return { value: 0 };
  }
  var SetNetworkStatus = {
    encode(message, writer = import_minimal12.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal12.default.Reader ? input2 : import_minimal12.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetNetworkStatus();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet12(object.value) ? jonGuiDataEnvironmentNetworkStatusFromJSON(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = jonGuiDataEnvironmentNetworkStatusToJSON(message.value);
      }
      return obj;
    },
    create(base) {
      return SetNetworkStatus.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetNetworkStatus();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function createBaseSetLightSourceCondition() {
    return { value: 0 };
  }
  var SetLightSourceCondition = {
    encode(message, writer = import_minimal12.default.Writer.create()) {
      if (message.value !== 0) {
        writer.uint32(8).int32(message.value);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal12.default.Reader ? input2 : import_minimal12.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetLightSourceCondition();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.value = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return { value: isSet12(object.value) ? jonGuiDataEnvironmentLightSourceFromJSON(object.value) : 0 };
    },
    toJSON(message) {
      const obj = {};
      if (message.value !== 0) {
        obj.value = jonGuiDataEnvironmentLightSourceToJSON(message.value);
      }
      return obj;
    },
    create(base) {
      return SetLightSourceCondition.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetLightSourceCondition();
      message.value = object.value ?? 0;
      return message;
    }
  };
  function isSet12(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_cmd_power.ts
  var import_minimal13 = __toESM(require_minimal2());
  function createBaseRoot12() {
    return { setDeviceState: void 0, getMeteo: void 0 };
  }
  var Root12 = {
    encode(message, writer = import_minimal13.default.Writer.create()) {
      if (message.setDeviceState !== void 0) {
        SetDeviceState.encode(message.setDeviceState, writer.uint32(10).fork()).ldelim();
      }
      if (message.getMeteo !== void 0) {
        GetMeteo7.encode(message.getMeteo, writer.uint32(26).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal13.default.Reader ? input2 : import_minimal13.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot12();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.setDeviceState = SetDeviceState.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.getMeteo = GetMeteo7.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        setDeviceState: isSet13(object.setDeviceState) ? SetDeviceState.fromJSON(object.setDeviceState) : void 0,
        getMeteo: isSet13(object.getMeteo) ? GetMeteo7.fromJSON(object.getMeteo) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.setDeviceState !== void 0) {
        obj.setDeviceState = SetDeviceState.toJSON(message.setDeviceState);
      }
      if (message.getMeteo !== void 0) {
        obj.getMeteo = GetMeteo7.toJSON(message.getMeteo);
      }
      return obj;
    },
    create(base) {
      return Root12.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot12();
      message.setDeviceState = object.setDeviceState !== void 0 && object.setDeviceState !== null ? SetDeviceState.fromPartial(object.setDeviceState) : void 0;
      message.getMeteo = object.getMeteo !== void 0 && object.getMeteo !== null ? GetMeteo7.fromPartial(object.getMeteo) : void 0;
      return message;
    }
  };
  function createBaseGetMeteo7() {
    return {};
  }
  var GetMeteo7 = {
    encode(_5, writer = import_minimal13.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal13.default.Reader ? input2 : import_minimal13.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGetMeteo7();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return GetMeteo7.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseGetMeteo7();
      return message;
    }
  };
  function createBasePowerOn() {
    return {};
  }
  var PowerOn = {
    encode(_5, writer = import_minimal13.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal13.default.Reader ? input2 : import_minimal13.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBasePowerOn();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return PowerOn.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBasePowerOn();
      return message;
    }
  };
  function createBasePowerOff2() {
    return {};
  }
  var PowerOff2 = {
    encode(_5, writer = import_minimal13.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal13.default.Reader ? input2 : import_minimal13.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBasePowerOff2();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return PowerOff2.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBasePowerOff2();
      return message;
    }
  };
  function createBasePowerReset() {
    return {};
  }
  var PowerReset = {
    encode(_5, writer = import_minimal13.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal13.default.Reader ? input2 : import_minimal13.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBasePowerReset();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return PowerReset.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBasePowerReset();
      return message;
    }
  };
  function createBaseCanOn() {
    return {};
  }
  var CanOn = {
    encode(_5, writer = import_minimal13.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal13.default.Reader ? input2 : import_minimal13.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseCanOn();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return CanOn.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseCanOn();
      return message;
    }
  };
  function createBaseCanOff() {
    return {};
  }
  var CanOff = {
    encode(_5, writer = import_minimal13.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal13.default.Reader ? input2 : import_minimal13.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseCanOff();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return CanOff.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseCanOff();
      return message;
    }
  };
  function createBaseCanReset() {
    return {};
  }
  var CanReset = {
    encode(_5, writer = import_minimal13.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal13.default.Reader ? input2 : import_minimal13.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseCanReset();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return CanReset.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseCanReset();
      return message;
    }
  };
  function createBaseSetDeviceState() {
    return {
      device: 0,
      powerOn: void 0,
      powerOff: void 0,
      powerReset: void 0,
      canOn: void 0,
      canOff: void 0,
      canReset: void 0
    };
  }
  var SetDeviceState = {
    encode(message, writer = import_minimal13.default.Writer.create()) {
      if (message.device !== 0) {
        writer.uint32(8).int32(message.device);
      }
      if (message.powerOn !== void 0) {
        PowerOn.encode(message.powerOn, writer.uint32(18).fork()).ldelim();
      }
      if (message.powerOff !== void 0) {
        PowerOff2.encode(message.powerOff, writer.uint32(26).fork()).ldelim();
      }
      if (message.powerReset !== void 0) {
        PowerReset.encode(message.powerReset, writer.uint32(34).fork()).ldelim();
      }
      if (message.canOn !== void 0) {
        CanOn.encode(message.canOn, writer.uint32(42).fork()).ldelim();
      }
      if (message.canOff !== void 0) {
        CanOff.encode(message.canOff, writer.uint32(50).fork()).ldelim();
      }
      if (message.canReset !== void 0) {
        CanReset.encode(message.canReset, writer.uint32(58).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal13.default.Reader ? input2 : import_minimal13.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetDeviceState();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.device = reader.int32();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.powerOn = PowerOn.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.powerOff = PowerOff2.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.powerReset = PowerReset.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.canOn = CanOn.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.canOff = CanOff.decode(reader, reader.uint32());
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }
            message.canReset = CanReset.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        device: isSet13(object.device) ? jonGuiDataPowerCanDeviceFromJSON(object.device) : 0,
        powerOn: isSet13(object.powerOn) ? PowerOn.fromJSON(object.powerOn) : void 0,
        powerOff: isSet13(object.powerOff) ? PowerOff2.fromJSON(object.powerOff) : void 0,
        powerReset: isSet13(object.powerReset) ? PowerReset.fromJSON(object.powerReset) : void 0,
        canOn: isSet13(object.canOn) ? CanOn.fromJSON(object.canOn) : void 0,
        canOff: isSet13(object.canOff) ? CanOff.fromJSON(object.canOff) : void 0,
        canReset: isSet13(object.canReset) ? CanReset.fromJSON(object.canReset) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.device !== 0) {
        obj.device = jonGuiDataPowerCanDeviceToJSON(message.device);
      }
      if (message.powerOn !== void 0) {
        obj.powerOn = PowerOn.toJSON(message.powerOn);
      }
      if (message.powerOff !== void 0) {
        obj.powerOff = PowerOff2.toJSON(message.powerOff);
      }
      if (message.powerReset !== void 0) {
        obj.powerReset = PowerReset.toJSON(message.powerReset);
      }
      if (message.canOn !== void 0) {
        obj.canOn = CanOn.toJSON(message.canOn);
      }
      if (message.canOff !== void 0) {
        obj.canOff = CanOff.toJSON(message.canOff);
      }
      if (message.canReset !== void 0) {
        obj.canReset = CanReset.toJSON(message.canReset);
      }
      return obj;
    },
    create(base) {
      return SetDeviceState.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseSetDeviceState();
      message.device = object.device ?? 0;
      message.powerOn = object.powerOn !== void 0 && object.powerOn !== null ? PowerOn.fromPartial(object.powerOn) : void 0;
      message.powerOff = object.powerOff !== void 0 && object.powerOff !== null ? PowerOff2.fromPartial(object.powerOff) : void 0;
      message.powerReset = object.powerReset !== void 0 && object.powerReset !== null ? PowerReset.fromPartial(object.powerReset) : void 0;
      message.canOn = object.canOn !== void 0 && object.canOn !== null ? CanOn.fromPartial(object.canOn) : void 0;
      message.canOff = object.canOff !== void 0 && object.canOff !== null ? CanOff.fromPartial(object.canOff) : void 0;
      message.canReset = object.canReset !== void 0 && object.canReset !== null ? CanReset.fromPartial(object.canReset) : void 0;
      return message;
    }
  };
  function isSet13(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_cmd.ts
  var import_minimal14 = __toESM(require_minimal2());
  function createBaseRoot13() {
    return {
      protocolVersion: 0,
      sessionId: 0,
      important: false,
      dayCamera: void 0,
      heatCamera: void 0,
      gps: void 0,
      compass: void 0,
      lrf: void 0,
      lrfCalib: void 0,
      rotary: void 0,
      osd: void 0,
      ping: void 0,
      noop: void 0,
      frozen: void 0,
      system: void 0,
      environment: void 0,
      geoTest: void 0,
      power: void 0
    };
  }
  var Root13 = {
    encode(message, writer = import_minimal14.default.Writer.create()) {
      if (message.protocolVersion !== 0) {
        writer.uint32(8).uint32(message.protocolVersion);
      }
      if (message.sessionId !== 0) {
        writer.uint32(16).uint32(message.sessionId);
      }
      if (message.important !== false) {
        writer.uint32(24).bool(message.important);
      }
      if (message.dayCamera !== void 0) {
        Root8.encode(message.dayCamera, writer.uint32(162).fork()).ldelim();
      }
      if (message.heatCamera !== void 0) {
        Root5.encode(message.heatCamera, writer.uint32(170).fork()).ldelim();
      }
      if (message.gps !== void 0) {
        Root.encode(message.gps, writer.uint32(178).fork()).ldelim();
      }
      if (message.compass !== void 0) {
        Root6.encode(message.compass, writer.uint32(186).fork()).ldelim();
      }
      if (message.lrf !== void 0) {
        Root7.encode(message.lrf, writer.uint32(194).fork()).ldelim();
      }
      if (message.lrfCalib !== void 0) {
        Root9.encode(message.lrfCalib, writer.uint32(202).fork()).ldelim();
      }
      if (message.rotary !== void 0) {
        Root4.encode(message.rotary, writer.uint32(210).fork()).ldelim();
      }
      if (message.osd !== void 0) {
        Root2.encode(message.osd, writer.uint32(218).fork()).ldelim();
      }
      if (message.ping !== void 0) {
        Ping.encode(message.ping, writer.uint32(226).fork()).ldelim();
      }
      if (message.noop !== void 0) {
        Noop.encode(message.noop, writer.uint32(234).fork()).ldelim();
      }
      if (message.frozen !== void 0) {
        Frozen.encode(message.frozen, writer.uint32(242).fork()).ldelim();
      }
      if (message.system !== void 0) {
        Root10.encode(message.system, writer.uint32(250).fork()).ldelim();
      }
      if (message.environment !== void 0) {
        Root11.encode(message.environment, writer.uint32(258).fork()).ldelim();
      }
      if (message.geoTest !== void 0) {
        Root3.encode(message.geoTest, writer.uint32(266).fork()).ldelim();
      }
      if (message.power !== void 0) {
        Root12.encode(message.power, writer.uint32(274).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal14.default.Reader ? input2 : import_minimal14.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRoot13();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.protocolVersion = reader.uint32();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.sessionId = reader.uint32();
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }
            message.important = reader.bool();
            continue;
          case 20:
            if (tag !== 162) {
              break;
            }
            message.dayCamera = Root8.decode(reader, reader.uint32());
            continue;
          case 21:
            if (tag !== 170) {
              break;
            }
            message.heatCamera = Root5.decode(reader, reader.uint32());
            continue;
          case 22:
            if (tag !== 178) {
              break;
            }
            message.gps = Root.decode(reader, reader.uint32());
            continue;
          case 23:
            if (tag !== 186) {
              break;
            }
            message.compass = Root6.decode(reader, reader.uint32());
            continue;
          case 24:
            if (tag !== 194) {
              break;
            }
            message.lrf = Root7.decode(reader, reader.uint32());
            continue;
          case 25:
            if (tag !== 202) {
              break;
            }
            message.lrfCalib = Root9.decode(reader, reader.uint32());
            continue;
          case 26:
            if (tag !== 210) {
              break;
            }
            message.rotary = Root4.decode(reader, reader.uint32());
            continue;
          case 27:
            if (tag !== 218) {
              break;
            }
            message.osd = Root2.decode(reader, reader.uint32());
            continue;
          case 28:
            if (tag !== 226) {
              break;
            }
            message.ping = Ping.decode(reader, reader.uint32());
            continue;
          case 29:
            if (tag !== 234) {
              break;
            }
            message.noop = Noop.decode(reader, reader.uint32());
            continue;
          case 30:
            if (tag !== 242) {
              break;
            }
            message.frozen = Frozen.decode(reader, reader.uint32());
            continue;
          case 31:
            if (tag !== 250) {
              break;
            }
            message.system = Root10.decode(reader, reader.uint32());
            continue;
          case 32:
            if (tag !== 258) {
              break;
            }
            message.environment = Root11.decode(reader, reader.uint32());
            continue;
          case 33:
            if (tag !== 266) {
              break;
            }
            message.geoTest = Root3.decode(reader, reader.uint32());
            continue;
          case 34:
            if (tag !== 274) {
              break;
            }
            message.power = Root12.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        protocolVersion: isSet14(object.protocolVersion) ? globalThis.Number(object.protocolVersion) : 0,
        sessionId: isSet14(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
        important: isSet14(object.important) ? globalThis.Boolean(object.important) : false,
        dayCamera: isSet14(object.dayCamera) ? Root8.fromJSON(object.dayCamera) : void 0,
        heatCamera: isSet14(object.heatCamera) ? Root5.fromJSON(object.heatCamera) : void 0,
        gps: isSet14(object.gps) ? Root.fromJSON(object.gps) : void 0,
        compass: isSet14(object.compass) ? Root6.fromJSON(object.compass) : void 0,
        lrf: isSet14(object.lrf) ? Root7.fromJSON(object.lrf) : void 0,
        lrfCalib: isSet14(object.lrfCalib) ? Root9.fromJSON(object.lrfCalib) : void 0,
        rotary: isSet14(object.rotary) ? Root4.fromJSON(object.rotary) : void 0,
        osd: isSet14(object.osd) ? Root2.fromJSON(object.osd) : void 0,
        ping: isSet14(object.ping) ? Ping.fromJSON(object.ping) : void 0,
        noop: isSet14(object.noop) ? Noop.fromJSON(object.noop) : void 0,
        frozen: isSet14(object.frozen) ? Frozen.fromJSON(object.frozen) : void 0,
        system: isSet14(object.system) ? Root10.fromJSON(object.system) : void 0,
        environment: isSet14(object.environment) ? Root11.fromJSON(object.environment) : void 0,
        geoTest: isSet14(object.geoTest) ? Root3.fromJSON(object.geoTest) : void 0,
        power: isSet14(object.power) ? Root12.fromJSON(object.power) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.protocolVersion !== 0) {
        obj.protocolVersion = Math.round(message.protocolVersion);
      }
      if (message.sessionId !== 0) {
        obj.sessionId = Math.round(message.sessionId);
      }
      if (message.important !== false) {
        obj.important = message.important;
      }
      if (message.dayCamera !== void 0) {
        obj.dayCamera = Root8.toJSON(message.dayCamera);
      }
      if (message.heatCamera !== void 0) {
        obj.heatCamera = Root5.toJSON(message.heatCamera);
      }
      if (message.gps !== void 0) {
        obj.gps = Root.toJSON(message.gps);
      }
      if (message.compass !== void 0) {
        obj.compass = Root6.toJSON(message.compass);
      }
      if (message.lrf !== void 0) {
        obj.lrf = Root7.toJSON(message.lrf);
      }
      if (message.lrfCalib !== void 0) {
        obj.lrfCalib = Root9.toJSON(message.lrfCalib);
      }
      if (message.rotary !== void 0) {
        obj.rotary = Root4.toJSON(message.rotary);
      }
      if (message.osd !== void 0) {
        obj.osd = Root2.toJSON(message.osd);
      }
      if (message.ping !== void 0) {
        obj.ping = Ping.toJSON(message.ping);
      }
      if (message.noop !== void 0) {
        obj.noop = Noop.toJSON(message.noop);
      }
      if (message.frozen !== void 0) {
        obj.frozen = Frozen.toJSON(message.frozen);
      }
      if (message.system !== void 0) {
        obj.system = Root10.toJSON(message.system);
      }
      if (message.environment !== void 0) {
        obj.environment = Root11.toJSON(message.environment);
      }
      if (message.geoTest !== void 0) {
        obj.geoTest = Root3.toJSON(message.geoTest);
      }
      if (message.power !== void 0) {
        obj.power = Root12.toJSON(message.power);
      }
      return obj;
    },
    create(base) {
      return Root13.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRoot13();
      message.protocolVersion = object.protocolVersion ?? 0;
      message.sessionId = object.sessionId ?? 0;
      message.important = object.important ?? false;
      message.dayCamera = object.dayCamera !== void 0 && object.dayCamera !== null ? Root8.fromPartial(object.dayCamera) : void 0;
      message.heatCamera = object.heatCamera !== void 0 && object.heatCamera !== null ? Root5.fromPartial(object.heatCamera) : void 0;
      message.gps = object.gps !== void 0 && object.gps !== null ? Root.fromPartial(object.gps) : void 0;
      message.compass = object.compass !== void 0 && object.compass !== null ? Root6.fromPartial(object.compass) : void 0;
      message.lrf = object.lrf !== void 0 && object.lrf !== null ? Root7.fromPartial(object.lrf) : void 0;
      message.lrfCalib = object.lrfCalib !== void 0 && object.lrfCalib !== null ? Root9.fromPartial(object.lrfCalib) : void 0;
      message.rotary = object.rotary !== void 0 && object.rotary !== null ? Root4.fromPartial(object.rotary) : void 0;
      message.osd = object.osd !== void 0 && object.osd !== null ? Root2.fromPartial(object.osd) : void 0;
      message.ping = object.ping !== void 0 && object.ping !== null ? Ping.fromPartial(object.ping) : void 0;
      message.noop = object.noop !== void 0 && object.noop !== null ? Noop.fromPartial(object.noop) : void 0;
      message.frozen = object.frozen !== void 0 && object.frozen !== null ? Frozen.fromPartial(object.frozen) : void 0;
      message.system = object.system !== void 0 && object.system !== null ? Root10.fromPartial(object.system) : void 0;
      message.environment = object.environment !== void 0 && object.environment !== null ? Root11.fromPartial(object.environment) : void 0;
      message.geoTest = object.geoTest !== void 0 && object.geoTest !== null ? Root3.fromPartial(object.geoTest) : void 0;
      message.power = object.power !== void 0 && object.power !== null ? Root12.fromPartial(object.power) : void 0;
      return message;
    }
  };
  function createBasePing() {
    return {};
  }
  var Ping = {
    encode(_5, writer = import_minimal14.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal14.default.Reader ? input2 : import_minimal14.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBasePing();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Ping.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBasePing();
      return message;
    }
  };
  function createBaseNoop() {
    return {};
  }
  var Noop = {
    encode(_5, writer = import_minimal14.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal14.default.Reader ? input2 : import_minimal14.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseNoop();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Noop.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseNoop();
      return message;
    }
  };
  function createBaseFrozen() {
    return {};
  }
  var Frozen = {
    encode(_5, writer = import_minimal14.default.Writer.create()) {
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal14.default.Reader ? input2 : import_minimal14.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseFrozen();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(_5) {
      return {};
    },
    toJSON(_5) {
      const obj = {};
      return obj;
    },
    create(base) {
      return Frozen.fromPartial(base ?? {});
    },
    fromPartial(_5) {
      const message = createBaseFrozen();
      return message;
    }
  };
  function isSet14(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/cmd/cmdSender/cmdSenderShared.ts
  function createRootMessage() {
    return Root13.create();
  }
  function encodeCmdMessage(rootMsg) {
    return Root13.encode(rootMsg).finish();
  }
  function sendCmdMessage(rootMsg) {
    if (!rootMsg.ping) {
      console.log("Sending cmd message:", Root13.toJSON(rootMsg));
    }
    const encodedMessage = encodeCmdMessage(rootMsg);
    let shouldBuffer = true;
    if (rootMsg.ping) {
      shouldBuffer = false;
    }
    cmdChannel.postMessage({ pld: encodedMessage, shouldBuffer });
  }
  var cmdChannel = new BroadcastChannel("cmd");

  // frontend/ts/cmd/cmdSender/cmdRotary.ts
  function setRotateToGps(lon, lat, alt) {
    console.log(`Setting rotate to GPS to ${lon}, ${lat}, ${alt}`);
    let rotateToGpsMsg = index_cmd_RotaryPlatform_exports.RotateToGPS.create({
      longitude: lon,
      latitude: lat,
      altitude: alt
    });
    let rootMsg = createRootMessage();
    rootMsg.rotary = index_cmd_RotaryPlatform_exports.Root.create({ rotateToGps: rotateToGpsMsg });
    sendCmdMessage(rootMsg);
  }

  // frontend/ts/globe/loader.ts
  var ModelLoader = class {
    constructor(modelMap) {
      this.loadedObjects = {};
      this.modelMap = modelMap;
    }
    async init() {
      const loadPromises = Object.entries(this.modelMap).map(async ([name, baseName]) => {
        try {
          const objPath = `./res/models/${baseName}.obj`;
          const objArray = await Object3d.loadObj(objPath);
          if (objArray.length > 0) {
            this.loadedObjects[name] = objArray[0];
          } else {
            console.warn(`No objects loaded for ${name}`);
          }
        } catch (error) {
          console.error(`Error loading model ${name}:`, error);
        }
      });
      await Promise.all(loadPromises);
    }
    createGeoObject(name) {
      const obj = this.loadedObjects[name];
      if (!obj) {
        console.warn(`No loaded object found for ${name}`);
        return null;
      }
      const baseName = this.modelMap[name];
      const texturePath = `./res/models/${baseName}.png`;
      const geoObject = new GeoObject({
        object3d: obj,
        scale: 5e-11,
        tag: name
      });
      geoObject.setTextureSrc(texturePath);
      return geoObject;
    }
  };

  // frontend/ts/globe/globeManager.ts
  var MODEL_NAMES = [
    "sych",
    "archdukepiginand",
    "borntosqueal",
    "oldham",
    "pigatozoid",
    "pigineer",
    "tupolev",
    "whooligans"
  ];
  var GlobeManager = class {
    constructor(deviceStateDispatch, containerID) {
      this.gpsHandlerFirstRun = true;
      this.dummyCamEntity = null;
      this.unsubscribers = [];
      this.lastMeasureId = -1;
      this.lastSessionId = -1;
      this.deviceStateDispatch = deviceStateDispatch;
      this.containerID = containerID;
      this.osmLayer = new OsmLayer();
      this.satLayer = new SatLayer();
      this.dummyCamLayer = new Vector("DummyCamLayer", {
        clampToGround: true,
        relativeToGround: true,
        iconSrc: "./res/camera_layer.png",
        pickingScale: 1,
        pickingEnabled: true,
        scaleByDistance: [100, 24e6, 1e10]
      });
      this.currentSessionLayer = new Vector("TargetLayer", {
        iconSrc: "./res/current_minion_layer.png",
        pickingScale: 1,
        pickingEnabled: true,
        scaleByDistance: [100, 24e6, 1e10]
      });
      this.globe = new Globe({
        target: this.containerID,
        name: "Earth",
        terrain: new EmptyTerrain(),
        layers: [this.osmLayer, this.satLayer, this.dummyCamLayer, this.currentSessionLayer],
        atmosphereEnabled: true
      });
      this.myPopup = new Popup({
        planet: this.globe.planet,
        offset: [0, 0],
        visibility: false
      });
      this.modelLoader = new ModelLoader(
        MODEL_NAMES.reduce((acc, name) => {
          acc[name] = name;
          return acc;
        }, {})
      );
      this.initGlobe();
      this.initModels().then(() => this.initDummyCam()).then(() => this.subscribeToStateUpdates()).catch(console.error);
    }
    initGlobe() {
      if (this.globe.planet.renderer) {
        this.globe.planet.renderer.events.on("lclick", this.onGlobeClick.bind(this));
      } else {
        console.error("Globe renderer not initialized");
      }
      this.globe.planet.addControl(new control_exports.LayerSwitcher());
    }
    async initModels() {
      await this.modelLoader.init();
    }
    async initDummyCam() {
      const sychGeoObject = this.modelLoader.createGeoObject("sych");
      if (!sychGeoObject) {
        console.error("Sych model not loaded");
        return;
      }
      this.dummyCamEntity = new Entity({
        lonlat: new LonLat(15.815316209646182, 50.02360496183876, 0)
      });
      this.dummyCamEntity.setGeoObject(sychGeoObject);
      this.dummyCamLayer.add(this.dummyCamEntity);
      this.dummyCamLayer.events.on("mouseenter", this.onMouseEnter.bind(this));
      this.dummyCamLayer.events.on("mouseleave", this.onMouseLeave.bind(this));
      this.dummyCamLayer.events.on("lclick", this.onClick.bind(this));
    }
    subscribeToStateUpdates() {
      this.unsubscribers.push(
        this.deviceStateDispatch.gps.subscribe(this.handleGpsUpdate.bind(this)),
        this.deviceStateDispatch.compass.subscribe(this.handleCompassUpdate.bind(this)),
        this.deviceStateDispatch.lrf.subscribe(this.handleLrfUpdate.bind(this))
      );
    }
    handleGpsUpdate(gps) {
      if (!this.dummyCamEntity || !gps) return;
      let newPosition;
      if (gps.useManual) {
        newPosition = new LonLat(gps.manualLongitude, gps.manualLatitude, gps.manualAltitude);
      } else {
        newPosition = new LonLat(gps.longitude, gps.latitude, gps.altitude);
      }
      this.dummyCamEntity.setLonLat(newPosition);
      if (this.gpsHandlerFirstRun || this.curGPSFixType && this.curGPSFixType !== gps.fixType || this.curUseManualGPS && this.curUseManualGPS !== gps.useManual) {
        this.curGPSFixType = gps.fixType;
        this.curUseManualGPS = gps.useManual;
        let ell = this.globe.planet.ellipsoid;
        this.globe.planet.camera.flyDistance(ell.lonLatToCartesian(newPosition));
        this.gpsHandlerFirstRun = false;
      }
    }
    handleCompassUpdate(compass) {
      if (!this.dummyCamEntity || !this.dummyCamEntity.geoObject || !compass) {
        return;
      }
      const azimuth = math_exports.DEG2RAD(compass.azimuth);
      this.dummyCamEntity.geoObject.setYaw(azimuth);
    }
    handleLrfUpdate(lrf) {
      if (lrf?.target && lrf.measureId && lrf.measureId !== this.lastMeasureId) {
        if (this.lastMeasureId) {
          this.handleTargetUpdate(lrf.target);
        }
        this.lastMeasureId = lrf.measureId;
      }
    }
    handleTargetUpdate(target) {
      const newPos = new LonLat(target.targetLongitude, target.targetLatitude, target.targetAltitude);
      const sessionId = target.sessionId;
      const id = target.targetId;
      if (this.lastSessionId !== sessionId) {
        this.updatePreviousSessionTargets();
        this.lastSessionId = sessionId;
      }
      const randomModel = this.getRandomTargetModel();
      if (!randomModel) {
        console.error("No target models available");
        return;
      }
      const targetEntity = new Entity({
        lonlat: newPos,
        properties: {
          id,
          sessionId,
          name: ""
        }
      });
      targetEntity.setGeoObject(randomModel);
      this.currentSessionLayer.add(targetEntity);
      this.globe.planet.flyLonLat(newPos);
    }
    updatePreviousSessionTargets() {
      this.currentSessionLayer.each((entity) => {
        this.currentSessionLayer.removeEntity(entity);
      });
    }
    getRandomTargetModel() {
      const availableModels = MODEL_NAMES.filter((name) => name !== "sych");
      if (availableModels.length === 0) return null;
      const randomName = availableModels[Math.floor(Math.random() * availableModels.length)];
      return this.modelLoader.createGeoObject(randomName);
    }
    onGlobeClick(e9) {
      let lonLat = this.globe.planet.getLonLatFromPixelTerrain(e9);
      if (!lonLat || !this.globe.planet.terrain) return;
      this.globe.planet.terrain.getHeightAsync(lonLat, (h8) => {
        const content = `lon = ${lonLat.lon.toFixed(5)}<br/>lat = ${lonLat.lat.toFixed(5)}<br/>height(msl) = ${Math.round(h8)} m`;
        this.myPopup.setContent(content);
        console.log(`Globe clicked at: ${lonLat.lon}, ${lonLat.lat}, ${h8}`);
        setRotateToGps(lonLat.lon, lonLat.lat, h8);
      });
      let groundPos = this.globe.planet.getCartesianFromMouseTerrain();
      if (!groundPos) return;
      this.myPopup.setCartesian3v(groundPos);
      this.myPopup.setVisibility(true);
    }
    onMouseEnter(e9) {
    }
    onMouseLeave(e9) {
    }
    onClick(e9) {
    }
    destroy() {
      this.unsubscribers.forEach((unsubscribe) => unsubscribe());
      this.unsubscribers = [];
    }
  };
  var globeManager_default = GlobeManager;

  // frontend/node_modules/@preact/signals-core/dist/signals-core.module.js
  var i = Symbol.for("preact-signals");
  function t() {
    if (!(s2 > 1)) {
      var i9, t9 = false;
      while (void 0 !== h2) {
        var r8 = h2;
        h2 = void 0;
        f++;
        while (void 0 !== r8) {
          var o7 = r8.o;
          r8.o = void 0;
          r8.f &= -3;
          if (!(8 & r8.f) && c(r8)) try {
            r8.c();
          } catch (r9) {
            if (!t9) {
              i9 = r9;
              t9 = true;
            }
          }
          r8 = o7;
        }
      }
      f = 0;
      s2--;
      if (t9) throw i9;
    } else s2--;
  }
  var o = void 0;
  var h2 = void 0;
  var s2 = 0;
  var f = 0;
  var v = 0;
  function e(i9) {
    if (void 0 !== o) {
      var t9 = i9.n;
      if (void 0 === t9 || t9.t !== o) {
        t9 = { i: 0, S: i9, p: o.s, n: void 0, t: o, e: void 0, x: void 0, r: t9 };
        if (void 0 !== o.s) o.s.n = t9;
        o.s = t9;
        i9.n = t9;
        if (32 & o.f) i9.S(t9);
        return t9;
      } else if (-1 === t9.i) {
        t9.i = 0;
        if (void 0 !== t9.n) {
          t9.n.p = t9.p;
          if (void 0 !== t9.p) t9.p.n = t9.n;
          t9.p = o.s;
          t9.n = void 0;
          o.s.n = t9;
          o.s = t9;
        }
        return t9;
      }
    }
  }
  function u(i9) {
    this.v = i9;
    this.i = 0;
    this.n = void 0;
    this.t = void 0;
  }
  u.prototype.brand = i;
  u.prototype.h = function() {
    return true;
  };
  u.prototype.S = function(i9) {
    if (this.t !== i9 && void 0 === i9.e) {
      i9.x = this.t;
      if (void 0 !== this.t) this.t.e = i9;
      this.t = i9;
    }
  };
  u.prototype.U = function(i9) {
    if (void 0 !== this.t) {
      var t9 = i9.e, r8 = i9.x;
      if (void 0 !== t9) {
        t9.x = r8;
        i9.e = void 0;
      }
      if (void 0 !== r8) {
        r8.e = t9;
        i9.x = void 0;
      }
      if (i9 === this.t) this.t = r8;
    }
  };
  u.prototype.subscribe = function(i9) {
    var t9 = this;
    return E2(function() {
      var r8 = t9.value, n7 = o;
      o = void 0;
      try {
        i9(r8);
      } finally {
        o = n7;
      }
    });
  };
  u.prototype.valueOf = function() {
    return this.value;
  };
  u.prototype.toString = function() {
    return this.value + "";
  };
  u.prototype.toJSON = function() {
    return this.value;
  };
  u.prototype.peek = function() {
    var i9 = o;
    o = void 0;
    try {
      return this.value;
    } finally {
      o = i9;
    }
  };
  Object.defineProperty(u.prototype, "value", { get: function() {
    var i9 = e(this);
    if (void 0 !== i9) i9.i = this.i;
    return this.v;
  }, set: function(i9) {
    if (i9 !== this.v) {
      if (f > 100) throw new Error("Cycle detected");
      this.v = i9;
      this.i++;
      v++;
      s2++;
      try {
        for (var r8 = this.t; void 0 !== r8; r8 = r8.x) r8.t.N();
      } finally {
        t();
      }
    }
  } });
  function d(i9) {
    return new u(i9);
  }
  function c(i9) {
    for (var t9 = i9.s; void 0 !== t9; t9 = t9.n) if (t9.S.i !== t9.i || !t9.S.h() || t9.S.i !== t9.i) return true;
    return false;
  }
  function a(i9) {
    for (var t9 = i9.s; void 0 !== t9; t9 = t9.n) {
      var r8 = t9.S.n;
      if (void 0 !== r8) t9.r = r8;
      t9.S.n = t9;
      t9.i = -1;
      if (void 0 === t9.n) {
        i9.s = t9;
        break;
      }
    }
  }
  function l(i9) {
    var t9 = i9.s, r8 = void 0;
    while (void 0 !== t9) {
      var o7 = t9.p;
      if (-1 === t9.i) {
        t9.S.U(t9);
        if (void 0 !== o7) o7.n = t9.n;
        if (void 0 !== t9.n) t9.n.p = o7;
      } else r8 = t9;
      t9.S.n = t9.r;
      if (void 0 !== t9.r) t9.r = void 0;
      t9 = o7;
    }
    i9.s = r8;
  }
  function y(i9) {
    u.call(this, void 0);
    this.x = i9;
    this.s = void 0;
    this.g = v - 1;
    this.f = 4;
  }
  (y.prototype = new u()).h = function() {
    this.f &= -3;
    if (1 & this.f) return false;
    if (32 == (36 & this.f)) return true;
    this.f &= -5;
    if (this.g === v) return true;
    this.g = v;
    this.f |= 1;
    if (this.i > 0 && !c(this)) {
      this.f &= -2;
      return true;
    }
    var i9 = o;
    try {
      a(this);
      o = this;
      var t9 = this.x();
      if (16 & this.f || this.v !== t9 || 0 === this.i) {
        this.v = t9;
        this.f &= -17;
        this.i++;
      }
    } catch (i10) {
      this.v = i10;
      this.f |= 16;
      this.i++;
    }
    o = i9;
    l(this);
    this.f &= -2;
    return true;
  };
  y.prototype.S = function(i9) {
    if (void 0 === this.t) {
      this.f |= 36;
      for (var t9 = this.s; void 0 !== t9; t9 = t9.n) t9.S.S(t9);
    }
    u.prototype.S.call(this, i9);
  };
  y.prototype.U = function(i9) {
    if (void 0 !== this.t) {
      u.prototype.U.call(this, i9);
      if (void 0 === this.t) {
        this.f &= -33;
        for (var t9 = this.s; void 0 !== t9; t9 = t9.n) t9.S.U(t9);
      }
    }
  };
  y.prototype.N = function() {
    if (!(2 & this.f)) {
      this.f |= 6;
      for (var i9 = this.t; void 0 !== i9; i9 = i9.x) i9.t.N();
    }
  };
  Object.defineProperty(y.prototype, "value", { get: function() {
    if (1 & this.f) throw new Error("Cycle detected");
    var i9 = e(this);
    this.h();
    if (void 0 !== i9) i9.i = this.i;
    if (16 & this.f) throw this.v;
    return this.v;
  } });
  function _(i9) {
    var r8 = i9.u;
    i9.u = void 0;
    if ("function" == typeof r8) {
      s2++;
      var n7 = o;
      o = void 0;
      try {
        r8();
      } catch (t9) {
        i9.f &= -2;
        i9.f |= 8;
        g(i9);
        throw t9;
      } finally {
        o = n7;
        t();
      }
    }
  }
  function g(i9) {
    for (var t9 = i9.s; void 0 !== t9; t9 = t9.n) t9.S.U(t9);
    i9.x = void 0;
    i9.s = void 0;
    _(i9);
  }
  function p(i9) {
    if (o !== this) throw new Error("Out-of-order effect");
    l(this);
    o = i9;
    this.f &= -2;
    if (8 & this.f) g(this);
    t();
  }
  function b(i9) {
    this.x = i9;
    this.u = void 0;
    this.s = void 0;
    this.o = void 0;
    this.f = 32;
  }
  b.prototype.c = function() {
    var i9 = this.S();
    try {
      if (8 & this.f) return;
      if (void 0 === this.x) return;
      var t9 = this.x();
      if ("function" == typeof t9) this.u = t9;
    } finally {
      i9();
    }
  };
  b.prototype.S = function() {
    if (1 & this.f) throw new Error("Cycle detected");
    this.f |= 1;
    this.f &= -9;
    _(this);
    a(this);
    s2++;
    var i9 = o;
    o = this;
    return p.bind(this, i9);
  };
  b.prototype.N = function() {
    if (!(2 & this.f)) {
      this.f |= 2;
      this.o = h2;
      h2 = this;
    }
  };
  b.prototype.d = function() {
    this.f |= 8;
    if (!(1 & this.f)) g(this);
  };
  function E2(i9) {
    var t9 = new b(i9);
    try {
      t9.c();
    } catch (i10) {
      t9.d();
      throw i10;
    }
    return t9.d.bind(t9);
  }

  // frontend/node_modules/@lit-labs/preact-signals/node_modules/lit/node_modules/lit-html/directive.js
  var t2 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
  var e2 = (t9) => (...e9) => ({ _$litDirective$: t9, values: e9 });
  var i2 = class {
    constructor(t9) {
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AT(t9, e9, i9) {
      this._$Ct = t9, this._$AM = e9, this._$Ci = i9;
    }
    _$AS(t9, e9) {
      return this.update(t9, e9);
    }
    update(t9, e9) {
      return this.render(...e9);
    }
  };

  // frontend/node_modules/@lit-labs/preact-signals/node_modules/lit/node_modules/lit-html/lit-html.js
  var t3 = globalThis;
  var i3 = t3.trustedTypes;
  var s3 = i3 ? i3.createPolicy("lit-html", { createHTML: (t9) => t9 }) : void 0;
  var e3 = "$lit$";
  var h3 = `lit$${Math.random().toFixed(9).slice(2)}$`;
  var o2 = "?" + h3;
  var n = `<${o2}>`;
  var r = document;
  var l2 = () => r.createComment("");
  var c2 = (t9) => null === t9 || "object" != typeof t9 && "function" != typeof t9;
  var a2 = Array.isArray;
  var u2 = (t9) => a2(t9) || "function" == typeof t9?.[Symbol.iterator];
  var d2 = "[ 	\n\f\r]";
  var f2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  var v2 = /-->/g;
  var _2 = />/g;
  var m2 = RegExp(`>|${d2}(?:([^\\s"'>=/]+)(${d2}*=${d2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
  var p2 = /'/g;
  var g2 = /"/g;
  var $ = /^(?:script|style|textarea|title)$/i;
  var y2 = (t9) => (i9, ...s7) => ({ _$litType$: t9, strings: i9, values: s7 });
  var x = y2(1);
  var b2 = y2(2);
  var w = Symbol.for("lit-noChange");
  var T = Symbol.for("lit-nothing");
  var A2 = /* @__PURE__ */ new WeakMap();
  var E3 = r.createTreeWalker(r, 129);
  function C(t9, i9) {
    if (!Array.isArray(t9) || !t9.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return void 0 !== s3 ? s3.createHTML(i9) : i9;
  }
  var P = (t9, i9) => {
    const s7 = t9.length - 1, o7 = [];
    let r8, l4 = 2 === i9 ? "<svg>" : "", c7 = f2;
    for (let i10 = 0; i10 < s7; i10++) {
      const s8 = t9[i10];
      let a6, u4, d4 = -1, y4 = 0;
      for (; y4 < s8.length && (c7.lastIndex = y4, u4 = c7.exec(s8), null !== u4); ) y4 = c7.lastIndex, c7 === f2 ? "!--" === u4[1] ? c7 = v2 : void 0 !== u4[1] ? c7 = _2 : void 0 !== u4[2] ? ($.test(u4[2]) && (r8 = RegExp("</" + u4[2], "g")), c7 = m2) : void 0 !== u4[3] && (c7 = m2) : c7 === m2 ? ">" === u4[0] ? (c7 = r8 ?? f2, d4 = -1) : void 0 === u4[1] ? d4 = -2 : (d4 = c7.lastIndex - u4[2].length, a6 = u4[1], c7 = void 0 === u4[3] ? m2 : '"' === u4[3] ? g2 : p2) : c7 === g2 || c7 === p2 ? c7 = m2 : c7 === v2 || c7 === _2 ? c7 = f2 : (c7 = m2, r8 = void 0);
      const x3 = c7 === m2 && t9[i10 + 1].startsWith("/>") ? " " : "";
      l4 += c7 === f2 ? s8 + n : d4 >= 0 ? (o7.push(a6), s8.slice(0, d4) + e3 + s8.slice(d4) + h3 + x3) : s8 + h3 + (-2 === d4 ? i10 : x3);
    }
    return [C(t9, l4 + (t9[s7] || "<?>") + (2 === i9 ? "</svg>" : "")), o7];
  };
  var V = class _V2 {
    constructor({ strings: t9, _$litType$: s7 }, n7) {
      let r8;
      this.parts = [];
      let c7 = 0, a6 = 0;
      const u4 = t9.length - 1, d4 = this.parts, [f8, v4] = P(t9, s7);
      if (this.el = _V2.createElement(f8, n7), E3.currentNode = this.el.content, 2 === s7) {
        const t10 = this.el.content.firstChild;
        t10.replaceWith(...t10.childNodes);
      }
      for (; null !== (r8 = E3.nextNode()) && d4.length < u4; ) {
        if (1 === r8.nodeType) {
          if (r8.hasAttributes()) for (const t10 of r8.getAttributeNames()) if (t10.endsWith(e3)) {
            const i9 = v4[a6++], s8 = r8.getAttribute(t10).split(h3), e9 = /([.?@])?(.*)/.exec(i9);
            d4.push({ type: 1, index: c7, name: e9[2], strings: s8, ctor: "." === e9[1] ? k : "?" === e9[1] ? H : "@" === e9[1] ? I : R2 }), r8.removeAttribute(t10);
          } else t10.startsWith(h3) && (d4.push({ type: 6, index: c7 }), r8.removeAttribute(t10));
          if ($.test(r8.tagName)) {
            const t10 = r8.textContent.split(h3), s8 = t10.length - 1;
            if (s8 > 0) {
              r8.textContent = i3 ? i3.emptyScript : "";
              for (let i9 = 0; i9 < s8; i9++) r8.append(t10[i9], l2()), E3.nextNode(), d4.push({ type: 2, index: ++c7 });
              r8.append(t10[s8], l2());
            }
          }
        } else if (8 === r8.nodeType) if (r8.data === o2) d4.push({ type: 2, index: c7 });
        else {
          let t10 = -1;
          for (; -1 !== (t10 = r8.data.indexOf(h3, t10 + 1)); ) d4.push({ type: 7, index: c7 }), t10 += h3.length - 1;
        }
        c7++;
      }
    }
    static createElement(t9, i9) {
      const s7 = r.createElement("template");
      return s7.innerHTML = t9, s7;
    }
  };
  function N2(t9, i9, s7 = t9, e9) {
    if (i9 === w) return i9;
    let h8 = void 0 !== e9 ? s7._$Co?.[e9] : s7._$Cl;
    const o7 = c2(i9) ? void 0 : i9._$litDirective$;
    return h8?.constructor !== o7 && (h8?._$AO?.(false), void 0 === o7 ? h8 = void 0 : (h8 = new o7(t9), h8._$AT(t9, s7, e9)), void 0 !== e9 ? (s7._$Co ??= [])[e9] = h8 : s7._$Cl = h8), void 0 !== h8 && (i9 = N2(t9, h8._$AS(t9, i9.values), h8, e9)), i9;
  }
  var S2 = class {
    constructor(t9, i9) {
      this._$AV = [], this._$AN = void 0, this._$AD = t9, this._$AM = i9;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(t9) {
      const { el: { content: i9 }, parts: s7 } = this._$AD, e9 = (t9?.creationScope ?? r).importNode(i9, true);
      E3.currentNode = e9;
      let h8 = E3.nextNode(), o7 = 0, n7 = 0, l4 = s7[0];
      for (; void 0 !== l4; ) {
        if (o7 === l4.index) {
          let i10;
          2 === l4.type ? i10 = new M(h8, h8.nextSibling, this, t9) : 1 === l4.type ? i10 = new l4.ctor(h8, l4.name, l4.strings, this, t9) : 6 === l4.type && (i10 = new L(h8, this, t9)), this._$AV.push(i10), l4 = s7[++n7];
        }
        o7 !== l4?.index && (h8 = E3.nextNode(), o7++);
      }
      return E3.currentNode = r, e9;
    }
    p(t9) {
      let i9 = 0;
      for (const s7 of this._$AV) void 0 !== s7 && (void 0 !== s7.strings ? (s7._$AI(t9, s7, i9), i9 += s7.strings.length - 2) : s7._$AI(t9[i9])), i9++;
    }
  };
  var M = class _M {
    get _$AU() {
      return this._$AM?._$AU ?? this._$Cv;
    }
    constructor(t9, i9, s7, e9) {
      this.type = 2, this._$AH = T, this._$AN = void 0, this._$AA = t9, this._$AB = i9, this._$AM = s7, this.options = e9, this._$Cv = e9?.isConnected ?? true;
    }
    get parentNode() {
      let t9 = this._$AA.parentNode;
      const i9 = this._$AM;
      return void 0 !== i9 && 11 === t9?.nodeType && (t9 = i9.parentNode), t9;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t9, i9 = this) {
      t9 = N2(this, t9, i9), c2(t9) ? t9 === T || null == t9 || "" === t9 ? (this._$AH !== T && this._$AR(), this._$AH = T) : t9 !== this._$AH && t9 !== w && this._(t9) : void 0 !== t9._$litType$ ? this.$(t9) : void 0 !== t9.nodeType ? this.T(t9) : u2(t9) ? this.k(t9) : this._(t9);
    }
    S(t9) {
      return this._$AA.parentNode.insertBefore(t9, this._$AB);
    }
    T(t9) {
      this._$AH !== t9 && (this._$AR(), this._$AH = this.S(t9));
    }
    _(t9) {
      this._$AH !== T && c2(this._$AH) ? this._$AA.nextSibling.data = t9 : this.T(r.createTextNode(t9)), this._$AH = t9;
    }
    $(t9) {
      const { values: i9, _$litType$: s7 } = t9, e9 = "number" == typeof s7 ? this._$AC(t9) : (void 0 === s7.el && (s7.el = V.createElement(C(s7.h, s7.h[0]), this.options)), s7);
      if (this._$AH?._$AD === e9) this._$AH.p(i9);
      else {
        const t10 = new S2(e9, this), s8 = t10.u(this.options);
        t10.p(i9), this.T(s8), this._$AH = t10;
      }
    }
    _$AC(t9) {
      let i9 = A2.get(t9.strings);
      return void 0 === i9 && A2.set(t9.strings, i9 = new V(t9)), i9;
    }
    k(t9) {
      a2(this._$AH) || (this._$AH = [], this._$AR());
      const i9 = this._$AH;
      let s7, e9 = 0;
      for (const h8 of t9) e9 === i9.length ? i9.push(s7 = new _M(this.S(l2()), this.S(l2()), this, this.options)) : s7 = i9[e9], s7._$AI(h8), e9++;
      e9 < i9.length && (this._$AR(s7 && s7._$AB.nextSibling, e9), i9.length = e9);
    }
    _$AR(t9 = this._$AA.nextSibling, i9) {
      for (this._$AP?.(false, true, i9); t9 && t9 !== this._$AB; ) {
        const i10 = t9.nextSibling;
        t9.remove(), t9 = i10;
      }
    }
    setConnected(t9) {
      void 0 === this._$AM && (this._$Cv = t9, this._$AP?.(t9));
    }
  };
  var R2 = class {
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    constructor(t9, i9, s7, e9, h8) {
      this.type = 1, this._$AH = T, this._$AN = void 0, this.element = t9, this.name = i9, this._$AM = e9, this.options = h8, s7.length > 2 || "" !== s7[0] || "" !== s7[1] ? (this._$AH = Array(s7.length - 1).fill(new String()), this.strings = s7) : this._$AH = T;
    }
    _$AI(t9, i9 = this, s7, e9) {
      const h8 = this.strings;
      let o7 = false;
      if (void 0 === h8) t9 = N2(this, t9, i9, 0), o7 = !c2(t9) || t9 !== this._$AH && t9 !== w, o7 && (this._$AH = t9);
      else {
        const e10 = t9;
        let n7, r8;
        for (t9 = h8[0], n7 = 0; n7 < h8.length - 1; n7++) r8 = N2(this, e10[s7 + n7], i9, n7), r8 === w && (r8 = this._$AH[n7]), o7 ||= !c2(r8) || r8 !== this._$AH[n7], r8 === T ? t9 = T : t9 !== T && (t9 += (r8 ?? "") + h8[n7 + 1]), this._$AH[n7] = r8;
      }
      o7 && !e9 && this.j(t9);
    }
    j(t9) {
      t9 === T ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t9 ?? "");
    }
  };
  var k = class extends R2 {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(t9) {
      this.element[this.name] = t9 === T ? void 0 : t9;
    }
  };
  var H = class extends R2 {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(t9) {
      this.element.toggleAttribute(this.name, !!t9 && t9 !== T);
    }
  };
  var I = class extends R2 {
    constructor(t9, i9, s7, e9, h8) {
      super(t9, i9, s7, e9, h8), this.type = 5;
    }
    _$AI(t9, i9 = this) {
      if ((t9 = N2(this, t9, i9, 0) ?? T) === w) return;
      const s7 = this._$AH, e9 = t9 === T && s7 !== T || t9.capture !== s7.capture || t9.once !== s7.once || t9.passive !== s7.passive, h8 = t9 !== T && (s7 === T || e9);
      e9 && this.element.removeEventListener(this.name, this, s7), h8 && this.element.addEventListener(this.name, this, t9), this._$AH = t9;
    }
    handleEvent(t9) {
      "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t9) : this._$AH.handleEvent(t9);
    }
  };
  var L = class {
    constructor(t9, i9, s7) {
      this.element = t9, this.type = 6, this._$AN = void 0, this._$AM = i9, this.options = s7;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t9) {
      N2(this, t9);
    }
  };
  var z = { P: e3, A: h3, C: o2, M: 1, L: P, R: S2, D: u2, V: N2, I: M, H: R2, N: H, U: I, B: k, F: L };
  var Z2 = t3.litHtmlPolyfillSupport;
  Z2?.(V, M), (t3.litHtmlVersions ??= []).push("3.1.4");

  // frontend/node_modules/@lit-labs/preact-signals/node_modules/lit/node_modules/lit-html/directive-helpers.js
  var { I: t4 } = z;
  var f3 = (o7) => void 0 === o7.strings;

  // frontend/node_modules/@lit-labs/preact-signals/node_modules/lit/node_modules/lit-html/async-directive.js
  var s4 = (i9, t9) => {
    const e9 = i9._$AN;
    if (void 0 === e9) return false;
    for (const i10 of e9) i10._$AO?.(t9, false), s4(i10, t9);
    return true;
  };
  var o3 = (i9) => {
    let t9, e9;
    do {
      if (void 0 === (t9 = i9._$AM)) break;
      e9 = t9._$AN, e9.delete(i9), i9 = t9;
    } while (0 === e9?.size);
  };
  var r2 = (i9) => {
    for (let t9; t9 = i9._$AM; i9 = t9) {
      let e9 = t9._$AN;
      if (void 0 === e9) t9._$AN = e9 = /* @__PURE__ */ new Set();
      else if (e9.has(i9)) break;
      e9.add(i9), c3(t9);
    }
  };
  function h4(i9) {
    void 0 !== this._$AN ? (o3(this), this._$AM = i9, r2(this)) : this._$AM = i9;
  }
  function n2(i9, t9 = false, e9 = 0) {
    const r8 = this._$AH, h8 = this._$AN;
    if (void 0 !== h8 && 0 !== h8.size) if (t9) if (Array.isArray(r8)) for (let i10 = e9; i10 < r8.length; i10++) s4(r8[i10], false), o3(r8[i10]);
    else null != r8 && (s4(r8, false), o3(r8));
    else s4(this, i9);
  }
  var c3 = (i9) => {
    i9.type == t2.CHILD && (i9._$AP ??= n2, i9._$AQ ??= h4);
  };
  var f4 = class extends i2 {
    constructor() {
      super(...arguments), this._$AN = void 0;
    }
    _$AT(i9, t9, e9) {
      super._$AT(i9, t9, e9), r2(this), this.isConnected = i9._$AU;
    }
    _$AO(i9, t9 = true) {
      i9 !== this.isConnected && (this.isConnected = i9, i9 ? this.reconnected?.() : this.disconnected?.()), t9 && (s4(this, i9), o3(this));
    }
    setValue(t9) {
      if (f3(this._$Ct)) this._$Ct._$AI(t9, this);
      else {
        const i9 = [...this._$Ct._$AH];
        i9[this._$Ci] = t9, this._$Ct._$AI(i9, this, 0);
      }
    }
    disconnected() {
    }
    reconnected() {
    }
  };

  // frontend/node_modules/@lit-labs/preact-signals/lib/watch.js
  var s5 = e2(class extends f4 {
    render(i9) {
      var t9;
      if (i9 !== this._$Oi) {
        null === (t9 = this._$Oo) || void 0 === t9 || t9.call(this), this._$Oi = i9;
        let s7 = true;
        this._$Oo = i9.subscribe((i10) => {
          false === s7 && this.setValue(i10);
        }), s7 = false;
      }
      return i9.peek();
    }
    disconnected() {
      var i9;
      null === (i9 = this._$Oo) || void 0 === i9 || i9.call(this);
    }
    reconnected() {
      var i9;
      this._$Oo = null === (i9 = this._$Oi) || void 0 === i9 ? void 0 : i9.subscribe((i10) => {
        this.setValue(i10);
      });
    }
  });

  // frontend/node_modules/@lit-labs/preact-signals/lib/html-tag.js
  var m3 = (t9) => (o7, ...m5) => t9(o7, ...m5.map((t10) => t10 instanceof u ? s5(t10) : t10));
  var a3 = m3(x);
  var i4 = m3(b2);

  // frontend/ts/proto/jon/jon_shared_data.ts
  var import_minimal26 = __toESM(require_minimal2());

  // frontend/ts/proto/jon/jon_shared_data_camera_day.ts
  var import_minimal15 = __toESM(require_minimal2());
  function createBaseJonGuiDataCameraDay() {
    return {
      focusPos: 0,
      zoomPos: 0,
      irisPos: 0,
      exposure: 0,
      gain: 0,
      autoFocus: false,
      recording: false,
      autoIris: false,
      infraredFilter: false,
      syncZoomToHeatCamera: false,
      zoomTablePos: 0,
      zoomTablePosMax: 0,
      meteo: void 0,
      crossPosX: 0,
      crossPosY: 0
    };
  }
  var JonGuiDataCameraDay = {
    encode(message, writer = import_minimal15.default.Writer.create()) {
      if (message.focusPos !== 0) {
        writer.uint32(13).float(message.focusPos);
      }
      if (message.zoomPos !== 0) {
        writer.uint32(29).float(message.zoomPos);
      }
      if (message.irisPos !== 0) {
        writer.uint32(37).float(message.irisPos);
      }
      if (message.exposure !== 0) {
        writer.uint32(45).float(message.exposure);
      }
      if (message.gain !== 0) {
        writer.uint32(53).float(message.gain);
      }
      if (message.autoFocus !== false) {
        writer.uint32(56).bool(message.autoFocus);
      }
      if (message.recording !== false) {
        writer.uint32(64).bool(message.recording);
      }
      if (message.autoIris !== false) {
        writer.uint32(72).bool(message.autoIris);
      }
      if (message.infraredFilter !== false) {
        writer.uint32(80).bool(message.infraredFilter);
      }
      if (message.syncZoomToHeatCamera !== false) {
        writer.uint32(88).bool(message.syncZoomToHeatCamera);
      }
      if (message.zoomTablePos !== 0) {
        writer.uint32(96).int32(message.zoomTablePos);
      }
      if (message.zoomTablePosMax !== 0) {
        writer.uint32(104).int32(message.zoomTablePosMax);
      }
      if (message.meteo !== void 0) {
        JonGuiDataMeteo.encode(message.meteo, writer.uint32(114).fork()).ldelim();
      }
      if (message.crossPosX !== 0) {
        writer.uint32(120).int32(message.crossPosX);
      }
      if (message.crossPosY !== 0) {
        writer.uint32(136).int32(message.crossPosY);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal15.default.Reader ? input2 : import_minimal15.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataCameraDay();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.focusPos = reader.float();
            continue;
          case 3:
            if (tag !== 29) {
              break;
            }
            message.zoomPos = reader.float();
            continue;
          case 4:
            if (tag !== 37) {
              break;
            }
            message.irisPos = reader.float();
            continue;
          case 5:
            if (tag !== 45) {
              break;
            }
            message.exposure = reader.float();
            continue;
          case 6:
            if (tag !== 53) {
              break;
            }
            message.gain = reader.float();
            continue;
          case 7:
            if (tag !== 56) {
              break;
            }
            message.autoFocus = reader.bool();
            continue;
          case 8:
            if (tag !== 64) {
              break;
            }
            message.recording = reader.bool();
            continue;
          case 9:
            if (tag !== 72) {
              break;
            }
            message.autoIris = reader.bool();
            continue;
          case 10:
            if (tag !== 80) {
              break;
            }
            message.infraredFilter = reader.bool();
            continue;
          case 11:
            if (tag !== 88) {
              break;
            }
            message.syncZoomToHeatCamera = reader.bool();
            continue;
          case 12:
            if (tag !== 96) {
              break;
            }
            message.zoomTablePos = reader.int32();
            continue;
          case 13:
            if (tag !== 104) {
              break;
            }
            message.zoomTablePosMax = reader.int32();
            continue;
          case 14:
            if (tag !== 114) {
              break;
            }
            message.meteo = JonGuiDataMeteo.decode(reader, reader.uint32());
            continue;
          case 15:
            if (tag !== 120) {
              break;
            }
            message.crossPosX = reader.int32();
            continue;
          case 17:
            if (tag !== 136) {
              break;
            }
            message.crossPosY = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        focusPos: isSet15(object.focusPos) ? globalThis.Number(object.focusPos) : 0,
        zoomPos: isSet15(object.zoomPos) ? globalThis.Number(object.zoomPos) : 0,
        irisPos: isSet15(object.irisPos) ? globalThis.Number(object.irisPos) : 0,
        exposure: isSet15(object.exposure) ? globalThis.Number(object.exposure) : 0,
        gain: isSet15(object.gain) ? globalThis.Number(object.gain) : 0,
        autoFocus: isSet15(object.autoFocus) ? globalThis.Boolean(object.autoFocus) : false,
        recording: isSet15(object.recording) ? globalThis.Boolean(object.recording) : false,
        autoIris: isSet15(object.autoIris) ? globalThis.Boolean(object.autoIris) : false,
        infraredFilter: isSet15(object.infraredFilter) ? globalThis.Boolean(object.infraredFilter) : false,
        syncZoomToHeatCamera: isSet15(object.syncZoomToHeatCamera) ? globalThis.Boolean(object.syncZoomToHeatCamera) : false,
        zoomTablePos: isSet15(object.zoomTablePos) ? globalThis.Number(object.zoomTablePos) : 0,
        zoomTablePosMax: isSet15(object.zoomTablePosMax) ? globalThis.Number(object.zoomTablePosMax) : 0,
        meteo: isSet15(object.meteo) ? JonGuiDataMeteo.fromJSON(object.meteo) : void 0,
        crossPosX: isSet15(object.crossPosX) ? globalThis.Number(object.crossPosX) : 0,
        crossPosY: isSet15(object.crossPosY) ? globalThis.Number(object.crossPosY) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.focusPos !== 0) {
        obj.focusPos = message.focusPos;
      }
      if (message.zoomPos !== 0) {
        obj.zoomPos = message.zoomPos;
      }
      if (message.irisPos !== 0) {
        obj.irisPos = message.irisPos;
      }
      if (message.exposure !== 0) {
        obj.exposure = message.exposure;
      }
      if (message.gain !== 0) {
        obj.gain = message.gain;
      }
      if (message.autoFocus !== false) {
        obj.autoFocus = message.autoFocus;
      }
      if (message.recording !== false) {
        obj.recording = message.recording;
      }
      if (message.autoIris !== false) {
        obj.autoIris = message.autoIris;
      }
      if (message.infraredFilter !== false) {
        obj.infraredFilter = message.infraredFilter;
      }
      if (message.syncZoomToHeatCamera !== false) {
        obj.syncZoomToHeatCamera = message.syncZoomToHeatCamera;
      }
      if (message.zoomTablePos !== 0) {
        obj.zoomTablePos = Math.round(message.zoomTablePos);
      }
      if (message.zoomTablePosMax !== 0) {
        obj.zoomTablePosMax = Math.round(message.zoomTablePosMax);
      }
      if (message.meteo !== void 0) {
        obj.meteo = JonGuiDataMeteo.toJSON(message.meteo);
      }
      if (message.crossPosX !== 0) {
        obj.crossPosX = Math.round(message.crossPosX);
      }
      if (message.crossPosY !== 0) {
        obj.crossPosY = Math.round(message.crossPosY);
      }
      return obj;
    },
    create(base) {
      return JonGuiDataCameraDay.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataCameraDay();
      message.focusPos = object.focusPos ?? 0;
      message.zoomPos = object.zoomPos ?? 0;
      message.irisPos = object.irisPos ?? 0;
      message.exposure = object.exposure ?? 0;
      message.gain = object.gain ?? 0;
      message.autoFocus = object.autoFocus ?? false;
      message.recording = object.recording ?? false;
      message.autoIris = object.autoIris ?? false;
      message.infraredFilter = object.infraredFilter ?? false;
      message.syncZoomToHeatCamera = object.syncZoomToHeatCamera ?? false;
      message.zoomTablePos = object.zoomTablePos ?? 0;
      message.zoomTablePosMax = object.zoomTablePosMax ?? 0;
      message.meteo = object.meteo !== void 0 && object.meteo !== null ? JonGuiDataMeteo.fromPartial(object.meteo) : void 0;
      message.crossPosX = object.crossPosX ?? 0;
      message.crossPosY = object.crossPosY ?? 0;
      return message;
    }
  };
  function isSet15(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_data_camera_heat.ts
  var import_minimal16 = __toESM(require_minimal2());
  function createBaseJonGuiDataCameraHeat() {
    return {
      focusPos: 0,
      zoomPos: 0,
      agcMode: 0,
      filter: 0,
      autoFocus: false,
      recording: false,
      syncZoomToDayCamera: false,
      zoomTablePos: 0,
      zoomTablePosMax: 0,
      meteo: void 0,
      ddeLevel: 0,
      ddeEnabled: false,
      ddeMaxLevel: 0,
      crossPosX: 0,
      crossPosY: 0
    };
  }
  var JonGuiDataCameraHeat = {
    encode(message, writer = import_minimal16.default.Writer.create()) {
      if (message.focusPos !== 0) {
        writer.uint32(13).float(message.focusPos);
      }
      if (message.zoomPos !== 0) {
        writer.uint32(21).float(message.zoomPos);
      }
      if (message.agcMode !== 0) {
        writer.uint32(24).int32(message.agcMode);
      }
      if (message.filter !== 0) {
        writer.uint32(32).int32(message.filter);
      }
      if (message.autoFocus !== false) {
        writer.uint32(40).bool(message.autoFocus);
      }
      if (message.recording !== false) {
        writer.uint32(48).bool(message.recording);
      }
      if (message.syncZoomToDayCamera !== false) {
        writer.uint32(56).bool(message.syncZoomToDayCamera);
      }
      if (message.zoomTablePos !== 0) {
        writer.uint32(64).int32(message.zoomTablePos);
      }
      if (message.zoomTablePosMax !== 0) {
        writer.uint32(72).int32(message.zoomTablePosMax);
      }
      if (message.meteo !== void 0) {
        JonGuiDataMeteo.encode(message.meteo, writer.uint32(82).fork()).ldelim();
      }
      if (message.ddeLevel !== 0) {
        writer.uint32(88).int32(message.ddeLevel);
      }
      if (message.ddeEnabled !== false) {
        writer.uint32(96).bool(message.ddeEnabled);
      }
      if (message.ddeMaxLevel !== 0) {
        writer.uint32(104).int32(message.ddeMaxLevel);
      }
      if (message.crossPosX !== 0) {
        writer.uint32(112).int32(message.crossPosX);
      }
      if (message.crossPosY !== 0) {
        writer.uint32(120).int32(message.crossPosY);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal16.default.Reader ? input2 : import_minimal16.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataCameraHeat();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.focusPos = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.zoomPos = reader.float();
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }
            message.agcMode = reader.int32();
            continue;
          case 4:
            if (tag !== 32) {
              break;
            }
            message.filter = reader.int32();
            continue;
          case 5:
            if (tag !== 40) {
              break;
            }
            message.autoFocus = reader.bool();
            continue;
          case 6:
            if (tag !== 48) {
              break;
            }
            message.recording = reader.bool();
            continue;
          case 7:
            if (tag !== 56) {
              break;
            }
            message.syncZoomToDayCamera = reader.bool();
            continue;
          case 8:
            if (tag !== 64) {
              break;
            }
            message.zoomTablePos = reader.int32();
            continue;
          case 9:
            if (tag !== 72) {
              break;
            }
            message.zoomTablePosMax = reader.int32();
            continue;
          case 10:
            if (tag !== 82) {
              break;
            }
            message.meteo = JonGuiDataMeteo.decode(reader, reader.uint32());
            continue;
          case 11:
            if (tag !== 88) {
              break;
            }
            message.ddeLevel = reader.int32();
            continue;
          case 12:
            if (tag !== 96) {
              break;
            }
            message.ddeEnabled = reader.bool();
            continue;
          case 13:
            if (tag !== 104) {
              break;
            }
            message.ddeMaxLevel = reader.int32();
            continue;
          case 14:
            if (tag !== 112) {
              break;
            }
            message.crossPosX = reader.int32();
            continue;
          case 15:
            if (tag !== 120) {
              break;
            }
            message.crossPosY = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        focusPos: isSet16(object.focusPos) ? globalThis.Number(object.focusPos) : 0,
        zoomPos: isSet16(object.zoomPos) ? globalThis.Number(object.zoomPos) : 0,
        agcMode: isSet16(object.agcMode) ? jonGuiDataVideoChannelHeatAGCModesFromJSON(object.agcMode) : 0,
        filter: isSet16(object.filter) ? jonGuiDataVideoChannelHeatFiltersFromJSON(object.filter) : 0,
        autoFocus: isSet16(object.autoFocus) ? globalThis.Boolean(object.autoFocus) : false,
        recording: isSet16(object.recording) ? globalThis.Boolean(object.recording) : false,
        syncZoomToDayCamera: isSet16(object.syncZoomToDayCamera) ? globalThis.Boolean(object.syncZoomToDayCamera) : false,
        zoomTablePos: isSet16(object.zoomTablePos) ? globalThis.Number(object.zoomTablePos) : 0,
        zoomTablePosMax: isSet16(object.zoomTablePosMax) ? globalThis.Number(object.zoomTablePosMax) : 0,
        meteo: isSet16(object.meteo) ? JonGuiDataMeteo.fromJSON(object.meteo) : void 0,
        ddeLevel: isSet16(object.ddeLevel) ? globalThis.Number(object.ddeLevel) : 0,
        ddeEnabled: isSet16(object.ddeEnabled) ? globalThis.Boolean(object.ddeEnabled) : false,
        ddeMaxLevel: isSet16(object.ddeMaxLevel) ? globalThis.Number(object.ddeMaxLevel) : 0,
        crossPosX: isSet16(object.crossPosX) ? globalThis.Number(object.crossPosX) : 0,
        crossPosY: isSet16(object.crossPosY) ? globalThis.Number(object.crossPosY) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.focusPos !== 0) {
        obj.focusPos = message.focusPos;
      }
      if (message.zoomPos !== 0) {
        obj.zoomPos = message.zoomPos;
      }
      if (message.agcMode !== 0) {
        obj.agcMode = jonGuiDataVideoChannelHeatAGCModesToJSON(message.agcMode);
      }
      if (message.filter !== 0) {
        obj.filter = jonGuiDataVideoChannelHeatFiltersToJSON(message.filter);
      }
      if (message.autoFocus !== false) {
        obj.autoFocus = message.autoFocus;
      }
      if (message.recording !== false) {
        obj.recording = message.recording;
      }
      if (message.syncZoomToDayCamera !== false) {
        obj.syncZoomToDayCamera = message.syncZoomToDayCamera;
      }
      if (message.zoomTablePos !== 0) {
        obj.zoomTablePos = Math.round(message.zoomTablePos);
      }
      if (message.zoomTablePosMax !== 0) {
        obj.zoomTablePosMax = Math.round(message.zoomTablePosMax);
      }
      if (message.meteo !== void 0) {
        obj.meteo = JonGuiDataMeteo.toJSON(message.meteo);
      }
      if (message.ddeLevel !== 0) {
        obj.ddeLevel = Math.round(message.ddeLevel);
      }
      if (message.ddeEnabled !== false) {
        obj.ddeEnabled = message.ddeEnabled;
      }
      if (message.ddeMaxLevel !== 0) {
        obj.ddeMaxLevel = Math.round(message.ddeMaxLevel);
      }
      if (message.crossPosX !== 0) {
        obj.crossPosX = Math.round(message.crossPosX);
      }
      if (message.crossPosY !== 0) {
        obj.crossPosY = Math.round(message.crossPosY);
      }
      return obj;
    },
    create(base) {
      return JonGuiDataCameraHeat.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataCameraHeat();
      message.focusPos = object.focusPos ?? 0;
      message.zoomPos = object.zoomPos ?? 0;
      message.agcMode = object.agcMode ?? 0;
      message.filter = object.filter ?? 0;
      message.autoFocus = object.autoFocus ?? false;
      message.recording = object.recording ?? false;
      message.syncZoomToDayCamera = object.syncZoomToDayCamera ?? false;
      message.zoomTablePos = object.zoomTablePos ?? 0;
      message.zoomTablePosMax = object.zoomTablePosMax ?? 0;
      message.meteo = object.meteo !== void 0 && object.meteo !== null ? JonGuiDataMeteo.fromPartial(object.meteo) : void 0;
      message.ddeLevel = object.ddeLevel ?? 0;
      message.ddeEnabled = object.ddeEnabled ?? false;
      message.ddeMaxLevel = object.ddeMaxLevel ?? 0;
      message.crossPosX = object.crossPosX ?? 0;
      message.crossPosY = object.crossPosY ?? 0;
      return message;
    }
  };
  function isSet16(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_data_compass.ts
  var import_minimal17 = __toESM(require_minimal2());
  function createBaseJonGuiDataCompass() {
    return {
      azimuth: 0,
      elevation: 0,
      bank: 0,
      offsetAzimuth: 0,
      offsetElevation: 0,
      magneticDeclination: 0,
      calibrating: false,
      meteo: void 0
    };
  }
  var JonGuiDataCompass = {
    encode(message, writer = import_minimal17.default.Writer.create()) {
      if (message.azimuth !== 0) {
        writer.uint32(13).float(message.azimuth);
      }
      if (message.elevation !== 0) {
        writer.uint32(21).float(message.elevation);
      }
      if (message.bank !== 0) {
        writer.uint32(29).float(message.bank);
      }
      if (message.offsetAzimuth !== 0) {
        writer.uint32(37).float(message.offsetAzimuth);
      }
      if (message.offsetElevation !== 0) {
        writer.uint32(45).float(message.offsetElevation);
      }
      if (message.magneticDeclination !== 0) {
        writer.uint32(53).float(message.magneticDeclination);
      }
      if (message.calibrating !== false) {
        writer.uint32(56).bool(message.calibrating);
      }
      if (message.meteo !== void 0) {
        JonGuiDataMeteo.encode(message.meteo, writer.uint32(66).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal17.default.Reader ? input2 : import_minimal17.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataCompass();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.azimuth = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.elevation = reader.float();
            continue;
          case 3:
            if (tag !== 29) {
              break;
            }
            message.bank = reader.float();
            continue;
          case 4:
            if (tag !== 37) {
              break;
            }
            message.offsetAzimuth = reader.float();
            continue;
          case 5:
            if (tag !== 45) {
              break;
            }
            message.offsetElevation = reader.float();
            continue;
          case 6:
            if (tag !== 53) {
              break;
            }
            message.magneticDeclination = reader.float();
            continue;
          case 7:
            if (tag !== 56) {
              break;
            }
            message.calibrating = reader.bool();
            continue;
          case 8:
            if (tag !== 66) {
              break;
            }
            message.meteo = JonGuiDataMeteo.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        azimuth: isSet17(object.azimuth) ? globalThis.Number(object.azimuth) : 0,
        elevation: isSet17(object.elevation) ? globalThis.Number(object.elevation) : 0,
        bank: isSet17(object.bank) ? globalThis.Number(object.bank) : 0,
        offsetAzimuth: isSet17(object.offsetAzimuth) ? globalThis.Number(object.offsetAzimuth) : 0,
        offsetElevation: isSet17(object.offsetElevation) ? globalThis.Number(object.offsetElevation) : 0,
        magneticDeclination: isSet17(object.magneticDeclination) ? globalThis.Number(object.magneticDeclination) : 0,
        calibrating: isSet17(object.calibrating) ? globalThis.Boolean(object.calibrating) : false,
        meteo: isSet17(object.meteo) ? JonGuiDataMeteo.fromJSON(object.meteo) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.azimuth !== 0) {
        obj.azimuth = message.azimuth;
      }
      if (message.elevation !== 0) {
        obj.elevation = message.elevation;
      }
      if (message.bank !== 0) {
        obj.bank = message.bank;
      }
      if (message.offsetAzimuth !== 0) {
        obj.offsetAzimuth = message.offsetAzimuth;
      }
      if (message.offsetElevation !== 0) {
        obj.offsetElevation = message.offsetElevation;
      }
      if (message.magneticDeclination !== 0) {
        obj.magneticDeclination = message.magneticDeclination;
      }
      if (message.calibrating !== false) {
        obj.calibrating = message.calibrating;
      }
      if (message.meteo !== void 0) {
        obj.meteo = JonGuiDataMeteo.toJSON(message.meteo);
      }
      return obj;
    },
    create(base) {
      return JonGuiDataCompass.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataCompass();
      message.azimuth = object.azimuth ?? 0;
      message.elevation = object.elevation ?? 0;
      message.bank = object.bank ?? 0;
      message.offsetAzimuth = object.offsetAzimuth ?? 0;
      message.offsetElevation = object.offsetElevation ?? 0;
      message.magneticDeclination = object.magneticDeclination ?? 0;
      message.calibrating = object.calibrating ?? false;
      message.meteo = object.meteo !== void 0 && object.meteo !== null ? JonGuiDataMeteo.fromPartial(object.meteo) : void 0;
      return message;
    }
  };
  function isSet17(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_data_compass_calibration.ts
  var import_minimal18 = __toESM(require_minimal2());
  function createBaseJonGuiDataCompassCalibration() {
    return { stage: 0, finalStage: 0, targetAzimuth: 0, targetElevation: 0, targetBank: 0, status: 0 };
  }
  var JonGuiDataCompassCalibration = {
    encode(message, writer = import_minimal18.default.Writer.create()) {
      if (message.stage !== 0) {
        writer.uint32(8).uint32(message.stage);
      }
      if (message.finalStage !== 0) {
        writer.uint32(16).uint32(message.finalStage);
      }
      if (message.targetAzimuth !== 0) {
        writer.uint32(29).float(message.targetAzimuth);
      }
      if (message.targetElevation !== 0) {
        writer.uint32(37).float(message.targetElevation);
      }
      if (message.targetBank !== 0) {
        writer.uint32(45).float(message.targetBank);
      }
      if (message.status !== 0) {
        writer.uint32(48).int32(message.status);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal18.default.Reader ? input2 : import_minimal18.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataCompassCalibration();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.stage = reader.uint32();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.finalStage = reader.uint32();
            continue;
          case 3:
            if (tag !== 29) {
              break;
            }
            message.targetAzimuth = reader.float();
            continue;
          case 4:
            if (tag !== 37) {
              break;
            }
            message.targetElevation = reader.float();
            continue;
          case 5:
            if (tag !== 45) {
              break;
            }
            message.targetBank = reader.float();
            continue;
          case 6:
            if (tag !== 48) {
              break;
            }
            message.status = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        stage: isSet18(object.stage) ? globalThis.Number(object.stage) : 0,
        finalStage: isSet18(object.finalStage) ? globalThis.Number(object.finalStage) : 0,
        targetAzimuth: isSet18(object.targetAzimuth) ? globalThis.Number(object.targetAzimuth) : 0,
        targetElevation: isSet18(object.targetElevation) ? globalThis.Number(object.targetElevation) : 0,
        targetBank: isSet18(object.targetBank) ? globalThis.Number(object.targetBank) : 0,
        status: isSet18(object.status) ? jonGuiDataCompassCalibrateStatusFromJSON(object.status) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.stage !== 0) {
        obj.stage = Math.round(message.stage);
      }
      if (message.finalStage !== 0) {
        obj.finalStage = Math.round(message.finalStage);
      }
      if (message.targetAzimuth !== 0) {
        obj.targetAzimuth = message.targetAzimuth;
      }
      if (message.targetElevation !== 0) {
        obj.targetElevation = message.targetElevation;
      }
      if (message.targetBank !== 0) {
        obj.targetBank = message.targetBank;
      }
      if (message.status !== 0) {
        obj.status = jonGuiDataCompassCalibrateStatusToJSON(message.status);
      }
      return obj;
    },
    create(base) {
      return JonGuiDataCompassCalibration.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataCompassCalibration();
      message.stage = object.stage ?? 0;
      message.finalStage = object.finalStage ?? 0;
      message.targetAzimuth = object.targetAzimuth ?? 0;
      message.targetElevation = object.targetElevation ?? 0;
      message.targetBank = object.targetBank ?? 0;
      message.status = object.status ?? 0;
      return message;
    }
  };
  function isSet18(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_data_environment.ts
  var import_minimal19 = __toESM(require_minimal2());
  function createBaseJonGuiDataEnvironment() {
    return {
      weatherCondition: 0,
      lightingCondition: 0,
      precipitationType: 0,
      groundCondition: 0,
      opticalVisibility: 0,
      thermalCondition: 0,
      networkStatus: 0,
      lightSourceCondition: 0
    };
  }
  var JonGuiDataEnvironment = {
    encode(message, writer = import_minimal19.default.Writer.create()) {
      if (message.weatherCondition !== 0) {
        writer.uint32(8).int32(message.weatherCondition);
      }
      if (message.lightingCondition !== 0) {
        writer.uint32(16).int32(message.lightingCondition);
      }
      if (message.precipitationType !== 0) {
        writer.uint32(24).int32(message.precipitationType);
      }
      if (message.groundCondition !== 0) {
        writer.uint32(32).int32(message.groundCondition);
      }
      if (message.opticalVisibility !== 0) {
        writer.uint32(40).int32(message.opticalVisibility);
      }
      if (message.thermalCondition !== 0) {
        writer.uint32(48).int32(message.thermalCondition);
      }
      if (message.networkStatus !== 0) {
        writer.uint32(56).int32(message.networkStatus);
      }
      if (message.lightSourceCondition !== 0) {
        writer.uint32(64).int32(message.lightSourceCondition);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal19.default.Reader ? input2 : import_minimal19.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataEnvironment();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.weatherCondition = reader.int32();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.lightingCondition = reader.int32();
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }
            message.precipitationType = reader.int32();
            continue;
          case 4:
            if (tag !== 32) {
              break;
            }
            message.groundCondition = reader.int32();
            continue;
          case 5:
            if (tag !== 40) {
              break;
            }
            message.opticalVisibility = reader.int32();
            continue;
          case 6:
            if (tag !== 48) {
              break;
            }
            message.thermalCondition = reader.int32();
            continue;
          case 7:
            if (tag !== 56) {
              break;
            }
            message.networkStatus = reader.int32();
            continue;
          case 8:
            if (tag !== 64) {
              break;
            }
            message.lightSourceCondition = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        weatherCondition: isSet19(object.weatherCondition) ? jonGuiDataEnvironmentWeatherConditionFromJSON(object.weatherCondition) : 0,
        lightingCondition: isSet19(object.lightingCondition) ? jonGuiDataEnvironmentLightingConditionFromJSON(object.lightingCondition) : 0,
        precipitationType: isSet19(object.precipitationType) ? jonGuiDataEnvironmentPrecipitationTypeFromJSON(object.precipitationType) : 0,
        groundCondition: isSet19(object.groundCondition) ? jonGuiDataEnvironmentGroundConditionFromJSON(object.groundCondition) : 0,
        opticalVisibility: isSet19(object.opticalVisibility) ? jonGuiDataEnvironmentOpticalVisibilityFromJSON(object.opticalVisibility) : 0,
        thermalCondition: isSet19(object.thermalCondition) ? jonGuiDataEnvironmentThermalConditionFromJSON(object.thermalCondition) : 0,
        networkStatus: isSet19(object.networkStatus) ? jonGuiDataEnvironmentNetworkStatusFromJSON(object.networkStatus) : 0,
        lightSourceCondition: isSet19(object.lightSourceCondition) ? jonGuiDataEnvironmentLightSourceFromJSON(object.lightSourceCondition) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.weatherCondition !== 0) {
        obj.weatherCondition = jonGuiDataEnvironmentWeatherConditionToJSON(message.weatherCondition);
      }
      if (message.lightingCondition !== 0) {
        obj.lightingCondition = jonGuiDataEnvironmentLightingConditionToJSON(message.lightingCondition);
      }
      if (message.precipitationType !== 0) {
        obj.precipitationType = jonGuiDataEnvironmentPrecipitationTypeToJSON(message.precipitationType);
      }
      if (message.groundCondition !== 0) {
        obj.groundCondition = jonGuiDataEnvironmentGroundConditionToJSON(message.groundCondition);
      }
      if (message.opticalVisibility !== 0) {
        obj.opticalVisibility = jonGuiDataEnvironmentOpticalVisibilityToJSON(message.opticalVisibility);
      }
      if (message.thermalCondition !== 0) {
        obj.thermalCondition = jonGuiDataEnvironmentThermalConditionToJSON(message.thermalCondition);
      }
      if (message.networkStatus !== 0) {
        obj.networkStatus = jonGuiDataEnvironmentNetworkStatusToJSON(message.networkStatus);
      }
      if (message.lightSourceCondition !== 0) {
        obj.lightSourceCondition = jonGuiDataEnvironmentLightSourceToJSON(message.lightSourceCondition);
      }
      return obj;
    },
    create(base) {
      return JonGuiDataEnvironment.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataEnvironment();
      message.weatherCondition = object.weatherCondition ?? 0;
      message.lightingCondition = object.lightingCondition ?? 0;
      message.precipitationType = object.precipitationType ?? 0;
      message.groundCondition = object.groundCondition ?? 0;
      message.opticalVisibility = object.opticalVisibility ?? 0;
      message.thermalCondition = object.thermalCondition ?? 0;
      message.networkStatus = object.networkStatus ?? 0;
      message.lightSourceCondition = object.lightSourceCondition ?? 0;
      return message;
    }
  };
  function isSet19(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_data_gps.ts
  var import_minimal20 = __toESM(require_minimal2());
  function createBaseJonGuiDataGps() {
    return {
      longitude: 0,
      latitude: 0,
      altitude: 0,
      manualLongitude: 0,
      manualLatitude: 0,
      manualAltitude: 0,
      fixType: 0,
      useManual: false,
      radius: 0,
      meteo: void 0
    };
  }
  var JonGuiDataGps = {
    encode(message, writer = import_minimal20.default.Writer.create()) {
      if (message.longitude !== 0) {
        writer.uint32(9).double(message.longitude);
      }
      if (message.latitude !== 0) {
        writer.uint32(17).double(message.latitude);
      }
      if (message.altitude !== 0) {
        writer.uint32(25).double(message.altitude);
      }
      if (message.manualLongitude !== 0) {
        writer.uint32(33).double(message.manualLongitude);
      }
      if (message.manualLatitude !== 0) {
        writer.uint32(41).double(message.manualLatitude);
      }
      if (message.manualAltitude !== 0) {
        writer.uint32(49).double(message.manualAltitude);
      }
      if (message.fixType !== 0) {
        writer.uint32(56).int32(message.fixType);
      }
      if (message.useManual !== false) {
        writer.uint32(64).bool(message.useManual);
      }
      if (message.radius !== 0) {
        writer.uint32(73).double(message.radius);
      }
      if (message.meteo !== void 0) {
        JonGuiDataMeteo.encode(message.meteo, writer.uint32(82).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal20.default.Reader ? input2 : import_minimal20.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataGps();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 9) {
              break;
            }
            message.longitude = reader.double();
            continue;
          case 2:
            if (tag !== 17) {
              break;
            }
            message.latitude = reader.double();
            continue;
          case 3:
            if (tag !== 25) {
              break;
            }
            message.altitude = reader.double();
            continue;
          case 4:
            if (tag !== 33) {
              break;
            }
            message.manualLongitude = reader.double();
            continue;
          case 5:
            if (tag !== 41) {
              break;
            }
            message.manualLatitude = reader.double();
            continue;
          case 6:
            if (tag !== 49) {
              break;
            }
            message.manualAltitude = reader.double();
            continue;
          case 7:
            if (tag !== 56) {
              break;
            }
            message.fixType = reader.int32();
            continue;
          case 8:
            if (tag !== 64) {
              break;
            }
            message.useManual = reader.bool();
            continue;
          case 9:
            if (tag !== 73) {
              break;
            }
            message.radius = reader.double();
            continue;
          case 10:
            if (tag !== 82) {
              break;
            }
            message.meteo = JonGuiDataMeteo.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        longitude: isSet20(object.longitude) ? globalThis.Number(object.longitude) : 0,
        latitude: isSet20(object.latitude) ? globalThis.Number(object.latitude) : 0,
        altitude: isSet20(object.altitude) ? globalThis.Number(object.altitude) : 0,
        manualLongitude: isSet20(object.manualLongitude) ? globalThis.Number(object.manualLongitude) : 0,
        manualLatitude: isSet20(object.manualLatitude) ? globalThis.Number(object.manualLatitude) : 0,
        manualAltitude: isSet20(object.manualAltitude) ? globalThis.Number(object.manualAltitude) : 0,
        fixType: isSet20(object.fixType) ? jonGuiDataGpsFixTypeFromJSON(object.fixType) : 0,
        useManual: isSet20(object.useManual) ? globalThis.Boolean(object.useManual) : false,
        radius: isSet20(object.radius) ? globalThis.Number(object.radius) : 0,
        meteo: isSet20(object.meteo) ? JonGuiDataMeteo.fromJSON(object.meteo) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.longitude !== 0) {
        obj.longitude = message.longitude;
      }
      if (message.latitude !== 0) {
        obj.latitude = message.latitude;
      }
      if (message.altitude !== 0) {
        obj.altitude = message.altitude;
      }
      if (message.manualLongitude !== 0) {
        obj.manualLongitude = message.manualLongitude;
      }
      if (message.manualLatitude !== 0) {
        obj.manualLatitude = message.manualLatitude;
      }
      if (message.manualAltitude !== 0) {
        obj.manualAltitude = message.manualAltitude;
      }
      if (message.fixType !== 0) {
        obj.fixType = jonGuiDataGpsFixTypeToJSON(message.fixType);
      }
      if (message.useManual !== false) {
        obj.useManual = message.useManual;
      }
      if (message.radius !== 0) {
        obj.radius = message.radius;
      }
      if (message.meteo !== void 0) {
        obj.meteo = JonGuiDataMeteo.toJSON(message.meteo);
      }
      return obj;
    },
    create(base) {
      return JonGuiDataGps.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataGps();
      message.longitude = object.longitude ?? 0;
      message.latitude = object.latitude ?? 0;
      message.altitude = object.altitude ?? 0;
      message.manualLongitude = object.manualLongitude ?? 0;
      message.manualLatitude = object.manualLatitude ?? 0;
      message.manualAltitude = object.manualAltitude ?? 0;
      message.fixType = object.fixType ?? 0;
      message.useManual = object.useManual ?? false;
      message.radius = object.radius ?? 0;
      message.meteo = object.meteo !== void 0 && object.meteo !== null ? JonGuiDataMeteo.fromPartial(object.meteo) : void 0;
      return message;
    }
  };
  function isSet20(value) {
    return value !== null && value !== void 0;
  }

  // frontend/node_modules/long/index.js
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e9) {
  }
  function Long(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  Long.prototype.__isLong__;
  Object.defineProperty(Long.prototype, "__isLong__", { value: true });
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  function ctz32(value) {
    var c7 = Math.clz32(value & -value);
    return value ? 31 - c7 : c7;
  }
  Long.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
      value >>>= 0;
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, 0, true);
      if (cache)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  Long.fromInt = fromInt;
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  Long.fromNumber = fromNumber;
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
  Long.fromBits = fromBits;
  var pow_dbl = Math.pow;
  function fromString(str, unsigned, radix) {
    if (str.length === 0)
      throw Error("empty string");
    if (typeof unsigned === "number") {
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return unsigned ? UZERO : ZERO;
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p4;
    if ((p4 = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p4 === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i9 = 0; i9 < str.length; i9 += 8) {
      var size = Math.min(8, str.length - i9), value = parseInt(str.substring(i9, i9 + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  Long.fromString = fromString;
  function fromValue(val, unsigned) {
    if (typeof val === "number")
      return fromNumber(val, unsigned);
    if (typeof val === "string")
      return fromString(val, unsigned);
    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
  }
  Long.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO = fromInt(0);
  Long.ZERO = ZERO;
  var UZERO = fromInt(0, true);
  Long.UZERO = UZERO;
  var ONE = fromInt(1);
  Long.ONE = ONE;
  var UONE = fromInt(1, true);
  Long.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  LongPrototype.toString = function toString2(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else
        return "-" + this.neg().toString(radix);
    }
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
      if ((val & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals2(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(
      /* validates */
      other
    );
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(
      /* validates */
      other
    ) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(
      /* validates */
      other
    ) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
      return this;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low = wasm["mul"](
        this.low,
        this.high,
        multiplier.low,
        multiplier.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (multiplier.isZero())
      return this.unsigned ? UZERO : ZERO;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
  LongPrototype.clz = LongPrototype.countLeadingZeros;
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b4;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b4 = 32 - numBits;
      return fromBits(this.low << numBits | this.high >>> b4, this.high << numBits | this.low >>> b4, this.unsigned);
    }
    numBits -= 32;
    b4 = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b4, this.low << numBits | this.high >>> b4, this.unsigned);
  };
  LongPrototype.rotl = LongPrototype.rotateLeft;
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b4;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b4 = 32 - numBits;
      return fromBits(this.high << b4 | this.low >>> numBits, this.low << b4 | this.high >>> numBits, this.unsigned);
    }
    numBits -= 32;
    b4 = 32 - numBits;
    return fromBits(this.low << b4 | this.high >>> numBits, this.high << b4 | this.low >>> numBits, this.unsigned);
  };
  LongPrototype.rotr = LongPrototype.rotateRight;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes(le2) {
    return le2 ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long.fromBytes = function fromBytes(bytes, unsigned, le2) {
    return le2 ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
  };
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
      bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
      bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
      unsigned
    );
  };
  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
      bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
      bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
      unsigned
    );
  };
  var long_default = Long;

  // frontend/ts/proto/jon/jon_shared_data_lrf.ts
  var import_minimal21 = __toESM(require_minimal2());
  function createBaseJonGuiDataLrf() {
    return { isScanning: false, isMeasuring: false, measureId: 0, target: void 0, meteo: void 0 };
  }
  var JonGuiDataLrf = {
    encode(message, writer = import_minimal21.default.Writer.create()) {
      if (message.isScanning !== false) {
        writer.uint32(8).bool(message.isScanning);
      }
      if (message.isMeasuring !== false) {
        writer.uint32(16).bool(message.isMeasuring);
      }
      if (message.measureId !== 0) {
        writer.uint32(24).int32(message.measureId);
      }
      if (message.target !== void 0) {
        JonGuiDataTarget.encode(message.target, writer.uint32(34).fork()).ldelim();
      }
      if (message.meteo !== void 0) {
        JonGuiDataMeteo.encode(message.meteo, writer.uint32(42).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal21.default.Reader ? input2 : import_minimal21.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataLrf();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.isScanning = reader.bool();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.isMeasuring = reader.bool();
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }
            message.measureId = reader.int32();
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.target = JonGuiDataTarget.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.meteo = JonGuiDataMeteo.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        isScanning: isSet21(object.isScanning) ? globalThis.Boolean(object.isScanning) : false,
        isMeasuring: isSet21(object.isMeasuring) ? globalThis.Boolean(object.isMeasuring) : false,
        measureId: isSet21(object.measureId) ? globalThis.Number(object.measureId) : 0,
        target: isSet21(object.target) ? JonGuiDataTarget.fromJSON(object.target) : void 0,
        meteo: isSet21(object.meteo) ? JonGuiDataMeteo.fromJSON(object.meteo) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.isScanning !== false) {
        obj.isScanning = message.isScanning;
      }
      if (message.isMeasuring !== false) {
        obj.isMeasuring = message.isMeasuring;
      }
      if (message.measureId !== 0) {
        obj.measureId = Math.round(message.measureId);
      }
      if (message.target !== void 0) {
        obj.target = JonGuiDataTarget.toJSON(message.target);
      }
      if (message.meteo !== void 0) {
        obj.meteo = JonGuiDataMeteo.toJSON(message.meteo);
      }
      return obj;
    },
    create(base) {
      return JonGuiDataLrf.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataLrf();
      message.isScanning = object.isScanning ?? false;
      message.isMeasuring = object.isMeasuring ?? false;
      message.measureId = object.measureId ?? 0;
      message.target = object.target !== void 0 && object.target !== null ? JonGuiDataTarget.fromPartial(object.target) : void 0;
      message.meteo = object.meteo !== void 0 && object.meteo !== null ? JonGuiDataMeteo.fromPartial(object.meteo) : void 0;
      return message;
    }
  };
  function createBaseJonGuiDataTarget() {
    return {
      timestamp: 0,
      targetLongitude: 0,
      targetLatitude: 0,
      targetAltitude: 0,
      observerLongitude: 0,
      observerLatitude: 0,
      observerAltitude: 0,
      observerAzimuth: 0,
      observerElevation: 0,
      observerBank: 0,
      distance2d: 0,
      distance3b: 0,
      observerFixType: 0,
      rangeA: 0,
      rangeB: 0,
      rangeC: 0,
      radius: 0,
      sessionId: 0,
      targetId: 0,
      targetColor: void 0,
      type: 0
    };
  }
  var JonGuiDataTarget = {
    encode(message, writer = import_minimal21.default.Writer.create()) {
      if (message.timestamp !== 0) {
        writer.uint32(8).int64(message.timestamp);
      }
      if (message.targetLongitude !== 0) {
        writer.uint32(17).double(message.targetLongitude);
      }
      if (message.targetLatitude !== 0) {
        writer.uint32(25).double(message.targetLatitude);
      }
      if (message.targetAltitude !== 0) {
        writer.uint32(33).double(message.targetAltitude);
      }
      if (message.observerLongitude !== 0) {
        writer.uint32(41).double(message.observerLongitude);
      }
      if (message.observerLatitude !== 0) {
        writer.uint32(49).double(message.observerLatitude);
      }
      if (message.observerAltitude !== 0) {
        writer.uint32(57).double(message.observerAltitude);
      }
      if (message.observerAzimuth !== 0) {
        writer.uint32(65).double(message.observerAzimuth);
      }
      if (message.observerElevation !== 0) {
        writer.uint32(73).double(message.observerElevation);
      }
      if (message.observerBank !== 0) {
        writer.uint32(81).double(message.observerBank);
      }
      if (message.distance2d !== 0) {
        writer.uint32(89).double(message.distance2d);
      }
      if (message.distance3b !== 0) {
        writer.uint32(97).double(message.distance3b);
      }
      if (message.observerFixType !== 0) {
        writer.uint32(104).int32(message.observerFixType);
      }
      if (message.rangeA !== 0) {
        writer.uint32(113).double(message.rangeA);
      }
      if (message.rangeB !== 0) {
        writer.uint32(121).double(message.rangeB);
      }
      if (message.rangeC !== 0) {
        writer.uint32(129).double(message.rangeC);
      }
      if (message.radius !== 0) {
        writer.uint32(137).double(message.radius);
      }
      if (message.sessionId !== 0) {
        writer.uint32(144).int32(message.sessionId);
      }
      if (message.targetId !== 0) {
        writer.uint32(152).int32(message.targetId);
      }
      if (message.targetColor !== void 0) {
        RgbColor.encode(message.targetColor, writer.uint32(162).fork()).ldelim();
      }
      if (message.type !== 0) {
        writer.uint32(168).uint32(message.type);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal21.default.Reader ? input2 : import_minimal21.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataTarget();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.timestamp = longToNumber(reader.int64());
            continue;
          case 2:
            if (tag !== 17) {
              break;
            }
            message.targetLongitude = reader.double();
            continue;
          case 3:
            if (tag !== 25) {
              break;
            }
            message.targetLatitude = reader.double();
            continue;
          case 4:
            if (tag !== 33) {
              break;
            }
            message.targetAltitude = reader.double();
            continue;
          case 5:
            if (tag !== 41) {
              break;
            }
            message.observerLongitude = reader.double();
            continue;
          case 6:
            if (tag !== 49) {
              break;
            }
            message.observerLatitude = reader.double();
            continue;
          case 7:
            if (tag !== 57) {
              break;
            }
            message.observerAltitude = reader.double();
            continue;
          case 8:
            if (tag !== 65) {
              break;
            }
            message.observerAzimuth = reader.double();
            continue;
          case 9:
            if (tag !== 73) {
              break;
            }
            message.observerElevation = reader.double();
            continue;
          case 10:
            if (tag !== 81) {
              break;
            }
            message.observerBank = reader.double();
            continue;
          case 11:
            if (tag !== 89) {
              break;
            }
            message.distance2d = reader.double();
            continue;
          case 12:
            if (tag !== 97) {
              break;
            }
            message.distance3b = reader.double();
            continue;
          case 13:
            if (tag !== 104) {
              break;
            }
            message.observerFixType = reader.int32();
            continue;
          case 14:
            if (tag !== 113) {
              break;
            }
            message.rangeA = reader.double();
            continue;
          case 15:
            if (tag !== 121) {
              break;
            }
            message.rangeB = reader.double();
            continue;
          case 16:
            if (tag !== 129) {
              break;
            }
            message.rangeC = reader.double();
            continue;
          case 17:
            if (tag !== 137) {
              break;
            }
            message.radius = reader.double();
            continue;
          case 18:
            if (tag !== 144) {
              break;
            }
            message.sessionId = reader.int32();
            continue;
          case 19:
            if (tag !== 152) {
              break;
            }
            message.targetId = reader.int32();
            continue;
          case 20:
            if (tag !== 162) {
              break;
            }
            message.targetColor = RgbColor.decode(reader, reader.uint32());
            continue;
          case 21:
            if (tag !== 168) {
              break;
            }
            message.type = reader.uint32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        timestamp: isSet21(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
        targetLongitude: isSet21(object.targetLongitude) ? globalThis.Number(object.targetLongitude) : 0,
        targetLatitude: isSet21(object.targetLatitude) ? globalThis.Number(object.targetLatitude) : 0,
        targetAltitude: isSet21(object.targetAltitude) ? globalThis.Number(object.targetAltitude) : 0,
        observerLongitude: isSet21(object.observerLongitude) ? globalThis.Number(object.observerLongitude) : 0,
        observerLatitude: isSet21(object.observerLatitude) ? globalThis.Number(object.observerLatitude) : 0,
        observerAltitude: isSet21(object.observerAltitude) ? globalThis.Number(object.observerAltitude) : 0,
        observerAzimuth: isSet21(object.observerAzimuth) ? globalThis.Number(object.observerAzimuth) : 0,
        observerElevation: isSet21(object.observerElevation) ? globalThis.Number(object.observerElevation) : 0,
        observerBank: isSet21(object.observerBank) ? globalThis.Number(object.observerBank) : 0,
        distance2d: isSet21(object.distance2d) ? globalThis.Number(object.distance2d) : 0,
        distance3b: isSet21(object.distance3b) ? globalThis.Number(object.distance3b) : 0,
        observerFixType: isSet21(object.observerFixType) ? jonGuiDataGpsFixTypeFromJSON(object.observerFixType) : 0,
        rangeA: isSet21(object.rangeA) ? globalThis.Number(object.rangeA) : 0,
        rangeB: isSet21(object.rangeB) ? globalThis.Number(object.rangeB) : 0,
        rangeC: isSet21(object.rangeC) ? globalThis.Number(object.rangeC) : 0,
        radius: isSet21(object.radius) ? globalThis.Number(object.radius) : 0,
        sessionId: isSet21(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
        targetId: isSet21(object.targetId) ? globalThis.Number(object.targetId) : 0,
        targetColor: isSet21(object.targetColor) ? RgbColor.fromJSON(object.targetColor) : void 0,
        type: isSet21(object.type) ? globalThis.Number(object.type) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.timestamp !== 0) {
        obj.timestamp = Math.round(message.timestamp);
      }
      if (message.targetLongitude !== 0) {
        obj.targetLongitude = message.targetLongitude;
      }
      if (message.targetLatitude !== 0) {
        obj.targetLatitude = message.targetLatitude;
      }
      if (message.targetAltitude !== 0) {
        obj.targetAltitude = message.targetAltitude;
      }
      if (message.observerLongitude !== 0) {
        obj.observerLongitude = message.observerLongitude;
      }
      if (message.observerLatitude !== 0) {
        obj.observerLatitude = message.observerLatitude;
      }
      if (message.observerAltitude !== 0) {
        obj.observerAltitude = message.observerAltitude;
      }
      if (message.observerAzimuth !== 0) {
        obj.observerAzimuth = message.observerAzimuth;
      }
      if (message.observerElevation !== 0) {
        obj.observerElevation = message.observerElevation;
      }
      if (message.observerBank !== 0) {
        obj.observerBank = message.observerBank;
      }
      if (message.distance2d !== 0) {
        obj.distance2d = message.distance2d;
      }
      if (message.distance3b !== 0) {
        obj.distance3b = message.distance3b;
      }
      if (message.observerFixType !== 0) {
        obj.observerFixType = jonGuiDataGpsFixTypeToJSON(message.observerFixType);
      }
      if (message.rangeA !== 0) {
        obj.rangeA = message.rangeA;
      }
      if (message.rangeB !== 0) {
        obj.rangeB = message.rangeB;
      }
      if (message.rangeC !== 0) {
        obj.rangeC = message.rangeC;
      }
      if (message.radius !== 0) {
        obj.radius = message.radius;
      }
      if (message.sessionId !== 0) {
        obj.sessionId = Math.round(message.sessionId);
      }
      if (message.targetId !== 0) {
        obj.targetId = Math.round(message.targetId);
      }
      if (message.targetColor !== void 0) {
        obj.targetColor = RgbColor.toJSON(message.targetColor);
      }
      if (message.type !== 0) {
        obj.type = Math.round(message.type);
      }
      return obj;
    },
    create(base) {
      return JonGuiDataTarget.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataTarget();
      message.timestamp = object.timestamp ?? 0;
      message.targetLongitude = object.targetLongitude ?? 0;
      message.targetLatitude = object.targetLatitude ?? 0;
      message.targetAltitude = object.targetAltitude ?? 0;
      message.observerLongitude = object.observerLongitude ?? 0;
      message.observerLatitude = object.observerLatitude ?? 0;
      message.observerAltitude = object.observerAltitude ?? 0;
      message.observerAzimuth = object.observerAzimuth ?? 0;
      message.observerElevation = object.observerElevation ?? 0;
      message.observerBank = object.observerBank ?? 0;
      message.distance2d = object.distance2d ?? 0;
      message.distance3b = object.distance3b ?? 0;
      message.observerFixType = object.observerFixType ?? 0;
      message.rangeA = object.rangeA ?? 0;
      message.rangeB = object.rangeB ?? 0;
      message.rangeC = object.rangeC ?? 0;
      message.radius = object.radius ?? 0;
      message.sessionId = object.sessionId ?? 0;
      message.targetId = object.targetId ?? 0;
      message.targetColor = object.targetColor !== void 0 && object.targetColor !== null ? RgbColor.fromPartial(object.targetColor) : void 0;
      message.type = object.type ?? 0;
      return message;
    }
  };
  function createBaseRgbColor() {
    return { red: 0, green: 0, blue: 0 };
  }
  var RgbColor = {
    encode(message, writer = import_minimal21.default.Writer.create()) {
      if (message.red !== 0) {
        writer.uint32(8).uint32(message.red);
      }
      if (message.green !== 0) {
        writer.uint32(16).uint32(message.green);
      }
      if (message.blue !== 0) {
        writer.uint32(24).uint32(message.blue);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal21.default.Reader ? input2 : import_minimal21.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRgbColor();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.red = reader.uint32();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.green = reader.uint32();
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }
            message.blue = reader.uint32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        red: isSet21(object.red) ? globalThis.Number(object.red) : 0,
        green: isSet21(object.green) ? globalThis.Number(object.green) : 0,
        blue: isSet21(object.blue) ? globalThis.Number(object.blue) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.red !== 0) {
        obj.red = Math.round(message.red);
      }
      if (message.green !== 0) {
        obj.green = Math.round(message.green);
      }
      if (message.blue !== 0) {
        obj.blue = Math.round(message.blue);
      }
      return obj;
    },
    create(base) {
      return RgbColor.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseRgbColor();
      message.red = object.red ?? 0;
      message.green = object.green ?? 0;
      message.blue = object.blue ?? 0;
      return message;
    }
  };
  function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
      throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
      throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return long.toNumber();
  }
  if (import_minimal21.default.util.Long !== long_default) {
    import_minimal21.default.util.Long = long_default;
    import_minimal21.default.configure();
  }
  function isSet21(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_data_power.ts
  var import_minimal22 = __toESM(require_minimal2());
  function createBaseJonGuiDataPowerModuleState() {
    return {
      voltage: 0,
      current: 0,
      power: 0,
      isAlarm: false,
      canCmdAddress: 0,
      canDataAddress: 0,
      isPowerOn: false,
      canDevice: 0
    };
  }
  var JonGuiDataPowerModuleState = {
    encode(message, writer = import_minimal22.default.Writer.create()) {
      if (message.voltage !== 0) {
        writer.uint32(8).int32(message.voltage);
      }
      if (message.current !== 0) {
        writer.uint32(16).int32(message.current);
      }
      if (message.power !== 0) {
        writer.uint32(24).int32(message.power);
      }
      if (message.isAlarm !== false) {
        writer.uint32(32).bool(message.isAlarm);
      }
      if (message.canCmdAddress !== 0) {
        writer.uint32(40).int32(message.canCmdAddress);
      }
      if (message.canDataAddress !== 0) {
        writer.uint32(48).int32(message.canDataAddress);
      }
      if (message.isPowerOn !== false) {
        writer.uint32(56).bool(message.isPowerOn);
      }
      if (message.canDevice !== 0) {
        writer.uint32(64).int32(message.canDevice);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal22.default.Reader ? input2 : import_minimal22.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataPowerModuleState();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.voltage = reader.int32();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.current = reader.int32();
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }
            message.power = reader.int32();
            continue;
          case 4:
            if (tag !== 32) {
              break;
            }
            message.isAlarm = reader.bool();
            continue;
          case 5:
            if (tag !== 40) {
              break;
            }
            message.canCmdAddress = reader.int32();
            continue;
          case 6:
            if (tag !== 48) {
              break;
            }
            message.canDataAddress = reader.int32();
            continue;
          case 7:
            if (tag !== 56) {
              break;
            }
            message.isPowerOn = reader.bool();
            continue;
          case 8:
            if (tag !== 64) {
              break;
            }
            message.canDevice = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        voltage: isSet22(object.voltage) ? globalThis.Number(object.voltage) : 0,
        current: isSet22(object.current) ? globalThis.Number(object.current) : 0,
        power: isSet22(object.power) ? globalThis.Number(object.power) : 0,
        isAlarm: isSet22(object.isAlarm) ? globalThis.Boolean(object.isAlarm) : false,
        canCmdAddress: isSet22(object.canCmdAddress) ? globalThis.Number(object.canCmdAddress) : 0,
        canDataAddress: isSet22(object.canDataAddress) ? globalThis.Number(object.canDataAddress) : 0,
        isPowerOn: isSet22(object.isPowerOn) ? globalThis.Boolean(object.isPowerOn) : false,
        canDevice: isSet22(object.canDevice) ? jonGuiDataPowerCanDeviceFromJSON(object.canDevice) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.voltage !== 0) {
        obj.voltage = Math.round(message.voltage);
      }
      if (message.current !== 0) {
        obj.current = Math.round(message.current);
      }
      if (message.power !== 0) {
        obj.power = Math.round(message.power);
      }
      if (message.isAlarm !== false) {
        obj.isAlarm = message.isAlarm;
      }
      if (message.canCmdAddress !== 0) {
        obj.canCmdAddress = Math.round(message.canCmdAddress);
      }
      if (message.canDataAddress !== 0) {
        obj.canDataAddress = Math.round(message.canDataAddress);
      }
      if (message.isPowerOn !== false) {
        obj.isPowerOn = message.isPowerOn;
      }
      if (message.canDevice !== 0) {
        obj.canDevice = jonGuiDataPowerCanDeviceToJSON(message.canDevice);
      }
      return obj;
    },
    create(base) {
      return JonGuiDataPowerModuleState.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataPowerModuleState();
      message.voltage = object.voltage ?? 0;
      message.current = object.current ?? 0;
      message.power = object.power ?? 0;
      message.isAlarm = object.isAlarm ?? false;
      message.canCmdAddress = object.canCmdAddress ?? 0;
      message.canDataAddress = object.canDataAddress ?? 0;
      message.isPowerOn = object.isPowerOn ?? false;
      message.canDevice = object.canDevice ?? 0;
      return message;
    }
  };
  function createBaseJonGuiDataPower() {
    return {
      s0: void 0,
      s1: void 0,
      s2: void 0,
      s3: void 0,
      s4: void 0,
      s5: void 0,
      s6: void 0,
      s7: void 0,
      meteo: void 0
    };
  }
  var JonGuiDataPower = {
    encode(message, writer = import_minimal22.default.Writer.create()) {
      if (message.s0 !== void 0) {
        JonGuiDataPowerModuleState.encode(message.s0, writer.uint32(10).fork()).ldelim();
      }
      if (message.s1 !== void 0) {
        JonGuiDataPowerModuleState.encode(message.s1, writer.uint32(18).fork()).ldelim();
      }
      if (message.s2 !== void 0) {
        JonGuiDataPowerModuleState.encode(message.s2, writer.uint32(26).fork()).ldelim();
      }
      if (message.s3 !== void 0) {
        JonGuiDataPowerModuleState.encode(message.s3, writer.uint32(34).fork()).ldelim();
      }
      if (message.s4 !== void 0) {
        JonGuiDataPowerModuleState.encode(message.s4, writer.uint32(42).fork()).ldelim();
      }
      if (message.s5 !== void 0) {
        JonGuiDataPowerModuleState.encode(message.s5, writer.uint32(50).fork()).ldelim();
      }
      if (message.s6 !== void 0) {
        JonGuiDataPowerModuleState.encode(message.s6, writer.uint32(58).fork()).ldelim();
      }
      if (message.s7 !== void 0) {
        JonGuiDataPowerModuleState.encode(message.s7, writer.uint32(66).fork()).ldelim();
      }
      if (message.meteo !== void 0) {
        JonGuiDataMeteo.encode(message.meteo, writer.uint32(74).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal22.default.Reader ? input2 : import_minimal22.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataPower();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }
            message.s0 = JonGuiDataPowerModuleState.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.s1 = JonGuiDataPowerModuleState.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.s2 = JonGuiDataPowerModuleState.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.s3 = JonGuiDataPowerModuleState.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.s4 = JonGuiDataPowerModuleState.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.s5 = JonGuiDataPowerModuleState.decode(reader, reader.uint32());
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }
            message.s6 = JonGuiDataPowerModuleState.decode(reader, reader.uint32());
            continue;
          case 8:
            if (tag !== 66) {
              break;
            }
            message.s7 = JonGuiDataPowerModuleState.decode(reader, reader.uint32());
            continue;
          case 9:
            if (tag !== 74) {
              break;
            }
            message.meteo = JonGuiDataMeteo.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        s0: isSet22(object.s0) ? JonGuiDataPowerModuleState.fromJSON(object.s0) : void 0,
        s1: isSet22(object.s1) ? JonGuiDataPowerModuleState.fromJSON(object.s1) : void 0,
        s2: isSet22(object.s2) ? JonGuiDataPowerModuleState.fromJSON(object.s2) : void 0,
        s3: isSet22(object.s3) ? JonGuiDataPowerModuleState.fromJSON(object.s3) : void 0,
        s4: isSet22(object.s4) ? JonGuiDataPowerModuleState.fromJSON(object.s4) : void 0,
        s5: isSet22(object.s5) ? JonGuiDataPowerModuleState.fromJSON(object.s5) : void 0,
        s6: isSet22(object.s6) ? JonGuiDataPowerModuleState.fromJSON(object.s6) : void 0,
        s7: isSet22(object.s7) ? JonGuiDataPowerModuleState.fromJSON(object.s7) : void 0,
        meteo: isSet22(object.meteo) ? JonGuiDataMeteo.fromJSON(object.meteo) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.s0 !== void 0) {
        obj.s0 = JonGuiDataPowerModuleState.toJSON(message.s0);
      }
      if (message.s1 !== void 0) {
        obj.s1 = JonGuiDataPowerModuleState.toJSON(message.s1);
      }
      if (message.s2 !== void 0) {
        obj.s2 = JonGuiDataPowerModuleState.toJSON(message.s2);
      }
      if (message.s3 !== void 0) {
        obj.s3 = JonGuiDataPowerModuleState.toJSON(message.s3);
      }
      if (message.s4 !== void 0) {
        obj.s4 = JonGuiDataPowerModuleState.toJSON(message.s4);
      }
      if (message.s5 !== void 0) {
        obj.s5 = JonGuiDataPowerModuleState.toJSON(message.s5);
      }
      if (message.s6 !== void 0) {
        obj.s6 = JonGuiDataPowerModuleState.toJSON(message.s6);
      }
      if (message.s7 !== void 0) {
        obj.s7 = JonGuiDataPowerModuleState.toJSON(message.s7);
      }
      if (message.meteo !== void 0) {
        obj.meteo = JonGuiDataMeteo.toJSON(message.meteo);
      }
      return obj;
    },
    create(base) {
      return JonGuiDataPower.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataPower();
      message.s0 = object.s0 !== void 0 && object.s0 !== null ? JonGuiDataPowerModuleState.fromPartial(object.s0) : void 0;
      message.s1 = object.s1 !== void 0 && object.s1 !== null ? JonGuiDataPowerModuleState.fromPartial(object.s1) : void 0;
      message.s2 = object.s2 !== void 0 && object.s2 !== null ? JonGuiDataPowerModuleState.fromPartial(object.s2) : void 0;
      message.s3 = object.s3 !== void 0 && object.s3 !== null ? JonGuiDataPowerModuleState.fromPartial(object.s3) : void 0;
      message.s4 = object.s4 !== void 0 && object.s4 !== null ? JonGuiDataPowerModuleState.fromPartial(object.s4) : void 0;
      message.s5 = object.s5 !== void 0 && object.s5 !== null ? JonGuiDataPowerModuleState.fromPartial(object.s5) : void 0;
      message.s6 = object.s6 !== void 0 && object.s6 !== null ? JonGuiDataPowerModuleState.fromPartial(object.s6) : void 0;
      message.s7 = object.s7 !== void 0 && object.s7 !== null ? JonGuiDataPowerModuleState.fromPartial(object.s7) : void 0;
      message.meteo = object.meteo !== void 0 && object.meteo !== null ? JonGuiDataMeteo.fromPartial(object.meteo) : void 0;
      return message;
    }
  };
  function isSet22(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_data_rotary.ts
  var import_minimal23 = __toESM(require_minimal2());
  function createBaseJonGuiDataRotary() {
    return {
      azimuth: 0,
      azimuthSpeed: 0,
      elevation: 0,
      elevationSpeed: 0,
      baseAzimuth: 0,
      baseElevation: 0,
      baseBank: 0,
      isMoving: false,
      meteo: void 0,
      mode: 0
    };
  }
  var JonGuiDataRotary = {
    encode(message, writer = import_minimal23.default.Writer.create()) {
      if (message.azimuth !== 0) {
        writer.uint32(13).float(message.azimuth);
      }
      if (message.azimuthSpeed !== 0) {
        writer.uint32(21).float(message.azimuthSpeed);
      }
      if (message.elevation !== 0) {
        writer.uint32(29).float(message.elevation);
      }
      if (message.elevationSpeed !== 0) {
        writer.uint32(37).float(message.elevationSpeed);
      }
      if (message.baseAzimuth !== 0) {
        writer.uint32(45).float(message.baseAzimuth);
      }
      if (message.baseElevation !== 0) {
        writer.uint32(53).float(message.baseElevation);
      }
      if (message.baseBank !== 0) {
        writer.uint32(61).float(message.baseBank);
      }
      if (message.isMoving !== false) {
        writer.uint32(64).bool(message.isMoving);
      }
      if (message.meteo !== void 0) {
        JonGuiDataMeteo.encode(message.meteo, writer.uint32(74).fork()).ldelim();
      }
      if (message.mode !== 0) {
        writer.uint32(80).int32(message.mode);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal23.default.Reader ? input2 : import_minimal23.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataRotary();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.azimuth = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.azimuthSpeed = reader.float();
            continue;
          case 3:
            if (tag !== 29) {
              break;
            }
            message.elevation = reader.float();
            continue;
          case 4:
            if (tag !== 37) {
              break;
            }
            message.elevationSpeed = reader.float();
            continue;
          case 5:
            if (tag !== 45) {
              break;
            }
            message.baseAzimuth = reader.float();
            continue;
          case 6:
            if (tag !== 53) {
              break;
            }
            message.baseElevation = reader.float();
            continue;
          case 7:
            if (tag !== 61) {
              break;
            }
            message.baseBank = reader.float();
            continue;
          case 8:
            if (tag !== 64) {
              break;
            }
            message.isMoving = reader.bool();
            continue;
          case 9:
            if (tag !== 74) {
              break;
            }
            message.meteo = JonGuiDataMeteo.decode(reader, reader.uint32());
            continue;
          case 10:
            if (tag !== 80) {
              break;
            }
            message.mode = reader.int32();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        azimuth: isSet23(object.azimuth) ? globalThis.Number(object.azimuth) : 0,
        azimuthSpeed: isSet23(object.azimuthSpeed) ? globalThis.Number(object.azimuthSpeed) : 0,
        elevation: isSet23(object.elevation) ? globalThis.Number(object.elevation) : 0,
        elevationSpeed: isSet23(object.elevationSpeed) ? globalThis.Number(object.elevationSpeed) : 0,
        baseAzimuth: isSet23(object.baseAzimuth) ? globalThis.Number(object.baseAzimuth) : 0,
        baseElevation: isSet23(object.baseElevation) ? globalThis.Number(object.baseElevation) : 0,
        baseBank: isSet23(object.baseBank) ? globalThis.Number(object.baseBank) : 0,
        isMoving: isSet23(object.isMoving) ? globalThis.Boolean(object.isMoving) : false,
        meteo: isSet23(object.meteo) ? JonGuiDataMeteo.fromJSON(object.meteo) : void 0,
        mode: isSet23(object.mode) ? jonGuiDataRotaryModeFromJSON(object.mode) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.azimuth !== 0) {
        obj.azimuth = message.azimuth;
      }
      if (message.azimuthSpeed !== 0) {
        obj.azimuthSpeed = message.azimuthSpeed;
      }
      if (message.elevation !== 0) {
        obj.elevation = message.elevation;
      }
      if (message.elevationSpeed !== 0) {
        obj.elevationSpeed = message.elevationSpeed;
      }
      if (message.baseAzimuth !== 0) {
        obj.baseAzimuth = message.baseAzimuth;
      }
      if (message.baseElevation !== 0) {
        obj.baseElevation = message.baseElevation;
      }
      if (message.baseBank !== 0) {
        obj.baseBank = message.baseBank;
      }
      if (message.isMoving !== false) {
        obj.isMoving = message.isMoving;
      }
      if (message.meteo !== void 0) {
        obj.meteo = JonGuiDataMeteo.toJSON(message.meteo);
      }
      if (message.mode !== 0) {
        obj.mode = jonGuiDataRotaryModeToJSON(message.mode);
      }
      return obj;
    },
    create(base) {
      return JonGuiDataRotary.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataRotary();
      message.azimuth = object.azimuth ?? 0;
      message.azimuthSpeed = object.azimuthSpeed ?? 0;
      message.elevation = object.elevation ?? 0;
      message.elevationSpeed = object.elevationSpeed ?? 0;
      message.baseAzimuth = object.baseAzimuth ?? 0;
      message.baseElevation = object.baseElevation ?? 0;
      message.baseBank = object.baseBank ?? 0;
      message.isMoving = object.isMoving ?? false;
      message.meteo = object.meteo !== void 0 && object.meteo !== null ? JonGuiDataMeteo.fromPartial(object.meteo) : void 0;
      message.mode = object.mode ?? 0;
      return message;
    }
  };
  function isSet23(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_data_system.ts
  var import_minimal24 = __toESM(require_minimal2());
  function createBaseJonGuiDataSystem() {
    return { cpuTemperature: 0, gpuTemperature: 0, gpuLoad: 0, cpuLoad: 0, powerConsumption: 0 };
  }
  var JonGuiDataSystem = {
    encode(message, writer = import_minimal24.default.Writer.create()) {
      if (message.cpuTemperature !== 0) {
        writer.uint32(13).float(message.cpuTemperature);
      }
      if (message.gpuTemperature !== 0) {
        writer.uint32(21).float(message.gpuTemperature);
      }
      if (message.gpuLoad !== 0) {
        writer.uint32(29).float(message.gpuLoad);
      }
      if (message.cpuLoad !== 0) {
        writer.uint32(37).float(message.cpuLoad);
      }
      if (message.powerConsumption !== 0) {
        writer.uint32(45).float(message.powerConsumption);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal24.default.Reader ? input2 : import_minimal24.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataSystem();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 13) {
              break;
            }
            message.cpuTemperature = reader.float();
            continue;
          case 2:
            if (tag !== 21) {
              break;
            }
            message.gpuTemperature = reader.float();
            continue;
          case 3:
            if (tag !== 29) {
              break;
            }
            message.gpuLoad = reader.float();
            continue;
          case 4:
            if (tag !== 37) {
              break;
            }
            message.cpuLoad = reader.float();
            continue;
          case 5:
            if (tag !== 45) {
              break;
            }
            message.powerConsumption = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        cpuTemperature: isSet24(object.cpuTemperature) ? globalThis.Number(object.cpuTemperature) : 0,
        gpuTemperature: isSet24(object.gpuTemperature) ? globalThis.Number(object.gpuTemperature) : 0,
        gpuLoad: isSet24(object.gpuLoad) ? globalThis.Number(object.gpuLoad) : 0,
        cpuLoad: isSet24(object.cpuLoad) ? globalThis.Number(object.cpuLoad) : 0,
        powerConsumption: isSet24(object.powerConsumption) ? globalThis.Number(object.powerConsumption) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.cpuTemperature !== 0) {
        obj.cpuTemperature = message.cpuTemperature;
      }
      if (message.gpuTemperature !== 0) {
        obj.gpuTemperature = message.gpuTemperature;
      }
      if (message.gpuLoad !== 0) {
        obj.gpuLoad = message.gpuLoad;
      }
      if (message.cpuLoad !== 0) {
        obj.cpuLoad = message.cpuLoad;
      }
      if (message.powerConsumption !== 0) {
        obj.powerConsumption = message.powerConsumption;
      }
      return obj;
    },
    create(base) {
      return JonGuiDataSystem.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataSystem();
      message.cpuTemperature = object.cpuTemperature ?? 0;
      message.gpuTemperature = object.gpuTemperature ?? 0;
      message.gpuLoad = object.gpuLoad ?? 0;
      message.cpuLoad = object.cpuLoad ?? 0;
      message.powerConsumption = object.powerConsumption ?? 0;
      return message;
    }
  };
  function isSet24(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_data_time.ts
  var import_minimal25 = __toESM(require_minimal2());
  function createBaseJonGuiDataTime() {
    return { timestamp: 0, manualTimestamp: 0, zoneId: 0, useManualTime: false };
  }
  var JonGuiDataTime = {
    encode(message, writer = import_minimal25.default.Writer.create()) {
      if (message.timestamp !== 0) {
        writer.uint32(8).int64(message.timestamp);
      }
      if (message.manualTimestamp !== 0) {
        writer.uint32(16).int64(message.manualTimestamp);
      }
      if (message.zoneId !== 0) {
        writer.uint32(24).int32(message.zoneId);
      }
      if (message.useManualTime !== false) {
        writer.uint32(32).bool(message.useManualTime);
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal25.default.Reader ? input2 : import_minimal25.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGuiDataTime();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.timestamp = longToNumber2(reader.int64());
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }
            message.manualTimestamp = longToNumber2(reader.int64());
            continue;
          case 3:
            if (tag !== 24) {
              break;
            }
            message.zoneId = reader.int32();
            continue;
          case 4:
            if (tag !== 32) {
              break;
            }
            message.useManualTime = reader.bool();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        timestamp: isSet25(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
        manualTimestamp: isSet25(object.manualTimestamp) ? globalThis.Number(object.manualTimestamp) : 0,
        zoneId: isSet25(object.zoneId) ? globalThis.Number(object.zoneId) : 0,
        useManualTime: isSet25(object.useManualTime) ? globalThis.Boolean(object.useManualTime) : false
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.timestamp !== 0) {
        obj.timestamp = Math.round(message.timestamp);
      }
      if (message.manualTimestamp !== 0) {
        obj.manualTimestamp = Math.round(message.manualTimestamp);
      }
      if (message.zoneId !== 0) {
        obj.zoneId = Math.round(message.zoneId);
      }
      if (message.useManualTime !== false) {
        obj.useManualTime = message.useManualTime;
      }
      return obj;
    },
    create(base) {
      return JonGuiDataTime.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGuiDataTime();
      message.timestamp = object.timestamp ?? 0;
      message.manualTimestamp = object.manualTimestamp ?? 0;
      message.zoneId = object.zoneId ?? 0;
      message.useManualTime = object.useManualTime ?? false;
      return message;
    }
  };
  function longToNumber2(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
      throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
      throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return long.toNumber();
  }
  if (import_minimal25.default.util.Long !== long_default) {
    import_minimal25.default.util.Long = long_default;
    import_minimal25.default.configure();
  }
  function isSet25(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/proto/jon/jon_shared_data.ts
  function createBaseJonGUIState() {
    return {
      protocolVersion: 0,
      system: void 0,
      meteoInternal: void 0,
      meteoExternal: void 0,
      lrf: void 0,
      time: void 0,
      gps: void 0,
      compass: void 0,
      rotary: void 0,
      cameraDay: void 0,
      cameraHeat: void 0,
      compassCalibration: void 0,
      environment: void 0,
      power: void 0
    };
  }
  var JonGUIState = {
    encode(message, writer = import_minimal26.default.Writer.create()) {
      if (message.protocolVersion !== 0) {
        writer.uint32(8).uint32(message.protocolVersion);
      }
      if (message.system !== void 0) {
        JonGuiDataSystem.encode(message.system, writer.uint32(18).fork()).ldelim();
      }
      if (message.meteoInternal !== void 0) {
        JonGuiDataMeteo.encode(message.meteoInternal, writer.uint32(26).fork()).ldelim();
      }
      if (message.meteoExternal !== void 0) {
        JonGuiDataMeteo.encode(message.meteoExternal, writer.uint32(34).fork()).ldelim();
      }
      if (message.lrf !== void 0) {
        JonGuiDataLrf.encode(message.lrf, writer.uint32(42).fork()).ldelim();
      }
      if (message.time !== void 0) {
        JonGuiDataTime.encode(message.time, writer.uint32(50).fork()).ldelim();
      }
      if (message.gps !== void 0) {
        JonGuiDataGps.encode(message.gps, writer.uint32(58).fork()).ldelim();
      }
      if (message.compass !== void 0) {
        JonGuiDataCompass.encode(message.compass, writer.uint32(66).fork()).ldelim();
      }
      if (message.rotary !== void 0) {
        JonGuiDataRotary.encode(message.rotary, writer.uint32(74).fork()).ldelim();
      }
      if (message.cameraDay !== void 0) {
        JonGuiDataCameraDay.encode(message.cameraDay, writer.uint32(82).fork()).ldelim();
      }
      if (message.cameraHeat !== void 0) {
        JonGuiDataCameraHeat.encode(message.cameraHeat, writer.uint32(90).fork()).ldelim();
      }
      if (message.compassCalibration !== void 0) {
        JonGuiDataCompassCalibration.encode(message.compassCalibration, writer.uint32(98).fork()).ldelim();
      }
      if (message.environment !== void 0) {
        JonGuiDataEnvironment.encode(message.environment, writer.uint32(106).fork()).ldelim();
      }
      if (message.power !== void 0) {
        JonGuiDataPower.encode(message.power, writer.uint32(114).fork()).ldelim();
      }
      return writer;
    },
    decode(input2, length) {
      const reader = input2 instanceof import_minimal26.default.Reader ? input2 : import_minimal26.default.Reader.create(input2);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseJonGUIState();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }
            message.protocolVersion = reader.uint32();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }
            message.system = JonGuiDataSystem.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }
            message.meteoInternal = JonGuiDataMeteo.decode(reader, reader.uint32());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }
            message.meteoExternal = JonGuiDataMeteo.decode(reader, reader.uint32());
            continue;
          case 5:
            if (tag !== 42) {
              break;
            }
            message.lrf = JonGuiDataLrf.decode(reader, reader.uint32());
            continue;
          case 6:
            if (tag !== 50) {
              break;
            }
            message.time = JonGuiDataTime.decode(reader, reader.uint32());
            continue;
          case 7:
            if (tag !== 58) {
              break;
            }
            message.gps = JonGuiDataGps.decode(reader, reader.uint32());
            continue;
          case 8:
            if (tag !== 66) {
              break;
            }
            message.compass = JonGuiDataCompass.decode(reader, reader.uint32());
            continue;
          case 9:
            if (tag !== 74) {
              break;
            }
            message.rotary = JonGuiDataRotary.decode(reader, reader.uint32());
            continue;
          case 10:
            if (tag !== 82) {
              break;
            }
            message.cameraDay = JonGuiDataCameraDay.decode(reader, reader.uint32());
            continue;
          case 11:
            if (tag !== 90) {
              break;
            }
            message.cameraHeat = JonGuiDataCameraHeat.decode(reader, reader.uint32());
            continue;
          case 12:
            if (tag !== 98) {
              break;
            }
            message.compassCalibration = JonGuiDataCompassCalibration.decode(reader, reader.uint32());
            continue;
          case 13:
            if (tag !== 106) {
              break;
            }
            message.environment = JonGuiDataEnvironment.decode(reader, reader.uint32());
            continue;
          case 14:
            if (tag !== 114) {
              break;
            }
            message.power = JonGuiDataPower.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    fromJSON(object) {
      return {
        protocolVersion: isSet26(object.protocolVersion) ? globalThis.Number(object.protocolVersion) : 0,
        system: isSet26(object.system) ? JonGuiDataSystem.fromJSON(object.system) : void 0,
        meteoInternal: isSet26(object.meteoInternal) ? JonGuiDataMeteo.fromJSON(object.meteoInternal) : void 0,
        meteoExternal: isSet26(object.meteoExternal) ? JonGuiDataMeteo.fromJSON(object.meteoExternal) : void 0,
        lrf: isSet26(object.lrf) ? JonGuiDataLrf.fromJSON(object.lrf) : void 0,
        time: isSet26(object.time) ? JonGuiDataTime.fromJSON(object.time) : void 0,
        gps: isSet26(object.gps) ? JonGuiDataGps.fromJSON(object.gps) : void 0,
        compass: isSet26(object.compass) ? JonGuiDataCompass.fromJSON(object.compass) : void 0,
        rotary: isSet26(object.rotary) ? JonGuiDataRotary.fromJSON(object.rotary) : void 0,
        cameraDay: isSet26(object.cameraDay) ? JonGuiDataCameraDay.fromJSON(object.cameraDay) : void 0,
        cameraHeat: isSet26(object.cameraHeat) ? JonGuiDataCameraHeat.fromJSON(object.cameraHeat) : void 0,
        compassCalibration: isSet26(object.compassCalibration) ? JonGuiDataCompassCalibration.fromJSON(object.compassCalibration) : void 0,
        environment: isSet26(object.environment) ? JonGuiDataEnvironment.fromJSON(object.environment) : void 0,
        power: isSet26(object.power) ? JonGuiDataPower.fromJSON(object.power) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.protocolVersion !== 0) {
        obj.protocolVersion = Math.round(message.protocolVersion);
      }
      if (message.system !== void 0) {
        obj.system = JonGuiDataSystem.toJSON(message.system);
      }
      if (message.meteoInternal !== void 0) {
        obj.meteoInternal = JonGuiDataMeteo.toJSON(message.meteoInternal);
      }
      if (message.meteoExternal !== void 0) {
        obj.meteoExternal = JonGuiDataMeteo.toJSON(message.meteoExternal);
      }
      if (message.lrf !== void 0) {
        obj.lrf = JonGuiDataLrf.toJSON(message.lrf);
      }
      if (message.time !== void 0) {
        obj.time = JonGuiDataTime.toJSON(message.time);
      }
      if (message.gps !== void 0) {
        obj.gps = JonGuiDataGps.toJSON(message.gps);
      }
      if (message.compass !== void 0) {
        obj.compass = JonGuiDataCompass.toJSON(message.compass);
      }
      if (message.rotary !== void 0) {
        obj.rotary = JonGuiDataRotary.toJSON(message.rotary);
      }
      if (message.cameraDay !== void 0) {
        obj.cameraDay = JonGuiDataCameraDay.toJSON(message.cameraDay);
      }
      if (message.cameraHeat !== void 0) {
        obj.cameraHeat = JonGuiDataCameraHeat.toJSON(message.cameraHeat);
      }
      if (message.compassCalibration !== void 0) {
        obj.compassCalibration = JonGuiDataCompassCalibration.toJSON(message.compassCalibration);
      }
      if (message.environment !== void 0) {
        obj.environment = JonGuiDataEnvironment.toJSON(message.environment);
      }
      if (message.power !== void 0) {
        obj.power = JonGuiDataPower.toJSON(message.power);
      }
      return obj;
    },
    create(base) {
      return JonGUIState.fromPartial(base ?? {});
    },
    fromPartial(object) {
      const message = createBaseJonGUIState();
      message.protocolVersion = object.protocolVersion ?? 0;
      message.system = object.system !== void 0 && object.system !== null ? JonGuiDataSystem.fromPartial(object.system) : void 0;
      message.meteoInternal = object.meteoInternal !== void 0 && object.meteoInternal !== null ? JonGuiDataMeteo.fromPartial(object.meteoInternal) : void 0;
      message.meteoExternal = object.meteoExternal !== void 0 && object.meteoExternal !== null ? JonGuiDataMeteo.fromPartial(object.meteoExternal) : void 0;
      message.lrf = object.lrf !== void 0 && object.lrf !== null ? JonGuiDataLrf.fromPartial(object.lrf) : void 0;
      message.time = object.time !== void 0 && object.time !== null ? JonGuiDataTime.fromPartial(object.time) : void 0;
      message.gps = object.gps !== void 0 && object.gps !== null ? JonGuiDataGps.fromPartial(object.gps) : void 0;
      message.compass = object.compass !== void 0 && object.compass !== null ? JonGuiDataCompass.fromPartial(object.compass) : void 0;
      message.rotary = object.rotary !== void 0 && object.rotary !== null ? JonGuiDataRotary.fromPartial(object.rotary) : void 0;
      message.cameraDay = object.cameraDay !== void 0 && object.cameraDay !== null ? JonGuiDataCameraDay.fromPartial(object.cameraDay) : void 0;
      message.cameraHeat = object.cameraHeat !== void 0 && object.cameraHeat !== null ? JonGuiDataCameraHeat.fromPartial(object.cameraHeat) : void 0;
      message.compassCalibration = object.compassCalibration !== void 0 && object.compassCalibration !== null ? JonGuiDataCompassCalibration.fromPartial(object.compassCalibration) : void 0;
      message.environment = object.environment !== void 0 && object.environment !== null ? JonGuiDataEnvironment.fromPartial(object.environment) : void 0;
      message.power = object.power !== void 0 && object.power !== null ? JonGuiDataPower.fromPartial(object.power) : void 0;
      return message;
    }
  };
  function isSet26(value) {
    return value !== null && value !== void 0;
  }

  // frontend/ts/statePub/deviceStateDispatch.ts
  var DeviceStateDispatch = class {
    constructor(channelName = "deviceState") {
      this.channel = new BroadcastChannel(channelName);
      this.channel.onmessage = this.handleBroadcastMessage.bind(this);
      this.systemSignal = d(void 0);
      this.lrfSignal = d(void 0);
      this.timeSignal = d(void 0);
      this.gpsSignal = d(void 0);
      this.compassSignal = d(void 0);
      this.rotarySignal = d(void 0);
      this.powerSignal = d(void 0);
      this.cameraDaySignal = d(void 0);
      this.cameraHeatSignal = d(void 0);
      this.compassCalibrationSignal = d(void 0);
      this.environmentSignal = d(void 0);
    }
    handleBroadcastMessage(event) {
      try {
        const binaryData = new Uint8Array(event.data);
        const deserializedData = JonGUIState.decode(binaryData);
        this.updateSignals(deserializedData);
      } catch (error) {
        console.error("Error deserializing JonGUIState:", error);
      }
    }
    updateSignals(newState) {
      this.compareAndUpdateSignal("system", this.systemSignal, newState.system);
      this.compareAndUpdateSignal("lrf", this.lrfSignal, newState.lrf);
      this.compareAndUpdateSignal("time", this.timeSignal, newState.time);
      this.compareAndUpdateSignal("gps", this.gpsSignal, newState.gps);
      this.compareAndUpdateSignal("compass", this.compassSignal, newState.compass);
      this.compareAndUpdateSignal("rotary", this.rotarySignal, newState.rotary);
      this.compareAndUpdateSignal("power", this.powerSignal, newState.power);
      this.compareAndUpdateSignal("cameraDay", this.cameraDaySignal, newState.cameraDay);
      this.compareAndUpdateSignal("cameraHeat", this.cameraHeatSignal, newState.cameraHeat);
      this.compareAndUpdateSignal("compassCalibration", this.compassCalibrationSignal, newState.compassCalibration);
      this.compareAndUpdateSignal("environment", this.environmentSignal, newState.environment);
    }
    compareAndUpdateSignal(key, signal, newValue) {
      if (JSON.stringify(signal.value) !== JSON.stringify(newValue)) {
        console.log(`Updating ${key} signal:`, newValue);
        signal.value = newValue;
      }
    }
    get system() {
      return this.systemSignal;
    }
    get lrf() {
      return this.lrfSignal;
    }
    get time() {
      return this.timeSignal;
    }
    get gps() {
      return this.gpsSignal;
    }
    get compass() {
      return this.compassSignal;
    }
    get rotary() {
      return this.rotarySignal;
    }
    get power() {
      return this.powerSignal;
    }
    get cameraDay() {
      return this.cameraDaySignal;
    }
    get cameraHeat() {
      return this.cameraHeatSignal;
    }
    get compassCalibration() {
      return this.compassCalibrationSignal;
    }
    get environment() {
      return this.environmentSignal;
    }
    destroy() {
      this.channel.close();
    }
  };

  // frontend/node_modules/@lit/reactive-element/css-tag.js
  var t5 = globalThis;
  var e5 = t5.ShadowRoot && (void 0 === t5.ShadyCSS || t5.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  var s6 = Symbol();
  var o4 = /* @__PURE__ */ new WeakMap();
  var n3 = class {
    constructor(t9, e9, o7) {
      if (this._$cssResult$ = true, o7 !== s6) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t9, this.t = e9;
    }
    get styleSheet() {
      let t9 = this.o;
      const s7 = this.t;
      if (e5 && void 0 === t9) {
        const e9 = void 0 !== s7 && 1 === s7.length;
        e9 && (t9 = o4.get(s7)), void 0 === t9 && ((this.o = t9 = new CSSStyleSheet()).replaceSync(this.cssText), e9 && o4.set(s7, t9));
      }
      return t9;
    }
    toString() {
      return this.cssText;
    }
  };
  var r3 = (t9) => new n3("string" == typeof t9 ? t9 : t9 + "", void 0, s6);
  var i5 = (t9, ...e9) => {
    const o7 = 1 === t9.length ? t9[0] : e9.reduce((e10, s7, o8) => e10 + ((t10) => {
      if (true === t10._$cssResult$) return t10.cssText;
      if ("number" == typeof t10) return t10;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + t10 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(s7) + t9[o8 + 1], t9[0]);
    return new n3(o7, t9, s6);
  };
  var S3 = (s7, o7) => {
    if (e5) s7.adoptedStyleSheets = o7.map((t9) => t9 instanceof CSSStyleSheet ? t9 : t9.styleSheet);
    else for (const e9 of o7) {
      const o8 = document.createElement("style"), n7 = t5.litNonce;
      void 0 !== n7 && o8.setAttribute("nonce", n7), o8.textContent = e9.cssText, s7.appendChild(o8);
    }
  };
  var c4 = e5 ? (t9) => t9 : (t9) => t9 instanceof CSSStyleSheet ? ((t10) => {
    let e9 = "";
    for (const s7 of t10.cssRules) e9 += s7.cssText;
    return r3(e9);
  })(t9) : t9;

  // frontend/node_modules/@lit/reactive-element/reactive-element.js
  var { is: i6, defineProperty: e6, getOwnPropertyDescriptor: r4, getOwnPropertyNames: h5, getOwnPropertySymbols: o5, getPrototypeOf: n4 } = Object;
  var a4 = globalThis;
  var c5 = a4.trustedTypes;
  var l3 = c5 ? c5.emptyScript : "";
  var p3 = a4.reactiveElementPolyfillSupport;
  var d3 = (t9, s7) => t9;
  var u3 = { toAttribute(t9, s7) {
    switch (s7) {
      case Boolean:
        t9 = t9 ? l3 : null;
        break;
      case Object:
      case Array:
        t9 = null == t9 ? t9 : JSON.stringify(t9);
    }
    return t9;
  }, fromAttribute(t9, s7) {
    let i9 = t9;
    switch (s7) {
      case Boolean:
        i9 = null !== t9;
        break;
      case Number:
        i9 = null === t9 ? null : Number(t9);
        break;
      case Object:
      case Array:
        try {
          i9 = JSON.parse(t9);
        } catch (t10) {
          i9 = null;
        }
    }
    return i9;
  } };
  var f5 = (t9, s7) => !i6(t9, s7);
  var y3 = { attribute: true, type: String, converter: u3, reflect: false, hasChanged: f5 };
  Symbol.metadata ??= Symbol("metadata"), a4.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
  var b3 = class extends HTMLElement {
    static addInitializer(t9) {
      this._$Ei(), (this.l ??= []).push(t9);
    }
    static get observedAttributes() {
      return this.finalize(), this._$Eh && [...this._$Eh.keys()];
    }
    static createProperty(t9, s7 = y3) {
      if (s7.state && (s7.attribute = false), this._$Ei(), this.elementProperties.set(t9, s7), !s7.noAccessor) {
        const i9 = Symbol(), r8 = this.getPropertyDescriptor(t9, i9, s7);
        void 0 !== r8 && e6(this.prototype, t9, r8);
      }
    }
    static getPropertyDescriptor(t9, s7, i9) {
      const { get: e9, set: h8 } = r4(this.prototype, t9) ?? { get() {
        return this[s7];
      }, set(t10) {
        this[s7] = t10;
      } };
      return { get() {
        return e9?.call(this);
      }, set(s8) {
        const r8 = e9?.call(this);
        h8.call(this, s8), this.requestUpdate(t9, r8, i9);
      }, configurable: true, enumerable: true };
    }
    static getPropertyOptions(t9) {
      return this.elementProperties.get(t9) ?? y3;
    }
    static _$Ei() {
      if (this.hasOwnProperty(d3("elementProperties"))) return;
      const t9 = n4(this);
      t9.finalize(), void 0 !== t9.l && (this.l = [...t9.l]), this.elementProperties = new Map(t9.elementProperties);
    }
    static finalize() {
      if (this.hasOwnProperty(d3("finalized"))) return;
      if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d3("properties"))) {
        const t10 = this.properties, s7 = [...h5(t10), ...o5(t10)];
        for (const i9 of s7) this.createProperty(i9, t10[i9]);
      }
      const t9 = this[Symbol.metadata];
      if (null !== t9) {
        const s7 = litPropertyMetadata.get(t9);
        if (void 0 !== s7) for (const [t10, i9] of s7) this.elementProperties.set(t10, i9);
      }
      this._$Eh = /* @__PURE__ */ new Map();
      for (const [t10, s7] of this.elementProperties) {
        const i9 = this._$Eu(t10, s7);
        void 0 !== i9 && this._$Eh.set(i9, t10);
      }
      this.elementStyles = this.finalizeStyles(this.styles);
    }
    static finalizeStyles(s7) {
      const i9 = [];
      if (Array.isArray(s7)) {
        const e9 = new Set(s7.flat(1 / 0).reverse());
        for (const s8 of e9) i9.unshift(c4(s8));
      } else void 0 !== s7 && i9.push(c4(s7));
      return i9;
    }
    static _$Eu(t9, s7) {
      const i9 = s7.attribute;
      return false === i9 ? void 0 : "string" == typeof i9 ? i9 : "string" == typeof t9 ? t9.toLowerCase() : void 0;
    }
    constructor() {
      super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
    }
    _$Ev() {
      this._$ES = new Promise((t9) => this.enableUpdating = t9), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t9) => t9(this));
    }
    addController(t9) {
      (this._$EO ??= /* @__PURE__ */ new Set()).add(t9), void 0 !== this.renderRoot && this.isConnected && t9.hostConnected?.();
    }
    removeController(t9) {
      this._$EO?.delete(t9);
    }
    _$E_() {
      const t9 = /* @__PURE__ */ new Map(), s7 = this.constructor.elementProperties;
      for (const i9 of s7.keys()) this.hasOwnProperty(i9) && (t9.set(i9, this[i9]), delete this[i9]);
      t9.size > 0 && (this._$Ep = t9);
    }
    createRenderRoot() {
      const t9 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
      return S3(t9, this.constructor.elementStyles), t9;
    }
    connectedCallback() {
      this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t9) => t9.hostConnected?.());
    }
    enableUpdating(t9) {
    }
    disconnectedCallback() {
      this._$EO?.forEach((t9) => t9.hostDisconnected?.());
    }
    attributeChangedCallback(t9, s7, i9) {
      this._$AK(t9, i9);
    }
    _$EC(t9, s7) {
      const i9 = this.constructor.elementProperties.get(t9), e9 = this.constructor._$Eu(t9, i9);
      if (void 0 !== e9 && true === i9.reflect) {
        const r8 = (void 0 !== i9.converter?.toAttribute ? i9.converter : u3).toAttribute(s7, i9.type);
        this._$Em = t9, null == r8 ? this.removeAttribute(e9) : this.setAttribute(e9, r8), this._$Em = null;
      }
    }
    _$AK(t9, s7) {
      const i9 = this.constructor, e9 = i9._$Eh.get(t9);
      if (void 0 !== e9 && this._$Em !== e9) {
        const t10 = i9.getPropertyOptions(e9), r8 = "function" == typeof t10.converter ? { fromAttribute: t10.converter } : void 0 !== t10.converter?.fromAttribute ? t10.converter : u3;
        this._$Em = e9, this[e9] = r8.fromAttribute(s7, t10.type), this._$Em = null;
      }
    }
    requestUpdate(t9, s7, i9) {
      if (void 0 !== t9) {
        if (i9 ??= this.constructor.getPropertyOptions(t9), !(i9.hasChanged ?? f5)(this[t9], s7)) return;
        this.P(t9, s7, i9);
      }
      false === this.isUpdatePending && (this._$ES = this._$ET());
    }
    P(t9, s7, i9) {
      this._$AL.has(t9) || this._$AL.set(t9, s7), true === i9.reflect && this._$Em !== t9 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t9);
    }
    async _$ET() {
      this.isUpdatePending = true;
      try {
        await this._$ES;
      } catch (t10) {
        Promise.reject(t10);
      }
      const t9 = this.scheduleUpdate();
      return null != t9 && await t9, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      if (!this.isUpdatePending) return;
      if (!this.hasUpdated) {
        if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
          for (const [t11, s8] of this._$Ep) this[t11] = s8;
          this._$Ep = void 0;
        }
        const t10 = this.constructor.elementProperties;
        if (t10.size > 0) for (const [s8, i9] of t10) true !== i9.wrapped || this._$AL.has(s8) || void 0 === this[s8] || this.P(s8, this[s8], i9);
      }
      let t9 = false;
      const s7 = this._$AL;
      try {
        t9 = this.shouldUpdate(s7), t9 ? (this.willUpdate(s7), this._$EO?.forEach((t10) => t10.hostUpdate?.()), this.update(s7)) : this._$EU();
      } catch (s8) {
        throw t9 = false, this._$EU(), s8;
      }
      t9 && this._$AE(s7);
    }
    willUpdate(t9) {
    }
    _$AE(t9) {
      this._$EO?.forEach((t10) => t10.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t9)), this.updated(t9);
    }
    _$EU() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$ES;
    }
    shouldUpdate(t9) {
      return true;
    }
    update(t9) {
      this._$Ej &&= this._$Ej.forEach((t10) => this._$EC(t10, this[t10])), this._$EU();
    }
    updated(t9) {
    }
    firstUpdated(t9) {
    }
  };
  b3.elementStyles = [], b3.shadowRootOptions = { mode: "open" }, b3[d3("elementProperties")] = /* @__PURE__ */ new Map(), b3[d3("finalized")] = /* @__PURE__ */ new Map(), p3?.({ ReactiveElement: b3 }), (a4.reactiveElementVersions ??= []).push("2.0.4");

  // frontend/node_modules/lit-html/lit-html.js
  var n5 = globalThis;
  var c6 = n5.trustedTypes;
  var h6 = c6 ? c6.createPolicy("lit-html", { createHTML: (t9) => t9 }) : void 0;
  var f6 = "$lit$";
  var v3 = `lit$${Math.random().toFixed(9).slice(2)}$`;
  var m4 = "?" + v3;
  var _3 = `<${m4}>`;
  var w2 = document;
  var lt = () => w2.createComment("");
  var st = (t9) => null === t9 || "object" != typeof t9 && "function" != typeof t9;
  var g3 = Array.isArray;
  var $2 = (t9) => g3(t9) || "function" == typeof t9?.[Symbol.iterator];
  var x2 = "[ 	\n\f\r]";
  var T2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  var E4 = /-->/g;
  var k2 = />/g;
  var O = RegExp(`>|${x2}(?:([^\\s"'>=/]+)(${x2}*=${x2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
  var S4 = /'/g;
  var j = /"/g;
  var M2 = /^(?:script|style|textarea|title)$/i;
  var P2 = (t9) => (i9, ...s7) => ({ _$litType$: t9, strings: i9, values: s7 });
  var ke = P2(1);
  var Oe = P2(2);
  var Se = P2(3);
  var R3 = Symbol.for("lit-noChange");
  var D = Symbol.for("lit-nothing");
  var V2 = /* @__PURE__ */ new WeakMap();
  var I2 = w2.createTreeWalker(w2, 129);
  function N3(t9, i9) {
    if (!g3(t9) || !t9.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return void 0 !== h6 ? h6.createHTML(i9) : i9;
  }
  var U = (t9, i9) => {
    const s7 = t9.length - 1, e9 = [];
    let h8, o7 = 2 === i9 ? "<svg>" : 3 === i9 ? "<math>" : "", n7 = T2;
    for (let i10 = 0; i10 < s7; i10++) {
      const s8 = t9[i10];
      let r8, l4, c7 = -1, a6 = 0;
      for (; a6 < s8.length && (n7.lastIndex = a6, l4 = n7.exec(s8), null !== l4); ) a6 = n7.lastIndex, n7 === T2 ? "!--" === l4[1] ? n7 = E4 : void 0 !== l4[1] ? n7 = k2 : void 0 !== l4[2] ? (M2.test(l4[2]) && (h8 = RegExp("</" + l4[2], "g")), n7 = O) : void 0 !== l4[3] && (n7 = O) : n7 === O ? ">" === l4[0] ? (n7 = h8 ?? T2, c7 = -1) : void 0 === l4[1] ? c7 = -2 : (c7 = n7.lastIndex - l4[2].length, r8 = l4[1], n7 = void 0 === l4[3] ? O : '"' === l4[3] ? j : S4) : n7 === j || n7 === S4 ? n7 = O : n7 === E4 || n7 === k2 ? n7 = T2 : (n7 = O, h8 = void 0);
      const u4 = n7 === O && t9[i10 + 1].startsWith("/>") ? " " : "";
      o7 += n7 === T2 ? s8 + _3 : c7 >= 0 ? (e9.push(r8), s8.slice(0, c7) + f6 + s8.slice(c7) + v3 + u4) : s8 + v3 + (-2 === c7 ? i10 : u4);
    }
    return [N3(t9, o7 + (t9[s7] || "<?>") + (2 === i9 ? "</svg>" : 3 === i9 ? "</math>" : "")), e9];
  };
  var B2 = class _B {
    constructor({ strings: t9, _$litType$: i9 }, s7) {
      let e9;
      this.parts = [];
      let h8 = 0, o7 = 0;
      const n7 = t9.length - 1, r8 = this.parts, [l4, a6] = U(t9, i9);
      if (this.el = _B.createElement(l4, s7), I2.currentNode = this.el.content, 2 === i9 || 3 === i9) {
        const t10 = this.el.content.firstChild;
        t10.replaceWith(...t10.childNodes);
      }
      for (; null !== (e9 = I2.nextNode()) && r8.length < n7; ) {
        if (1 === e9.nodeType) {
          if (e9.hasAttributes()) for (const t10 of e9.getAttributeNames()) if (t10.endsWith(f6)) {
            const i10 = a6[o7++], s8 = e9.getAttribute(t10).split(v3), n8 = /([.?@])?(.*)/.exec(i10);
            r8.push({ type: 1, index: h8, name: n8[2], strings: s8, ctor: "." === n8[1] ? Y2 : "?" === n8[1] ? Z3 : "@" === n8[1] ? q : G2 }), e9.removeAttribute(t10);
          } else t10.startsWith(v3) && (r8.push({ type: 6, index: h8 }), e9.removeAttribute(t10));
          if (M2.test(e9.tagName)) {
            const t10 = e9.textContent.split(v3), i10 = t10.length - 1;
            if (i10 > 0) {
              e9.textContent = c6 ? c6.emptyScript : "";
              for (let s8 = 0; s8 < i10; s8++) e9.append(t10[s8], lt()), I2.nextNode(), r8.push({ type: 2, index: ++h8 });
              e9.append(t10[i10], lt());
            }
          }
        } else if (8 === e9.nodeType) if (e9.data === m4) r8.push({ type: 2, index: h8 });
        else {
          let t10 = -1;
          for (; -1 !== (t10 = e9.data.indexOf(v3, t10 + 1)); ) r8.push({ type: 7, index: h8 }), t10 += v3.length - 1;
        }
        h8++;
      }
    }
    static createElement(t9, i9) {
      const s7 = w2.createElement("template");
      return s7.innerHTML = t9, s7;
    }
  };
  function z2(t9, i9, s7 = t9, e9) {
    if (i9 === R3) return i9;
    let h8 = void 0 !== e9 ? s7.o?.[e9] : s7.l;
    const o7 = st(i9) ? void 0 : i9._$litDirective$;
    return h8?.constructor !== o7 && (h8?._$AO?.(false), void 0 === o7 ? h8 = void 0 : (h8 = new o7(t9), h8._$AT(t9, s7, e9)), void 0 !== e9 ? (s7.o ??= [])[e9] = h8 : s7.l = h8), void 0 !== h8 && (i9 = z2(t9, h8._$AS(t9, i9.values), h8, e9)), i9;
  }
  var F = class {
    constructor(t9, i9) {
      this._$AV = [], this._$AN = void 0, this._$AD = t9, this._$AM = i9;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(t9) {
      const { el: { content: i9 }, parts: s7 } = this._$AD, e9 = (t9?.creationScope ?? w2).importNode(i9, true);
      I2.currentNode = e9;
      let h8 = I2.nextNode(), o7 = 0, n7 = 0, r8 = s7[0];
      for (; void 0 !== r8; ) {
        if (o7 === r8.index) {
          let i10;
          2 === r8.type ? i10 = new et(h8, h8.nextSibling, this, t9) : 1 === r8.type ? i10 = new r8.ctor(h8, r8.name, r8.strings, this, t9) : 6 === r8.type && (i10 = new K(h8, this, t9)), this._$AV.push(i10), r8 = s7[++n7];
        }
        o7 !== r8?.index && (h8 = I2.nextNode(), o7++);
      }
      return I2.currentNode = w2, e9;
    }
    p(t9) {
      let i9 = 0;
      for (const s7 of this._$AV) void 0 !== s7 && (void 0 !== s7.strings ? (s7._$AI(t9, s7, i9), i9 += s7.strings.length - 2) : s7._$AI(t9[i9])), i9++;
    }
  };
  var et = class _et {
    get _$AU() {
      return this._$AM?._$AU ?? this.v;
    }
    constructor(t9, i9, s7, e9) {
      this.type = 2, this._$AH = D, this._$AN = void 0, this._$AA = t9, this._$AB = i9, this._$AM = s7, this.options = e9, this.v = e9?.isConnected ?? true;
    }
    get parentNode() {
      let t9 = this._$AA.parentNode;
      const i9 = this._$AM;
      return void 0 !== i9 && 11 === t9?.nodeType && (t9 = i9.parentNode), t9;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t9, i9 = this) {
      t9 = z2(this, t9, i9), st(t9) ? t9 === D || null == t9 || "" === t9 ? (this._$AH !== D && this._$AR(), this._$AH = D) : t9 !== this._$AH && t9 !== R3 && this._(t9) : void 0 !== t9._$litType$ ? this.$(t9) : void 0 !== t9.nodeType ? this.T(t9) : $2(t9) ? this.k(t9) : this._(t9);
    }
    O(t9) {
      return this._$AA.parentNode.insertBefore(t9, this._$AB);
    }
    T(t9) {
      this._$AH !== t9 && (this._$AR(), this._$AH = this.O(t9));
    }
    _(t9) {
      this._$AH !== D && st(this._$AH) ? this._$AA.nextSibling.data = t9 : this.T(w2.createTextNode(t9)), this._$AH = t9;
    }
    $(t9) {
      const { values: i9, _$litType$: s7 } = t9, e9 = "number" == typeof s7 ? this._$AC(t9) : (void 0 === s7.el && (s7.el = B2.createElement(N3(s7.h, s7.h[0]), this.options)), s7);
      if (this._$AH?._$AD === e9) this._$AH.p(i9);
      else {
        const t10 = new F(e9, this), s8 = t10.u(this.options);
        t10.p(i9), this.T(s8), this._$AH = t10;
      }
    }
    _$AC(t9) {
      let i9 = V2.get(t9.strings);
      return void 0 === i9 && V2.set(t9.strings, i9 = new B2(t9)), i9;
    }
    k(t9) {
      g3(this._$AH) || (this._$AH = [], this._$AR());
      const i9 = this._$AH;
      let s7, e9 = 0;
      for (const h8 of t9) e9 === i9.length ? i9.push(s7 = new _et(this.O(lt()), this.O(lt()), this, this.options)) : s7 = i9[e9], s7._$AI(h8), e9++;
      e9 < i9.length && (this._$AR(s7 && s7._$AB.nextSibling, e9), i9.length = e9);
    }
    _$AR(t9 = this._$AA.nextSibling, i9) {
      for (this._$AP?.(false, true, i9); t9 && t9 !== this._$AB; ) {
        const i10 = t9.nextSibling;
        t9.remove(), t9 = i10;
      }
    }
    setConnected(t9) {
      void 0 === this._$AM && (this.v = t9, this._$AP?.(t9));
    }
  };
  var G2 = class {
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    constructor(t9, i9, s7, e9, h8) {
      this.type = 1, this._$AH = D, this._$AN = void 0, this.element = t9, this.name = i9, this._$AM = e9, this.options = h8, s7.length > 2 || "" !== s7[0] || "" !== s7[1] ? (this._$AH = Array(s7.length - 1).fill(new String()), this.strings = s7) : this._$AH = D;
    }
    _$AI(t9, i9 = this, s7, e9) {
      const h8 = this.strings;
      let o7 = false;
      if (void 0 === h8) t9 = z2(this, t9, i9, 0), o7 = !st(t9) || t9 !== this._$AH && t9 !== R3, o7 && (this._$AH = t9);
      else {
        const e10 = t9;
        let n7, r8;
        for (t9 = h8[0], n7 = 0; n7 < h8.length - 1; n7++) r8 = z2(this, e10[s7 + n7], i9, n7), r8 === R3 && (r8 = this._$AH[n7]), o7 ||= !st(r8) || r8 !== this._$AH[n7], r8 === D ? t9 = D : t9 !== D && (t9 += (r8 ?? "") + h8[n7 + 1]), this._$AH[n7] = r8;
      }
      o7 && !e9 && this.j(t9);
    }
    j(t9) {
      t9 === D ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t9 ?? "");
    }
  };
  var Y2 = class extends G2 {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(t9) {
      this.element[this.name] = t9 === D ? void 0 : t9;
    }
  };
  var Z3 = class extends G2 {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(t9) {
      this.element.toggleAttribute(this.name, !!t9 && t9 !== D);
    }
  };
  var q = class extends G2 {
    constructor(t9, i9, s7, e9, h8) {
      super(t9, i9, s7, e9, h8), this.type = 5;
    }
    _$AI(t9, i9 = this) {
      if ((t9 = z2(this, t9, i9, 0) ?? D) === R3) return;
      const s7 = this._$AH, e9 = t9 === D && s7 !== D || t9.capture !== s7.capture || t9.once !== s7.once || t9.passive !== s7.passive, h8 = t9 !== D && (s7 === D || e9);
      e9 && this.element.removeEventListener(this.name, this, s7), h8 && this.element.addEventListener(this.name, this, t9), this._$AH = t9;
    }
    handleEvent(t9) {
      "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t9) : this._$AH.handleEvent(t9);
    }
  };
  var K = class {
    constructor(t9, i9, s7) {
      this.element = t9, this.type = 6, this._$AN = void 0, this._$AM = i9, this.options = s7;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t9) {
      z2(this, t9);
    }
  };
  var si = { M: f6, P: v3, A: m4, C: 1, L: U, R: F, D: $2, V: z2, I: et, H: G2, N: Z3, U: q, B: Y2, F: K };
  var Re = n5.litHtmlPolyfillSupport;
  Re?.(B2, et), (n5.litHtmlVersions ??= []).push("3.2.0");
  var Q = (t9, i9, s7) => {
    const e9 = s7?.renderBefore ?? i9;
    let h8 = e9._$litPart$;
    if (void 0 === h8) {
      const t10 = s7?.renderBefore ?? null;
      e9._$litPart$ = h8 = new et(i9.insertBefore(lt(), t10), t10, void 0, s7 ?? {});
    }
    return h8._$AI(t9), h8;
  };

  // frontend/node_modules/lit-element/lit-element.js
  var h7 = class extends b3 {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
    }
    createRenderRoot() {
      const t9 = super.createRenderRoot();
      return this.renderOptions.renderBefore ??= t9.firstChild, t9;
    }
    update(t9) {
      const e9 = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t9), this.o = Q(e9, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      super.connectedCallback(), this.o?.setConnected(true);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this.o?.setConnected(false);
    }
    render() {
      return R3;
    }
  };
  h7._$litElement$ = true, h7["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h7 });
  var f7 = globalThis.litElementPolyfillSupport;
  f7?.({ LitElement: h7 });
  (globalThis.litElementVersions ??= []).push("4.1.0");

  // frontend/node_modules/@lit/reactive-element/decorators/custom-element.js
  var t6 = (t9) => (e9, o7) => {
    void 0 !== o7 ? o7.addInitializer(() => {
      customElements.define(t9, e9);
    }) : customElements.define(t9, e9);
  };

  // frontend/node_modules/@lit/reactive-element/decorators/property.js
  var o6 = { attribute: true, type: String, converter: u3, reflect: false, hasChanged: f5 };
  var r5 = (t9 = o6, e9, r8) => {
    const { kind: n7, metadata: i9 } = r8;
    let s7 = globalThis.litPropertyMetadata.get(i9);
    if (void 0 === s7 && globalThis.litPropertyMetadata.set(i9, s7 = /* @__PURE__ */ new Map()), s7.set(r8.name, t9), "accessor" === n7) {
      const { name: o7 } = r8;
      return { set(r9) {
        const n8 = e9.get.call(this);
        e9.set.call(this, r9), this.requestUpdate(o7, n8, t9);
      }, init(e10) {
        return void 0 !== e10 && this.P(o7, void 0, t9), e10;
      } };
    }
    if ("setter" === n7) {
      const { name: o7 } = r8;
      return function(r9) {
        const n8 = this[o7];
        e9.call(this, r9), this.requestUpdate(o7, n8, t9);
      };
    }
    throw Error("Unsupported decorator location: " + n7);
  };
  function n6(t9) {
    return (e9, o7) => "object" == typeof o7 ? r5(t9, e9, o7) : ((t10, e10, o8) => {
      const r8 = e10.hasOwnProperty(o8);
      return e10.constructor.createProperty(o8, r8 ? { ...t10, wrapped: true } : t10), r8 ? Object.getOwnPropertyDescriptor(e10, o8) : void 0;
    })(t9, e9, o7);
  }

  // frontend/node_modules/@lit/reactive-element/decorators/state.js
  function r6(r8) {
    return n6({ ...r8, state: true, attribute: false });
  }

  // frontend/node_modules/style-vendorizer/dist/esm/bundle.min.mjs
  var i7 = /* @__PURE__ */ new Map([["align-self", "-ms-grid-row-align"], ["color-adjust", "-webkit-print-color-adjust"], ["column-gap", "grid-column-gap"], ["forced-color-adjust", "-ms-high-contrast-adjust"], ["gap", "grid-gap"], ["grid-template-columns", "-ms-grid-columns"], ["grid-template-rows", "-ms-grid-rows"], ["justify-self", "-ms-grid-column-align"], ["margin-inline-end", "-webkit-margin-end"], ["margin-inline-start", "-webkit-margin-start"], ["mask-border", "-webkit-mask-box-image"], ["mask-border-outset", "-webkit-mask-box-image-outset"], ["mask-border-slice", "-webkit-mask-box-image-slice"], ["mask-border-source", "-webkit-mask-box-image-source"], ["mask-border-repeat", "-webkit-mask-box-image-repeat"], ["mask-border-width", "-webkit-mask-box-image-width"], ["overflow-wrap", "word-wrap"], ["padding-inline-end", "-webkit-padding-end"], ["padding-inline-start", "-webkit-padding-start"], ["print-color-adjust", "color-adjust"], ["row-gap", "grid-row-gap"], ["scroll-margin-bottom", "scroll-snap-margin-bottom"], ["scroll-margin-left", "scroll-snap-margin-left"], ["scroll-margin-right", "scroll-snap-margin-right"], ["scroll-margin-top", "scroll-snap-margin-top"], ["scroll-margin", "scroll-snap-margin"], ["text-combine-upright", "-ms-text-combine-horizontal"]]);
  function r7(r8) {
    return i7.get(r8);
  }
  function a5(i9) {
    var r8 = /^(?:(text-(?:decoration$|e|or|si)|back(?:ground-cl|d|f)|box-d|mask(?:$|-[ispro]|-cl)|pr|hyphena|flex-d)|(tab-|column(?!-s)|text-align-l)|(ap)|u|hy)/i.exec(i9);
    return r8 ? r8[1] ? 1 : r8[2] ? 2 : r8[3] ? 3 : 5 : 0;
  }
  function t7(i9, r8) {
    var a6 = /^(?:(pos)|(cli)|(background-i)|(flex(?:$|-b)|(?:max-|min-)?(?:block-s|inl|he|widt))|dis)/i.exec(i9);
    return a6 ? a6[1] ? /^sti/i.test(r8) ? 1 : 0 : a6[2] ? /^pat/i.test(r8) ? 1 : 0 : a6[3] ? /^image-/i.test(r8) ? 1 : 0 : a6[4] ? "-" === r8[3] ? 2 : 0 : /^(?:inline-)?grid$/i.test(r8) ? 4 : 0 : 0;
  }

  // frontend/node_modules/twind/twind.js
  var includes = (value, search) => !!~value.indexOf(search);
  var join = (parts, separator = "-") => parts.join(separator);
  var joinTruthy = (parts, separator) => join(parts.filter(Boolean), separator);
  var tail = (array, startIndex = 1) => array.slice(startIndex);
  var identity = (value) => value;
  var noop = () => {
  };
  var capitalize = (value) => value[0].toUpperCase() + tail(value);
  var hyphenate = (value) => value.replace(/[A-Z]/g, "-$&").toLowerCase();
  var evalThunk = (value, context) => {
    while (typeof value == "function") {
      value = value(context);
    }
    return value;
  };
  var ensureMaxSize = (map, max) => {
    if (map.size > max) {
      map.delete(map.keys().next().value);
    }
  };
  var isCSSProperty = (key, value) => !includes("@:&", key[0]) && (includes("rg", (typeof value)[5]) || Array.isArray(value));
  var merge = (target, source, context) => source ? Object.keys(source).reduce((target2, key) => {
    const value = evalThunk(source[key], context);
    if (isCSSProperty(key, value)) {
      target2[hyphenate(key)] = value;
    } else {
      target2[key] = key[0] == "@" && includes("figa", key[1]) ? (target2[key] || []).concat(value) : merge(target2[key] || {}, value, context);
    }
    return target2;
  }, target) : target;
  var escape = typeof CSS !== "undefined" && CSS.escape || ((className) => className.replace(/[!"'`*+.,;:\\/<=>?@#$%&^|~()[\]{}]/g, "\\$&").replace(/^\d/, "\\3$& "));
  var buildMediaQuery = (screen) => {
    if (!Array.isArray(screen)) {
      screen = [screen];
    }
    return "@media " + join(screen.map((screen2) => {
      if (typeof screen2 == "string") {
        screen2 = { min: screen2 };
      }
      return screen2.raw || join(Object.keys(screen2).map((feature) => `(${feature}-width:${screen2[feature]})`), " and ");
    }), ",");
  };
  var cyrb32 = (value) => {
    for (var h8 = 9, index = value.length; index--; ) {
      h8 = Math.imul(h8 ^ value.charCodeAt(index), 1597334677);
    }
    return "tw-" + ((h8 ^ h8 >>> 9) >>> 0).toString(36);
  };
  var sortedInsertionIndex = (array, element) => {
    for (var low = 0, high = array.length; low < high; ) {
      const pivot = high + low >> 1;
      if (array[pivot] <= element) {
        low = pivot + 1;
      } else {
        high = pivot;
      }
    }
    return high;
  };
  var groupings;
  var rules;
  var startGrouping = (value = "") => {
    groupings.push(value);
    return "";
  };
  var endGrouping = (isWhitespace) => {
    groupings.length = Math.max(groupings.lastIndexOf("") + ~~isWhitespace, 0);
  };
  var onlyPrefixes = (s7) => s7 && !includes("!:", s7[0]);
  var onlyVariants = (s7) => s7[0] == ":";
  var addRule = (directive2, negate2) => {
    rules.push({
      v: groupings.filter(onlyVariants),
      d: directive2,
      n: negate2,
      i: includes(groupings, "!"),
      $: ""
    });
  };
  var saveRule = (buffer) => {
    const negate2 = buffer[0] == "-";
    if (negate2) {
      buffer = tail(buffer);
    }
    const prefix = join(groupings.filter(onlyPrefixes));
    addRule(buffer == "&" ? prefix : (prefix && prefix + "-") + buffer, negate2);
    return "";
  };
  var parseString = (token, isVariant) => {
    let buffer = "";
    for (let char, dynamic = false, position2 = 0; char = token[position2++]; ) {
      if (dynamic || char == "[") {
        buffer += char;
        dynamic = char != "]";
        continue;
      }
      switch (char) {
        case ":":
          buffer = buffer && startGrouping(":" + (token[position2] == char ? token[position2++] : "") + buffer);
          break;
        case "(":
          buffer = buffer && startGrouping(buffer);
          startGrouping();
          break;
        case "!":
          startGrouping(char);
          break;
        case ")":
        case " ":
        case "	":
        case "\n":
        case "\r":
          buffer = buffer && saveRule(buffer);
          endGrouping(char !== ")");
          break;
        default:
          buffer += char;
      }
    }
    if (buffer) {
      if (isVariant) {
        startGrouping(":" + buffer);
      } else if (buffer.slice(-1) == "-") {
        startGrouping(buffer.slice(0, -1));
      } else {
        saveRule(buffer);
      }
    }
  };
  var parseGroupedToken = (token) => {
    startGrouping();
    parseToken(token);
    endGrouping();
  };
  var parseGroup = (key, token) => {
    if (token) {
      startGrouping();
      const isVariant = includes("tbu", (typeof token)[1]);
      parseString(key, isVariant);
      if (isVariant) {
        parseGroupedToken(token);
      }
      endGrouping();
    }
  };
  var parseToken = (token) => {
    switch (typeof token) {
      case "string":
        parseString(token);
        break;
      case "function":
        addRule(token);
        break;
      case "object":
        if (Array.isArray(token)) {
          token.forEach(parseGroupedToken);
        } else if (token) {
          Object.keys(token).forEach((key) => {
            parseGroup(key, token[key]);
          });
        }
    }
  };
  var staticsCaches = /* @__PURE__ */ new WeakMap();
  var buildStatics = (strings) => {
    let statics = staticsCaches.get(strings);
    if (!statics) {
      let slowModeIndex = NaN;
      let buffer = "";
      statics = strings.map((token, index) => {
        if (slowModeIndex !== slowModeIndex && (token.slice(-1) == "[" || includes(":-(", (strings[index + 1] || "")[0]))) {
          slowModeIndex = index;
        }
        if (index >= slowModeIndex) {
          return (interpolation) => {
            if (index == slowModeIndex) {
              buffer = "";
            }
            buffer += token;
            if (includes("rg", (typeof interpolation)[5])) {
              buffer += interpolation;
            } else if (interpolation) {
              parseString(buffer);
              buffer = "";
              parseToken(interpolation);
            }
            if (index == strings.length - 1) {
              parseString(buffer);
            }
          };
        }
        const staticRules = rules = [];
        parseString(token);
        const activeGroupings = [...groupings];
        rules = [];
        return (interpolation) => {
          rules.push(...staticRules);
          groupings = [...activeGroupings];
          if (interpolation) {
            parseToken(interpolation);
          }
        };
      });
      staticsCaches.set(strings, statics);
    }
    return statics;
  };
  var parse = (tokens) => {
    groupings = [];
    rules = [];
    if (Array.isArray(tokens[0]) && Array.isArray(tokens[0].raw)) {
      buildStatics(tokens[0]).forEach((apply2, index) => apply2(tokens[index + 1]));
    } else {
      parseToken(tokens);
    }
    return rules;
  };
  var isFunctionFree;
  var detectFunction = (key, value) => {
    if (typeof value == "function") {
      isFunctionFree = false;
    }
    return value;
  };
  var stringify = (data) => {
    isFunctionFree = true;
    const key = JSON.stringify(data, detectFunction);
    return isFunctionFree && key;
  };
  var cacheByFactory = /* @__PURE__ */ new WeakMap();
  var directive = (factory, data) => {
    const key = stringify(data);
    let directive2;
    if (key) {
      var cache = cacheByFactory.get(factory);
      if (!cache) {
        cacheByFactory.set(factory, cache = /* @__PURE__ */ new Map());
      }
      directive2 = cache.get(key);
    }
    if (!directive2) {
      directive2 = Object.defineProperty((params, context) => {
        context = Array.isArray(params) ? context : params;
        return evalThunk(factory(data, context), context);
      }, "toJSON", {
        value: () => key || data
      });
      if (cache) {
        cache.set(key, directive2);
        ensureMaxSize(cache, 1e4);
      }
    }
    return directive2;
  };
  var applyFactory = (tokens, { css }) => css(parse(tokens));
  var apply = (...tokens) => directive(applyFactory, tokens);
  var positions = (resolve) => (value, position2, prefix, suffix) => {
    if (value) {
      const properties = position2 && resolve(position2);
      if (properties && properties.length > 0) {
        return properties.reduce((declarations, property2) => {
          declarations[joinTruthy([prefix, property2, suffix])] = value;
          return declarations;
        }, {});
      }
    }
  };
  var corners = /* @__PURE__ */ positions((key) => ({
    t: ["top-left", "top-right"],
    r: ["top-right", "bottom-right"],
    b: ["bottom-left", "bottom-right"],
    l: ["bottom-left", "top-left"],
    tl: ["top-left"],
    tr: ["top-right"],
    bl: ["bottom-left"],
    br: ["bottom-right"]
  })[key]);
  var expandEdges = (key) => {
    const parts = ({ x: "lr", y: "tb" }[key] || key || "").split("").sort();
    for (let index = parts.length; index--; ) {
      if (!(parts[index] = {
        t: "top",
        r: "right",
        b: "bottom",
        l: "left"
      }[parts[index]]))
        return;
    }
    if (parts.length)
      return parts;
  };
  var edges = /* @__PURE__ */ positions(expandEdges);
  var stringifyVariant = (selector, variant) => selector + (variant[1] == ":" ? tail(variant, 2) + ":" : tail(variant)) + ":";
  var stringifyRule = (rule, directive2 = rule.d) => typeof directive2 == "function" ? "" : rule.v.reduce(stringifyVariant, "") + (rule.i ? "!" : "") + (rule.n ? "-" : "") + directive2;
  var _4;
  var __;
  var $3;
  var toColumnsOrRows = (x3) => x3 == "cols" ? "columns" : "rows";
  var property = (property2) => (params, context, id) => ({
    [property2]: id + ((_4 = join(params)) && "-" + _4)
  });
  var propertyValue = (property2, separator) => (params, context, id) => (_4 = join(params, separator)) && {
    [property2 || id]: _4
  };
  var themeProperty = (section) => (params, { theme: theme2 }, id) => (_4 = theme2(section || id, params)) && {
    [section || id]: _4
  };
  var themePropertyFallback = (section, separator) => (params, { theme: theme2 }, id) => (_4 = theme2(section || id, params, join(params, separator))) && {
    [section || id]: _4
  };
  var alias = (handler, name) => (params, context) => handler(params, context, name);
  var display = property("display");
  var position = property("position");
  var textTransform = property("textTransform");
  var textDecoration = property("textDecoration");
  var fontStyle = property("fontStyle");
  var fontVariantNumeric = (key) => (params, context, id) => ({
    ["--tw-" + key]: id,
    fontVariantNumeric: "var(--tw-ordinal,/*!*/ /*!*/) var(--tw-slashed-zero,/*!*/ /*!*/) var(--tw-numeric-figure,/*!*/ /*!*/) var(--tw-numeric-spacing,/*!*/ /*!*/) var(--tw-numeric-fraction,/*!*/ /*!*/)"
  });
  var inset = (params, { theme: theme2 }, id) => (_4 = theme2("inset", params)) && { [id]: _4 };
  var opacityProperty = (params, theme2, id, section = id) => (_4 = theme2(section + "Opacity", tail(params))) && {
    [`--tw-${id}-opacity`]: _4
  };
  var parseColorComponent = (chars, factor) => Math.round(parseInt(chars, 16) * factor);
  var asRGBA = (color, opacityProperty2, opacityDefault) => {
    if (color && color[0] == "#" && (_4 = (color.length - 1) / 3) && ($3 = [17, 1, 0.062272][_4 - 1])) {
      return `rgba(${parseColorComponent(color.substr(1, _4), $3)},${parseColorComponent(color.substr(1 + _4, _4), $3)},${parseColorComponent(color.substr(1 + 2 * _4, _4), $3)},${opacityProperty2 ? `var(--tw-${opacityProperty2}${opacityDefault ? "," + opacityDefault : ""})` : opacityDefault || 1})`;
    }
    return color;
  };
  var withOpacityFallback = (property2, kind, color) => color && typeof color == "string" ? (_4 = asRGBA(color, kind + "-opacity")) && _4 !== color ? {
    [`--tw-${kind}-opacity`]: "1",
    [property2]: [color, _4]
  } : { [property2]: color } : void 0;
  var transparentTo = (color) => ($3 = asRGBA(color, "", "0")) == _4 ? "transparent" : $3;
  var reversableEdge = (params, { theme: theme2 }, id, section, prefix, suffix) => (_4 = { x: ["right", "left"], y: ["bottom", "top"] }[params[0]]) && ($3 = `--tw-${id}-${params[0]}-reverse`) ? params[1] == "reverse" ? {
    [$3]: "1"
  } : {
    [$3]: "0",
    [joinTruthy([prefix, _4[0], suffix])]: (__ = theme2(section, tail(params))) && `calc(${__} * var(${$3}))`,
    [joinTruthy([prefix, _4[1], suffix])]: __ && [__, `calc(${__} * calc(1 - var(${$3})))`]
  } : void 0;
  var placeHelper = (property2, params) => params[0] && {
    [property2]: (includes("wun", (params[0] || "")[3]) ? "space-" : "") + params[0]
  };
  var contentPluginFor = (property2) => (params) => includes(["start", "end"], params[0]) ? { [property2]: "flex-" + params[0] } : placeHelper(property2, params);
  var gridPlugin = (kind) => (params, { theme: theme2 }) => {
    if (_4 = theme2("grid" + capitalize(kind), params, "")) {
      return { ["grid-" + kind]: _4 };
    }
    switch (params[0]) {
      case "span":
        return params[1] && {
          ["grid-" + kind]: `span ${params[1]} / span ${params[1]}`
        };
      case "start":
      case "end":
        return (_4 = theme2("grid" + capitalize(kind) + capitalize(params[0]), tail(params), join(tail(params)))) && {
          [`grid-${kind}-${params[0]}`]: _4
        };
    }
  };
  var border = (params, { theme: theme2 }, id) => {
    switch (params[0]) {
      case "solid":
      case "dashed":
      case "dotted":
      case "double":
      case "none":
        return propertyValue("borderStyle")(params);
      case "collapse":
      case "separate":
        return propertyValue("borderCollapse")(params);
      case "opacity":
        return opacityProperty(params, theme2, id);
    }
    return (_4 = theme2(id + "Width", params, "")) ? { borderWidth: _4 } : withOpacityFallback("borderColor", id, theme2(id + "Color", params));
  };
  var borderEdges = (params, context, id) => {
    var _a;
    const edges2 = (_a = expandEdges(params[0])) == null ? void 0 : _a.map(capitalize);
    if (edges2) {
      params = tail(params);
    }
    let rules2 = border(params, context, id);
    if (edges2 && rules2 && typeof rules2 === "object") {
      rules2 = Object.entries(rules2).reduce((newRules, [key, value]) => {
        if (key.startsWith("border")) {
          for (const edge of edges2) {
            newRules[key.slice(0, 6) + edge + key.slice(6)] = value;
          }
        } else {
          newRules[key] = value;
        }
        return newRules;
      }, {});
    }
    return rules2;
  };
  var transform = (gpu) => (gpu ? "translate3d(var(--tw-translate-x,0),var(--tw-translate-y,0),0)" : "translateX(var(--tw-translate-x,0)) translateY(var(--tw-translate-y,0))") + " rotate(var(--tw-rotate,0)) skewX(var(--tw-skew-x,0)) skewY(var(--tw-skew-y,0)) scaleX(var(--tw-scale-x,1)) scaleY(var(--tw-scale-y,1))";
  var transformXYFunction = (params, context, id) => params[0] && (_4 = context.theme(id, params[1] || params[0])) && {
    [`--tw-${id}-x`]: params[0] !== "y" && _4,
    [`--tw-${id}-y`]: params[0] !== "x" && _4,
    transform: [`${id}${params[1] ? params[0].toUpperCase() : ""}(${_4})`, transform()]
  };
  var edgesPluginFor = (key) => (params, context, id) => id[1] ? edges(context.theme(key, params), id[1], key) : themeProperty(key)(params, context, id);
  var padding = edgesPluginFor("padding");
  var margin = edgesPluginFor("margin");
  var minMax = (params, { theme: theme2 }, id) => (_4 = { w: "width", h: "height" }[params[0]]) && {
    [_4 = `${id}${capitalize(_4)}`]: theme2(_4, tail(params))
  };
  var filter = (params, { theme: theme2 }, id) => {
    const parts = id.split("-");
    const prefix = parts[0] == "backdrop" ? parts[0] + "-" : "";
    if (!prefix) {
      params.unshift(...parts);
    }
    if (params[0] == "filter") {
      const filters = [
        "blur",
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        prefix && "opacity",
        "saturate",
        "sepia",
        !prefix && "drop-shadow"
      ].filter(Boolean);
      return params[1] == "none" ? { [prefix + "filter"]: "none" } : filters.reduce((css, key) => {
        css["--tw-" + prefix + key] = "var(--tw-empty,/*!*/ /*!*/)";
        return css;
      }, {
        [prefix + "filter"]: filters.map((key) => `var(--tw-${prefix}${key})`).join(" ")
      });
    }
    $3 = params.shift();
    if (includes(["hue", "drop"], $3))
      $3 += capitalize(params.shift());
    return (_4 = theme2(prefix ? "backdrop" + capitalize($3) : $3, params)) && {
      ["--tw-" + prefix + $3]: (Array.isArray(_4) ? _4 : [_4]).map((_42) => `${hyphenate($3)}(${_42})`).join(" ")
    };
  };
  var corePlugins = {
    group: (params, { tag }, id) => tag(join([id, ...params])),
    hidden: alias(display, "none"),
    inline: display,
    block: display,
    contents: display,
    flow: display,
    table: (params, context, id) => includes(["auto", "fixed"], params[0]) ? { tableLayout: params[0] } : display(params, context, id),
    flex(params, context, id) {
      switch (params[0]) {
        case "row":
        case "col":
          return {
            flexDirection: join(params[0] == "col" ? ["column", ...tail(params)] : params)
          };
        case "nowrap":
        case "wrap":
          return { flexWrap: join(params) };
        case "grow":
        case "shrink":
          _4 = context.theme("flex" + capitalize(params[0]), tail(params), params[1] || 1);
          return _4 != null && {
            ["flex-" + params[0]]: "" + _4
          };
      }
      return (_4 = context.theme("flex", params, "")) ? { flex: _4 } : display(params, context, id);
    },
    grid(params, context, id) {
      switch (params[0]) {
        case "cols":
        case "rows":
          return (_4 = context.theme("gridTemplate" + capitalize(toColumnsOrRows(params[0])), tail(params), params.length == 2 && Number(params[1]) ? `repeat(${params[1]},minmax(0,1fr))` : join(tail(params)))) && {
            ["gridTemplate-" + toColumnsOrRows(params[0])]: _4
          };
        case "flow":
          return params.length > 1 && {
            gridAutoFlow: join(params[1] == "col" ? ["column", ...tail(params, 2)] : tail(params), " ")
          };
      }
      return display(params, context, id);
    },
    auto: (params, { theme: theme2 }) => includes(["cols", "rows"], params[0]) && (_4 = theme2("gridAuto" + capitalize(toColumnsOrRows(params[0])), tail(params), join(tail(params)))) && {
      ["gridAuto-" + toColumnsOrRows(params[0])]: _4
    },
    static: position,
    fixed: position,
    absolute: position,
    relative: position,
    sticky: position,
    visible: { visibility: "visible" },
    invisible: { visibility: "hidden" },
    antialiased: {
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale"
    },
    "subpixel-antialiased": {
      WebkitFontSmoothing: "auto",
      MozOsxFontSmoothing: "auto"
    },
    truncate: {
      overflow: "hidden",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis"
    },
    "sr-only": {
      position: "absolute",
      width: "1px",
      height: "1px",
      padding: "0",
      margin: "-1px",
      overflow: "hidden",
      whiteSpace: "nowrap",
      clip: "rect(0,0,0,0)",
      borderWidth: "0"
    },
    "not-sr-only": {
      position: "static",
      width: "auto",
      height: "auto",
      padding: "0",
      margin: "0",
      overflow: "visible",
      whiteSpace: "normal",
      clip: "auto"
    },
    resize: (params) => ({
      resize: { x: "horizontal", y: "vertical" }[params[0]] || params[0] || "both"
    }),
    box: (params) => params[0] && { boxSizing: params[0] + "-box" },
    appearance: propertyValue(),
    cursor: themePropertyFallback(),
    float: propertyValue(),
    clear: propertyValue(),
    decoration: propertyValue("boxDecorationBreak"),
    isolate: { isolation: "isolate" },
    isolation: propertyValue(),
    "mix-blend": propertyValue("mixBlendMode"),
    top: inset,
    right: inset,
    bottom: inset,
    left: inset,
    inset: (params, { theme: theme2 }) => (_4 = expandEdges(params[0])) ? edges(theme2("inset", tail(params)), params[0]) : (_4 = theme2("inset", params)) && {
      top: _4,
      right: _4,
      bottom: _4,
      left: _4
    },
    underline: textDecoration,
    "line-through": textDecoration,
    "no-underline": alias(textDecoration, "none"),
    "text-underline": alias(textDecoration, "underline"),
    "text-no-underline": alias(textDecoration, "none"),
    "text-line-through": alias(textDecoration, "line-through"),
    uppercase: textTransform,
    lowercase: textTransform,
    capitalize: textTransform,
    "normal-case": alias(textTransform, "none"),
    "text-normal-case": alias(textTransform, "none"),
    italic: fontStyle,
    "not-italic": alias(fontStyle, "normal"),
    "font-italic": alias(fontStyle, "italic"),
    "font-not-italic": alias(fontStyle, "normal"),
    font: (params, context, id) => (_4 = context.theme("fontFamily", params, "")) ? { fontFamily: _4 } : themeProperty("fontWeight")(params, context, id),
    items: (params) => params[0] && {
      alignItems: includes(["start", "end"], params[0]) ? "flex-" + params[0] : join(params)
    },
    "justify-self": propertyValue(),
    "justify-items": propertyValue(),
    justify: contentPluginFor("justifyContent"),
    content: contentPluginFor("alignContent"),
    self: contentPluginFor("alignSelf"),
    place: (params) => params[0] && placeHelper("place-" + params[0], tail(params)),
    overscroll: (params) => params[0] && {
      ["overscrollBehavior" + (params[1] ? "-" + params[0] : "")]: params[1] || params[0]
    },
    col: gridPlugin("column"),
    row: gridPlugin("row"),
    duration: themeProperty("transitionDuration"),
    delay: themeProperty("transitionDelay"),
    tracking: themeProperty("letterSpacing"),
    leading: themeProperty("lineHeight"),
    z: themeProperty("zIndex"),
    opacity: themeProperty(),
    ease: themeProperty("transitionTimingFunction"),
    p: padding,
    py: padding,
    px: padding,
    pt: padding,
    pr: padding,
    pb: padding,
    pl: padding,
    m: margin,
    my: margin,
    mx: margin,
    mt: margin,
    mr: margin,
    mb: margin,
    ml: margin,
    w: themeProperty("width"),
    h: themeProperty("height"),
    min: minMax,
    max: minMax,
    fill: themeProperty(),
    order: themeProperty(),
    origin: themePropertyFallback("transformOrigin", " "),
    select: propertyValue("userSelect"),
    "pointer-events": propertyValue(),
    align: propertyValue("verticalAlign"),
    whitespace: propertyValue("whiteSpace"),
    "normal-nums": { fontVariantNumeric: "normal" },
    ordinal: fontVariantNumeric("ordinal"),
    "slashed-zero": fontVariantNumeric("slashed-zero"),
    "lining-nums": fontVariantNumeric("numeric-figure"),
    "oldstyle-nums": fontVariantNumeric("numeric-figure"),
    "proportional-nums": fontVariantNumeric("numeric-spacing"),
    "tabular-nums": fontVariantNumeric("numeric-spacing"),
    "diagonal-fractions": fontVariantNumeric("numeric-fraction"),
    "stacked-fractions": fontVariantNumeric("numeric-fraction"),
    overflow: (params, context, id) => includes(["ellipsis", "clip"], params[0]) ? propertyValue("textOverflow")(params) : params[1] ? { ["overflow-" + params[0]]: params[1] } : propertyValue()(params, context, id),
    transform: (params) => params[0] == "none" ? { transform: "none" } : {
      "--tw-translate-x": "0",
      "--tw-translate-y": "0",
      "--tw-rotate": "0",
      "--tw-skew-x": "0",
      "--tw-skew-y": "0",
      "--tw-scale-x": "1",
      "--tw-scale-y": "1",
      transform: transform(params[0] == "gpu")
    },
    rotate: (params, { theme: theme2 }) => (_4 = theme2("rotate", params)) && {
      "--tw-rotate": _4,
      transform: [`rotate(${_4})`, transform()]
    },
    scale: transformXYFunction,
    translate: transformXYFunction,
    skew: transformXYFunction,
    gap: (params, context, id) => (_4 = { x: "column", y: "row" }[params[0]]) ? { [_4 + "Gap"]: context.theme("gap", tail(params)) } : themeProperty("gap")(params, context, id),
    stroke: (params, context, id) => (_4 = context.theme("stroke", params, "")) ? { stroke: _4 } : themeProperty("strokeWidth")(params, context, id),
    outline: (params, { theme: theme2 }) => (_4 = theme2("outline", params)) && {
      outline: _4[0],
      outlineOffset: _4[1]
    },
    "break-normal": {
      wordBreak: "normal",
      overflowWrap: "normal"
    },
    "break-words": { overflowWrap: "break-word" },
    "break-all": { wordBreak: "break-all" },
    text(params, { theme: theme2 }, id) {
      switch (params[0]) {
        case "left":
        case "center":
        case "right":
        case "justify":
          return { textAlign: params[0] };
        case "uppercase":
        case "lowercase":
        case "capitalize":
          return textTransform([], _4, params[0]);
        case "opacity":
          return opacityProperty(params, theme2, id);
      }
      const fontSize = theme2("fontSize", params, "");
      if (fontSize) {
        return typeof fontSize == "string" ? { fontSize } : {
          fontSize: fontSize[0],
          ...typeof fontSize[1] == "string" ? { lineHeight: fontSize[1] } : fontSize[1]
        };
      }
      return withOpacityFallback("color", "text", theme2("textColor", params));
    },
    bg(params, { theme: theme2 }, id) {
      switch (params[0]) {
        case "fixed":
        case "local":
        case "scroll":
          return propertyValue("backgroundAttachment", ",")(params);
        case "bottom":
        case "center":
        case "left":
        case "right":
        case "top":
          return propertyValue("backgroundPosition", " ")(params);
        case "no":
          return params[1] == "repeat" && propertyValue("backgroundRepeat")(params);
        case "repeat":
          return includes("xy", params[1]) ? propertyValue("backgroundRepeat")(params) : { backgroundRepeat: params[1] || params[0] };
        case "opacity":
          return opacityProperty(params, theme2, id, "background");
        case "clip":
        case "origin":
          return params[1] && {
            ["background-" + params[0]]: params[1] + (params[1] == "text" ? "" : "-box")
          };
        case "blend":
          return propertyValue("background-blend-mode")(tail(params));
        case "gradient":
          if (params[1] == "to" && (_4 = expandEdges(params[2]))) {
            return {
              backgroundImage: `linear-gradient(to ${join(_4, " ")},var(--tw-gradient-stops))`
            };
          }
      }
      return (_4 = theme2("backgroundPosition", params, "")) ? { backgroundPosition: _4 } : (_4 = theme2("backgroundSize", params, "")) ? { backgroundSize: _4 } : (_4 = theme2("backgroundImage", params, "")) ? { backgroundImage: _4 } : withOpacityFallback("backgroundColor", "bg", theme2("backgroundColor", params));
    },
    from: (params, { theme: theme2 }) => (_4 = theme2("gradientColorStops", params)) && {
      "--tw-gradient-from": _4,
      "--tw-gradient-stops": `var(--tw-gradient-from),var(--tw-gradient-to,${transparentTo(_4)})`
    },
    via: (params, { theme: theme2 }) => (_4 = theme2("gradientColorStops", params)) && {
      "--tw-gradient-stops": `var(--tw-gradient-from),${_4},var(--tw-gradient-to,${transparentTo(_4)})`
    },
    to: (params, { theme: theme2 }) => (_4 = theme2("gradientColorStops", params)) && {
      "--tw-gradient-to": _4
    },
    border: borderEdges,
    divide: (params, context, id) => (_4 = reversableEdge(params, context, id, "divideWidth", "border", "width") || border(params, context, id)) && {
      "&>:not([hidden])~:not([hidden])": _4
    },
    space: (params, context, id) => (_4 = reversableEdge(params, context, id, "space", "margin")) && {
      "&>:not([hidden])~:not([hidden])": _4
    },
    placeholder: (params, { theme: theme2 }, id) => (_4 = params[0] == "opacity" ? opacityProperty(params, theme2, id) : withOpacityFallback("color", "placeholder", theme2("placeholderColor", params))) && {
      "&::placeholder": _4
    },
    shadow: (params, { theme: theme2 }) => (_4 = theme2("boxShadow", params)) && {
      ":global": {
        "*": {
          "--tw-shadow": "0 0 transparent"
        }
      },
      "--tw-shadow": _4 == "none" ? "0 0 transparent" : _4,
      boxShadow: [
        _4,
        `var(--tw-ring-offset-shadow,0 0 transparent),var(--tw-ring-shadow,0 0 transparent),var(--tw-shadow)`
      ]
    },
    animate: (params, { theme: theme2, tag }) => {
      if ($3 = theme2("animation", params)) {
        const parts = $3.split(" ");
        if ((_4 = theme2("keyframes", parts[0], __ = {})) !== __) {
          return ($3 = tag(parts[0])) && {
            animation: $3 + " " + join(tail(parts), " "),
            ["@keyframes " + $3]: _4
          };
        }
        return { animation: $3 };
      }
    },
    ring(params, { theme: theme2 }, id) {
      switch (params[0]) {
        case "inset":
          return { "--tw-ring-inset": "inset" };
        case "opacity":
          return opacityProperty(params, theme2, id);
        case "offset":
          return (_4 = theme2("ringOffsetWidth", tail(params), "")) ? {
            "--tw-ring-offset-width": _4
          } : {
            "--tw-ring-offset-color": theme2("ringOffsetColor", tail(params))
          };
      }
      return (_4 = theme2("ringWidth", params, "")) ? {
        "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
        "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${_4} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
        boxShadow: `var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 transparent)`,
        ":global": {
          "*": {
            "--tw-ring-inset": "var(--tw-empty,/*!*/ /*!*/)",
            "--tw-ring-offset-width": theme2("ringOffsetWidth", "", "0px"),
            "--tw-ring-offset-color": theme2("ringOffsetColor", "", "#fff"),
            "--tw-ring-color": asRGBA(theme2("ringColor", "", "#93c5fd"), "ring-opacity", theme2("ringOpacity", "", "0.5")),
            "--tw-ring-offset-shadow": "0 0 transparent",
            "--tw-ring-shadow": "0 0 transparent"
          }
        }
      } : {
        "--tw-ring-opacity": "1",
        "--tw-ring-color": asRGBA(theme2("ringColor", params), "ring-opacity")
      };
    },
    object: (params, context, id) => includes(["contain", "cover", "fill", "none", "scale-down"], join(params)) ? { objectFit: join(params) } : themePropertyFallback("objectPosition", " ")(params, context, id),
    list: (params, context, id) => join(params) == "item" ? display(params, context, id) : includes(["inside", "outside"], join(params)) ? { listStylePosition: params[0] } : themePropertyFallback("listStyleType")(params, context, id),
    rounded: (params, context, id) => corners(context.theme("borderRadius", tail(params), ""), params[0], "border", "radius") || themeProperty("borderRadius")(params, context, id),
    "transition-none": { transitionProperty: "none" },
    transition: (params, { theme: theme2 }) => ({
      transitionProperty: theme2("transitionProperty", params),
      transitionTimingFunction: theme2("transitionTimingFunction", ""),
      transitionDuration: theme2("transitionDuration", "")
    }),
    container: (params, { theme: theme2 }) => {
      const { screens = theme2("screens"), center, padding: padding2 } = theme2("container");
      const paddingFor = (screen) => (_4 = padding2 && (typeof padding2 == "string" ? padding2 : padding2[screen] || padding2.DEFAULT)) ? {
        paddingRight: _4,
        paddingLeft: _4
      } : {};
      return Object.keys(screens).reduce((rules2, screen) => {
        if (($3 = screens[screen]) && typeof $3 == "string") {
          rules2[buildMediaQuery($3)] = {
            "&": {
              "max-width": $3,
              ...paddingFor(screen)
            }
          };
        }
        return rules2;
      }, {
        width: "100%",
        ...center ? { marginRight: "auto", marginLeft: "auto" } : {},
        ...paddingFor("xs")
      });
    },
    filter,
    blur: filter,
    brightness: filter,
    contrast: filter,
    grayscale: filter,
    "hue-rotate": filter,
    invert: filter,
    saturate: filter,
    sepia: filter,
    "drop-shadow": filter,
    backdrop: filter
  };
  var createPreflight = (theme2) => ({
    ":root": { tabSize: 4 },
    "body,blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre,fieldset,ol,ul": { margin: "0" },
    button: { backgroundColor: "transparent", backgroundImage: "none" },
    'button,[type="button"],[type="reset"],[type="submit"]': { WebkitAppearance: "button" },
    "button:focus": { outline: ["1px dotted", "5px auto -webkit-focus-ring-color"] },
    "fieldset,ol,ul,legend": { padding: "0" },
    "ol,ul": { listStyle: "none" },
    html: {
      lineHeight: "1.5",
      WebkitTextSizeAdjust: "100%",
      fontFamily: theme2("fontFamily.sans", "ui-sans-serif,system-ui,sans-serif")
    },
    body: { fontFamily: "inherit", lineHeight: "inherit" },
    "*,::before,::after": {
      boxSizing: "border-box",
      border: `0 solid ${theme2("borderColor.DEFAULT", "currentColor")}`
    },
    hr: { height: "0", color: "inherit", borderTopWidth: "1px" },
    img: { borderStyle: "solid" },
    textarea: { resize: "vertical" },
    "input::placeholder,textarea::placeholder": {
      opacity: "1",
      color: theme2("placeholderColor.DEFAULT", theme2("colors.gray.400", "#a1a1aa"))
    },
    'button,[role="button"]': { cursor: "pointer" },
    table: { textIndent: "0", borderColor: "inherit", borderCollapse: "collapse" },
    "h1,h2,h3,h4,h5,h6": { fontSize: "inherit", fontWeight: "inherit" },
    a: { color: "inherit", textDecoration: "inherit" },
    "button,input,optgroup,select,textarea": {
      fontFamily: "inherit",
      fontSize: "100%",
      margin: "0",
      padding: "0",
      lineHeight: "inherit",
      color: "inherit"
    },
    "button,select": { textTransform: "none" },
    "::-moz-focus-inner": { borderStyle: "none", padding: "0" },
    ":-moz-focusring": { outline: "1px dotted ButtonText" },
    ":-moz-ui-invalid": { boxShadow: "none" },
    progress: { verticalAlign: "baseline" },
    "::-webkit-inner-spin-button,::-webkit-outer-spin-button": { height: "auto" },
    '[type="search"]': { WebkitAppearance: "textfield", outlineOffset: "-2px" },
    "::-webkit-search-decoration": { WebkitAppearance: "none" },
    "::-webkit-file-upload-button": { WebkitAppearance: "button", font: "inherit" },
    summary: { display: "list-item" },
    "abbr[title]": { textDecoration: "underline dotted" },
    "b,strong": { fontWeight: "bolder" },
    "pre,code,kbd,samp": {
      fontFamily: theme2("fontFamily", "mono", "ui-monospace,monospace"),
      fontSize: "1em"
    },
    "sub,sup": { fontSize: "75%", lineHeight: "0", position: "relative", verticalAlign: "baseline" },
    sub: { bottom: "-0.25em" },
    sup: { top: "-0.5em" },
    "img,svg,video,canvas,audio,iframe,embed,object": { display: "block", verticalAlign: "middle" },
    "img,video": { maxWidth: "100%", height: "auto" }
  });
  var coreVariants = {
    dark: "@media (prefers-color-scheme:dark)",
    sticky: "@supports ((position: -webkit-sticky) or (position:sticky))",
    "motion-reduce": "@media (prefers-reduced-motion:reduce)",
    "motion-safe": "@media (prefers-reduced-motion:no-preference)",
    first: "&:first-child",
    last: "&:last-child",
    even: "&:nth-child(2n)",
    odd: "&:nth-child(odd)",
    children: "&>*",
    siblings: "&~*",
    sibling: "&+*",
    override: "&&"
  };
  var STYLE_ELEMENT_ID = "__twind";
  var getStyleElement = (nonce) => {
    let element = self[STYLE_ELEMENT_ID];
    if (!element) {
      element = document.head.appendChild(document.createElement("style"));
      element.id = STYLE_ELEMENT_ID;
      nonce && (element.nonce = nonce);
      element.appendChild(document.createTextNode(""));
    }
    return element;
  };
  var cssomSheet = ({
    nonce,
    target = getStyleElement(nonce).sheet
  } = {}) => {
    const offset = target.cssRules.length;
    return {
      target,
      insert: (rule, index) => target.insertRule(rule, offset + index)
    };
  };
  var voidSheet = () => ({
    target: null,
    insert: noop
  });
  var mode = (report) => ({
    unknown(section, key = [], optional, context) {
      if (!optional) {
        this.report({ id: "UNKNOWN_THEME_VALUE", key: section + "." + join(key) }, context);
      }
    },
    report({ id, ...info }) {
      return report(`[${id}] ${JSON.stringify(info)}`);
    }
  });
  var warn = /* @__PURE__ */ mode((message) => console.warn(message));
  var strict = /* @__PURE__ */ mode((message) => {
    throw new Error(message);
  });
  var silent = /* @__PURE__ */ mode(noop);
  var noprefix = (property2, value, important) => `${property2}:${value}${important ? " !important" : ""}`;
  var autoprefix = (property2, value, important) => {
    let cssText = "";
    const propertyAlias = r7(property2);
    if (propertyAlias)
      cssText += `${noprefix(propertyAlias, value, important)};`;
    let flags = a5(property2);
    if (flags & 1)
      cssText += `-webkit-${noprefix(property2, value, important)};`;
    if (flags & 2)
      cssText += `-moz-${noprefix(property2, value, important)};`;
    if (flags & 4)
      cssText += `-ms-${noprefix(property2, value, important)};`;
    flags = t7(property2, value);
    if (flags & 1)
      cssText += `${noprefix(property2, `-webkit-${value}`, important)};`;
    if (flags & 2)
      cssText += `${noprefix(property2, `-moz-${value}`, important)};`;
    if (flags & 4)
      cssText += `${noprefix(property2, `-ms-${value}`, important)};`;
    cssText += noprefix(property2, value, important);
    return cssText;
  };
  var ratios = (start, end) => {
    const result = {};
    do {
      for (let dividend = 1; dividend < start; dividend++) {
        result[`${dividend}/${start}`] = Number((dividend / start * 100).toFixed(6)) + "%";
      }
    } while (++start <= end);
    return result;
  };
  var exponential = (stop, unit, start = 0) => {
    const result = {};
    for (; start <= stop; start = start * 2 || 1) {
      result[start] = start + unit;
    }
    return result;
  };
  var linear = (stop, unit = "", divideBy = 1, start = 0, step2 = 1, result = {}) => {
    for (; start <= stop; start += step2) {
      result[start] = start / divideBy + unit;
    }
    return result;
  };
  var alias2 = (section) => (theme2) => theme2(section);
  var defaultTheme = {
    screens: {
      sm: "640px",
      md: "768px",
      lg: "1024px",
      xl: "1280px",
      "2xl": "1536px"
    },
    colors: {
      transparent: "transparent",
      current: "currentColor",
      black: "#000",
      white: "#fff",
      gray: {
        50: "#f9fafb",
        100: "#f3f4f6",
        200: "#e5e7eb",
        300: "#d1d5db",
        400: "#9ca3af",
        500: "#6b7280",
        600: "#4b5563",
        700: "#374151",
        800: "#1f2937",
        900: "#111827"
      },
      red: {
        50: "#fef2f2",
        100: "#fee2e2",
        200: "#fecaca",
        300: "#fca5a5",
        400: "#f87171",
        500: "#ef4444",
        600: "#dc2626",
        700: "#b91c1c",
        800: "#991b1b",
        900: "#7f1d1d"
      },
      yellow: {
        50: "#fffbeb",
        100: "#fef3c7",
        200: "#fde68a",
        300: "#fcd34d",
        400: "#fbbf24",
        500: "#f59e0b",
        600: "#d97706",
        700: "#b45309",
        800: "#92400e",
        900: "#78350f"
      },
      green: {
        50: "#ecfdf5",
        100: "#d1fae5",
        200: "#a7f3d0",
        300: "#6ee7b7",
        400: "#34d399",
        500: "#10b981",
        600: "#059669",
        700: "#047857",
        800: "#065f46",
        900: "#064e3b"
      },
      blue: {
        50: "#eff6ff",
        100: "#dbeafe",
        200: "#bfdbfe",
        300: "#93c5fd",
        400: "#60a5fa",
        500: "#3b82f6",
        600: "#2563eb",
        700: "#1d4ed8",
        800: "#1e40af",
        900: "#1e3a8a"
      },
      indigo: {
        50: "#eef2ff",
        100: "#e0e7ff",
        200: "#c7d2fe",
        300: "#a5b4fc",
        400: "#818cf8",
        500: "#6366f1",
        600: "#4f46e5",
        700: "#4338ca",
        800: "#3730a3",
        900: "#312e81"
      },
      purple: {
        50: "#f5f3ff",
        100: "#ede9fe",
        200: "#ddd6fe",
        300: "#c4b5fd",
        400: "#a78bfa",
        500: "#8b5cf6",
        600: "#7c3aed",
        700: "#6d28d9",
        800: "#5b21b6",
        900: "#4c1d95"
      },
      pink: {
        50: "#fdf2f8",
        100: "#fce7f3",
        200: "#fbcfe8",
        300: "#f9a8d4",
        400: "#f472b6",
        500: "#ec4899",
        600: "#db2777",
        700: "#be185d",
        800: "#9d174d",
        900: "#831843"
      }
    },
    spacing: {
      px: "1px",
      0: "0px",
      .../* @__PURE__ */ linear(4, "rem", 4, 0.5, 0.5),
      .../* @__PURE__ */ linear(12, "rem", 4, 5),
      14: "3.5rem",
      .../* @__PURE__ */ linear(64, "rem", 4, 16, 4),
      72: "18rem",
      80: "20rem",
      96: "24rem"
    },
    durations: {
      75: "75ms",
      100: "100ms",
      150: "150ms",
      200: "200ms",
      300: "300ms",
      500: "500ms",
      700: "700ms",
      1e3: "1000ms"
    },
    animation: {
      none: "none",
      spin: "spin 1s linear infinite",
      ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
      pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
      bounce: "bounce 1s infinite"
    },
    backdropBlur: /* @__PURE__ */ alias2("blur"),
    backdropBrightness: /* @__PURE__ */ alias2("brightness"),
    backdropContrast: /* @__PURE__ */ alias2("contrast"),
    backdropGrayscale: /* @__PURE__ */ alias2("grayscale"),
    backdropHueRotate: /* @__PURE__ */ alias2("hueRotate"),
    backdropInvert: /* @__PURE__ */ alias2("invert"),
    backdropOpacity: /* @__PURE__ */ alias2("opacity"),
    backdropSaturate: /* @__PURE__ */ alias2("saturate"),
    backdropSepia: /* @__PURE__ */ alias2("sepia"),
    backgroundColor: /* @__PURE__ */ alias2("colors"),
    backgroundImage: {
      none: "none"
    },
    backgroundOpacity: /* @__PURE__ */ alias2("opacity"),
    backgroundSize: {
      auto: "auto",
      cover: "cover",
      contain: "contain"
    },
    blur: {
      0: "0",
      sm: "4px",
      DEFAULT: "8px",
      md: "12px",
      lg: "16px",
      xl: "24px",
      "2xl": "40px",
      "3xl": "64px"
    },
    brightness: {
      .../* @__PURE__ */ linear(200, "", 100, 0, 50),
      .../* @__PURE__ */ linear(110, "", 100, 90, 5),
      75: "0.75",
      125: "1.25"
    },
    borderColor: (theme2) => ({
      ...theme2("colors"),
      DEFAULT: theme2("colors.gray.200", "currentColor")
    }),
    borderOpacity: /* @__PURE__ */ alias2("opacity"),
    borderRadius: {
      none: "0px",
      sm: "0.125rem",
      DEFAULT: "0.25rem",
      md: "0.375rem",
      lg: "0.5rem",
      xl: "0.75rem",
      "2xl": "1rem",
      "3xl": "1.5rem",
      "1/2": "50%",
      full: "9999px"
    },
    borderWidth: {
      DEFAULT: "1px",
      .../* @__PURE__ */ exponential(8, "px")
    },
    boxShadow: {
      sm: "0 1px 2px 0 rgba(0,0,0,0.05)",
      DEFAULT: "0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06)",
      md: "0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06)",
      lg: "0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05)",
      xl: "0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04)",
      "2xl": "0 25px 50px -12px rgba(0,0,0,0.25)",
      inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
      none: "none"
    },
    contrast: {
      .../* @__PURE__ */ linear(200, "", 100, 0, 50),
      75: "0.75",
      125: "1.25"
    },
    divideColor: /* @__PURE__ */ alias2("borderColor"),
    divideOpacity: /* @__PURE__ */ alias2("borderOpacity"),
    divideWidth: /* @__PURE__ */ alias2("borderWidth"),
    dropShadow: {
      sm: "0 1px 1px rgba(0,0,0,0.05)",
      DEFAULT: ["0 1px 2px rgba(0,0,0,0.1)", "0 1px 1px rgba(0,0,0,0.06)"],
      md: ["0 4px 3px rgba(0,0,0,0.07)", "0 2px 2px rgba(0,0,0,0.06)"],
      lg: ["0 10px 8px rgba(0,0,0,0.04)", "0 4px 3px rgba(0,0,0,0.1)"],
      xl: ["0 20px 13px rgba(0,0,0,0.03)", "0 8px 5px rgba(0,0,0,0.08)"],
      "2xl": "0 25px 25px rgba(0,0,0,0.15)",
      none: "0 0 #0000"
    },
    fill: { current: "currentColor" },
    grayscale: {
      0: "0",
      DEFAULT: "100%"
    },
    hueRotate: {
      0: "0deg",
      15: "15deg",
      30: "30deg",
      60: "60deg",
      90: "90deg",
      180: "180deg"
    },
    invert: {
      0: "0",
      DEFAULT: "100%"
    },
    flex: {
      1: "1 1 0%",
      auto: "1 1 auto",
      initial: "0 1 auto",
      none: "none"
    },
    fontFamily: {
      sans: 'ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"'.split(","),
      serif: 'ui-serif,Georgia,Cambria,"Times New Roman",Times,serif'.split(","),
      mono: 'ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'.split(",")
    },
    fontSize: {
      xs: ["0.75rem", "1rem"],
      sm: ["0.875rem", "1.25rem"],
      base: ["1rem", "1.5rem"],
      lg: ["1.125rem", "1.75rem"],
      xl: ["1.25rem", "1.75rem"],
      "2xl": ["1.5rem", "2rem"],
      "3xl": ["1.875rem", "2.25rem"],
      "4xl": ["2.25rem", "2.5rem"],
      "5xl": ["3rem", "1"],
      "6xl": ["3.75rem", "1"],
      "7xl": ["4.5rem", "1"],
      "8xl": ["6rem", "1"],
      "9xl": ["8rem", "1"]
    },
    fontWeight: {
      thin: "100",
      extralight: "200",
      light: "300",
      normal: "400",
      medium: "500",
      semibold: "600",
      bold: "700",
      extrabold: "800",
      black: "900"
    },
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridAutoColumns: {
      min: "min-content",
      max: "max-content",
      fr: "minmax(0,1fr)"
    },
    gridAutoRows: {
      min: "min-content",
      max: "max-content",
      fr: "minmax(0,1fr)"
    },
    gridColumn: {
      auto: "auto",
      "span-full": "1 / -1"
    },
    gridRow: {
      auto: "auto",
      "span-full": "1 / -1"
    },
    gap: /* @__PURE__ */ alias2("spacing"),
    gradientColorStops: /* @__PURE__ */ alias2("colors"),
    height: (theme2) => ({
      auto: "auto",
      ...theme2("spacing"),
      ...ratios(2, 6),
      full: "100%",
      screen: "100vh"
    }),
    inset: (theme2) => ({
      auto: "auto",
      ...theme2("spacing"),
      ...ratios(2, 4),
      full: "100%"
    }),
    keyframes: {
      spin: {
        from: {
          transform: "rotate(0deg)"
        },
        to: {
          transform: "rotate(360deg)"
        }
      },
      ping: {
        "0%": {
          transform: "scale(1)",
          opacity: "1"
        },
        "75%,100%": {
          transform: "scale(2)",
          opacity: "0"
        }
      },
      pulse: {
        "0%,100%": {
          opacity: "1"
        },
        "50%": {
          opacity: ".5"
        }
      },
      bounce: {
        "0%, 100%": {
          transform: "translateY(-25%)",
          animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
        },
        "50%": {
          transform: "none",
          animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
        }
      }
    },
    letterSpacing: {
      tighter: "-0.05em",
      tight: "-0.025em",
      normal: "0em",
      wide: "0.025em",
      wider: "0.05em",
      widest: "0.1em"
    },
    lineHeight: {
      none: "1",
      tight: "1.25",
      snug: "1.375",
      normal: "1.5",
      relaxed: "1.625",
      loose: "2",
      .../* @__PURE__ */ linear(10, "rem", 4, 3)
    },
    margin: (theme2) => ({
      auto: "auto",
      ...theme2("spacing")
    }),
    maxHeight: (theme2) => ({
      ...theme2("spacing"),
      full: "100%",
      screen: "100vh"
    }),
    maxWidth: (theme2, { breakpoints }) => ({
      none: "none",
      0: "0rem",
      xs: "20rem",
      sm: "24rem",
      md: "28rem",
      lg: "32rem",
      xl: "36rem",
      "2xl": "42rem",
      "3xl": "48rem",
      "4xl": "56rem",
      "5xl": "64rem",
      "6xl": "72rem",
      "7xl": "80rem",
      full: "100%",
      min: "min-content",
      max: "max-content",
      prose: "65ch",
      ...breakpoints(theme2("screens"))
    }),
    minHeight: {
      0: "0px",
      full: "100%",
      screen: "100vh"
    },
    minWidth: {
      0: "0px",
      full: "100%",
      min: "min-content",
      max: "max-content"
    },
    opacity: {
      .../* @__PURE__ */ linear(100, "", 100, 0, 10),
      5: "0.05",
      25: "0.25",
      75: "0.75",
      95: "0.95"
    },
    order: {
      first: "-9999",
      last: "9999",
      none: "0",
      .../* @__PURE__ */ linear(12, "", 1, 1)
    },
    outline: {
      none: ["2px solid transparent", "2px"],
      white: ["2px dotted white", "2px"],
      black: ["2px dotted black", "2px"]
    },
    padding: /* @__PURE__ */ alias2("spacing"),
    placeholderColor: /* @__PURE__ */ alias2("colors"),
    placeholderOpacity: /* @__PURE__ */ alias2("opacity"),
    ringColor: (theme2) => ({
      DEFAULT: theme2("colors.blue.500", "#3b82f6"),
      ...theme2("colors")
    }),
    ringOffsetColor: /* @__PURE__ */ alias2("colors"),
    ringOffsetWidth: /* @__PURE__ */ exponential(8, "px"),
    ringOpacity: (theme2) => ({
      DEFAULT: "0.5",
      ...theme2("opacity")
    }),
    ringWidth: {
      DEFAULT: "3px",
      .../* @__PURE__ */ exponential(8, "px")
    },
    rotate: {
      .../* @__PURE__ */ exponential(2, "deg"),
      .../* @__PURE__ */ exponential(12, "deg", 3),
      .../* @__PURE__ */ exponential(180, "deg", 45)
    },
    saturate: /* @__PURE__ */ linear(200, "", 100, 0, 50),
    scale: {
      .../* @__PURE__ */ linear(150, "", 100, 0, 50),
      .../* @__PURE__ */ linear(110, "", 100, 90, 5),
      75: "0.75",
      125: "1.25"
    },
    sepia: {
      0: "0",
      DEFAULT: "100%"
    },
    skew: {
      .../* @__PURE__ */ exponential(2, "deg"),
      .../* @__PURE__ */ exponential(12, "deg", 3)
    },
    space: /* @__PURE__ */ alias2("spacing"),
    stroke: {
      current: "currentColor"
    },
    strokeWidth: /* @__PURE__ */ linear(2),
    textColor: /* @__PURE__ */ alias2("colors"),
    textOpacity: /* @__PURE__ */ alias2("opacity"),
    transitionDuration: (theme2) => ({
      DEFAULT: "150ms",
      ...theme2("durations")
    }),
    transitionDelay: /* @__PURE__ */ alias2("durations"),
    transitionProperty: {
      none: "none",
      all: "all",
      DEFAULT: "background-color,border-color,color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter",
      colors: "background-color,border-color,color,fill,stroke",
      opacity: "opacity",
      shadow: "box-shadow",
      transform: "transform"
    },
    transitionTimingFunction: {
      DEFAULT: "cubic-bezier(0.4,0,0.2,1)",
      linear: "linear",
      in: "cubic-bezier(0.4,0,1,1)",
      out: "cubic-bezier(0,0,0.2,1)",
      "in-out": "cubic-bezier(0.4,0,0.2,1)"
    },
    translate: (theme2) => ({
      ...theme2("spacing"),
      ...ratios(2, 4),
      full: "100%"
    }),
    width: (theme2) => ({
      auto: "auto",
      ...theme2("spacing"),
      ...ratios(2, 6),
      ...ratios(12, 12),
      screen: "100vw",
      full: "100%",
      min: "min-content",
      max: "max-content"
    }),
    zIndex: {
      auto: "auto",
      .../* @__PURE__ */ linear(50, "", 1, 0, 10)
    }
  };
  var flattenColorPalette = (colors, target = {}, prefix = []) => {
    Object.keys(colors).forEach((property2) => {
      const value = colors[property2];
      if (property2 == "DEFAULT") {
        target[join(prefix)] = value;
        target[join(prefix, ".")] = value;
      }
      const key = [...prefix, property2];
      target[join(key)] = value;
      target[join(key, ".")] = value;
      if (value && typeof value == "object") {
        flattenColorPalette(value, target, key);
      }
    }, target);
    return target;
  };
  var resolveContext = {
    negative: () => ({}),
    breakpoints: (screens) => Object.keys(screens).filter((key) => typeof screens[key] == "string").reduce((target, key) => {
      target["screen-" + key] = screens[key];
      return target;
    }, {})
  };
  var handleArbitraryValues = (section, key) => (key = key[0] == "[" && key.slice(-1) == "]" && key.slice(1, -1)) && includes(section, "olor") == /^(#|(hsl|rgb)a?\(|[a-z]+$)/.test(key) && (includes(key, "calc(") ? key.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ") : key);
  var makeThemeResolver = (config) => {
    const cache = /* @__PURE__ */ new Map();
    const theme2 = { ...defaultTheme, ...config };
    const deref = (theme3, section) => {
      const base = theme3 && theme3[section];
      const value = typeof base == "function" ? base(resolve, resolveContext) : base;
      return value && section == "colors" ? flattenColorPalette(value) : value;
    };
    const resolve = (section, key, defaultValue) => {
      const keypath = section.split(".");
      section = keypath[0];
      if (keypath.length > 1) {
        defaultValue = key;
        key = join(tail(keypath), ".");
      }
      let base = cache.get(section);
      if (!base) {
        cache.set(section, base = { ...deref(theme2, section) });
        Object.assign(base, deref(theme2.extend, section));
      }
      if (key != null) {
        key = (Array.isArray(key) ? join(key) : key) || "DEFAULT";
        const value = handleArbitraryValues(section, key) || base[key];
        return value == null ? defaultValue : Array.isArray(value) && !includes(["fontSize", "outline", "dropShadow"], section) ? join(value, ",") : value;
      }
      return base;
    };
    return resolve;
  };
  var translate = (plugins, context) => (rule, isTranslating) => {
    if (typeof rule.d == "function") {
      return rule.d(context);
    }
    const parameters = rule.d.split(/-(?![^[]*])/g);
    if (!isTranslating && parameters[0] == "tw" && rule.$ == rule.d) {
      return rule.$;
    }
    for (let index = parameters.length; index; index--) {
      const id = join(parameters.slice(0, index));
      if (Object.prototype.hasOwnProperty.call(plugins, id)) {
        const plugin = plugins[id];
        return typeof plugin == "function" ? plugin(tail(parameters, index), context, id) : typeof plugin == "string" ? context[isTranslating ? "css" : "tw"](plugin) : plugin;
      }
    }
  };
  var _22;
  var GROUP_RE = /^:(group(?:(?!-focus).+?)*)-(.+)$/;
  var NOT_PREFIX_RE = /^(:not)-(.+)/;
  var prepareVariantSelector = (variant) => variant[1] == "[" ? tail(variant) : variant;
  var decorate = (darkMode, variants, { theme: theme2, tag }) => {
    const applyVariant = (translation, variant) => {
      if (_22 = theme2("screens", tail(variant), "")) {
        return { [buildMediaQuery(_22)]: translation };
      }
      if (variant == ":dark" && darkMode == "class") {
        return { ".dark &": translation };
      }
      if (_22 = GROUP_RE.exec(variant)) {
        return { [`.${escape(tag(_22[1]))}:${_22[2]} &`]: translation };
      }
      return {
        [variants[tail(variant)] || "&" + variant.replace(NOT_PREFIX_RE, (_42, not2, variant2) => not2 + "(" + prepareVariantSelector(":" + variant2) + ")")]: translation
      };
    };
    return (translation, rule) => rule.v.reduceRight(applyVariant, translation);
  };
  var _32;
  var responsivePrecedence = (css) => (((_32 = /(?:^|min-width: *)(\d+(?:.\d+)?)(p)?/.exec(css)) ? +_32[1] / (_32[2] ? 15 : 1) / 10 : 0) & 31) << 22;
  var seperatorPrecedence = (string) => {
    _32 = 0;
    for (let index = string.length; index--; ) {
      _32 += includes("-:,", string[index]);
    }
    return _32;
  };
  var atRulePresedence = (css) => (seperatorPrecedence(css) & 15) << 18;
  var PRECEDENCES_BY_PSEUDO_CLASS = [
    "rst",
    "st",
    "en",
    "d",
    "nk",
    "sited",
    "pty",
    "ecked",
    "cus-w",
    "ver",
    "cus",
    "cus-v",
    "tive",
    "sable",
    "ad-on",
    "tiona",
    "quire"
  ];
  var pseudoPrecedence = (pseudoClass) => 1 << (~(_32 = PRECEDENCES_BY_PSEUDO_CLASS.indexOf(pseudoClass.replace(GROUP_RE, ":$2").slice(3, 8))) ? _32 : 17);
  var makeVariantPresedenceCalculator = (theme2, variants) => (presedence, variant) => presedence | ((_32 = theme2("screens", tail(variant), "")) ? 1 << 27 | responsivePrecedence(buildMediaQuery(_32)) : variant == ":dark" ? 1 << 30 : (_32 = variants[variant] || variant.replace(NOT_PREFIX_RE, ":$2"))[0] == "@" ? atRulePresedence(_32) : pseudoPrecedence(variant));
  var declarationPropertyPrecedence = (property2) => property2[0] == "-" ? 0 : seperatorPrecedence(property2) + ((_32 = /^(?:(border-(?!w|c|sty)|[tlbr].{2,4}m?$|c.{7}$)|([fl].{5}l|g.{8}$|pl))/.exec(property2)) ? +!!_32[1] || -!!_32[2] : 0) + 1;
  var stringifyBlock = (body, selector) => selector + "{" + body + "}";
  var serialize = (prefix, variants, context) => {
    const { theme: theme2, tag } = context;
    const tagVar = (_42, property2) => "--" + tag(property2);
    const tagVars = (value) => `${value}`.replace(/--(tw-[\w-]+)\b/g, tagVar);
    const stringifyDeclaration = (property2, value, important) => {
      property2 = tagVars(property2);
      return Array.isArray(value) ? join(value.filter(Boolean).map((value2) => prefix(property2, tagVars(value2), important)), ";") : prefix(property2, tagVars(value), important);
    };
    let rules2;
    const stringify2 = (atRules, selector, presedence, css, important) => {
      if (Array.isArray(css)) {
        css.forEach((css2) => css2 && stringify2(atRules, selector, presedence, css2, important));
        return;
      }
      let declarations = "";
      let maxPropertyPresedence = 0;
      let numberOfDeclarations = 0;
      if (css["@apply"]) {
        css = merge(evalThunk(apply(css["@apply"]), context), { ...css, "@apply": void 0 }, context);
      }
      Object.keys(css).forEach((key) => {
        const value = evalThunk(css[key], context);
        if (isCSSProperty(key, value)) {
          if (value !== "" && key.length > 1) {
            const property2 = hyphenate(key);
            numberOfDeclarations += 1;
            maxPropertyPresedence = Math.max(maxPropertyPresedence, declarationPropertyPrecedence(property2));
            declarations = (declarations && declarations + ";") + stringifyDeclaration(property2, value, important);
          }
        } else if (value) {
          if (key == ":global") {
            key = "@global";
          }
          if (key[0] == "@") {
            if (key[1] == "g") {
              stringify2([], "", 0, value, important);
            } else if (key[1] == "f") {
              stringify2([], key, 0, value, important);
            } else if (key[1] == "k") {
              const currentSize = rules2.length;
              stringify2([], "", 0, value, important);
              const waypoints = rules2.splice(currentSize, rules2.length - currentSize);
              rules2.push({
                r: stringifyBlock(join(waypoints.map((p4) => p4.r), ""), key),
                p: waypoints.reduce((sum, p4) => sum + p4.p, 0)
              });
            } else if (key[1] == "i") {
              ;
              (Array.isArray(value) ? value : [value]).forEach((value2) => value2 && rules2.push({ p: 0, r: `${key} ${value2};` }));
            } else {
              if (key[2] == "c") {
                key = buildMediaQuery(context.theme("screens", tail(key, 8).trim()));
              }
              stringify2([...atRules, key], selector, presedence | responsivePrecedence(key) | atRulePresedence(key), value, important);
            }
          } else {
            stringify2(atRules, selector ? selector.replace(/ *((?:\(.+?\)|\[.+?\]|[^,])+) *(,|$)/g, (_42, selectorPart, comma) => key.replace(/ *((?:\(.+?\)|\[.+?\]|[^,])+) *(,|$)/g, (_5, keyPart, comma2) => (includes(keyPart, "&") ? keyPart.replace(/&/g, selectorPart) : (selectorPart && selectorPart + " ") + keyPart) + comma2) + comma) : key, presedence, value, important);
          }
        }
      });
      if (numberOfDeclarations) {
        rules2.push({
          r: atRules.reduceRight(stringifyBlock, stringifyBlock(declarations, selector)),
          p: presedence * (1 << 8) + ((Math.max(0, 15 - numberOfDeclarations) & 15) << 4 | (maxPropertyPresedence || 15) & 15)
        });
      }
    };
    const variantPresedence = makeVariantPresedenceCalculator(theme2, variants);
    return (css, className, rule, layer = 0) => {
      layer <<= 28;
      rules2 = [];
      stringify2([], className ? "." + escape(className) : "", rule ? rule.v.reduceRight(variantPresedence, layer) : layer, css, rule && rule.i);
      return rules2;
    };
  };
  var inject = (sheet5, mode2, init2, context) => {
    let sortedPrecedences;
    init2((value = []) => sortedPrecedences = value);
    let insertedRules;
    init2((value = /* @__PURE__ */ new Set()) => insertedRules = value);
    return ({ r: css, p: presedence }) => {
      if (!insertedRules.has(css)) {
        insertedRules.add(css);
        const index = sortedInsertionIndex(sortedPrecedences, presedence);
        try {
          sheet5.insert(css, index);
          sortedPrecedences.splice(index, 0, presedence);
        } catch (error) {
          if (!/:-[mwo]/.test(css)) {
            mode2.report({ id: "INJECT_CSS_ERROR", css, error }, context);
          }
        }
      }
    };
  };
  var sanitize = (value, defaultValue, disabled, enabled = defaultValue) => value === false ? disabled : value === true ? enabled : value || defaultValue;
  var loadMode = (mode2) => (typeof mode2 == "string" ? { t: strict, a: warn, i: silent }[mode2[1]] : mode2) || warn;
  var COMPONENT_PROPS = { _: { value: "", writable: true } };
  var configure = (config = {}) => {
    const theme2 = makeThemeResolver(config.theme);
    const mode2 = loadMode(config.mode);
    const hash = sanitize(config.hash, false, false, cyrb32);
    const important = config.important;
    let activeRule = { v: [] };
    let translateDepth = 0;
    const lastTranslations = [];
    const context = {
      tw: (...tokens) => process2(tokens),
      theme: (section, key, defaultValue) => {
        var _a;
        const value = (_a = theme2(section, key, defaultValue)) != null ? _a : mode2.unknown(section, key == null || Array.isArray(key) ? key : key.split("."), defaultValue != null, context);
        return activeRule.n && value && includes("rg", (typeof value)[5]) ? `calc(${value} * -1)` : value;
      },
      tag: (value) => hash ? hash(value) : value,
      css: (rules2) => {
        translateDepth++;
        const lastTranslationsIndex = lastTranslations.length;
        try {
          ;
          (typeof rules2 == "string" ? parse([rules2]) : rules2).forEach(convert2);
          const css = Object.create(null, COMPONENT_PROPS);
          for (let index = lastTranslationsIndex; index < lastTranslations.length; index++) {
            const translation = lastTranslations[index];
            if (translation) {
              switch (typeof translation) {
                case "object":
                  merge(css, translation, context);
                  break;
                case "string":
                  css._ += (css._ && " ") + translation;
              }
            }
          }
          return css;
        } finally {
          lastTranslations.length = lastTranslationsIndex;
          translateDepth--;
        }
      }
    };
    const translate2 = translate({ ...corePlugins, ...config.plugins }, context);
    const doTranslate = (rule) => {
      const parentRule = activeRule;
      activeRule = rule;
      try {
        return evalThunk(translate2(rule), context);
      } finally {
        activeRule = parentRule;
      }
    };
    const variants = { ...coreVariants, ...config.variants };
    const decorate2 = decorate(config.darkMode || "media", variants, context);
    const serialize2 = serialize(sanitize(config.prefix, autoprefix, noprefix), variants, context);
    const sheet5 = config.sheet || (typeof window == "undefined" ? voidSheet() : cssomSheet(config));
    const { init: init2 = (callback) => callback() } = sheet5;
    const inject2 = inject(sheet5, mode2, init2, context);
    let idToClassName;
    init2((value = /* @__PURE__ */ new Map()) => idToClassName = value);
    const inlineDirectiveName = /* @__PURE__ */ new WeakMap();
    const evaluateFunctions = (key, value) => key == "_" ? void 0 : typeof value == "function" ? JSON.stringify(evalThunk(value, context), evaluateFunctions) : value;
    const convert2 = (rule) => {
      if (!translateDepth && activeRule.v.length) {
        rule = { ...rule, v: [...activeRule.v, ...rule.v], $: "" };
      }
      if (!rule.$) {
        rule.$ = stringifyRule(rule, inlineDirectiveName.get(rule.d));
      }
      let className = translateDepth ? null : idToClassName.get(rule.$);
      if (className == null) {
        let translation = doTranslate(rule);
        if (!rule.$) {
          rule.$ = cyrb32(JSON.stringify(translation, evaluateFunctions));
          inlineDirectiveName.set(rule.d, rule.$);
          rule.$ = stringifyRule(rule, rule.$);
        }
        if (translation && typeof translation == "object") {
          rule.v = rule.v.map(prepareVariantSelector);
          if (important)
            rule.i = important;
          translation = decorate2(translation, rule);
          if (translateDepth) {
            lastTranslations.push(translation);
          } else {
            const layer = typeof rule.d == "function" ? typeof translation._ == "string" ? 1 : 3 : 2;
            className = hash || typeof rule.d == "function" ? (hash || cyrb32)(layer + rule.$) : rule.$;
            serialize2(translation, className, rule, layer).forEach(inject2);
            if (translation._) {
              className += " " + translation._;
            }
          }
        } else {
          if (typeof translation == "string") {
            className = translation;
          } else {
            className = rule.$;
            mode2.report({ id: "UNKNOWN_DIRECTIVE", rule: className }, context);
          }
          if (translateDepth && typeof rule.d !== "function") {
            lastTranslations.push(className);
          }
        }
        if (!translateDepth) {
          idToClassName.set(rule.$, className);
          ensureMaxSize(idToClassName, 3e4);
        }
      }
      return className;
    };
    const process2 = (tokens) => join(parse(tokens).map(convert2).filter(Boolean), " ");
    const preflight = sanitize(config.preflight, identity, false);
    if (preflight) {
      const css = createPreflight(theme2);
      const styles = serialize2(typeof preflight == "function" ? evalThunk(preflight(css, context), context) || css : { ...css, ...preflight });
      init2((injected = (styles.forEach(inject2), true)) => injected);
    }
    return {
      init: () => mode2.report({ id: "LATE_SETUP_CALL" }, context),
      process: process2
    };
  };
  var create = (config) => {
    let process2 = (tokens) => {
      init2();
      return process2(tokens);
    };
    let init2 = (config2) => {
      ;
      ({ process: process2, init: init2 } = configure(config2));
    };
    if (config)
      init2(config);
    let context;
    const fromContext = (key) => () => {
      if (!context) {
        process2([
          (_42) => {
            context = _42;
            return "";
          }
        ]);
      }
      return context[key];
    };
    return {
      tw: Object.defineProperties((...tokens) => process2(tokens), {
        theme: {
          get: fromContext("theme")
        }
      }),
      setup: (config2) => init2(config2)
    };
  };
  var { tw, setup } = /* @__PURE__ */ create();

  // frontend/ts/components/lit/componentSwitcher.ts
  var sheet = cssomSheet({ target: new CSSStyleSheet() });
  var { tw: tw2 } = create({ sheet });
  var ComponentSwitcher = class extends h7 {
    constructor() {
      super(...arguments);
      this.options = [];
      this.selectedOption = "";
      this.components = /* @__PURE__ */ new Map();
    }
    connectedCallback() {
      super.connectedCallback();
      this.updateOptions();
    }
    updateOptions() {
      const children = Array.from(this.children);
      this.components.clear();
      this.options = children.map((child) => {
        const name = child.getAttribute("name") || "";
        this.components.set(name, child);
        return name;
      });
      if (this.options.length > 0 && !this.selectedOption) {
        this.selectedOption = this.options[0];
      }
      this.requestUpdate();
    }
    handleChange(e9) {
      this.selectedOption = e9.target.value;
      this.requestUpdate();
    }
    render() {
      const selectedComponent = this.components.get(this.selectedOption);
      const outerWrapperClasses = tw2`
      bg-gray-100 rounded-xl shadow-lg p-6 my-8 max-w-4xl mx-auto
    `;
      const innerWrapperClasses = tw2`
      bg-white rounded-lg shadow-md p-4
    `;
      const selectClasses = tw2`
      w-full p-3 mb-4 border border-gray-300 rounded-md 
      focus:outline-none focus:ring-2 focus:ring-blue-500
      text-lg font-bold text-gray-700
      appearance-none bg-white
    `;
      const contentClasses = tw2`
      mt-4 max-h-[calc(100vh-250px)] overflow-y-auto pr-2
    `;
      return ke`
      <div class="${outerWrapperClasses}">
        <div class="${tw2`relative`}">
          <select @change=${this.handleChange} class="${selectClasses}">
            ${this.options.map((option) => ke`
              <option value=${option} ?selected=${option === this.selectedOption}>
                ${option.charAt(0).toUpperCase() + option.slice(1).replace(/([A-Z])/g, " $1").trim()}
              </option>
            `)}
          </select>
          <div class="${tw2`pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700`}">
            <svg class="${tw2`fill-current h-4 w-4`}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
              <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
            </svg>
          </div>
        </div>
        <div class="${innerWrapperClasses}">
          <div class="${contentClasses}">
            ${selectedComponent ? selectedComponent.cloneNode(true) : ""}
          </div>
        </div>
      </div>
    `;
    }
  };
  ComponentSwitcher.styles = [sheet.target];
  __decorateClass([
    r6()
  ], ComponentSwitcher.prototype, "options", 2);
  __decorateClass([
    n6({ type: String })
  ], ComponentSwitcher.prototype, "selectedOption", 2);
  __decorateClass([
    r6()
  ], ComponentSwitcher.prototype, "components", 2);
  ComponentSwitcher = __decorateClass([
    t6("component-switcher")
  ], ComponentSwitcher);
  var SwitchableComponent = class extends h7 {
    constructor() {
      super(...arguments);
      this.name = "";
    }
    render() {
      return ke`<slot></slot>`;
    }
  };
  SwitchableComponent.styles = [sheet.target];
  __decorateClass([
    n6({ type: String })
  ], SwitchableComponent.prototype, "name", 2);
  SwitchableComponent = __decorateClass([
    t6("switchable-component")
  ], SwitchableComponent);

  // frontend/node_modules/lit-html/directive.js
  var t8 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
  var e8 = (t9) => (...e9) => ({ _$litDirective$: t9, values: e9 });
  var i8 = class {
    constructor(t9) {
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AT(t9, e9, i9) {
      this.t = t9, this._$AM = e9, this.i = i9;
    }
    _$AS(t9, e9) {
      return this.update(t9, e9);
    }
    update(t9, e9) {
      return this.render(...e9);
    }
  };

  // frontend/node_modules/lit-html/directives/unsafe-html.js
  var le = class extends i8 {
    constructor(i9) {
      if (super(i9), this.it = D, i9.type !== t8.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
    }
    render(t9) {
      if (t9 === D || null == t9) return this._t = void 0, this.it = t9;
      if (t9 === R3) return t9;
      if ("string" != typeof t9) throw Error(this.constructor.directiveName + "() called with a non-string value");
      if (t9 === this.it) return this._t;
      this.it = t9;
      const i9 = [t9];
      return i9.raw = i9, this._t = { _$litType$: this.constructor.resultType, strings: i9, values: [] };
    }
  };
  le.directiveName = "unsafeHTML", le.resultType = 1;
  var ae = e8(le);

  // frontend/node_modules/tslib/tslib.es6.js
  var __assign = function() {
    __assign = Object.assign || function __assign2(t9) {
      for (var s7, i9 = 1, n7 = arguments.length; i9 < n7; i9++) {
        s7 = arguments[i9];
        for (var p4 in s7) if (Object.prototype.hasOwnProperty.call(s7, p4)) t9[p4] = s7[p4];
      }
      return t9;
    };
    return __assign.apply(this, arguments);
  };

  // frontend/node_modules/highlight-ts/es/common.js
  var IDENT_RE = "[a-zA-Z]\\w*";
  var UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
  var NUMBER_RE = "\\b\\d+(\\.\\d+)?";
  var C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
  var BINARY_NUMBER_RE = "\\b(0b[01]+)";
  var RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
  var BACKSLASH_ESCAPE = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  };
  var APOS_STRING_MODE = {
    className: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  var QUOTE_STRING_MODE = {
    className: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  var PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  function COMMENT(begin, end, inherits) {
    if (inherits === void 0) {
      inherits = {};
    }
    var mode2 = __assign({ className: "comment", begin, end, contains: [] }, inherits);
    var contains = mode2.contains;
    if (contains) {
      contains.push(PHRASAL_WORDS_MODE);
      contains.push({
        className: "doctag",
        begin: "(?:TODO|FIXME|NOTE|BUG|XXX):",
        relevance: 0
      });
    }
    return mode2;
  }
  var C_LINE_COMMENT_MODE = COMMENT("//", "$");
  var C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
  var HASH_COMMENT_MODE = COMMENT("#", "$");
  var NUMBER_MODE = {
    className: "number",
    begin: NUMBER_RE,
    relevance: 0
  };
  var C_NUMBER_MODE = {
    className: "number",
    begin: C_NUMBER_RE,
    relevance: 0
  };
  var BINARY_NUMBER_MODE = {
    className: "number",
    begin: BINARY_NUMBER_RE,
    relevance: 0
  };
  var CSS_NUMBER_MODE = {
    className: "number",
    begin: NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  };
  var REGEXP_MODE = {
    className: "regexp",
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      BACKSLASH_ESCAPE,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [BACKSLASH_ESCAPE]
      }
    ]
  };
  var TITLE_MODE = {
    className: "title",
    begin: IDENT_RE,
    relevance: 0
  };
  var UNDERSCORE_TITLE_MODE = {
    className: "title",
    begin: UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  var METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
    relevance: 0
  };

  // frontend/node_modules/highlight-ts/es/compile.js
  function reStr(re) {
    return re && re.source || re;
  }
  var noneRe = { exec: function() {
    return null;
  } };
  function langRe(language, value, global2) {
    return new RegExp(reStr(value), "m" + (language.case_insensitive ? "i" : "") + (global2 ? "g" : ""));
  }
  function compileLanguage(language) {
    var cached_modes = [];
    function getCompiled(sub) {
      for (var _i = 0, cached_modes_1 = cached_modes; _i < cached_modes_1.length; _i++) {
        var _a = cached_modes_1[_i], mode2 = _a[0], compiled_1 = _a[1];
        if (sub === mode2) {
          return compiled_1;
        }
      }
    }
    var cached_variants = [];
    function getVariants(mode2) {
      if (!mode2.variants || !mode2.variants.length) {
        return void 0;
      }
      for (var _i = 0, cached_variants_1 = cached_variants; _i < cached_variants_1.length; _i++) {
        var _a = cached_variants_1[_i], mode_ = _a[0], variants_1 = _a[1];
        if (mode2 === mode_) {
          return variants_1;
        }
      }
      var variants = mode2.variants.map(function(variant) {
        return __assign({}, mode2, { variants: void 0 }, variant);
      });
      cached_variants.push([mode2, variants]);
      return variants;
    }
    ;
    function compileMode(mode2, parent, parent_terminator_end) {
      var already_compiled = getCompiled(mode2);
      if (already_compiled) {
        return already_compiled;
      }
      var compiled2 = {
        lexemesRe: langRe(language, mode2.lexemes || /\w+/, true),
        relevance: mode2.relevance == null ? 1 : mode2.relevance,
        contains: [],
        terminators: noneRe,
        subLanguage: mode2.subLanguage == null ? void 0 : typeof mode2.subLanguage == "string" ? [mode2.subLanguage] : mode2.subLanguage
      };
      cached_modes.push([mode2, compiled2]);
      if (mode2.className) {
        compiled2.className = mode2.className;
      }
      if (mode2.illegal) {
        compiled2.illegalRe = langRe(language, mode2.illegal);
      }
      for (var _i = 0, _a = ["endsParent", "endsWithParent", "skip", "excludeBegin", "excludeEnd", "returnBegin", "returnEnd"]; _i < _a.length; _i++) {
        var key = _a[_i];
        if (mode2[key]) {
          compiled2[key] = true;
        }
      }
      var compiled_terminator_end;
      if (parent) {
        var begin = mode2.beginKeywords ? "\\b(" + mode2.beginKeywords.split(/\s+/).join("|") + ")\\b" : mode2.begin || /\B|\b/;
        mode2.begin = begin;
        compiled2.beginRe = langRe(language, begin);
        var end = !mode2.end && !mode2.endsWithParent ? /\B|\b/ : mode2.end;
        if (end) {
          mode2.end = end;
          compiled2.endRe = langRe(language, end);
        }
        compiled_terminator_end = reStr(end) || "";
        if (mode2.endsWithParent && parent_terminator_end) {
          compiled_terminator_end += (end ? "|" : "") + parent_terminator_end;
        }
      }
      var keywords = mode2.keywords || mode2.beginKeywords;
      if (keywords) {
        var compiled_keywords_1 = {};
        var flatten2 = function(className2, str) {
          if (language.case_insensitive) {
            str = str.toLowerCase();
          }
          var kws = str.split(/\s+/);
          for (var _i2 = 0, kws_1 = kws; _i2 < kws_1.length; _i2++) {
            var kw = kws_1[_i2];
            var _a2 = kw.split(/\|/), key2 = _a2[0], rel = _a2[1];
            compiled_keywords_1[key2] = [className2, rel ? Number(rel) : 1];
          }
        };
        if (typeof keywords == "string") {
          flatten2("keyword", keywords);
        } else {
          for (var className in keywords) {
            flatten2(className, keywords[className]);
          }
        }
        compiled2.keywords = compiled_keywords_1;
      }
      var contains = [];
      if (mode2.contains && mode2.contains.length) {
        for (var _b = 0, _c = mode2.contains; _b < _c.length; _b++) {
          var child = _c[_b];
          var sub = child === "self" ? mode2 : child;
          var variants = getVariants(sub) || sub.endsWithParent && [__assign({}, sub)] || [sub];
          for (var _d = 0, variants_2 = variants; _d < variants_2.length; _d++) {
            var variant = variants_2[_d];
            contains.push(variant);
          }
        }
        compiled2.contains = contains.map(function(child2) {
          return compileMode(child2, compiled2, compiled_terminator_end);
        });
      }
      if (mode2.starts) {
        compiled2.starts = compileMode(mode2.starts, parent, parent_terminator_end);
      }
      var terminators = contains.map(function(child2) {
        return child2.beginKeywords ? "\\.?(" + child2.begin + ")\\.?" : child2.begin;
      }).concat([
        compiled_terminator_end,
        mode2.illegal
      ]).map(reStr).filter(Boolean);
      if (terminators.length)
        compiled2.terminators = langRe(language, terminators.join("|"), true);
      return compiled2;
    }
    var compiled = compileMode(language);
    if (language.case_insensitive)
      compiled.case_insensitive = true;
    return compiled;
  }

  // frontend/node_modules/highlight-ts/es/languages.js
  var languages = {};
  var aliases = {};
  function compiledLanguage(language) {
    return "lexemesRe" in language;
  }
  function registerLanguage(language) {
    languages[language.name] = language;
    if (language.aliases) {
      for (var _i = 0, _a = language.aliases; _i < _a.length; _i++) {
        var alias3 = _a[_i];
        aliases[alias3] = language.name;
      }
    }
  }
  function registerLanguages() {
    var languages2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      languages2[_i] = arguments[_i];
    }
    for (var _a = 0, languages_1 = languages2; _a < languages_1.length; _a++) {
      var language = languages_1[_a];
      registerLanguage(language);
    }
  }
  function listLanguages() {
    return Object.keys(languages);
  }
  function getLanguage(name) {
    name = (name || "").toLowerCase();
    name = aliases[name] || name;
    var language = languages[name];
    if (!language) {
      return void 0;
    }
    if (compiledLanguage(language)) {
      return language;
    }
    return languages[name] = compileLanguage(language);
  }

  // frontend/node_modules/highlight-ts/es/process.js
  function testRe(re, lexeme) {
    var match = re && re.exec(lexeme);
    return match && match.index === 0 || false;
  }
  function highlight(options2, render, lang, value, ignore_illegals, continuation) {
    var output = [{ content: [] }];
    function outContent(content2) {
      var cont = output[0].content;
      if (typeof content2 == "string" && cont.length && typeof cont[cont.length - 1] == "string") {
        cont[cont.length - 1] += content2;
      } else {
        cont.push(content2);
      }
    }
    function outText(text) {
      outContent(render.text(text));
    }
    ;
    function openSpan(className2, noPrefix) {
      if (!noPrefix)
        className2 = options2.classPrefix + className2;
      output.unshift({ className: className2, content: [] });
    }
    ;
    function wrapSpan(className2) {
      className2 = options2.classPrefix + className2;
      output.push({ className: className2, content: [] });
    }
    ;
    function closeSpan() {
      if (output.length < 2)
        throw "unbalanced";
      var _a2 = output.shift(), className2 = _a2.className, content2 = _a2.content;
      var output_2 = render.join(content2);
      outContent(className2 ? render.wrap(className2, output_2) : output_2);
    }
    ;
    function endOfMode(mode2, lexeme) {
      if (testRe(mode2.endRe, lexeme)) {
        for (; mode2.endsParent && mode2.parent; mode2 = mode2.parent)
          ;
        return mode2;
      }
      if (mode2.endsWithParent && mode2.parent) {
        return endOfMode(mode2.parent, lexeme);
      }
    }
    function processKeywords() {
      if (!top.keywords) {
        outText(mode_buffer);
        return;
      }
      var last_index = 0;
      top.lexemesRe.lastIndex = 0;
      var match2 = top.lexemesRe.exec(mode_buffer);
      while (match2) {
        outText(mode_buffer.substring(last_index, match2.index));
        var match_str = language.case_insensitive ? match2[0].toLowerCase() : match2[0];
        var keyword_match = top.keywords.hasOwnProperty(match_str) && top.keywords[match_str];
        if (keyword_match) {
          relevance += keyword_match[1];
          openSpan(keyword_match[0], false);
          outText(match2[0]);
          closeSpan();
        } else {
          outText(match2[0]);
        }
        last_index = top.lexemesRe.lastIndex;
        match2 = top.lexemesRe.exec(mode_buffer);
      }
      outText(mode_buffer.substr(last_index));
    }
    function processSubLanguage(subLanguage) {
      var explicitLanguage = subLanguage.length == 1 && subLanguage[0];
      if (explicitLanguage && !getLanguage(explicitLanguage)) {
        outText(mode_buffer);
        return;
      }
      var result2 = explicitLanguage ? highlight(options2, render, explicitLanguage, mode_buffer, true, continuations[explicitLanguage]) : highlightAuto(options2, render, mode_buffer, subLanguage.length ? top.subLanguage : void 0);
      if (top.relevance > 0) {
        relevance += result2.relevance;
      }
      if (explicitLanguage && result2.top) {
        continuations[explicitLanguage] = result2.top;
      }
      openSpan(result2.language, true);
      outContent(result2.value);
      closeSpan();
    }
    function processBuffer() {
      if (top.subLanguage != null)
        processSubLanguage(top.subLanguage);
      else
        processKeywords();
      mode_buffer = "";
    }
    function startNewMode(mode2) {
      if (mode2.className) {
        openSpan(mode2.className, false);
      }
      top = Object.create(mode2, { parent: { value: top } });
    }
    function processLexeme(buffer, lexeme) {
      mode_buffer += buffer;
      if (lexeme == null) {
        processBuffer();
        return 0;
      }
      var new_mode;
      for (var _i = 0, _a2 = top.contains; _i < _a2.length; _i++) {
        var sub = _a2[_i];
        if (testRe(sub.beginRe, lexeme)) {
          new_mode = sub;
          break;
        }
      }
      if (new_mode) {
        if (new_mode.skip) {
          mode_buffer += lexeme;
        } else {
          if (new_mode.excludeBegin) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (!new_mode.returnBegin && !new_mode.excludeBegin) {
            mode_buffer = lexeme;
          }
        }
        startNewMode(
          new_mode
          /*, lexeme*/
        );
        return new_mode.returnBegin ? 0 : lexeme.length;
      }
      var end_mode = endOfMode(top, lexeme);
      if (end_mode) {
        var origin_1 = top;
        if (origin_1.skip) {
          mode_buffer += lexeme;
        } else {
          if (!(origin_1.returnEnd || origin_1.excludeEnd)) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (origin_1.excludeEnd) {
            mode_buffer = lexeme;
          }
        }
        do {
          if (top.className) {
            closeSpan();
          }
          if (!top.skip && !top.subLanguage) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== end_mode.parent);
        if (end_mode.starts) {
          startNewMode(
            end_mode.starts
            /*, ''*/
          );
        }
        return origin_1.returnEnd ? 0 : lexeme.length;
      }
      if (!ignore_illegals && testRe(top.illegalRe, lexeme)) {
        throw new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || "<unnamed>") + '"');
      }
      mode_buffer += lexeme;
      return lexeme.length || 1;
    }
    var language = getLanguage(lang);
    if (!language)
      throw new Error('Unknown language: "' + lang + '"');
    var top = continuation || language;
    var continuations = {};
    var current;
    for (current = top; current && current !== language; current = current.parent) {
      if (current.className) {
        wrapSpan(current.className);
      }
    }
    var mode_buffer = "";
    var relevance = 0;
    try {
      var match = void 0, count = void 0, index = 0;
      while (true) {
        top.terminators.lastIndex = index;
        match = top.terminators.exec(value);
        if (!match)
          break;
        count = processLexeme(value.substring(index, match.index), match[0]);
        index = match.index + count;
      }
      processLexeme(value.substr(index));
      for (current = top; current.parent; current = current.parent) {
        if (current.className) {
          closeSpan();
        }
      }
      if (output.length != 1)
        throw "unbalanced";
      var _a = output[0], className = _a.className, content = _a.content;
      var output_ = render.join(content);
      var result = className ? render.wrap(className, output_) : output_;
      return {
        language: lang,
        relevance,
        value: result,
        top
      };
    } catch (e9) {
      if (e9.message && e9.message.indexOf("Illegal") !== -1) {
        return {
          language: lang,
          relevance: 0,
          value: render.text(value)
        };
      } else {
        throw e9;
      }
    }
  }
  function highlightAuto(options2, render, text, languageSubset) {
    if (languageSubset === void 0) {
      languageSubset = options2.languages || listLanguages();
    }
    var result = {
      language: "",
      relevance: 0,
      value: render.text(text)
    };
    if (text != "") {
      var second_best = result;
      var languages2 = languageSubset.filter(getLanguage);
      for (var _i = 0, languages_1 = languages2; _i < languages_1.length; _i++) {
        var lang = languages_1[_i];
        var current = highlight(options2, render, lang, text, false);
        if (current.relevance > second_best.relevance) {
          second_best = current;
        }
        if (current.relevance > result.relevance) {
          second_best = result;
          result = current;
        }
      }
      if (second_best.language) {
        result.second_best = second_best;
      }
    }
    return result;
  }
  var defaults = {
    classPrefix: "hljs-",
    //tabReplace: undefined,
    useBr: false
  };
  function init(render, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      render,
      options: __assign({}, defaults, options2)
    };
  }
  function process(_a, source, lang) {
    var render = _a.render, options2 = _a.options;
    return typeof lang == "string" ? highlight(options2, render, lang, source, false) : highlightAuto(options2, render, source, lang);
  }

  // frontend/node_modules/highlight-ts/es/render/html.js
  function escape2(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  var htmlRender = {
    text: function(chunk) {
      return escape2(chunk);
    },
    join: function(chunks) {
      return chunks.join("");
    },
    wrap: function(className, chunk) {
      return '<span class="' + className + '">' + chunk + "</span>";
    }
  };

  // frontend/node_modules/highlight-ts/es/languages/cplusplus.js
  var CPP_PRIMITIVE_TYPES = {
    className: "keyword",
    begin: "\\b[a-z\\d_]*_t\\b"
  };
  var STRINGS = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U)?L?"',
        end: '"',
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE]
      },
      {
        begin: '(u8?|U)?R"',
        end: '"',
        contains: [BACKSLASH_ESCAPE]
      },
      {
        begin: "'\\\\?.",
        end: "'",
        illegal: "."
      }
    ]
  };
  var NUMBERS = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  };
  var PREPROCESSOR = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: {
      "meta-keyword": "if else elif endif define undef warning error line pragma ifdef ifndef include"
    },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      __assign({}, STRINGS, { className: "meta-string" }),
      {
        className: "meta-string",
        begin: /<[^\n>]*>/,
        end: /$/,
        illegal: "\\n"
      },
      C_LINE_COMMENT_MODE,
      C_BLOCK_COMMENT_MODE
    ]
  };
  var FUNCTION_TITLE = IDENT_RE + "\\s*\\(";
  var CPP_KEYWORDS = {
    keyword: "int float while private char catch import module export virtual operator sizeof dynamic_cast|10 typedef const_cast|10 const for static_cast|10 union namespace unsigned long volatile static protected bool template mutable if public friend do goto auto void enum else break extern using asm case typeid short reinterpret_cast|10 default double register explicit signed typename try this switch continue inline delete alignof constexpr decltype noexcept static_assert thread_local restrict _Bool complex _Complex _Imaginary atomic_bool atomic_char atomic_schar atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong atomic_ullong new throw return and or not",
    built_in: "std string cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap array shared_ptr abort abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr",
    literal: "true false nullptr NULL"
  };
  var EXPRESSION_CONTAINS = [
    CPP_PRIMITIVE_TYPES,
    C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE,
    NUMBERS,
    STRINGS
  ];
  var CPlusPlus = {
    name: "cplusplus",
    aliases: ["c", "cc", "h", "c++", "h++", "cpp", "hpp"],
    keywords: CPP_KEYWORDS,
    illegal: "</",
    contains: EXPRESSION_CONTAINS.concat([
      PREPROCESSOR,
      {
        begin: "\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",
        end: ">",
        keywords: CPP_KEYWORDS,
        contains: ["self", CPP_PRIMITIVE_TYPES]
      },
      {
        begin: IDENT_RE + "::",
        keywords: CPP_KEYWORDS
      },
      {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          { begin: /=/, end: /;/ },
          { begin: /\(/, end: /\)/ },
          { beginKeywords: "new throw return else", end: /;/ }
        ],
        keywords: CPP_KEYWORDS,
        contains: EXPRESSION_CONTAINS.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: CPP_KEYWORDS,
            contains: EXPRESSION_CONTAINS.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      },
      {
        className: "function",
        begin: "(" + IDENT_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: CPP_KEYWORDS,
        illegal: /[^\w\s\*&]/,
        contains: [
          {
            begin: FUNCTION_TITLE,
            returnBegin: true,
            contains: [TITLE_MODE],
            relevance: 0
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: CPP_KEYWORDS,
            relevance: 0,
            contains: [
              C_LINE_COMMENT_MODE,
              C_BLOCK_COMMENT_MODE,
              STRINGS,
              NUMBERS,
              CPP_PRIMITIVE_TYPES
            ]
          },
          C_LINE_COMMENT_MODE,
          C_BLOCK_COMMENT_MODE,
          PREPROCESSOR
        ]
      },
      {
        className: "class",
        beginKeywords: "class struct",
        end: /[{;:]/,
        contains: [
          { begin: /</, end: />/, contains: ["self"] },
          TITLE_MODE
        ]
      }
    ])
  };

  // frontend/node_modules/highlight-ts/es/languages/d.js
  var decimal_integer_re = "(0|[1-9][\\d_]*)";
  var decimal_integer_nosus_re = "(0|[1-9][\\d_]*|\\d[\\d_]*|[\\d_]+?\\d)";
  var binary_integer_re = "0[bB][01_]+";
  var hexadecimal_digits_re = "([\\da-fA-F][\\da-fA-F_]*|_[\\da-fA-F][\\da-fA-F_]*)";
  var hexadecimal_integer_re = "0[xX]" + hexadecimal_digits_re;
  var decimal_exponent_re = "([eE][+-]?" + decimal_integer_nosus_re + ")";
  var decimal_float_re = "(" + decimal_integer_nosus_re + "(\\.\\d*|" + decimal_exponent_re + ")|\\d+\\." + decimal_integer_nosus_re + decimal_integer_nosus_re + "|\\." + decimal_integer_re + decimal_exponent_re + "?)";
  var hexadecimal_float_re = "(0[xX](" + hexadecimal_digits_re + "\\." + hexadecimal_digits_re + "|\\.?" + hexadecimal_digits_re + ")[pP][+-]?" + decimal_integer_nosus_re + ")";
  var integer_re = "(" + decimal_integer_re + "|" + binary_integer_re + "|" + hexadecimal_integer_re + ")";
  var float_re = "(" + hexadecimal_float_re + "|" + decimal_float_re + ")";
  var escape_sequence_re = `\\\\(['"\\?\\\\abfnrtv]|u[\\dA-Fa-f]{4}|[0-7]{1,3}|x[\\dA-Fa-f]{2}|U[\\dA-Fa-f]{8})|&[a-zA-Z\\d]{2,};`;
  var D_INTEGER_MODE = {
    className: "number",
    begin: "\\b" + integer_re + "(L|u|U|Lu|LU|uL|UL)?",
    relevance: 0
  };
  var D_FLOAT_MODE = {
    className: "number",
    begin: "\\b(" + float_re + "([fF]|L|i|[fF]i|Li)?|" + integer_re + "(i|[fF]i|Li))",
    relevance: 0
  };
  var D_CHARACTER_MODE = {
    className: "string",
    begin: "'(" + escape_sequence_re + "|.)",
    end: "'",
    illegal: "."
  };
  var D_NESTING_COMMENT_MODE = COMMENT("\\/\\+", "\\+\\/", {
    contains: ["self"],
    relevance: 10
  });

  // frontend/node_modules/highlight-ts/es/languages/haskell.js
  var COMMENT2 = {
    variants: [
      COMMENT("--", "$"),
      COMMENT("{-", "-}", {
        contains: ["self"]
      })
    ]
  };
  var PRAGMA = {
    className: "meta",
    begin: "{-#",
    end: "#-}"
  };
  var PREPROCESSOR2 = {
    className: "meta",
    begin: "^#",
    end: "$"
  };
  var CONSTRUCTOR = {
    className: "type",
    begin: "\\b[A-Z][\\w']*",
    relevance: 0
  };
  var LIST = {
    begin: "\\(",
    end: "\\)",
    illegal: '"',
    contains: [
      PRAGMA,
      PREPROCESSOR2,
      { className: "type", begin: "\\b[A-Z][\\w]*(\\((\\.\\.|,|\\w+)\\))?" },
      __assign({}, TITLE_MODE, { begin: "[_a-z][\\w']*" }),
      COMMENT2
    ]
  };
  var RECORD = {
    begin: "{",
    end: "}",
    contains: LIST.contains
  };
  var Haskell = {
    name: "haskell",
    aliases: ["hs"],
    keywords: "let in if then else case of where do module import hiding qualified type data newtype deriving class instance as default infix infixl infixr foreign export ccall stdcall cplusplus jvm dotnet safe unsafe family forall mdo proc rec",
    contains: [
      // Top-level constructions.
      {
        beginKeywords: "module",
        end: "where",
        keywords: "module where",
        contains: [LIST, COMMENT2],
        illegal: "\\W\\.|;"
      },
      {
        begin: "\\bimport\\b",
        end: "$",
        keywords: "import qualified as hiding",
        contains: [LIST, COMMENT2],
        illegal: "\\W\\.|;"
      },
      {
        className: "class",
        begin: "^(\\s*)?(class|instance)\\b",
        end: "where",
        keywords: "class family instance where",
        contains: [CONSTRUCTOR, LIST, COMMENT2]
      },
      {
        className: "class",
        begin: "\\b(data|(new)?type)\\b",
        end: "$",
        keywords: "data family type newtype deriving",
        contains: [PRAGMA, CONSTRUCTOR, LIST, RECORD, COMMENT2]
      },
      {
        beginKeywords: "default",
        end: "$",
        contains: [CONSTRUCTOR, LIST, COMMENT2]
      },
      {
        beginKeywords: "infix infixl infixr",
        end: "$",
        contains: [C_NUMBER_MODE, COMMENT2]
      },
      {
        begin: "\\bforeign\\b",
        end: "$",
        keywords: "foreign import export ccall stdcall cplusplus jvm dotnet safe unsafe",
        contains: [CONSTRUCTOR, QUOTE_STRING_MODE, COMMENT2]
      },
      {
        className: "meta",
        begin: "#!\\/usr\\/bin\\/env runhaskell",
        end: "$"
      },
      // "Whitespaces".
      PRAGMA,
      PREPROCESSOR2,
      // Literals and names.
      // TODO: characters.
      QUOTE_STRING_MODE,
      C_NUMBER_MODE,
      CONSTRUCTOR,
      __assign({}, TITLE_MODE, { begin: "^[_a-z][\\w']*" }),
      COMMENT2,
      { begin: "->|<-" }
      // No markup, relevance booster
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/rust.js
  var NUM_SUFFIX = "([ui](8|16|32|64|128|size)|f(32|64))?";
  var KEYWORDS = "alignof as be box break const continue crate do else enum extern false fn for if impl in let loop match mod mut offsetof once priv proc pub pure ref return self Self sizeof static struct super trait true type typeof unsafe unsized use virtual while where yield move default";
  var BUILTINS = (
    // functions
    "drop i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize f32 f64 str char bool Box Option Result String Vec Copy Send Sized Sync Drop Fn FnMut FnOnce ToOwned Clone Debug PartialEq PartialOrd Eq Ord AsRef AsMut Into From Default Iterator Extend IntoIterator DoubleEndedIterator ExactSizeIterator SliceConcatExt ToString assert! assert_eq! bitflags! bytes! cfg! col! concat! concat_idents! debug_assert! debug_assert_eq! env! panic! file! format! format_args! include_bin! include_str! line! local_data_key! module_path! option_env! print! println! select! stringify! try! unimplemented! unreachable! vec! write! writeln! macro_rules! assert_ne! debug_assert_ne!"
  );
  var Rust = {
    name: "rust",
    aliases: ["rs"],
    keywords: {
      keyword: KEYWORDS,
      literal: "true false Some None Ok Err",
      built_in: BUILTINS
    },
    lexemes: IDENT_RE + "!?",
    illegal: "</",
    contains: [
      C_LINE_COMMENT_MODE,
      COMMENT("/\\*", "\\*/", { contains: ["self"] }),
      __assign({}, QUOTE_STRING_MODE, { begin: /b?"/, illegal: void 0 }),
      {
        className: "string",
        variants: [
          { begin: /r(#*)"(.|\n)*?"\1(?!#)/ },
          { begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/ }
        ]
      },
      {
        className: "symbol",
        begin: /'[a-zA-Z_][a-zA-Z0-9_]*/
      },
      {
        className: "number",
        variants: [
          { begin: "\\b0b([01_]+)" + NUM_SUFFIX },
          { begin: "\\b0o([0-7_]+)" + NUM_SUFFIX },
          { begin: "\\b0x([A-Fa-f0-9_]+)" + NUM_SUFFIX },
          {
            begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + NUM_SUFFIX
          }
        ],
        relevance: 0
      },
      {
        className: "function",
        beginKeywords: "fn",
        end: "(\\(|<)",
        excludeEnd: true,
        contains: [UNDERSCORE_TITLE_MODE]
      },
      {
        className: "meta",
        begin: "#\\!?\\[",
        end: "\\]",
        contains: [
          {
            className: "meta-string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        className: "class",
        beginKeywords: "type",
        end: ";",
        contains: [
          __assign({}, UNDERSCORE_TITLE_MODE, { endsParent: true })
        ],
        illegal: "\\S"
      },
      {
        className: "class",
        beginKeywords: "trait enum struct union",
        end: "{",
        contains: [
          __assign({}, UNDERSCORE_TITLE_MODE, { endsParent: true })
        ],
        illegal: "[\\w\\d]"
      },
      {
        begin: IDENT_RE + "::",
        keywords: { built_in: BUILTINS }
      },
      {
        begin: "->"
      }
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/haxe.js
  var IDENT_RE2 = "[a-zA-Z_$][a-zA-Z0-9_$]*";
  var HAXE_BASIC_TYPES = "Int Float String Bool Dynamic Void Array ";
  var Haxe = {
    name: "haxe",
    aliases: ["hx"],
    keywords: {
      keyword: "break case cast catch continue default do dynamic else enum extern for function here if import in inline never new override package private get set public return static super switch this throw trace try typedef untyped using var while " + HAXE_BASIC_TYPES,
      built_in: "trace this",
      literal: "true false null _"
    },
    contains: [
      {
        className: "string",
        begin: "'",
        end: "'",
        contains: [
          BACKSLASH_ESCAPE,
          {
            className: "subst",
            begin: "\\$\\{",
            end: "\\}"
          },
          {
            className: "subst",
            begin: "\\$",
            end: "\\W}"
          }
        ]
      },
      QUOTE_STRING_MODE,
      C_LINE_COMMENT_MODE,
      C_BLOCK_COMMENT_MODE,
      C_NUMBER_MODE,
      {
        className: "meta",
        begin: "@:",
        end: "$"
      },
      {
        className: "meta",
        begin: "#",
        end: "$",
        keywords: { "meta-keyword": "if else elseif end error" }
      },
      {
        className: "type",
        begin: ":[ 	]*",
        end: "[^A-Za-z0-9_ 	\\->]",
        excludeBegin: true,
        excludeEnd: true,
        relevance: 0
      },
      {
        className: "type",
        begin: ":[ 	]*",
        end: "\\W",
        excludeBegin: true,
        excludeEnd: true
      },
      {
        className: "type",
        begin: "new *",
        end: "\\W",
        excludeBegin: true,
        excludeEnd: true
      },
      {
        className: "class",
        beginKeywords: "enum",
        end: "\\{",
        contains: [
          TITLE_MODE
        ]
      },
      {
        className: "class",
        beginKeywords: "abstract",
        end: "[\\{$]",
        contains: [
          {
            className: "type",
            begin: "\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "type",
            begin: "from +",
            end: "\\W",
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "type",
            begin: "to +",
            end: "\\W",
            excludeBegin: true,
            excludeEnd: true
          },
          TITLE_MODE
        ],
        keywords: {
          keyword: "abstract from to"
        }
      },
      {
        className: "class",
        begin: "\\b(class|interface) +",
        end: "[\\{$]",
        excludeEnd: true,
        keywords: "class interface",
        contains: [
          {
            className: "keyword",
            begin: "\\b(extends|implements) +",
            keywords: "extends implements",
            contains: [
              {
                className: "type",
                begin: IDENT_RE2,
                relevance: 0
              }
            ]
          },
          TITLE_MODE
        ]
      },
      {
        className: "function",
        beginKeywords: "function",
        end: "\\(",
        excludeEnd: true,
        illegal: "\\S",
        contains: [
          TITLE_MODE
        ]
      }
    ],
    illegal: /<\//
  };

  // frontend/node_modules/highlight-ts/es/languages/java.js
  var JAVA_IDENT_RE = "[\xC0-\u02B8a-zA-Z_$][\xC0-\u02B8a-zA-Z_$0-9]*";
  var GENERIC_IDENT_RE = JAVA_IDENT_RE + "(<" + JAVA_IDENT_RE + "(\\s*,\\s*" + JAVA_IDENT_RE + ")*>)?";
  var KEYWORDS2 = "false synchronized int abstract float private char boolean static null if const for true while long strictfp finally protected import native final void enum else break transient catch instanceof byte super volatile case assert short package default double public try this switch continue throws protected public private module requires exports do";
  var JAVA_NUMBER_RE = "\\b(0[bB]([01]+[01_]+[01]+|[01]+)|0[xX]([a-fA-F0-9]+[a-fA-F0-9_]+[a-fA-F0-9]+|[a-fA-F0-9]+)|(([\\d]+[\\d_]+[\\d]+|[\\d]+)(\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))?|\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))([eE][-+]?\\d+)?)[lLfF]?";
  var JAVA_NUMBER_MODE = {
    className: "number",
    begin: JAVA_NUMBER_RE,
    relevance: 0
  };
  var Java = {
    name: "java",
    aliases: ["jsp"],
    keywords: KEYWORDS2,
    illegal: /<\/|#/,
    contains: [
      COMMENT("/\\*\\*", "\\*/", {
        relevance: 0,
        contains: [
          {
            // eat up @'s in emails to prevent them to be recognized as doctags
            begin: /\w+@/,
            relevance: 0
          },
          {
            className: "doctag",
            begin: "@[A-Za-z]+"
          }
        ]
      }),
      C_LINE_COMMENT_MODE,
      C_BLOCK_COMMENT_MODE,
      APOS_STRING_MODE,
      QUOTE_STRING_MODE,
      {
        className: "class",
        beginKeywords: "class interface",
        end: /[{;=]/,
        excludeEnd: true,
        keywords: "class interface",
        illegal: /[:"\[\]]/,
        contains: [
          { beginKeywords: "extends implements" },
          UNDERSCORE_TITLE_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        className: "function",
        begin: "(" + GENERIC_IDENT_RE + "\\s+)+" + UNDERSCORE_IDENT_RE + "\\s*\\(",
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: KEYWORDS2,
        contains: [
          {
            begin: UNDERSCORE_IDENT_RE + "\\s*\\(",
            returnBegin: true,
            relevance: 0,
            contains: [UNDERSCORE_TITLE_MODE]
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: KEYWORDS2,
            relevance: 0,
            contains: [
              APOS_STRING_MODE,
              QUOTE_STRING_MODE,
              C_NUMBER_MODE,
              C_BLOCK_COMMENT_MODE
            ]
          },
          C_LINE_COMMENT_MODE,
          C_BLOCK_COMMENT_MODE
        ]
      },
      JAVA_NUMBER_MODE,
      {
        className: "meta",
        begin: "@[A-Za-z]+"
      }
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/lua.js
  var OPENING_LONG_BRACKET = "\\[=*\\[";
  var CLOSING_LONG_BRACKET = "\\]=*\\]";
  var LONG_BRACKETS = {
    begin: OPENING_LONG_BRACKET,
    end: CLOSING_LONG_BRACKET,
    contains: ["self"]
  };
  var COMMENTS = [
    COMMENT("--(?!" + OPENING_LONG_BRACKET + ")", "$"),
    COMMENT("--" + OPENING_LONG_BRACKET, CLOSING_LONG_BRACKET, {
      contains: [LONG_BRACKETS],
      relevance: 10
    })
  ];
  var Lua = {
    name: "lua",
    lexemes: UNDERSCORE_IDENT_RE,
    keywords: {
      literal: "true false nil",
      keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
      built_in: (
        //Metatags and globals:
        "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstringmodule next pairs pcall print rawequal rawget rawset require select setfenvsetmetatable tonumber tostring type unpack xpcall arg selfcoroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
      )
    },
    contains: COMMENTS.concat([
      {
        className: "function",
        beginKeywords: "function",
        end: "\\)",
        contains: [
          __assign({}, TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
          {
            className: "params",
            begin: "\\(",
            endsWithParent: true,
            contains: COMMENTS
          }
        ].concat(COMMENTS)
      },
      C_NUMBER_MODE,
      APOS_STRING_MODE,
      QUOTE_STRING_MODE,
      {
        className: "string",
        begin: OPENING_LONG_BRACKET,
        end: CLOSING_LONG_BRACKET,
        contains: [LONG_BRACKETS],
        relevance: 5
      }
    ])
  };

  // frontend/node_modules/highlight-ts/es/languages/lisp.js
  var LISP_IDENT_RE = "[a-zA-Z_\\-\\+\\*\\/\\<\\=\\>\\&\\#][a-zA-Z0-9_\\-\\+\\*\\/\\<\\=\\>\\&\\#!]*";
  var MEC_RE = "\\|[^]*?\\|";
  var LISP_SIMPLE_NUMBER_RE = "(\\-|\\+)?\\d+(\\.\\d+|\\/\\d+)?((d|e|f|l|s|D|E|F|L|S)(\\+|\\-)?\\d+)?";
  var LITERAL = {
    className: "literal",
    begin: "\\b(t{1}|nil)\\b"
  };
  var NUMBER = {
    className: "number",
    variants: [
      { begin: LISP_SIMPLE_NUMBER_RE, relevance: 0 },
      { begin: "#(b|B)[0-1]+(/[0-1]+)?" },
      { begin: "#(o|O)[0-7]+(/[0-7]+)?" },
      { begin: "#(x|X)[0-9a-fA-F]+(/[0-9a-fA-F]+)?" },
      { begin: "#(c|C)\\(" + LISP_SIMPLE_NUMBER_RE + " +" + LISP_SIMPLE_NUMBER_RE, end: "\\)" }
    ]
  };
  var STRING = __assign({}, QUOTE_STRING_MODE, { illegal: void 0 });
  var COMMENT3 = COMMENT(";", "$", {
    relevance: 0
  });
  var VARIABLE = {
    begin: "\\*",
    end: "\\*"
  };
  var KEYWORD = {
    className: "symbol",
    begin: "[:&]" + LISP_IDENT_RE
  };
  var IDENT = {
    begin: LISP_IDENT_RE,
    relevance: 0
  };
  var MEC = {
    begin: MEC_RE
  };
  var QUOTED_LIST = {
    begin: "\\(",
    end: "\\)",
    contains: ["self", LITERAL, STRING, NUMBER, IDENT]
  };
  var QUOTED = {
    contains: [NUMBER, STRING, VARIABLE, KEYWORD, QUOTED_LIST, IDENT],
    variants: [
      {
        begin: "['`]\\(",
        end: "\\)"
      },
      {
        begin: "\\(quote ",
        end: "\\)",
        keywords: { name: "quote" }
      },
      {
        begin: "'" + MEC_RE
      }
    ]
  };
  var QUOTED_ATOM = {
    variants: [
      { begin: "'" + LISP_IDENT_RE },
      { begin: "#'" + LISP_IDENT_RE + "(::" + LISP_IDENT_RE + ")*" }
    ]
  };
  var LIST2 = {
    begin: "\\(\\s*",
    end: "\\)"
  };
  var BODY = {
    endsWithParent: true,
    relevance: 0
  };
  LIST2.contains = [
    {
      className: "name",
      variants: [
        { begin: LISP_IDENT_RE },
        { begin: MEC_RE }
      ]
    },
    BODY
  ];
  BODY.contains = [QUOTED, QUOTED_ATOM, LIST2, LITERAL, NUMBER, STRING, COMMENT3, VARIABLE, KEYWORD, MEC, IDENT];

  // frontend/node_modules/highlight-ts/es/languages/llvm.js
  var identifier = "([-a-zA-Z$._][\\w\\-$.]*)";
  var LLVM = {
    name: "llvm",
    //lexemes: '[.%]?' + IDENT_RE,
    keywords: "begin end true false declare define global constant private linker_private internal available_externally linkonce linkonce_odr weak weak_odr appending dllimport dllexport common default hidden protected extern_weak external thread_local zeroinitializer undef null to tail target triple datalayout volatile nuw nsw nnan ninf nsz arcp fast exact inbounds align addrspace section alias module asm sideeffect gc dbg linker_private_weak attributes blockaddress initialexec localdynamic localexec prefix unnamed_addr ccc fastcc coldcc x86_stdcallcc x86_fastcallcc arm_apcscc arm_aapcscc arm_aapcs_vfpcc ptx_device ptx_kernel intel_ocl_bicc msp430_intrcc spir_func spir_kernel x86_64_sysvcc x86_64_win64cc x86_thiscallcc cc c signext zeroext inreg sret nounwind noreturn noalias nocapture byval nest readnone readonly inlinehint noinline alwaysinline optsize ssp sspreq noredzone noimplicitfloat naked builtin cold nobuiltin noduplicate nonlazybind optnone returns_twice sanitize_address sanitize_memory sanitize_thread sspstrong uwtable returned type opaque eq ne slt sgt sle sge ult ugt ule uge oeq one olt ogt ole oge ord uno ueq une x acq_rel acquire alignstack atomic catch cleanup filter inteldialect max min monotonic nand personality release seq_cst singlethread umax umin unordered xchg add fadd sub fsub mul fmul udiv sdiv fdiv urem srem frem shl lshr ashr and or xor icmp fcmp phi call trunc zext sext fptrunc fpext uitofp sitofp fptoui fptosi inttoptr ptrtoint bitcast addrspacecast select va_arg ret br switch invoke unwind unreachable indirectbr landingpad resume malloc alloca free load store getelementptr extractelement insertelement shufflevector getresult extractvalue insertvalue atomicrmw cmpxchg fence argmemonly double",
    contains: [
      {
        className: "keyword",
        begin: "i\\d+"
      },
      COMMENT(";", "\\n", { relevance: 0 }),
      // Double quote string
      QUOTE_STRING_MODE,
      {
        className: "string",
        variants: [
          // Double-quoted string
          { begin: '"', end: '[^\\\\]"' }
        ],
        relevance: 0
      },
      {
        className: "title",
        variants: [
          { begin: "@" + identifier },
          { begin: "@\\d+" },
          { begin: "!" + identifier },
          { begin: "!\\d+" + identifier }
        ]
      },
      {
        className: "symbol",
        variants: [
          { begin: "%" + identifier },
          { begin: "%\\d+" },
          { begin: "#\\d+" }
        ]
      },
      {
        className: "number",
        variants: [
          { begin: "0[xX][a-fA-F0-9]+" },
          { begin: "-?\\d+(?:[.]\\d+)?(?:[eE][-+]?\\d+(?:[.]\\d+)?)?" }
        ],
        relevance: 0
      }
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/scheme.js
  var SCHEME_IDENT_RE = "[^\\(\\)\\[\\]\\{\\}\",'`;#|\\\\\\s]+";
  var SCHEME_SIMPLE_NUMBER_RE = "(\\-|\\+)?\\d+([./]\\d+)?";
  var SCHEME_COMPLEX_NUMBER_RE = SCHEME_SIMPLE_NUMBER_RE + "[+\\-]" + SCHEME_SIMPLE_NUMBER_RE + "i";
  var BUILTINS2 = {
    "builtin-name": "case-lambda call/cc class define-class exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules ' * + , ,@ - ... / ; < <= = => > >= ` abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?"
  };
  var SHEBANG = {
    className: "meta",
    begin: "^#!",
    end: "$"
  };
  var LITERAL2 = {
    className: "literal",
    begin: "(#t|#f|#\\\\" + SCHEME_IDENT_RE + "|#\\\\.)"
  };
  var NUMBER2 = {
    className: "number",
    variants: [
      { begin: SCHEME_SIMPLE_NUMBER_RE, relevance: 0 },
      { begin: SCHEME_COMPLEX_NUMBER_RE, relevance: 0 },
      { begin: "#b[0-1]+(/[0-1]+)?" },
      { begin: "#o[0-7]+(/[0-7]+)?" },
      { begin: "#x[0-9a-f]+(/[0-9a-f]+)?" }
    ]
  };
  var STRING2 = QUOTE_STRING_MODE;
  var COMMENT_MODES = [
    COMMENT(";", "$", {
      relevance: 0
    }),
    COMMENT("#\\|", "\\|#")
  ];
  var IDENT2 = {
    begin: SCHEME_IDENT_RE,
    relevance: 0
  };
  var QUOTED_IDENT = {
    className: "symbol",
    begin: "'" + SCHEME_IDENT_RE
  };
  var BODY2 = {
    endsWithParent: true,
    relevance: 0
  };
  var QUOTED_LIST2 = {
    variants: [
      { begin: /'/ },
      { begin: "`" }
    ],
    contains: [
      {
        begin: "\\(",
        end: "\\)",
        contains: ["self", LITERAL2, STRING2, NUMBER2, IDENT2, QUOTED_IDENT]
      }
    ]
  };
  var NAME = {
    className: "name",
    begin: SCHEME_IDENT_RE,
    lexemes: SCHEME_IDENT_RE,
    keywords: BUILTINS2
  };
  var LAMBDA = {
    begin: /lambda/,
    endsWithParent: true,
    returnBegin: true,
    contains: [
      NAME,
      {
        begin: /\(/,
        end: /\)/,
        endsParent: true,
        contains: [IDENT2]
      }
    ]
  };
  var LIST3 = {
    variants: [
      { begin: "\\(", end: "\\)" },
      { begin: "\\[", end: "\\]" }
    ],
    contains: [LAMBDA, NAME, BODY2]
  };
  BODY2.contains = [LITERAL2, NUMBER2, STRING2, IDENT2, QUOTED_IDENT, QUOTED_LIST2, LIST3].concat(COMMENT_MODES);
  var Scheme = {
    name: "scheme",
    illegal: /\S/,
    contains: [SHEBANG, NUMBER2, STRING2, QUOTED_IDENT, QUOTED_LIST2, LIST3].concat(COMMENT_MODES)
  };

  // frontend/node_modules/highlight-ts/es/languages/matlab.js
  var COMMON_CONTAINS = [
    C_NUMBER_MODE,
    {
      className: "string",
      begin: "'",
      end: "'",
      contains: [BACKSLASH_ESCAPE, { begin: "''" }]
    }
  ];
  var TRANSPOSE = {
    relevance: 0,
    contains: [
      {
        begin: /'['\.]*/
      }
    ]
  };
  var Matlab = {
    name: "matlab",
    aliases: ["octave"],
    keywords: {
      keyword: "break case catch classdef continue else elseif end enumerated events for function global if methods otherwise parfor persistent properties return spmd switch try while",
      built_in: "sin sind sinh asin asind asinh cos cosd cosh acos acosd acosh tan tand tanh atan atand atan2 atanh sec secd sech asec asecd asech csc cscd csch acsc acscd acsch cot cotd coth acot acotd acoth hypot exp expm1 log log1p log10 log2 pow2 realpow reallog realsqrt sqrt nthroot nextpow2 abs angle complex conj imag real unwrap isreal cplxpair fix floor ceil round mod rem sign airy besselj bessely besselh besseli besselk beta betainc betaln ellipj ellipke erf erfc erfcx erfinv expint gamma gammainc gammaln psi legendre cross dot factor isprime primes gcd lcm rat rats perms nchoosek factorial cart2sph cart2pol pol2cart sph2cart hsv2rgb rgb2hsv zeros ones eye repmat rand randn linspace logspace freqspace meshgrid accumarray size length ndims numel disp isempty isequal isequalwithequalnans cat reshape diag blkdiag tril triu fliplr flipud flipdim rot90 find sub2ind ind2sub bsxfun ndgrid permute ipermute shiftdim circshift squeeze isscalar isvector ans eps realmax realmin pi i inf nan isnan isinf isfinite j why compan gallery hadamard hankel hilb invhilb magic pascal rosser toeplitz vander wilkinson"
    },
    illegal: '(//|"|#|/\\*|\\s+/\\w+)',
    contains: [
      {
        className: "function",
        beginKeywords: "function",
        end: "$",
        contains: [
          UNDERSCORE_TITLE_MODE,
          {
            className: "params",
            variants: [
              { begin: "\\(", end: "\\)" },
              { begin: "\\[", end: "\\]" }
            ]
          }
        ]
      },
      {
        begin: /[a-zA-Z_][a-zA-Z_0-9]*'['\.]*/,
        returnBegin: true,
        relevance: 0,
        contains: [
          { begin: /[a-zA-Z_][a-zA-Z_0-9]*/, relevance: 0 },
          TRANSPOSE.contains[0]
        ]
      },
      {
        begin: "\\[",
        end: "\\]",
        contains: COMMON_CONTAINS,
        relevance: 0,
        starts: TRANSPOSE
      },
      {
        begin: "\\{",
        end: /}/,
        contains: COMMON_CONTAINS,
        relevance: 0,
        starts: TRANSPOSE
      },
      {
        // transpose operators at the end of a function call
        begin: /\)/,
        relevance: 0,
        starts: TRANSPOSE
      },
      COMMENT("^\\s*\\%\\{\\s*$", "^\\s*\\%\\}\\s*$"),
      COMMENT("\\%", "$")
    ].concat(COMMON_CONTAINS)
  };

  // frontend/node_modules/highlight-ts/es/languages/typescript.js
  var KEYWORDS3 = {
    keyword: "in if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const class public private protected get set super static implements enum export import declare type namespace abstract as from extends async await",
    literal: "true false null undefined NaN Infinity",
    built_in: "eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require module console window document any number boolean string void Promise"
  };
  var TITLE_MODE2 = __assign({}, TITLE_MODE, { begin: /[A-Za-z$_][0-9A-Za-z$_]*/ });
  var PARAMS_CONTAINS = [
    C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE
  ];
  var PARAMS_MODE = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS3,
    contains: PARAMS_CONTAINS
  };
  var ARROW_FUNCTION_MODE = {
    className: "function",
    begin: "(\\(.*?\\)|" + IDENT_RE + ")\\s*=>",
    returnBegin: true,
    end: "\\s*=>",
    contains: [
      {
        className: "params",
        variants: [
          {
            begin: IDENT_RE
          },
          {
            begin: /\(\s*\)/
          },
          __assign({}, PARAMS_MODE, { className: void 0 })
        ]
      }
    ]
  };
  PARAMS_CONTAINS.push(ARROW_FUNCTION_MODE);
  var TypeScript = {
    name: "typescript",
    aliases: ["ts"],
    keywords: KEYWORDS3,
    contains: [
      {
        className: "meta",
        begin: /^\s*['"]use strict['"]/
      },
      APOS_STRING_MODE,
      QUOTE_STRING_MODE,
      {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          BACKSLASH_ESCAPE,
          {
            className: "subst",
            begin: "\\$\\{",
            end: "\\}"
          }
        ]
      },
      C_LINE_COMMENT_MODE,
      C_BLOCK_COMMENT_MODE,
      {
        className: "number",
        variants: [
          { begin: "\\b(0[bB][01]+)" },
          { begin: "\\b(0[oO][0-7]+)" },
          { begin: C_NUMBER_RE }
        ],
        relevance: 0
      },
      {
        begin: "(" + RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        contains: [
          C_LINE_COMMENT_MODE,
          C_BLOCK_COMMENT_MODE,
          REGEXP_MODE,
          ARROW_FUNCTION_MODE
        ],
        relevance: 0
      },
      {
        className: "function",
        begin: "function",
        end: /[\{;]/,
        excludeEnd: true,
        keywords: KEYWORDS3,
        contains: [
          "self",
          TITLE_MODE2,
          PARAMS_MODE
        ],
        illegal: /%/,
        relevance: 0
        // () => {} is more typical in TypeScript
      },
      {
        beginKeywords: "constructor",
        end: /\{/,
        excludeEnd: true,
        contains: [
          "self",
          PARAMS_MODE
        ]
      },
      {
        begin: /module\./,
        keywords: { built_in: "module" },
        relevance: 0
      },
      {
        beginKeywords: "module",
        end: /\{/,
        excludeEnd: true
      },
      {
        beginKeywords: "namespace",
        end: /\{/,
        excludeEnd: true,
        contains: [TITLE_MODE2]
      },
      {
        beginKeywords: "interface",
        end: /\{/,
        excludeEnd: true,
        keywords: "interface extends",
        contains: [TITLE_MODE2]
      },
      {
        begin: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      },
      {
        begin: "\\." + IDENT_RE,
        relevance: 0
        // hack: prevents detection of keywords after dots
      },
      {
        className: "meta",
        begin: "@[A-Za-z]+"
      }
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/coffeescript.js
  var KEYWORDS4 = {
    keyword: (
      // JS keywords
      "in if for while finally new do return else break catch instanceof throw try this switch continue typeof delete debugger super yield import export from as default await then unless until loop of by when and or is isnt not"
    ),
    literal: (
      // JS literals
      "true false null undefined yes no on off"
    ),
    built_in: "npm require console print module global window document"
  };
  var JS_IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
  var SUBST = {
    className: "subst",
    begin: /#\{/,
    end: /}/,
    keywords: KEYWORDS4
  };
  var EXPRESSIONS = [
    BINARY_NUMBER_MODE,
    __assign({}, C_NUMBER_MODE, { starts: { end: "(\\s*/)?", relevance: 0 } }),
    {
      className: "string",
      variants: [
        {
          begin: /'''/,
          end: /'''/,
          contains: [BACKSLASH_ESCAPE]
        },
        {
          begin: /'/,
          end: /'/,
          contains: [BACKSLASH_ESCAPE]
        },
        {
          begin: /"""/,
          end: /"""/,
          contains: [BACKSLASH_ESCAPE, SUBST]
        },
        {
          begin: /"/,
          end: /"/,
          contains: [BACKSLASH_ESCAPE, SUBST]
        }
      ]
    },
    {
      className: "regexp",
      variants: [
        {
          begin: "///",
          end: "///",
          contains: [SUBST, HASH_COMMENT_MODE]
        },
        {
          begin: "//[gim]*",
          relevance: 0
        },
        {
          // regex can't start with space to parse x / 2 / 3 as two divisions
          // regex can't start with *, and it supports an "illegal" in the main mode
          begin: /\/(?![ *])(\\\/|.)*?\/[gim]*(?=\W|$)/
        }
      ]
    },
    {
      begin: "@" + JS_IDENT_RE
      // relevance booster
    },
    {
      subLanguage: "javascript",
      excludeBegin: true,
      excludeEnd: true,
      variants: [
        {
          begin: "```",
          end: "```"
        },
        {
          begin: "`",
          end: "`"
        }
      ]
    }
  ];
  SUBST.contains = EXPRESSIONS;
  var TITLE = __assign({}, TITLE_MODE, { begin: JS_IDENT_RE });
  var PARAMS_RE = "(\\(.*\\))?\\s*\\B[-=]>";
  var PARAMS = {
    className: "params",
    begin: "\\([^\\(]",
    returnBegin: true,
    /* We need another contained nameless mode to not have every nested
    pair of parens to be called "params" */
    contains: [{
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS4,
      contains: ["self"].concat(EXPRESSIONS)
    }]
  };
  var CoffeeScript = {
    name: "coffeescript",
    aliases: ["coffee", "cson", "iced"],
    keywords: KEYWORDS4,
    illegal: /\/\*/,
    contains: EXPRESSIONS.concat([
      COMMENT("###", "###"),
      HASH_COMMENT_MODE,
      {
        className: "function",
        begin: "^\\s*" + JS_IDENT_RE + "\\s*=\\s*" + PARAMS_RE,
        end: "[-=]>",
        returnBegin: true,
        contains: [TITLE, PARAMS]
      },
      {
        // anonymous function start
        begin: /[:\(,=]\s*/,
        relevance: 0,
        contains: [
          {
            className: "function",
            begin: PARAMS_RE,
            end: "[-=]>",
            returnBegin: true,
            contains: [PARAMS]
          }
        ]
      },
      {
        className: "class",
        beginKeywords: "class",
        end: "$",
        illegal: /[:="\[\]]/,
        contains: [
          {
            beginKeywords: "extends",
            endsWithParent: true,
            illegal: /[:="\[\]]/,
            contains: [TITLE]
          },
          TITLE
        ]
      },
      {
        begin: JS_IDENT_RE + ":",
        end: ":",
        returnBegin: true,
        returnEnd: true,
        relevance: 0
      }
    ])
  };

  // frontend/node_modules/highlight-ts/es/languages/javascript.js
  var IDENT_RE3 = "[A-Za-z$_][0-9A-Za-z$_]*";
  var KEYWORDS5 = {
    keyword: "in of if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const export super debugger as async await static import from as",
    literal: "true false null undefined NaN Infinity",
    built_in: "eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect Promise"
  };
  var NUMBER3 = {
    className: "number",
    variants: [
      { begin: "\\b(0[bB][01]+)" },
      { begin: "\\b(0[oO][0-7]+)" },
      { begin: C_NUMBER_RE }
    ],
    relevance: 0
  };
  var SUBST2 = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS5,
    contains: []
    // defined later
  };
  var TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      BACKSLASH_ESCAPE,
      SUBST2
    ]
  };
  SUBST2.contains = [
    APOS_STRING_MODE,
    QUOTE_STRING_MODE,
    TEMPLATE_STRING,
    NUMBER3,
    REGEXP_MODE
  ];
  var PARAMS_CONTAINS2 = SUBST2.contains.concat([
    C_BLOCK_COMMENT_MODE,
    C_LINE_COMMENT_MODE
  ]);
  var JavaScript = {
    name: "javascript",
    aliases: ["js", "jsx"],
    keywords: KEYWORDS5,
    contains: [
      {
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      },
      {
        className: "meta",
        begin: /^#!/,
        end: /$/
      },
      APOS_STRING_MODE,
      QUOTE_STRING_MODE,
      TEMPLATE_STRING,
      C_LINE_COMMENT_MODE,
      C_BLOCK_COMMENT_MODE,
      NUMBER3,
      {
        begin: /[{,]\s*/,
        relevance: 0,
        contains: [
          {
            begin: IDENT_RE3 + "\\s*:",
            returnBegin: true,
            relevance: 0,
            contains: [{ className: "attr", begin: IDENT_RE3, relevance: 0 }]
          }
        ]
      },
      {
        begin: "(" + RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        contains: [
          C_LINE_COMMENT_MODE,
          C_BLOCK_COMMENT_MODE,
          REGEXP_MODE,
          {
            className: "function",
            begin: "(\\(.*?\\)|" + IDENT_RE3 + ")\\s*=>",
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: IDENT_RE3
                  },
                  {
                    begin: /\(\s*\)/
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS5,
                    contains: PARAMS_CONTAINS2
                  }
                ]
              }
            ]
          },
          {
            begin: /</,
            end: /(\/\w+|\w+\/)>/,
            subLanguage: "xml",
            contains: [
              { begin: /<\w+\s*\/>/, skip: true },
              {
                begin: /<\w+/,
                end: /(\/\w+|\w+\/)>/,
                skip: true,
                contains: [
                  { begin: /<\w+\s*\/>/, skip: true },
                  "self"
                ]
              }
            ]
          }
        ],
        relevance: 0
      },
      {
        className: "function",
        beginKeywords: "function",
        end: /\{/,
        excludeEnd: true,
        contains: [
          __assign({}, TITLE_MODE, { begin: IDENT_RE3 }),
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            contains: PARAMS_CONTAINS2
          }
        ],
        illegal: /\[|%/
      },
      {
        begin: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      },
      METHOD_GUARD,
      {
        className: "class",
        beginKeywords: "class",
        end: /[{;=]/,
        excludeEnd: true,
        illegal: /[:"\[\]]/,
        contains: [
          { beginKeywords: "extends" },
          UNDERSCORE_TITLE_MODE
        ]
      },
      {
        beginKeywords: "constructor",
        end: /\{/,
        excludeEnd: true
      }
    ],
    illegal: /#(?!!)/
  };

  // frontend/node_modules/highlight-ts/es/languages/python.js
  var KEYWORDS6 = {
    keyword: "and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda async await nonlocal|10 None True False",
    built_in: "Ellipsis NotImplemented"
  };
  var PROMPT = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  };
  var SUBST3 = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS6,
    illegal: /#/
  };
  var STRING3 = {
    className: "string",
    contains: [BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /(u|b)?r?'''/,
        end: /'''/,
        contains: [PROMPT],
        relevance: 10
      },
      {
        begin: /(u|b)?r?"""/,
        end: /"""/,
        contains: [PROMPT],
        relevance: 10
      },
      {
        begin: /(fr|rf|f)'''/,
        end: /'''/,
        contains: [PROMPT, SUBST3]
      },
      {
        begin: /(fr|rf|f)"""/,
        end: /"""/,
        contains: [PROMPT, SUBST3]
      },
      {
        begin: /(u|r|ur)'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /(u|r|ur)"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /(b|br)'/,
        end: /'/
      },
      {
        begin: /(b|br)"/,
        end: /"/
      },
      {
        begin: /(fr|rf|f)'/,
        end: /'/,
        contains: [SUBST3]
      },
      {
        begin: /(fr|rf|f)"/,
        end: /"/,
        contains: [SUBST3]
      },
      APOS_STRING_MODE,
      QUOTE_STRING_MODE
    ]
  };
  var NUMBER4 = {
    className: "number",
    relevance: 0,
    variants: [
      { begin: BINARY_NUMBER_RE + "[lLjJ]?" },
      { begin: "\\b(0o[0-7]+)[lLjJ]?" },
      { begin: C_NUMBER_RE + "[lLjJ]?" }
    ]
  };
  var PARAMS2 = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    contains: ["self", PROMPT, NUMBER4, STRING3]
  };
  SUBST3.contains = [STRING3, NUMBER4, PROMPT];
  var Python = {
    name: "python",
    aliases: ["py", "gyp"],
    keywords: KEYWORDS6,
    illegal: /(<\/|->|\?)|=>/,
    contains: [
      PROMPT,
      NUMBER4,
      STRING3,
      HASH_COMMENT_MODE,
      {
        variants: [
          { className: "function", beginKeywords: "def" },
          { className: "class", beginKeywords: "class" }
        ],
        end: /:/,
        illegal: /[${=;\n,]/,
        contains: [
          UNDERSCORE_TITLE_MODE,
          PARAMS2,
          {
            begin: /->/,
            endsWithParent: true,
            keywords: "None"
          }
        ]
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /$/
      },
      {
        begin: /\b(print|exec)\(/
        // don’t highlight keywords-turned-functions in Python 3
      }
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/php.js
  var VARIABLE2 = {
    begin: "\\$+[a-zA-Z_\x7F-\xFF][a-zA-Z0-9_\x7F-\xFF]*"
  };
  var PREPROCESSOR3 = {
    className: "meta",
    begin: /<\?(php)?|\?>/
  };
  var STRING4 = {
    className: "string",
    contains: [BACKSLASH_ESCAPE, PREPROCESSOR3],
    variants: [
      {
        begin: 'b"',
        end: '"'
      },
      {
        begin: "b'",
        end: "'"
      },
      __assign({}, APOS_STRING_MODE, { illegal: void 0 }),
      __assign({}, QUOTE_STRING_MODE, { illegal: void 0 })
    ]
  };
  var NUMBER5 = { variants: [BINARY_NUMBER_MODE, C_NUMBER_MODE] };
  var PHP = {
    name: "php",
    aliases: ["php3", "php4", "php5", "php6"],
    case_insensitive: true,
    keywords: "and include_once list abstract global private echo interface as static endswitch array null if endwhile or const for endforeach self var while isset public protected exit foreach throw elseif include __FILE__ empty require_once do xor return parent clone use __CLASS__ __LINE__ else break print eval new catch __METHOD__ case exception default die require __FUNCTION__ enddeclare final try switch continue endfor endif declare unset true false trait goto instanceof insteadof __DIR__ __NAMESPACE__ yield finally",
    contains: [
      HASH_COMMENT_MODE,
      COMMENT("//", "$", { contains: [PREPROCESSOR3] }),
      COMMENT("/\\*", "\\*/", {
        contains: [
          {
            className: "doctag",
            begin: "@[A-Za-z]+"
          }
        ]
      }),
      COMMENT("__halt_compiler.+?;", void 0, {
        endsWithParent: true,
        keywords: "__halt_compiler",
        lexemes: UNDERSCORE_IDENT_RE
      }),
      {
        className: "string",
        begin: /<<<['"]?\w+['"]?$/,
        end: /^\w+;?$/,
        contains: [
          BACKSLASH_ESCAPE,
          {
            className: "subst",
            variants: [
              { begin: /\$\w+/ },
              { begin: /\{\$/, end: /\}/ }
            ]
          }
        ]
      },
      PREPROCESSOR3,
      {
        className: "keyword",
        begin: /\$this\b/
      },
      VARIABLE2,
      {
        // swallow composed identifiers to avoid parsing them as keywords
        begin: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/
      },
      {
        className: "function",
        beginKeywords: "function",
        end: /[;{]/,
        excludeEnd: true,
        illegal: "\\$|\\[|%",
        contains: [
          UNDERSCORE_TITLE_MODE,
          {
            className: "params",
            begin: "\\(",
            end: "\\)",
            contains: [
              "self",
              VARIABLE2,
              C_BLOCK_COMMENT_MODE,
              STRING4,
              NUMBER5
            ]
          }
        ]
      },
      {
        className: "class",
        beginKeywords: "class interface",
        end: "{",
        excludeEnd: true,
        illegal: /[:\(\$"]/,
        contains: [
          { beginKeywords: "extends implements" },
          UNDERSCORE_TITLE_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        end: ";",
        illegal: /[\.']/,
        contains: [UNDERSCORE_TITLE_MODE]
      },
      {
        beginKeywords: "use",
        end: ";",
        contains: [UNDERSCORE_TITLE_MODE]
      },
      {
        begin: "=>"
        // No markup, just a relevance booster
      },
      STRING4,
      NUMBER5
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/sql.js
  var COMMENT_MODE = COMMENT("--", "$");

  // frontend/node_modules/highlight-ts/es/languages/makefile.js
  var VARIABLE3 = {
    className: "variable",
    variants: [
      {
        begin: "\\$\\(" + UNDERSCORE_IDENT_RE + "\\)",
        contains: [BACKSLASH_ESCAPE]
      },
      {
        begin: /\$[@%<?\^\+\*]/
      }
    ]
  };
  var VAR_ASSIG = {
    begin: "^" + UNDERSCORE_IDENT_RE + "\\s*[:+?]?=",
    illegal: "\\n",
    returnBegin: true,
    contains: [
      {
        begin: "^" + UNDERSCORE_IDENT_RE,
        end: "[:+?]?=",
        excludeEnd: true
      }
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/bash.js
  var VAR = {
    className: "variable",
    variants: [
      { begin: /\$[\w\d#@][\w\d_]*/ },
      { begin: /\$\{(.*?)}/ }
    ]
  };
  var QUOTE_STRING = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      BACKSLASH_ESCAPE,
      VAR,
      {
        className: "variable",
        begin: /\$\(/,
        end: /\)/,
        contains: [BACKSLASH_ESCAPE]
      }
    ]
  };
  var APOS_STRING = {
    className: "string",
    begin: /'/,
    end: /'/
  };
  var Bash = {
    name: "bash",
    aliases: ["sh", "zsh"],
    lexemes: /\b-?[a-z\._]+\b/,
    keywords: {
      keyword: "if then else elif fi for while in do done case esac function",
      literal: "true false",
      built_in: (
        // Shell built-ins
        // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
        "break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp"
      ),
      _: "-ne -eq -lt -gt -f -d -e -s -l -a"
      // relevance booster
    },
    contains: [
      {
        className: "meta",
        begin: /^#![^\n]+sh\s*$/,
        relevance: 10
      },
      {
        className: "function",
        begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
        returnBegin: true,
        contains: [__assign({}, TITLE_MODE, { begin: /\w[\w\d_]*/ })],
        relevance: 0
      },
      HASH_COMMENT_MODE,
      QUOTE_STRING,
      APOS_STRING,
      VAR
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/nginx.js
  var VAR2 = {
    className: "variable",
    variants: [
      { begin: /\$\d+/ },
      { begin: /\$\{/, end: /}/ },
      { begin: "[\\$\\@]" + UNDERSCORE_IDENT_RE }
    ]
  };
  var DEFAULT = {
    endsWithParent: true,
    lexemes: "[a-z/_]+",
    keywords: {
      literal: "on off yes no true false none blocked debug info notice warn error crit select break last permanent redirect kqueue rtsig epoll poll /dev/poll"
    },
    relevance: 0,
    illegal: "=>",
    contains: [
      HASH_COMMENT_MODE,
      {
        className: "string",
        contains: [BACKSLASH_ESCAPE, VAR2],
        variants: [
          { begin: /"/, end: /"/ },
          { begin: /'/, end: /'/ }
        ]
      },
      // this swallows entire URLs to avoid detecting numbers within
      {
        begin: "([a-z]+):/",
        end: "\\s",
        endsWithParent: true,
        excludeEnd: true,
        contains: [VAR2]
      },
      {
        className: "regexp",
        contains: [BACKSLASH_ESCAPE, VAR2],
        variants: [
          { begin: "\\s\\^", end: "\\s|{|;", returnEnd: true },
          // regexp locations (~, ~*)
          { begin: "~\\*?\\s+", end: "\\s|{|;", returnEnd: true },
          // *.example.com
          { begin: "\\*(\\.[a-z\\-]+)+" },
          // sub.example.*
          { begin: "([a-z\\-]+\\.)+\\*" }
        ]
      },
      // IP
      {
        className: "number",
        begin: "\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b"
      },
      // units
      {
        className: "number",
        begin: "\\b\\d+[kKmMgGdshdwy]*\\b",
        relevance: 0
      },
      VAR2
    ]
  };
  var Nginx = {
    name: "nginx",
    aliases: ["nginxconf"],
    contains: [
      HASH_COMMENT_MODE,
      {
        begin: UNDERSCORE_IDENT_RE + "\\s+{",
        returnBegin: true,
        end: "{",
        contains: [
          {
            className: "section",
            begin: UNDERSCORE_IDENT_RE
          }
        ],
        relevance: 0
      },
      {
        begin: UNDERSCORE_IDENT_RE + "\\s",
        end: ";|{",
        returnBegin: true,
        contains: [
          {
            className: "attribute",
            begin: UNDERSCORE_IDENT_RE,
            starts: DEFAULT
          }
        ],
        relevance: 0
      }
    ],
    illegal: "[^\\s\\}]"
  };

  // frontend/node_modules/highlight-ts/es/languages/nix.js
  var NIX_KEYWORDS = {
    keyword: "rec with let in inherit assert if else then",
    literal: "true false or and null",
    built_in: "import abort baseNameOf dirOf isNull builtins map removeAttrs throw toString derivation"
  };
  var ANTIQUOTE = {
    className: "subst",
    begin: /\$\{/,
    end: /}/,
    keywords: NIX_KEYWORDS
  };
  var ATTRS = {
    begin: /[a-zA-Z0-9-_]+(\s*=)/,
    returnBegin: true,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: /\S+/
      }
    ]
  };
  var STRING5 = {
    className: "string",
    contains: [ANTIQUOTE],
    variants: [
      { begin: "''", end: "''" },
      { begin: '"', end: '"' }
    ]
  };
  var EXPRESSIONS2 = [
    NUMBER_MODE,
    HASH_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE,
    STRING5,
    ATTRS
  ];
  ANTIQUOTE.contains = EXPRESSIONS2;

  // frontend/node_modules/highlight-ts/es/languages/openscad.js
  var STRING6 = __assign({}, QUOTE_STRING_MODE, { illegal: void 0 });

  // frontend/node_modules/highlight-ts/es/languages/gcode.js
  var GCODE_IDENT_RE = "[A-Z_][A-Z0-9_.]*";
  var GCODE_CLOSE_RE = "\\%";
  var GCODE_KEYWORDS = "IF DO WHILE ENDWHILE CALL ENDIF SUB ENDSUB GOTO REPEAT ENDREPEAT EQ LT GT NE GE LE OR XOR";
  var GCODE_START = {
    className: "meta",
    begin: "([O])([0-9]+)"
  };
  var GCODE_CODE = [
    C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE,
    COMMENT(/\(/, /\)/),
    __assign({}, C_NUMBER_MODE, { begin: "([-+]?([0-9]*\\.?[0-9]+\\.?))|" + C_NUMBER_RE }),
    __assign({}, APOS_STRING_MODE, { illegal: void 0 }),
    __assign({}, QUOTE_STRING_MODE, { illegal: void 0 }),
    {
      className: "name",
      begin: "([G])([0-9]+\\.?[0-9]?)"
    },
    {
      className: "name",
      begin: "([M])([0-9]+\\.?[0-9]?)"
    },
    {
      className: "attr",
      begin: "(VC|VS|#)",
      end: "(\\d+)"
    },
    {
      className: "attr",
      begin: "(VZOFX|VZOFY|VZOFZ)"
    },
    {
      className: "built_in",
      begin: "(ATAN|ABS|ACOS|ASIN|SIN|COS|EXP|FIX|FUP|ROUND|LN|TAN)(\\[)",
      end: "([-+]?([0-9]*\\.?[0-9]+\\.?))(\\])"
    },
    {
      className: "symbol",
      variants: [
        {
          begin: "N",
          end: "\\d+",
          illegal: "\\W"
        }
      ]
    }
  ];
  var GCode = {
    name: "gcode",
    aliases: ["nc"],
    // Some implementations (CNC controls) of G-code are interoperable with uppercase and lowercase letters seamlessly.
    // However, most prefer all uppercase and uppercase is customary.
    case_insensitive: true,
    lexemes: GCODE_IDENT_RE,
    keywords: GCODE_KEYWORDS,
    contains: [
      {
        className: "meta",
        begin: GCODE_CLOSE_RE
      },
      GCODE_START
    ].concat(GCODE_CODE)
  };

  // frontend/node_modules/highlight-ts/es/languages/http.js
  var VERSION = "HTTP/[0-9\\.]+";
  var HTTP = {
    name: "http",
    aliases: ["https"],
    illegal: "\\S",
    contains: [
      {
        begin: "^" + VERSION,
        end: "$",
        contains: [
          {
            className: "number",
            begin: "\\b\\d{3}\\b"
          },
          {
            className: "string",
            begin: "\\b[A-Za-z]+",
            end: "$"
          }
        ]
      },
      {
        begin: "^[A-Z]+ (.*?) " + VERSION + "$",
        returnBegin: true,
        end: "$",
        contains: [
          {
            className: "string",
            begin: " ",
            end: " ",
            excludeBegin: true,
            excludeEnd: true
          },
          {
            begin: VERSION
          },
          {
            className: "keyword",
            begin: "[A-Z]+"
          }
        ]
      },
      {
        className: "attribute",
        begin: "^\\w",
        end: ": ",
        excludeEnd: true,
        illegal: "\\n|\\s|=",
        starts: { end: "$", relevance: 0 }
      },
      {
        begin: "\\n\\n",
        starts: { subLanguage: [], endsWithParent: true }
      }
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/ini.js
  var STRING7 = {
    className: "string",
    contains: [BACKSLASH_ESCAPE],
    variants: [
      {
        begin: "'''",
        end: "'''",
        relevance: 10
      },
      {
        begin: '"""',
        end: '"""',
        relevance: 10
      },
      {
        begin: '"',
        end: '"'
      },
      {
        begin: "'",
        end: "'"
      }
    ]
  };
  var INI = {
    name: "ini",
    aliases: ["toml"],
    case_insensitive: true,
    illegal: /\S/,
    contains: [
      COMMENT(";", "$"),
      HASH_COMMENT_MODE,
      {
        className: "section",
        begin: /^\s*\[+/,
        end: /\]+/
      },
      {
        begin: /^[a-z0-9\[\]_-]+\s*=\s*/,
        end: "$",
        returnBegin: true,
        contains: [
          {
            className: "attr",
            begin: /[a-z0-9\[\]_-]+/
          },
          {
            begin: /=/,
            endsWithParent: true,
            relevance: 0,
            contains: [
              {
                className: "literal",
                begin: /\bon|off|true|false|yes|no\b/
              },
              {
                className: "variable",
                variants: [
                  { begin: /\$[\w\d"][\w\d_]*/ },
                  { begin: /\$\{(.*?)}/ }
                ]
              },
              STRING7,
              {
                className: "number",
                begin: /([\+\-]+)?[\d]+_[\d_]+/
              },
              NUMBER_MODE
            ]
          }
        ]
      }
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/json.js
  var LITERALS = { literal: "true false null" };
  var TYPES = [
    QUOTE_STRING_MODE,
    C_NUMBER_MODE
  ];
  var VALUE_CONTAINER = {
    end: ",",
    endsWithParent: true,
    excludeEnd: true,
    contains: TYPES,
    keywords: LITERALS
  };
  var OBJECT = {
    begin: "{",
    end: "}",
    contains: [
      {
        className: "attr",
        begin: /"/,
        end: /"/,
        contains: [BACKSLASH_ESCAPE],
        illegal: "\\n"
      },
      __assign({}, VALUE_CONTAINER, { begin: /:/ })
    ],
    illegal: "\\S"
  };
  var ARRAY = {
    begin: "\\[",
    end: "\\]",
    contains: [__assign({}, VALUE_CONTAINER)],
    illegal: "\\S"
  };
  TYPES.splice(TYPES.length, 0, OBJECT, ARRAY);
  var JSON2 = {
    name: "json",
    contains: TYPES,
    keywords: LITERALS,
    illegal: "\\S"
  };

  // frontend/node_modules/highlight-ts/es/languages/yaml.js
  var LITERALS2 = "true false yes no null";
  var keyPrefix = "^[ \\-]*";
  var keyName = "[a-zA-Z_][\\w\\-]*";
  var KEY = {
    className: "attr",
    variants: [
      { begin: keyPrefix + keyName + ":" },
      { begin: keyPrefix + '"' + keyName + '":' },
      { begin: keyPrefix + "'" + keyName + "':" }
    ]
  };
  var TEMPLATE_VARIABLES = {
    className: "template-variable",
    variants: [
      { begin: "{{", end: "}}" },
      { begin: "%{", end: "}" }
      // Ruby i18n
    ]
  };
  var STRING8 = {
    className: "string",
    relevance: 0,
    variants: [
      { begin: /'/, end: /'/ },
      { begin: /"/, end: /"/ },
      { begin: /\S+/ }
    ],
    contains: [
      BACKSLASH_ESCAPE,
      TEMPLATE_VARIABLES
    ]
  };
  var YAML = {
    name: "yaml",
    case_insensitive: true,
    aliases: ["yml", "YAML", "yaml"],
    contains: [
      KEY,
      {
        className: "meta",
        begin: "^---s*$",
        relevance: 10
      },
      {
        className: "string",
        begin: "[\\|>] *$",
        returnEnd: true,
        contains: STRING8.contains,
        // very simple termination: next hash key
        end: KEY.variants[0].begin
      },
      {
        begin: "<%[%=-]?",
        end: "[%-]?%>",
        subLanguage: "ruby",
        excludeBegin: true,
        excludeEnd: true,
        relevance: 0
      },
      {
        className: "type",
        begin: "!!" + UNDERSCORE_IDENT_RE
      },
      {
        className: "meta",
        begin: "&" + UNDERSCORE_IDENT_RE + "$"
      },
      {
        className: "meta",
        begin: "\\*" + UNDERSCORE_IDENT_RE + "$"
      },
      {
        className: "bullet",
        begin: "^ *-",
        relevance: 0
      },
      HASH_COMMENT_MODE,
      {
        beginKeywords: LITERALS2,
        keywords: { literal: LITERALS2 }
      },
      C_NUMBER_MODE,
      STRING8
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/less.js
  var IDENT_RE4 = "[\\w-]+";
  var INTERP_IDENT_RE = "(" + IDENT_RE4 + "|@{" + IDENT_RE4 + "})";
  var RULES = [];
  var VALUE = [];
  var STRING_MODE = function(c7) {
    return {
      // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
      className: "string",
      begin: "~?" + c7 + ".*?" + c7
    };
  };
  var IDENT_MODE = function(className, begin, relevance) {
    return { className, begin, relevance };
  };
  var PARENS_MODE = {
    // used only to properly balance nested parens inside mixin call, def. arg list
    begin: "\\(",
    end: "\\)",
    contains: VALUE,
    relevance: 0
  };
  VALUE.push(
    C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE,
    STRING_MODE("'"),
    STRING_MODE('"'),
    CSS_NUMBER_MODE,
    // fixme: it does not include dot for numbers like .5em :(
    {
      begin: "(url|data-uri)\\(",
      starts: { className: "string", end: "[\\)\\n]", excludeEnd: true }
    },
    IDENT_MODE("number", "#[0-9A-Fa-f]+\\b"),
    PARENS_MODE,
    IDENT_MODE("variable", "@@?" + IDENT_RE4, 10),
    IDENT_MODE("variable", "@{" + IDENT_RE4 + "}"),
    IDENT_MODE("built_in", "~?`[^`]*?`"),
    // inline javascript (or whatever host language) *multiline* string
    {
      className: "attribute",
      begin: IDENT_RE4 + "\\s*:",
      end: ":",
      returnBegin: true,
      excludeEnd: true
    },
    {
      className: "meta",
      begin: "!important"
    }
  );
  var VALUE_WITH_RULESETS = VALUE.concat({
    begin: "{",
    end: "}",
    contains: RULES
  });
  var MIXIN_GUARD_MODE = {
    beginKeywords: "when",
    endsWithParent: true,
    contains: [{ beginKeywords: "and not" }].concat(VALUE)
    // using this form to override VALUE’s 'function' match
  };
  var RULE_MODE = {
    begin: INTERP_IDENT_RE + "\\s*:",
    returnBegin: true,
    end: "[;}]",
    relevance: 0,
    contains: [
      {
        className: "attribute",
        begin: INTERP_IDENT_RE,
        end: ":",
        excludeEnd: true,
        starts: {
          endsWithParent: true,
          illegal: "[<=$]",
          relevance: 0,
          contains: VALUE
        }
      }
    ]
  };
  var AT_RULE_MODE = {
    className: "keyword",
    begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
    starts: { end: "[;{}]", returnEnd: true, contains: VALUE, relevance: 0 }
  };
  var VAR_RULE_MODE = {
    className: "variable",
    variants: [
      // using more strict pattern for higher relevance to increase chances of Less detection.
      // this is *the only* Less specific statement used in most of the sources, so...
      // (we’ll still often loose to the css-parser unless there's '//' comment,
      // simply because 1 variable just can't beat 99 properties :)
      { begin: "@" + IDENT_RE4 + "\\s*:", relevance: 15 },
      { begin: "@" + IDENT_RE4 }
    ],
    starts: { end: "[;}]", returnEnd: true, contains: VALUE_WITH_RULESETS }
  };
  var SELECTOR_MODE = {
    // first parse unambiguous selectors (i.e. those not starting with tag)
    // then fall into the scary lookahead-discriminator variant.
    // this mode also handles mixin definitions and calls
    variants: [{
      begin: "[\\.#:&\\[>]",
      end: "[;{}]"
      // mixin calls end with ';'
    }, {
      begin: INTERP_IDENT_RE,
      end: "{"
    }],
    returnBegin: true,
    returnEnd: true,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      C_LINE_COMMENT_MODE,
      C_BLOCK_COMMENT_MODE,
      MIXIN_GUARD_MODE,
      IDENT_MODE("keyword", "all\\b"),
      IDENT_MODE("variable", "@{" + IDENT_RE4 + "}"),
      IDENT_MODE("selector-tag", INTERP_IDENT_RE + "%?", 0),
      IDENT_MODE("selector-id", "#" + INTERP_IDENT_RE),
      IDENT_MODE("selector-class", "\\." + INTERP_IDENT_RE, 0),
      IDENT_MODE("selector-tag", "&", 0),
      { className: "selector-attr", begin: "\\[", end: "\\]" },
      { className: "selector-pseudo", begin: /:(:)?[a-zA-Z0-9\_\-\+\(\)"'.]+/ },
      { begin: "\\(", end: "\\)", contains: VALUE_WITH_RULESETS },
      { begin: "!important" }
      // eat !important after mixin call or it will be colored as tag
    ]
  };
  RULES.push(C_LINE_COMMENT_MODE, C_BLOCK_COMMENT_MODE, AT_RULE_MODE, VAR_RULE_MODE, RULE_MODE, SELECTOR_MODE);

  // frontend/node_modules/highlight-ts/es/languages/scss.js
  var IDENT_RE5 = "[a-zA-Z-][a-zA-Z0-9_-]*";
  var VARIABLE4 = {
    className: "variable",
    begin: "(\\$" + IDENT_RE5 + ")\\b"
  };

  // frontend/node_modules/highlight-ts/es/languages/xml.js
  var XML_IDENT_RE = "[A-Za-z0-9\\._:-]+";
  var TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: XML_IDENT_RE,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: true,
            variants: [
              { begin: /"/, end: /"/ },
              { begin: /'/, end: /'/ },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  var XML = {
    name: "xml",
    aliases: ["html", "xhtml", "rss", "atom", "xjb", "xsd", "xsl", "plist"],
    case_insensitive: true,
    contains: [
      {
        className: "meta",
        begin: "<!DOCTYPE",
        end: ">",
        relevance: 10,
        contains: [{ begin: "\\[", end: "\\]" }]
      },
      COMMENT("<!--", "-->", {
        relevance: 10
      }),
      {
        begin: "<\\!\\[CDATA\\[",
        end: "\\]\\]>",
        relevance: 10
      },
      {
        className: "meta",
        begin: /<\?xml/,
        end: /\?>/,
        relevance: 10
      },
      {
        begin: /<\?(php)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [{ begin: "/\\*", end: "\\*/", skip: true }]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending braket. The '$' is needed for the lexeme to be recognized
        by subMode() that tests lexemes outside the stream.
        */
        begin: "<style(?=\\s|>|$)",
        end: ">",
        keywords: { name: "style" },
        contains: [TAG_INTERNALS],
        starts: {
          end: "</style>",
          returnEnd: true,
          subLanguage: ["css", "xml"]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: "<script(?=\\s|>|$)",
        end: ">",
        keywords: { name: "script" },
        contains: [TAG_INTERNALS],
        starts: {
          end: "<\/script>",
          returnEnd: true,
          subLanguage: ["actionscript", "javascript", "handlebars", "xml"]
        }
      },
      {
        className: "tag",
        begin: "</?",
        end: "/?>",
        contains: [
          {
            className: "name",
            begin: /[^\/><\s]+/,
            relevance: 0
          },
          TAG_INTERNALS
        ]
      }
    ]
  };

  // frontend/node_modules/highlight-ts/es/languages/markdown.js
  var INLINE_LINK_MODE = {
    begin: "<\\w+:[^>]*>",
    returnBegin: true,
    contains: [
      {
        className: "link",
        begin: "<",
        end: ">",
        excludeBegin: true,
        excludeEnd: true
      }
    ],
    relevance: 5
  };
  var INLINE_HTML_MODE = {
    begin: "<",
    end: ">",
    subLanguage: "xml",
    relevance: 0
  };
  var INLINE_CODE_MODE = {
    className: "code",
    begin: "`.+?`"
  };
  var STRONG_CONTAINS = [
    INLINE_LINK_MODE,
    INLINE_HTML_MODE,
    INLINE_CODE_MODE
  ];
  var STRONG_MODE = {
    className: "strong",
    variants: [
      {
        begin: "\\*{2}",
        end: "\\*{2}",
        contains: STRONG_CONTAINS
      },
      {
        begin: "_{2}",
        end: "_{2}",
        contains: STRONG_CONTAINS
      }
    ]
  };
  var EMPHASIS_CONTAINS = [
    INLINE_LINK_MODE,
    INLINE_HTML_MODE,
    INLINE_CODE_MODE
  ];
  var EMPHASIS_MODE = {
    className: "emphasis",
    variants: [
      {
        begin: "\\*(?!\\*)",
        end: "\\*(?!\\*)",
        contains: EMPHASIS_CONTAINS
      },
      {
        begin: "_(?!_)",
        end: "_(?!_)",
        contains: EMPHASIS_CONTAINS,
        relevance: 0
      }
    ]
  };
  var INLINE_CONTAINS = [
    INLINE_LINK_MODE,
    INLINE_HTML_MODE,
    INLINE_CODE_MODE
  ];
  var LINK_MODE = {
    begin: "\\!?\\[.+?\\][\\(\\[].*?[\\)\\]]",
    returnBegin: true,
    contains: [
      {
        className: "string",
        begin: "\\!?\\[",
        end: "\\]",
        excludeBegin: true,
        returnEnd: true,
        contains: INLINE_CONTAINS,
        relevance: 0
      },
      {
        className: "link",
        begin: "\\]\\(",
        end: "\\)",
        excludeBegin: true,
        excludeEnd: true
      },
      {
        className: "symbol",
        begin: "\\]\\[",
        end: "\\]",
        excludeBegin: true,
        excludeEnd: true
      }
    ],
    relevance: 10
  };
  STRONG_CONTAINS.push(EMPHASIS_MODE);
  STRONG_CONTAINS.push(LINK_MODE);
  EMPHASIS_CONTAINS.push(STRONG_MODE);
  EMPHASIS_CONTAINS.push(LINK_MODE);
  INLINE_CONTAINS.push(STRONG_MODE);
  INLINE_CONTAINS.push(EMPHASIS_MODE);
  INLINE_CONTAINS.push(LINK_MODE);
  var Markdown = {
    name: "markdown",
    aliases: ["md", "mkdown", "mkd"],
    contains: [
      // highlight headers
      {
        className: "section",
        variants: [
          { begin: "^#{1,6}", end: "$" },
          { begin: "^.+?\\n[=-]{2,}$" }
        ],
        contains: INLINE_CONTAINS
      },
      // lists (indicators only)
      {
        className: "bullet",
        begin: "^\\s*([*+-]|(\\d+\\.))\\s+"
      },
      // blockquotes
      {
        className: "quote",
        begin: "^>\\s+",
        end: "$",
        contains: INLINE_CONTAINS
      },
      // code snippets
      {
        className: "code",
        variants: [
          {
            begin: "^```w*s*$",
            end: "^```s*$"
          },
          {
            begin: "^( {4}|	)",
            end: "$",
            relevance: 0
          }
        ]
      },
      // horizontal rules
      {
        begin: "^[-\\*]{3,}",
        end: "$"
      },
      {
        begin: /^\s*\[[^\n]+\]:/,
        returnBegin: true,
        contains: [
          {
            className: "symbol",
            begin: /\s*\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "link",
            begin: /:\s*/,
            end: /$/,
            excludeBegin: true
          }
        ]
      }
    ].concat(INLINE_CONTAINS)
  };

  // frontend/node_modules/highlight-ts/es/languages/tex.js
  var COMMAND = {
    className: "tag",
    begin: /\\/,
    relevance: 0,
    contains: [
      {
        className: "name",
        variants: [
          { begin: /[a-zA-Zа-яА-я]+[*]?/ },
          { begin: /[^a-zA-Zа-яА-я0-9]/ }
        ],
        starts: {
          endsWithParent: true,
          relevance: 0,
          contains: [
            {
              className: "string",
              variants: [
                { begin: /\[/, end: /\]/ },
                { begin: /\{/, end: /\}/ }
              ]
            },
            {
              begin: /\s*=\s*/,
              endsWithParent: true,
              relevance: 0,
              contains: [
                {
                  className: "number",
                  begin: /-?\d*\.?\d+(pt|pc|mm|cm|in|dd|cc|ex|em)?/
                }
              ]
            }
          ]
        }
      }
    ]
  };
  var TeX = {
    name: "tex",
    aliases: ["latex", "xetex"],
    contains: [
      COMMAND,
      {
        className: "formula",
        contains: [COMMAND],
        relevance: 0,
        variants: [
          { begin: /\$\$/, end: /\$\$/ },
          { begin: /\$/, end: /\$/ }
        ]
      },
      COMMENT("%", "$", {
        relevance: 0
      })
    ]
  };

  // frontend/ts/components/lit/syntaxHighlighter.ts
  registerLanguages(JavaScript, TypeScript, Python, JSON2, Markdown);
  var options = {
    classPrefix: "hljs-",
    useBr: true
  };
  var highlighter = init(htmlRender, options);
  var SyntaxHighlighter = class extends h7 {
    constructor() {
      super(...arguments);
      this.lang = "plaintext";
      this.code = "";
    }
    render() {
      const highlightedCode = process(highlighter, this.code, this.lang);
      return ke`<pre>${ae(highlightedCode.value)}</pre>`;
    }
    connectedCallback() {
      super.connectedCallback();
      if (!this.code) {
        this.code = this.textContent || "";
      }
    }
  };
  SyntaxHighlighter.styles = i5`
    /*
    
    Intellij Idea-like styling (c) Vasily Polovnyov <vast@whiteants.net>
    
    */

    .hljs {
      display: block;
      overflow-x: auto;
      padding: 0.5em;
      color: #000;
      background: #fff;
    }

    .hljs-subst,
    .hljs-title {
      font-weight: normal;
      color: #000;
    }

    .hljs-comment,
    .hljs-quote {
      color: #808080;
      font-style: italic;
    }

    .hljs-meta {
      color: #808000;
    }

    .hljs-tag {
      background: #efefef;
    }

    .hljs-section,
    .hljs-name,
    .hljs-literal,
    .hljs-keyword,
    .hljs-selector-tag,
    .hljs-type,
    .hljs-selector-id,
    .hljs-selector-class {
      font-weight: bold;
      color: #000080;
    }

    .hljs-attribute,
    .hljs-number,
    .hljs-regexp,
    .hljs-link {
      font-weight: bold;
      color: #0000ff;
    }

    .hljs-number,
    .hljs-regexp,
    .hljs-link {
      font-weight: normal;
    }

    .hljs-string {
      color: #008000;
      font-weight: bold;
    }

    .hljs-symbol,
    .hljs-bullet,
    .hljs-formula {
      color: #000;
      background: #d0eded;
      font-style: italic;
    }

    .hljs-doctag {
      text-decoration: underline;
    }

    .hljs-variable,
    .hljs-template-variable {
      color: #660e7a;
    }

    .hljs-addition {
      background: #baeeba;
    }

    .hljs-deletion {
      background: #ffc8bd;
    }

    .hljs-emphasis {
      font-style: italic;
    }

    .hljs-strong {
      font-weight: bold;
    }
  `;
  __decorateClass([
    n6({ type: String })
  ], SyntaxHighlighter.prototype, "lang", 2);
  __decorateClass([
    n6({ type: String })
  ], SyntaxHighlighter.prototype, "code", 2);
  SyntaxHighlighter = __decorateClass([
    t6("syntax-hl")
  ], SyntaxHighlighter);

  // frontend/ts/components/lit/foldableCard.ts
  var sheet2 = cssomSheet({ target: new CSSStyleSheet() });
  var { tw: tw3 } = create({ sheet: sheet2 });
  var FoldableCard = class extends h7 {
    constructor() {
      super(...arguments);
      this._title = "";
      this.isUnfolded = false;
    }
    get title() {
      return this._title;
    }
    set title(value) {
      const oldValue = this._title;
      this._title = value;
      this.requestUpdate("title", oldValue);
    }
    render() {
      const wrapperClasses = tw3`my-4`;
      const cardClasses = tw3`
      bg-white rounded-lg shadow-md transition-all duration-300 ease-in-out
      border border-gray-200 p-2
      ${this.isUnfolded ? "unfolded" : ""}
    `;
      const headerClasses = tw3`
      flex items-center cursor-pointer
      ${this.isUnfolded ? "mb-2" : ""}
    `;
      const arrowClasses = tw3`
      text-blue-500 transition-transform duration-300 ease-in-out
      ${this.isUnfolded ? "transform rotate-90" : ""}
      mr-2
    `;
      const titleClasses = tw3`text-lg font-semibold m-0 truncate flex-grow`;
      const dividerClasses = tw3`
      border-t border-gray-200 my-2
      ${this.isUnfolded ? "" : "hidden"}
    `;
      return ke`
      <div class="${wrapperClasses}">
        <div class="${cardClasses} card">
          <div class="${headerClasses}" @click=${this.toggleFold}>
            <span class="${arrowClasses}" aria-hidden="true">&#10095;</span>
            <h2 class="${titleClasses}">${this.title}</h2>
          </div>
          <div class="card-content">
            <div class="${dividerClasses}"></div>
            <slot></slot>
          </div>
        </div>
      </div>
    `;
    }
    toggleFold() {
      this.isUnfolded = !this.isUnfolded;
      this.requestUpdate();
    }
  };
  FoldableCard.styles = [
    sheet2.target,
    i5`
      .card {
        display: grid;
        grid-template-rows: auto 0fr;
        transition: grid-template-rows 0.3s ease-out;
      }
      .card.unfolded {
        grid-template-rows: auto 1fr;
      }
      .card-content {
        overflow: hidden;
      }
    `
  ];
  __decorateClass([
    n6({ type: String })
  ], FoldableCard.prototype, "title", 1);
  __decorateClass([
    r6()
  ], FoldableCard.prototype, "isUnfolded", 2);
  FoldableCard = __decorateClass([
    t6("foldable-card")
  ], FoldableCard);

  // frontend/node_modules/lit-html/directive-helpers.js
  var { I: et2 } = si;
  var lt2 = () => document.createComment("");
  var at = (o7, t9, i9) => {
    const n7 = o7._$AA.parentNode, e9 = void 0 === t9 ? o7._$AB : t9._$AA;
    if (void 0 === i9) {
      const t10 = n7.insertBefore(lt2(), e9), l4 = n7.insertBefore(lt2(), e9);
      i9 = new et2(t10, l4, o7, o7.options);
    } else {
      const t10 = i9._$AB.nextSibling, l4 = i9._$AM, c7 = l4 !== o7;
      if (c7) {
        let t11;
        i9._$AQ?.(o7), i9._$AM = o7, void 0 !== i9._$AP && (t11 = o7._$AU) !== l4._$AU && i9._$AP(t11);
      }
      if (t10 !== e9 || c7) {
        let o8 = i9._$AA;
        for (; o8 !== t10; ) {
          const t11 = o8.nextSibling;
          n7.insertBefore(o8, e9), o8 = t11;
        }
      }
    }
    return i9;
  };
  var ct = (o7, t9, i9 = o7) => (o7._$AI(t9, i9), o7);
  var ht = {};
  var dt = (o7, t9 = ht) => o7._$AH = t9;
  var ut = (o7) => o7._$AH;
  var pt = (o7) => {
    o7._$AP?.(false, true);
    let t9 = o7._$AA;
    const i9 = o7._$AB.nextSibling;
    for (; t9 !== i9; ) {
      const o8 = t9.nextSibling;
      t9.remove(), t9 = o8;
    }
  };

  // frontend/node_modules/lit-html/directives/repeat.js
  var Jt = (e9, s7, t9) => {
    const r8 = /* @__PURE__ */ new Map();
    for (let l4 = s7; l4 <= t9; l4++) r8.set(e9[l4], l4);
    return r8;
  };
  var Qt = e8(class extends i8 {
    constructor(e9) {
      if (super(e9), e9.type !== t8.CHILD) throw Error("repeat() can only be used in text expressions");
    }
    dt(e9, s7, t9) {
      let r8;
      void 0 === t9 ? t9 = s7 : void 0 !== s7 && (r8 = s7);
      const l4 = [], o7 = [];
      let i9 = 0;
      for (const s8 of e9) l4[i9] = r8 ? r8(s8, i9) : i9, o7[i9] = t9(s8, i9), i9++;
      return { values: o7, keys: l4 };
    }
    render(e9, s7, t9) {
      return this.dt(e9, s7, t9).values;
    }
    update(e9, [s7, t9, r8]) {
      const l4 = ut(e9), { values: o7, keys: i9 } = this.dt(s7, t9, r8);
      if (!Array.isArray(l4)) return this.ut = i9, o7;
      const n7 = this.ut ??= [], f8 = [];
      let u4, c7, d4 = 0, p4 = l4.length - 1, a6 = 0, h8 = o7.length - 1;
      for (; d4 <= p4 && a6 <= h8; ) if (null === l4[d4]) d4++;
      else if (null === l4[p4]) p4--;
      else if (n7[d4] === i9[a6]) f8[a6] = ct(l4[d4], o7[a6]), d4++, a6++;
      else if (n7[p4] === i9[h8]) f8[h8] = ct(l4[p4], o7[h8]), p4--, h8--;
      else if (n7[d4] === i9[h8]) f8[h8] = ct(l4[d4], o7[h8]), at(e9, f8[h8 + 1], l4[d4]), d4++, h8--;
      else if (n7[p4] === i9[a6]) f8[a6] = ct(l4[p4], o7[a6]), at(e9, l4[d4], l4[p4]), p4--, a6++;
      else if (void 0 === u4 && (u4 = Jt(i9, a6, h8), c7 = Jt(n7, d4, p4)), u4.has(n7[d4])) if (u4.has(n7[p4])) {
        const s8 = c7.get(i9[a6]), t10 = void 0 !== s8 ? l4[s8] : null;
        if (null === t10) {
          const s9 = at(e9, l4[d4]);
          ct(s9, o7[a6]), f8[a6] = s9;
        } else f8[a6] = ct(t10, o7[a6]), at(e9, l4[d4], t10), l4[s8] = null;
        a6++;
      } else pt(l4[p4]), p4--;
      else pt(l4[d4]), d4++;
      for (; a6 <= h8; ) {
        const s8 = at(e9, f8[h8 + 1]);
        ct(s8, o7[a6]), f8[a6++] = s8;
      }
      for (; d4 <= p4; ) {
        const e10 = l4[d4++];
        null !== e10 && pt(e10);
      }
      return this.ut = i9, dt(e9, f8), R3;
    }
  });

  // frontend/ts/components/lit/serverUpdatesComponent.ts
  var ServerUpdatesComponent = class extends h7 {
    constructor() {
      super();
      this.updates = /* @__PURE__ */ new Map();
      this.deviceState = new DeviceStateDispatch();
      this.initializeSignals();
    }
    initializeSignals() {
      const signals = [
        { name: "System", signal: this.deviceState.system },
        { name: "LRF", signal: this.deviceState.lrf },
        { name: "Time", signal: this.deviceState.time },
        { name: "GPS", signal: this.deviceState.gps },
        { name: "Compass", signal: this.deviceState.compass },
        { name: "Rotary", signal: this.deviceState.rotary },
        { name: "Power", signal: this.deviceState.power },
        { name: "Camera Day", signal: this.deviceState.cameraDay },
        { name: "Camera Heat", signal: this.deviceState.cameraHeat },
        { name: "Compass Calibration", signal: this.deviceState.compassCalibration },
        { name: "Environment", signal: this.deviceState.environment }
      ];
      signals.forEach(({ name, signal }) => {
        signal.subscribe((value) => {
          if (value !== void 0) {
            this.addUpdate(name, value);
          }
        });
      });
    }
    addUpdate(name, value) {
      const update = {
        timestamp: Date.now(),
        value
      };
      if (!this.updates.has(name)) {
        this.updates.set(name, []);
      }
      const updatesForName = this.updates.get(name);
      updatesForName.unshift(update);
      this.updates = new Map(this.updates);
      this.requestUpdate();
    }
    render() {
      return ke`
      ${Qt(
        Array.from(this.updates.entries()),
        ([name, _5]) => name,
        ([name, updates]) => ke`
          <foldable-card .title="${`${name} (${updates.length} updates)`}">
            ${Qt(
          updates,
          (update) => update.timestamp,
          (update) => ke`
                <div class="update-entry">
                  <p>Timestamp: ${new Date(update.timestamp).toLocaleString()}</p>
                  <syntax-hl lang="json">${JSON.stringify(update.value, null, 2)}</syntax-hl>
                </div>
              `
        )}
          </foldable-card>
        `
      )}
    `;
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this.deviceState.destroy();
    }
  };
  __decorateClass([
    r6()
  ], ServerUpdatesComponent.prototype, "updates", 2);
  ServerUpdatesComponent = __decorateClass([
    t6("server-updates")
  ], ServerUpdatesComponent);

  // frontend/ts/cmd/cmdSender/cmdGeoTest.ts
  function GeoTestSend(args) {
    console.log("Sending GeoTest with data ", args);
    let rootMsg = createRootMessage();
    rootMsg.geoTest = index_cmd_GeoTest_exports.Root.create({
      longitude: args.longitude ?? 0,
      latitude: args.latitude ?? 0,
      altitude: args.altitude ?? 0,
      range: args.range ?? 0,
      azimuth: args.azimuth ?? 0,
      elevation: args.elevation ?? 0,
      bank: args.bank ?? 0
    });
    sendCmdMessage(rootMsg);
  }

  // frontend/ts/cmd/cmdSender/cmdLRF.ts
  function lrfNewSession() {
    console.log("Sending LRF new session");
    let rootMsg = createRootMessage();
    rootMsg.lrf = index_cmd_Lrf_exports.Root.create({ newSession: index_cmd_Lrf_exports.NewSession.create() });
    sendCmdMessage(rootMsg);
  }

  // frontend/ts/components/lit/geoTestCard.ts
  var sheet3 = cssomSheet({ target: new CSSStyleSheet() });
  var { tw: tw4 } = create({ sheet: sheet3 });
  var GeoTestCard = class extends h7 {
    constructor() {
      super();
      this.geoData = {
        lrf: { range: void 0 },
        gps: { longitude: void 0, latitude: void 0, altitude: void 0 },
        compass: { azimuth: void 0, elevation: void 0, bank: void 0 }
      };
      this.lastSignalData = {
        lrf: { range: void 0 },
        gps: { longitude: void 0, latitude: void 0, altitude: void 0 },
        compass: { azimuth: void 0, elevation: void 0, bank: void 0 }
      };
      this.isManuallyEdited = false;
      this.deviceState = new DeviceStateDispatch();
      this.initializeFromSignals();
    }
    initializeFromSignals() {
      this.deviceState.lrf.subscribe((lrfData) => {
        if (lrfData) {
          this.lastSignalData.lrf.range = lrfData.target?.rangeA;
          if (!this.isManuallyEdited) {
            this.geoData.lrf.range = lrfData.target?.rangeA;
            this.requestUpdate();
          }
        }
      });
      this.deviceState.gps.subscribe((gpsData) => {
        if (gpsData) {
          this.lastSignalData.gps = {
            longitude: gpsData.longitude,
            latitude: gpsData.latitude,
            altitude: gpsData.altitude
          };
          if (!this.isManuallyEdited) {
            this.geoData.gps = { ...this.lastSignalData.gps };
            this.requestUpdate();
          }
        }
      });
      this.deviceState.compass.subscribe((compassData) => {
        if (compassData) {
          this.lastSignalData.compass = {
            azimuth: compassData.azimuth,
            elevation: compassData.elevation,
            bank: compassData.bank
          };
          if (!this.isManuallyEdited) {
            this.geoData.compass = { ...this.lastSignalData.compass };
            this.requestUpdate();
          }
        }
      });
    }
    render() {
      const containerClasses = tw4`bg-white p-6 rounded-lg shadow-md`;
      const titleClasses = tw4`text-2xl font-bold mb-6 text-gray-800`;
      const sectionsContainerClasses = tw4`space-y-6`;
      const buttonsContainerClasses = tw4`flex flex-wrap justify-start gap-3 mt-6`;
      return ke`
      <div class="${containerClasses}">
        <h2 class="${titleClasses}">Geo Test Measurements</h2>
        <div class="${sectionsContainerClasses}">
          ${this.renderSection("LRF", this.geoData.lrf)}
          ${this.renderSection("GPS", this.geoData.gps)}
          ${this.renderSection("Compass", this.geoData.compass)}
        </div>
        <div class="${buttonsContainerClasses}">
          ${this.renderButton("Capture target", this.sendGeoTest, "bg-blue-500 hover:bg-blue-600")}
          ${this.renderButton("New target session", this.newSession, "bg-green-500 hover:bg-green-600")}
          ${this.renderButton("Refresh geo data", this.refreshFromSignals, "bg-yellow-500 hover:bg-yellow-600")}
        </div>
      </div>
    `;
    }
    renderSection(title, data) {
      const sectionClasses = tw4`bg-gray-50 p-4 rounded-md border border-gray-200`;
      const sectionTitleClasses = tw4`text-lg font-semibold mb-3 text-gray-700`;
      const inputsContainerClasses = tw4`space-y-3`;
      return ke`
      <div class="${sectionClasses}">
        <h3 class="${sectionTitleClasses}">${title}</h3>
        <div class="${inputsContainerClasses}">
          ${Object.entries(data).map(([key, value]) => this.renderInput(title, key, value))}
        </div>
      </div>
    `;
    }
    renderInput(groupName, key, value) {
      const inputGroupClasses = tw4`flex flex-col`;
      const labelClasses = tw4`text-sm font-medium text-gray-600 mb-1`;
      const inputClasses = tw4`w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500`;
      return ke`
      <div class="${inputGroupClasses}">
        <label for="${groupName}-${key}" class="${labelClasses}">
          ${key.charAt(0).toUpperCase() + key.slice(1)}
        </label>
        <input
          id="${groupName}-${key}"
          class="${inputClasses}"
          .value=${value ?? ""}
          @input=${this.updateGeoData}
          data-group="${groupName.toLowerCase()}"
          data-field="${key}"
        >
      </div>
    `;
    }
    renderButton(text, onClick, colorClasses) {
      const buttonClasses = tw4`px-4 py-2 text-sm font-medium text-white rounded-md transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-offset-2 ${colorClasses}`;
      return ke`
      <button
        @click=${onClick}
        class="${buttonClasses}"
      >
        ${text}
      </button>
    `;
    }
    updateGeoData(e9) {
      const target = e9.target;
      const group = target.dataset.group;
      const field = target.dataset.field;
      const value = target.value === "" ? void 0 : Number(target.value);
      this.geoData = {
        ...this.geoData,
        [group]: {
          ...this.geoData[group],
          [field]: value
        }
      };
      this.isManuallyEdited = true;
    }
    sendGeoTest() {
      const flattenedGeoData = {
        ...this.geoData.lrf,
        ...this.geoData.gps,
        ...this.geoData.compass
      };
      GeoTestSend(flattenedGeoData);
    }
    newSession() {
      lrfNewSession();
    }
    refreshFromSignals() {
      this.geoData = JSON.parse(JSON.stringify(this.lastSignalData));
      this.isManuallyEdited = false;
      this.requestUpdate();
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this.deviceState.destroy();
    }
  };
  GeoTestCard.styles = [
    sheet3.target,
    i5`
      :host {
        display: block;
      }
    `
  ];
  __decorateClass([
    r6()
  ], GeoTestCard.prototype, "geoData", 2);
  __decorateClass([
    r6()
  ], GeoTestCard.prototype, "lastSignalData", 2);
  __decorateClass([
    r6()
  ], GeoTestCard.prototype, "isManuallyEdited", 2);
  GeoTestCard = __decorateClass([
    t6("geo-test-card")
  ], GeoTestCard);

  // frontend/ts/components/lit/targetListByTile.ts
  var sheet4 = cssomSheet({ target: new CSSStyleSheet() });
  var { tw: tw5 } = create({ sheet: sheet4 });
  var TargetListByTile = class extends h7 {
    constructor() {
      super();
      this.targets = [];
      this.tileParams = { x: 0, y: 0, z: 0 };
      this.deviceState = new DeviceStateDispatch();
    }
    connectedCallback() {
      super.connectedCallback();
      this.initializeLRFSignal();
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this.deviceState.destroy();
    }
    initializeLRFSignal() {
      this.deviceState.lrf.subscribe((value) => {
        if (value !== void 0) {
          this.fetchTargets();
        }
      });
    }
    async fetchTargets() {
      try {
        const { x: x3, y: y4, z: z3 } = this.tileParams;
        const response = await fetch(`https://sych.app/api/targets/targets-by-tile/${x3}/${y4}/${z3}`);
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const fetchedTargets = await response.json();
        this.targets = [...fetchedTargets];
        this.requestUpdate();
      } catch (error) {
        console.error("Error fetching targets:", error);
      }
    }
    render() {
      const containerClasses = tw5`p-4 bg-white rounded-lg shadow-md`;
      const titleClasses = tw5`text-2xl font-bold mb-4 text-gray-800`;
      const formClasses = tw5`mb-4 p-4 bg-gray-100 rounded-md`;
      const inputContainerClasses = tw5`flex items-center mb-2`;
      const labelClasses = tw5`w-20 font-medium text-gray-700`;
      const inputClasses = tw5`w-24 p-1 border rounded`;
      const buttonClasses = tw5`px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors`;
      const targetsContainerClasses = tw5`mt-4 space-y-4`;
      const targetItemClasses = tw5`p-3 bg-gray-50 rounded-md shadow`;
      const targetPropertyClasses = tw5`mb-1 text-sm`;
      return ke`
      <div class=${containerClasses}>
        <h2 class=${titleClasses}>Targets by Tile</h2>
        <form class=${formClasses} @submit=${this.handleSubmit}>
          ${["x", "y", "z"].map((param) => ke`
            <div class=${inputContainerClasses}>
              <label class=${labelClasses} for=${param}>${param.toUpperCase()}:</label>
              <input class=${inputClasses} type="number" id=${param} .value=${this.tileParams[param]} @input=${this.handleInputChange}>
            </div>
          `)}
          <button class=${buttonClasses} type="submit">Fetch Targets</button>
        </form>
        <div class=${targetsContainerClasses}>
          ${this.targets.length ? ke`
            ${Qt(this.targets, (target) => target.id, (target) => ke`
              <div class=${targetItemClasses}>
                <div class=${targetPropertyClasses}>ID: ${target.id}</div>
                <div class=${targetPropertyClasses}>Longitude: ${target.lon}</div>
                <div class=${targetPropertyClasses}>Latitude: ${target.lat}</div>
              </div>
            `)}
          ` : ke`
            <p>No targets found for this tile.</p>
          `}
        </div>
      </div>
    `;
    }
    handleInputChange(e9) {
      const target = e9.target;
      const param = target.id;
      this.tileParams = { ...this.tileParams, [param]: Number(target.value) };
    }
    handleSubmit(e9) {
      e9.preventDefault();
      this.fetchTargets();
    }
  };
  TargetListByTile.styles = [sheet4.target];
  __decorateClass([
    n6({ type: Array })
  ], TargetListByTile.prototype, "targets", 2);
  __decorateClass([
    r6()
  ], TargetListByTile.prototype, "tileParams", 2);
  TargetListByTile = __decorateClass([
    t6("target-list-by-tile")
  ], TargetListByTile);

  // frontend/ts/components/lit/targetsMenu.ts
  var TargetsMenu = class extends h7 {
    render() {
      return ke`
      <h1>Demo menu for Targets:</h1>
      <component-switcher>
        <switchable-component name="Updates from the server">
            <server-updates></server-updates>
        </switchable-component>
        <switchable-component name="Target capture">
            <geo-test-card></geo-test-card>
        </switchable-component>
        <switchable-component name="Targets list by tile">
            <target-list-by-tile></target-list-by-tile>
        </switchable-component>
      </component-switcher>
    `;
    }
  };
  TargetsMenu = __decorateClass([
    t6("targets-menu")
  ], TargetsMenu);

  // frontend/ts/map_app.ts
  document.addEventListener("DOMContentLoaded", function() {
    let wscm = new WebSocketConnectionManager();
    wscm.startWebSocketWorker("wss://sych.app/ws/ws_cmd", "cmd", "deviceState");
    let deviceStateDispatch = new DeviceStateDispatch();
    let globeManager = new globeManager_default(deviceStateDispatch, "globe");
    let targetsMenu = new TargetsMenu();
    document.getElementById("targets-menu-container")?.appendChild(targetsMenu);
  });
})();
/*! Bundled license information:

@openglobus/og/lib/js/terrain/Geoid.js:
  (* This file is mostly a straight translation of
   * GeographicLib/src/Geoid.cpp from C++ to JavaScript
   * by Kim Vandry <vandry@TZoNE.ORG>
   *
   * @license
   *  **
   * * \file Geoid.cpp
   * * \brief Implementation for GeographicLib::Geoid class
   * *
   * * Copyright (c) Charles Karney (2009) <charles@karney.com>
   * * and licensed under the LGPL.  For more information, see
   * * http://geographiclib.sourceforge.net/
   * **********************************************************************
   *
   * Geoid height grade not supported
   * The files can be downloaded from here:
   * http://geographiclib.sourceforge.net/1.18/geoid.html
   *)

@lit-labs/preact-signals/lib/signal-watcher.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/preact-signals/lib/watch.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/preact-signals/lib/html-tag.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/repeat.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
