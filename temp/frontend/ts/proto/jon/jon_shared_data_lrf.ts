// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.27.2
// source: jon_shared_data_lrf.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  JonGuiDataGpsFixType,
  jonGuiDataGpsFixTypeFromJSON,
  jonGuiDataGpsFixTypeToJSON,
  JonGuiDataMeteo,
} from "./jon_shared_data_types";

export interface JonGuiDataLrf {
  isScanning: boolean;
  isMeasuring: boolean;
  measureId: number;
  target: JonGuiDataTarget | undefined;
  meteo: JonGuiDataMeteo | undefined;
}

export interface JonGuiDataTarget {
  timestamp: number;
  targetLongitude: number;
  targetLatitude: number;
  targetAltitude: number;
  observerLongitude: number;
  observerLatitude: number;
  observerAltitude: number;
  observerAzimuth: number;
  observerElevation: number;
  observerBank: number;
  /** Decemetres. In 2D, the distance between the observer and the target. */
  distance2d: number;
  /** Decemetres (3D). Accounting for the altitude difference. */
  distance3b: number;
  observerFixType: JonGuiDataGpsFixType;
  rangeA: number;
  rangeB: number;
  rangeC: number;
  /** Radius of the displayed area based on precision (measurement conditions). */
  radius: number;
  sessionId: number;
  targetId: number;
  /** RGB color representation */
  targetColor:
    | RgbColor
    | undefined;
  /** Tank, soldier... */
  type: number;
}

export interface RgbColor {
  /** 0-255 */
  red: number;
  /** 0-255 */
  green: number;
  /** 0-255 */
  blue: number;
}

function createBaseJonGuiDataLrf(): JonGuiDataLrf {
  return { isScanning: false, isMeasuring: false, measureId: 0, target: undefined, meteo: undefined };
}

export const JonGuiDataLrf = {
  encode(message: JonGuiDataLrf, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isScanning !== false) {
      writer.uint32(8).bool(message.isScanning);
    }
    if (message.isMeasuring !== false) {
      writer.uint32(16).bool(message.isMeasuring);
    }
    if (message.measureId !== 0) {
      writer.uint32(24).int32(message.measureId);
    }
    if (message.target !== undefined) {
      JonGuiDataTarget.encode(message.target, writer.uint32(34).fork()).ldelim();
    }
    if (message.meteo !== undefined) {
      JonGuiDataMeteo.encode(message.meteo, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): JonGuiDataLrf {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJonGuiDataLrf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isScanning = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isMeasuring = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.measureId = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.target = JonGuiDataTarget.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.meteo = JonGuiDataMeteo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JonGuiDataLrf {
    return {
      isScanning: isSet(object.isScanning) ? globalThis.Boolean(object.isScanning) : false,
      isMeasuring: isSet(object.isMeasuring) ? globalThis.Boolean(object.isMeasuring) : false,
      measureId: isSet(object.measureId) ? globalThis.Number(object.measureId) : 0,
      target: isSet(object.target) ? JonGuiDataTarget.fromJSON(object.target) : undefined,
      meteo: isSet(object.meteo) ? JonGuiDataMeteo.fromJSON(object.meteo) : undefined,
    };
  },

  toJSON(message: JonGuiDataLrf): unknown {
    const obj: any = {};
    if (message.isScanning !== false) {
      obj.isScanning = message.isScanning;
    }
    if (message.isMeasuring !== false) {
      obj.isMeasuring = message.isMeasuring;
    }
    if (message.measureId !== 0) {
      obj.measureId = Math.round(message.measureId);
    }
    if (message.target !== undefined) {
      obj.target = JonGuiDataTarget.toJSON(message.target);
    }
    if (message.meteo !== undefined) {
      obj.meteo = JonGuiDataMeteo.toJSON(message.meteo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JonGuiDataLrf>, I>>(base?: I): JonGuiDataLrf {
    return JonGuiDataLrf.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JonGuiDataLrf>, I>>(object: I): JonGuiDataLrf {
    const message = createBaseJonGuiDataLrf();
    message.isScanning = object.isScanning ?? false;
    message.isMeasuring = object.isMeasuring ?? false;
    message.measureId = object.measureId ?? 0;
    message.target = (object.target !== undefined && object.target !== null)
      ? JonGuiDataTarget.fromPartial(object.target)
      : undefined;
    message.meteo = (object.meteo !== undefined && object.meteo !== null)
      ? JonGuiDataMeteo.fromPartial(object.meteo)
      : undefined;
    return message;
  },
};

function createBaseJonGuiDataTarget(): JonGuiDataTarget {
  return {
    timestamp: 0,
    targetLongitude: 0,
    targetLatitude: 0,
    targetAltitude: 0,
    observerLongitude: 0,
    observerLatitude: 0,
    observerAltitude: 0,
    observerAzimuth: 0,
    observerElevation: 0,
    observerBank: 0,
    distance2d: 0,
    distance3b: 0,
    observerFixType: 0,
    rangeA: 0,
    rangeB: 0,
    rangeC: 0,
    radius: 0,
    sessionId: 0,
    targetId: 0,
    targetColor: undefined,
    type: 0,
  };
}

export const JonGuiDataTarget = {
  encode(message: JonGuiDataTarget, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== 0) {
      writer.uint32(8).int64(message.timestamp);
    }
    if (message.targetLongitude !== 0) {
      writer.uint32(17).double(message.targetLongitude);
    }
    if (message.targetLatitude !== 0) {
      writer.uint32(25).double(message.targetLatitude);
    }
    if (message.targetAltitude !== 0) {
      writer.uint32(33).double(message.targetAltitude);
    }
    if (message.observerLongitude !== 0) {
      writer.uint32(41).double(message.observerLongitude);
    }
    if (message.observerLatitude !== 0) {
      writer.uint32(49).double(message.observerLatitude);
    }
    if (message.observerAltitude !== 0) {
      writer.uint32(57).double(message.observerAltitude);
    }
    if (message.observerAzimuth !== 0) {
      writer.uint32(65).double(message.observerAzimuth);
    }
    if (message.observerElevation !== 0) {
      writer.uint32(73).double(message.observerElevation);
    }
    if (message.observerBank !== 0) {
      writer.uint32(81).double(message.observerBank);
    }
    if (message.distance2d !== 0) {
      writer.uint32(89).double(message.distance2d);
    }
    if (message.distance3b !== 0) {
      writer.uint32(97).double(message.distance3b);
    }
    if (message.observerFixType !== 0) {
      writer.uint32(104).int32(message.observerFixType);
    }
    if (message.rangeA !== 0) {
      writer.uint32(113).double(message.rangeA);
    }
    if (message.rangeB !== 0) {
      writer.uint32(121).double(message.rangeB);
    }
    if (message.rangeC !== 0) {
      writer.uint32(129).double(message.rangeC);
    }
    if (message.radius !== 0) {
      writer.uint32(137).double(message.radius);
    }
    if (message.sessionId !== 0) {
      writer.uint32(144).int32(message.sessionId);
    }
    if (message.targetId !== 0) {
      writer.uint32(152).int32(message.targetId);
    }
    if (message.targetColor !== undefined) {
      RgbColor.encode(message.targetColor, writer.uint32(162).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(168).uint32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): JonGuiDataTarget {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJonGuiDataTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.targetLongitude = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.targetLatitude = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.targetAltitude = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.observerLongitude = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.observerLatitude = reader.double();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.observerAltitude = reader.double();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.observerAzimuth = reader.double();
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.observerElevation = reader.double();
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.observerBank = reader.double();
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.distance2d = reader.double();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.distance3b = reader.double();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.observerFixType = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 113) {
            break;
          }

          message.rangeA = reader.double();
          continue;
        case 15:
          if (tag !== 121) {
            break;
          }

          message.rangeB = reader.double();
          continue;
        case 16:
          if (tag !== 129) {
            break;
          }

          message.rangeC = reader.double();
          continue;
        case 17:
          if (tag !== 137) {
            break;
          }

          message.radius = reader.double();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.targetId = reader.int32();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.targetColor = RgbColor.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.type = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JonGuiDataTarget {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      targetLongitude: isSet(object.targetLongitude) ? globalThis.Number(object.targetLongitude) : 0,
      targetLatitude: isSet(object.targetLatitude) ? globalThis.Number(object.targetLatitude) : 0,
      targetAltitude: isSet(object.targetAltitude) ? globalThis.Number(object.targetAltitude) : 0,
      observerLongitude: isSet(object.observerLongitude) ? globalThis.Number(object.observerLongitude) : 0,
      observerLatitude: isSet(object.observerLatitude) ? globalThis.Number(object.observerLatitude) : 0,
      observerAltitude: isSet(object.observerAltitude) ? globalThis.Number(object.observerAltitude) : 0,
      observerAzimuth: isSet(object.observerAzimuth) ? globalThis.Number(object.observerAzimuth) : 0,
      observerElevation: isSet(object.observerElevation) ? globalThis.Number(object.observerElevation) : 0,
      observerBank: isSet(object.observerBank) ? globalThis.Number(object.observerBank) : 0,
      distance2d: isSet(object.distance2d) ? globalThis.Number(object.distance2d) : 0,
      distance3b: isSet(object.distance3b) ? globalThis.Number(object.distance3b) : 0,
      observerFixType: isSet(object.observerFixType) ? jonGuiDataGpsFixTypeFromJSON(object.observerFixType) : 0,
      rangeA: isSet(object.rangeA) ? globalThis.Number(object.rangeA) : 0,
      rangeB: isSet(object.rangeB) ? globalThis.Number(object.rangeB) : 0,
      rangeC: isSet(object.rangeC) ? globalThis.Number(object.rangeC) : 0,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      targetId: isSet(object.targetId) ? globalThis.Number(object.targetId) : 0,
      targetColor: isSet(object.targetColor) ? RgbColor.fromJSON(object.targetColor) : undefined,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
    };
  },

  toJSON(message: JonGuiDataTarget): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.targetLongitude !== 0) {
      obj.targetLongitude = message.targetLongitude;
    }
    if (message.targetLatitude !== 0) {
      obj.targetLatitude = message.targetLatitude;
    }
    if (message.targetAltitude !== 0) {
      obj.targetAltitude = message.targetAltitude;
    }
    if (message.observerLongitude !== 0) {
      obj.observerLongitude = message.observerLongitude;
    }
    if (message.observerLatitude !== 0) {
      obj.observerLatitude = message.observerLatitude;
    }
    if (message.observerAltitude !== 0) {
      obj.observerAltitude = message.observerAltitude;
    }
    if (message.observerAzimuth !== 0) {
      obj.observerAzimuth = message.observerAzimuth;
    }
    if (message.observerElevation !== 0) {
      obj.observerElevation = message.observerElevation;
    }
    if (message.observerBank !== 0) {
      obj.observerBank = message.observerBank;
    }
    if (message.distance2d !== 0) {
      obj.distance2d = message.distance2d;
    }
    if (message.distance3b !== 0) {
      obj.distance3b = message.distance3b;
    }
    if (message.observerFixType !== 0) {
      obj.observerFixType = jonGuiDataGpsFixTypeToJSON(message.observerFixType);
    }
    if (message.rangeA !== 0) {
      obj.rangeA = message.rangeA;
    }
    if (message.rangeB !== 0) {
      obj.rangeB = message.rangeB;
    }
    if (message.rangeC !== 0) {
      obj.rangeC = message.rangeC;
    }
    if (message.radius !== 0) {
      obj.radius = message.radius;
    }
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.targetId !== 0) {
      obj.targetId = Math.round(message.targetId);
    }
    if (message.targetColor !== undefined) {
      obj.targetColor = RgbColor.toJSON(message.targetColor);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JonGuiDataTarget>, I>>(base?: I): JonGuiDataTarget {
    return JonGuiDataTarget.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JonGuiDataTarget>, I>>(object: I): JonGuiDataTarget {
    const message = createBaseJonGuiDataTarget();
    message.timestamp = object.timestamp ?? 0;
    message.targetLongitude = object.targetLongitude ?? 0;
    message.targetLatitude = object.targetLatitude ?? 0;
    message.targetAltitude = object.targetAltitude ?? 0;
    message.observerLongitude = object.observerLongitude ?? 0;
    message.observerLatitude = object.observerLatitude ?? 0;
    message.observerAltitude = object.observerAltitude ?? 0;
    message.observerAzimuth = object.observerAzimuth ?? 0;
    message.observerElevation = object.observerElevation ?? 0;
    message.observerBank = object.observerBank ?? 0;
    message.distance2d = object.distance2d ?? 0;
    message.distance3b = object.distance3b ?? 0;
    message.observerFixType = object.observerFixType ?? 0;
    message.rangeA = object.rangeA ?? 0;
    message.rangeB = object.rangeB ?? 0;
    message.rangeC = object.rangeC ?? 0;
    message.radius = object.radius ?? 0;
    message.sessionId = object.sessionId ?? 0;
    message.targetId = object.targetId ?? 0;
    message.targetColor = (object.targetColor !== undefined && object.targetColor !== null)
      ? RgbColor.fromPartial(object.targetColor)
      : undefined;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseRgbColor(): RgbColor {
  return { red: 0, green: 0, blue: 0 };
}

export const RgbColor = {
  encode(message: RgbColor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.red !== 0) {
      writer.uint32(8).uint32(message.red);
    }
    if (message.green !== 0) {
      writer.uint32(16).uint32(message.green);
    }
    if (message.blue !== 0) {
      writer.uint32(24).uint32(message.blue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RgbColor {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRgbColor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.red = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.green = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blue = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RgbColor {
    return {
      red: isSet(object.red) ? globalThis.Number(object.red) : 0,
      green: isSet(object.green) ? globalThis.Number(object.green) : 0,
      blue: isSet(object.blue) ? globalThis.Number(object.blue) : 0,
    };
  },

  toJSON(message: RgbColor): unknown {
    const obj: any = {};
    if (message.red !== 0) {
      obj.red = Math.round(message.red);
    }
    if (message.green !== 0) {
      obj.green = Math.round(message.green);
    }
    if (message.blue !== 0) {
      obj.blue = Math.round(message.blue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RgbColor>, I>>(base?: I): RgbColor {
    return RgbColor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RgbColor>, I>>(object: I): RgbColor {
    const message = createBaseRgbColor();
    message.red = object.red ?? 0;
    message.green = object.green ?? 0;
    message.blue = object.blue ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
